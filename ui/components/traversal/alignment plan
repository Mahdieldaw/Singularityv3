alignment  plan
# System Alignment Agent Prompt

You are performing a **comprehensive architectural alignment** of a multi-layer AI decision pipeline. Your task is to ensure the **implementation matches the design specification** across all layers, call sites, handlers, and UI components.

---

## Core System Flow (Ground Truth)

The system operates in **three sequential layers**:

### **Layer 1: Sensing (Structural Perception)**
**Shadow Mapper** extracts raw statements from model responses:
- Mechanical extraction (no LLM)
- Classifies stance (prescriptive, cautionary, prerequisite, dependent, assertive, uncertain)
- Detects signals (sequence, tension, conditional)
- Assigns provenance IDs
- **Output:** `ShadowStatement[]` with metadata

### **Layer 2: Decision (Constraint Resolution)**
**Semantic Mapper** groups statements into claims (LLM-based):
- Groups statements → claims (canonical labels)
- Extracts **gates** (conditionals: "if X", prerequisites: "requires Y")
- Detects **conflicts** (not "edges" - this changed)
- Every claim/gate/conflict **must cite shadow statement IDs**
- **Cannot add new content** - only organize existing statements
- **Output:** `Claim[]` with gates and conflicts

**Claim Assembly** enriches claims (mechanical):
- Resolves shadow statement references
- Computes support ratios
- Builds inverse relationships (enables array from prerequisites)
- **Output:** `AssembledClaim[]`

**Traversal Builder** computes decision structure (mechanical):
- Computes **tiers** from prerequisite gates (topological sort)
- Extracts **forcing points** (user-facing questions)
- Determines blocking relationships
- **Output:** `TraversalGraph` with tiers and forcing points

**Traversal Execution** (if forcing points exist):
- Presents forcing points in tier order
- User answers → claims pruned (with cascade)
- Continues until complete
- **Output:** Active claim set + user path

### **Layer 3: Explanation (Contextualization)**
**Structural Analysis** analyzes the **active claim set** (post-traversal):
- Only operates on claims that survived traversal
- Generates **targeted** insights (not generic)
- Contextualizes to user's path
- **Output:** Structural notes specific to user's choices

**Bucket System** arranges claims (mechanical):
- No hierarchy, randomized presentation
- Outliers anchor buckets, consensus distributed
- **Output:** Position brief with evidence

**Concierge** synthesizes final answer (LLM-based):
- Receives: user path + claim evidence + structural notes
- **Permission to transcend** suggestions if needed
- Must be decisive, conditional, never vague
- **Output:** Final recommendation

---

## Critical Contract Changes (Must Be Enforced Everywhere)

### **1. Edges Removed, Conflicts Added**
**Old contract:**
```typescript
edges: {
  sequence: SequenceEdge[];
  tension: TensionEdge[];
}
```

**New contract:**
```typescript
enables?: string[];         
conflicts?: ConflictEdge[];  // Must have provenance

 // Claim IDs (computed from prerequisites) ### How `enables` Is Computed (Claim Assembly)
For each claim with prerequisites:
```typescript
// If claim B has prerequisite gate pointing to claim A:
claimB.gates.prerequisites = [{ requiredClaimId: "claimA", ... }]

// Then claim A should have:
claimA.enables = ["claimB"]  // Inverse relationship

```
## Guiding Principle

**Accuracy through reduction:** Surface only what can be proven with provenance.
User decisions prune uncertain branches anyway. When in doubt, don't output.
### **2. Gates Now Include Questions**
**Old contract:**
```typescript
ConditionalGate {
  condition: string;
  sourceStatementIds: string[];
}
```

**New contract:**
```typescript
ConditionalGate {
  condition: string;
  question: string;  // REQUIRED: canonical question form
  sourceStatementIds: string[];
}
```

Same for `PrerequisiteGate`.

### **3. Conflicts Have Questions**
```typescript
ConflictEdge {
  claimId: string;
  question: string;              // REQUIRED: "Which matters more: X or Y?"
  sourceStatementIds: string[];  // REQUIRED
  nature?: 'optimization' | 'mutual_exclusion' | 'resource_competition';
}
```

---

## Your Mission

### **Phase 1: Contract Enforcement**
1. **Verify contract.ts defines:**
   - `ConditionalGate` with `question` field
   - `PrerequisiteGate` with `question` field
   - `ConflictEdge` (not `TensionEdge`)
   - `Claim` with `enables` and `conflicts` (not `edges`)

2. **Update all producers:**
   - Semantic mapper prompt must instruct LLM to output `question` for every gate/conflict
   - Semantic mapper parser must validate `question` exists
   - Any code building gates/conflicts must include `question`

3. **Update all consumers:**
   - `claimAssembly.ts`: Process `enables` and `conflicts` (not `edges.sequence` and `edges.tension`)
   - `traversal.ts`: Read from `claim.conflicts` (not `claim.edges.tension`)
   - `forcingPoints.ts`: Use `gate.question` and `conflict.question` (not hardcoded strings)

### **Phase 2: Pipeline Flow Verification**
Trace the data flow **in execution order**:

1. **Batch responses arrive** → stored as provider responses
2. **Shadow Mapper executes** → produces `ShadowStatement[]`
3. **Semantic Mapper executes** → receives shadow statements, produces `Claim[]`
4. **Claim Assembly executes** → enriches claims, produces `AssembledClaim[]`
5. **Traversal Builder executes** → produces `TraversalGraph`
6. **Forcing Points extracted** → produces `ForcingPoint[]`
7. **Pipeline pauses IF** traversal exists AND forcing points exist AND not continuation
8. **User resolves forcing points** → traversal state updated
9. **User submits continuation** → pipeline resumes
10. **Structural Analysis executes** → operates on **active claims only** (post-traversal)
11. **Bucket System executes** → arranges claims
12. **Concierge executes** → synthesizes final answer

**Verify each step:**
- Check the call site exists
- Verify inputs match expected contract
- Verify outputs are used correctly by next step
- Ensure no steps are skipped or out of order

### **Phase 3: Traversal Pause/Resume Logic**
The pipeline must **pause** when:
```typescript
hasTraversal = !!mapperArtifact.traversalGraph
hasForcingPoints = forcingPoints.length > 0
isNotContinuation = !context.isTraversalContinuation

if (hasTraversal && hasForcingPoints && isNotContinuation) {
  // Pause: set pipelineStatus = 'awaiting_traversal'
  // Emit MAPPER_ARTIFACT_READY with artifact
  // Do NOT execute Singularity
  // Return early
}
```

The pipeline must **resume** when:
- User posts `CONTINUE_COGNITIVE_WORKFLOW` message
- Payload includes `isTraversalContinuation: true`
- Handler builds continuation prompt from user's traversal decisions
- Singularity executes with continuation prompt
- pipelineStatus updates to `'complete'`

**Verify:**
- Pause logic exists in `CognitivePipelineHandler.js`
- UI sends correct message type (`CONTINUE_COGNITIVE_WORKFLOW`, not `CONTINUE_COGNITIVE_REQUEST`)
- Background handler catches `CONTINUE_COGNITIVE_WORKFLOW`
- Continuation prompt builder exists and is called
- Status updates properly

### **Phase 4: UI Component Alignment**
All UI components rendering traversal must:

1. **Import from contract, not define locally:**
   ```typescript
   // WRONG:
   interface Claim { ... }
   
   // RIGHT:
   import { Claim, ConditionalGate } from '@/shared/contract';
   ```

2. **Render gate/conflict questions from data:**
   ```typescript
   // WRONG:
   <div>Does this apply to your situation?</div>
   
   // RIGHT:
   <div>{gate.question}</div>
   ```

3. **Handle both legacy and current data shapes:**
   ```typescript
   // Guard against legacy serialization
   if (!traversalGraph?.tiers || !Array.isArray(traversalGraph.tiers)) {
     return <LegacyWarning />;
   }
   ```

**Components to check:**
- `TraversalGraphView.tsx`
- `TraversalGateCard.tsx`
- `TraversalForcingPointCard.tsx`
- `CognitiveOutputRenderer.tsx`

### **Phase 5: Message Contract Alignment**
Ensure all runtime messages are:
1. Defined in `shared/messaging.ts` (single source of truth)
2. Used consistently (no string literals)
3. Handled properly (no dead paths)

**Messages to verify:**
- `MAPPER_ARTIFACT_READY`
- `CONTINUE_COGNITIVE_WORKFLOW`
- `WORKFLOW_STEP_UPDATE`
- `TURN_FINALIZED`

**Check:**
- Sender uses constant
- Handler exists in background
- UI listener exists
- Contract types match payload

### **Phase 6: Serialization Safety**
Ensure **no Map/Set crosses message boundaries**:

1. **TraversalState** (UI-local) uses Map/Set → **OK** (never serialized)
2. **TraversalGraph** (persisted) uses plain objects → **OK**
3. **Continuation payload** uses primitives only → **OK**

**Verify:**
- `traversalGraph.tiers` is `Array`, not `Map`
- `traversalGraph.claims` are plain objects
- Message payloads contain no `Map`, `Set`, or functions

---

## Execution Instructions

For each phase:
1. **Identify all files** that interact with that layer
2. **Check each call site** matches the contract
3. **Flag mismatches** with exact file:line references
4. **Propose fixes** as minimal diffs
5. **Verify dependencies** (if you fix A, does B need updating?)

**Do not:**
- Cite the design document (you're verifying implementation against it)
- Assume code is correct (verify every claim)
- Skip "minor" files (UI components, utils, helpers all matter)
- Leave dead code paths (if handler doesn't exist, flag it)

**Do:**
- Trace actual execution flow through the codebase
- Check TypeScript types match runtime behavior
- Verify error boundaries exist
- Ensure backward compatibility guards are in place

---

## Success Criteria

The system is aligned when:

1. ✅ Contract types match implementation (no drift)
2. ✅ Pipeline executes in documented order (no skipped steps)
3. ✅ Traversal pause/resume works (verified dead path fixed)
4. ✅ UI renders semantic mapper's questions (not hardcoded)
5. ✅ All messages defined and handled (no string literals)
6. ✅ No serialization violations (no Map/Set in messages)
7. ✅ TypeScript compiles with no errors
8. ✅ Tests pass

---

## Report Format

For each phase, provide:

```
## Phase N: [Name]

### Files Checked:
- path/to/file.ts (lines X-Y)
- path/to/other.tsx (lines A-B)

### Issues Found:
1. [File:Line] - [Description]
   Current: [code snippet]
   Expected: [what contract requires]
   Fix: [minimal diff or explanation]

2. ...

### Dependencies:
- Fixing issue 1 requires updating [other file]
- Issue 3 is blocked by Phase N-1 completion

### Verification:
- [ ] Types match contract
- [ ] Runtime behavior correct
- [ ] Error handling present
- [ ] Legacy guards in place
```
---

## Architectural Principle (Do Not Violate)

**Accuracy through reduction.** The system surfaces fewer relationships but is correct about each one.

1. **Prerequisites** → Syntax encodes direction. High accuracy.
2. **Conditionals** → Syntax encodes structure. High accuracy.
3. **Conflicts** → Requires semantic judgment. Only output with provenance.
4. **Enables** → Computed mechanically from prerequisites (inverse relationship).

**When semantic mapper cannot prove a relationship with statement IDs, it does not output it.**

User decisions prune the uncertain branches anyway. Gaps are acceptable; hallucinations are not.

---
Begin Phase 1.