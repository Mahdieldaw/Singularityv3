# Legacy Cleanup Instructions (Post-Migration)

## Prerequisites

Before cleanup:
- [ ] All paths working with new phase structure
- [ ] Data persists and loads correctly after refresh
- [ ] All UI reads from `batch`, `mapping`, `singularity` only
- [ ] Tests passing

---

## Phase 1: Remove Legacy Writes

### File: `CognitivePipelineHandler.js`

**Remove:**
```javascript
// DELETE this line:
t.singularityOutput = inferredSingularityOutput;

// KEEP only:
if (singularityPhase) t.singularity = singularityPhase;
```

**Remove:**
```javascript
// DELETE these if present:
t.mapperArtifact = ...
t.pipelineArtifacts = ...
t.batchResponses = ...
t.mappingResponses = ...
t.singularityResponses = ...
```

### File: `TurnEmitter.ts`

**Remove legacy from aiTurn construction:**
```typescript
// DELETE these from aiTurn object:
mapperArtifact: context?.mapperArtifact,
pipelineArtifacts: context?.pipelineArtifacts,
singularityOutput: context?.singularityOutput,
batchResponses: ...,
mappingResponses: ...,
singularityResponses: ...,

// KEEP only:
batch: batchPhase,
mapping: mappingPhase,
singularity: singularityPhase,
```

### File: `workflow-engine.js`

**Remove legacy context assignments:**
```javascript
// DELETE:
context.mapperArtifact = result.mapperArtifact;
context.pipelineArtifacts = result.pipelineArtifacts;

// REPLACE with:
context.mappingArtifact = buildCognitiveArtifact(
  result.mapperArtifact,
  result.pipelineArtifacts
);
```

---

## Phase 2: Update Reads to New Structure

### File: `CognitivePipelineHandler.js`

**Before:**
```javascript
const cognitiveArtifact = buildCognitiveArtifact(
  finalAiTurn?.mapperArtifact,
  finalAiTurn?.pipelineArtifacts
);
```

**After:**
```javascript
const cognitiveArtifact = finalAiTurn?.mapping?.artifact;
```

### File: `TurnEmitter.ts`

**Before:**
```typescript
let effectiveMapperArtifact = context?.mapperArtifact;
let effectivePipelineArtifacts = context?.pipelineArtifacts;
// ... fallback logic ...
const cognitiveArtifact = buildCognitiveArtifact(
  effectiveMapperArtifact,
  effectivePipelineArtifacts
);
```

**After:**
```typescript
const cognitiveArtifact = context?.mappingArtifact;
// Remove all fallback logic
```

### File: `context-resolver.js`

**Before:**
```javascript
providerContexts: lastTurn.providerContexts,
previousAnalysis: lastTurn.mapperArtifact?.fullAnalysis,
```

**After:**
```javascript
providerContexts: Object.fromEntries(
  Object.entries(lastTurn.batch?.responses || {}).map(([pid, r]) => [pid, r.meta])
),
previousAnalysis: computeStructuralAnalysis(lastTurn.mapping?.artifact),
```

---

## Phase 3: Update UI Components

### File: `DecisionMapSheet.tsx`

**Remove all legacy reads:**
```typescript
// DELETE patterns like:
(aiTurn as any)?.mapperArtifact
(aiTurn as any)?.pipelineArtifacts
aiTurn?.mapperArtifact?.claims

// REPLACE with:
aiTurn?.mapping?.artifact?.semantic?.claims
aiTurn?.mapping?.artifact?.semantic?.edges
aiTurn?.mapping?.artifact?.semantic?.narrative
aiTurn?.mapping?.artifact?.geometry?.substrate
aiTurn?.mapping?.artifact?.traversal?.forcingPoints
aiTurn?.mapping?.artifact?.traversal?.graph
aiTurn?.mapping?.artifact?.shadow?.statements
```

### File: `StructuralDebugPanel.tsx`

**Update props and reads:**
```typescript
// BEFORE:
mapperArtifact={aiTurn?.mapperArtifact}
completeness={aiTurn?.mapperArtifact?.completeness}
traversalGraph={aiTurn?.mapperArtifact?.traversalGraph}

// AFTER:
artifact={aiTurn?.mapping?.artifact}
completeness={computedCompleteness}  // Compute on-demand
traversalGraph={aiTurn?.mapping?.artifact?.traversal?.graph}
```

### File: `useCognitiveMode.ts`

**Update artifact access:**
```typescript
// BEFORE:
payload.mapperArtifact

// AFTER:
payload.mappingArtifact  // or retrieve from stored turn
```

### File: `useChat.ts`

**Update hasAnyCognitiveData:**
```typescript
// BEFORE:
round.mapperArtifact || round.pipelineArtifacts || round.singularityOutput

// AFTER:
round.mapping?.artifact || round.singularity?.output
```

---

## Phase 4: Update Persistence Types

### File: `src/persistence/types.ts`

**Remove from AiTurnRecord:**
```typescript
// DELETE:
mapperArtifact?: object | string;
pipelineArtifacts?: object | string;
singularityOutput?: object | string;
storedAnalysis?: object | string;
batchResponses?: Record<string, any>;
mappingResponses?: Record<string, any>;
singularityResponses?: Record<string, any>;

// KEEP only:
batch?: object | string;
mapping?: object | string;
singularity?: object | string;
```

### File: `shared/contract.ts`

**Remove from AiTurn:**
```typescript
// DELETE:
mapperArtifact?: MapperArtifact | null;
pipelineArtifacts?: PipelineArtifacts | null;
singularityOutput?: SingularityOutput | null;
batchResponses?: Record<string, ProviderResponse[]>;
mappingResponses?: Record<string, ProviderResponse[]>;
singularityResponses?: Record<string, ProviderResponse[]>;
storedAnalysis?: StructuralAnalysis | null;
providerContexts?: Record<string, any> | null;

// KEEP only:
batch?: BatchPhase;
mapping?: MappingPhase;
singularity?: SingularityPhase;
```

### File: `ui/types/index.ts`

**Same removals as contract.ts**

---

## Phase 5: Remove Unused Types

### File: `shared/contract.ts`

**Consider removing (if no longer used):**
```typescript
// DELETE if unused:
interface MapperArtifact { ... }
interface PipelineArtifacts { ... }
interface SingularityOutput { ... }  // Keep if singularity.output uses it

// KEEP:
interface CognitiveArtifact { ... }
interface BatchPhase { ... }
interface MappingPhase { ... }
interface SingularityPhase { ... }
```

---

## Phase 6: Remove Helper Functions

### File: `CognitivePipelineHandler.js` / `TurnEmitter.ts`

**After all reads are from new structure:**
```javascript
// buildCognitiveArtifact() can be simplified or removed
// It's only needed during migration to convert legacy → new

// If still needed for initial construction, keep it
// If only used for reading, remove it
```

---

## Verification Checklist

After each phase:

```bash
# Search for remaining legacy usage
grep -rn "mapperArtifact" src/ ui/ --include="*.ts" --include="*.tsx" --include="*.js"
grep -rn "pipelineArtifacts" src/ ui/ --include="*.ts" --include="*.tsx" --include="*.js"
grep -rn "singularityOutput" src/ ui/ --include="*.ts" --include="*.tsx" --include="*.js"
grep -rn "batchResponses" src/ ui/ --include="*.ts" --include="*.tsx" --include="*.js"
grep -rn "mappingResponses" src/ ui/ --include="*.ts" --include="*.tsx" --include="*.js"

# Run tests
npm test

# Typecheck
npx tsc --noEmit

# Manual test
# 1. Send message (no conflicts) → verify all phases display
# 2. Send message (with conflicts) → halt → continue → verify all phases
# 3. Refresh → verify all phases persist
```

---

## Final State

| Field | Location | Structure |
|-------|----------|-----------|
| Batch responses | `turn.batch.responses` | `Record<providerId, {text, status, modelIndex, meta}>` |
| Mapping artifact | `turn.mapping.artifact` | `CognitiveArtifact` |
| Singularity output | `turn.singularity` | `{prompt, output, traversalState}` |

**No legacy fields remain. Single source of truth.**