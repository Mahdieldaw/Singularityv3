However, to truly implement the Variable Extended Timeout (VET) logic we discussedâ€”a critical guard against streaming stallsâ€”and to align with the principle of avoiding epistemic limits, the current code requires a modest architectural refactoring within the ClaudeSessionApi.ask method. The core problem is that the current while (true) loop inside ask is blocking the client until a new chunk arrives or the server closes the stream, meaning you can't check a client-side timeout unless the reader.read() call is timed out, which is not natively supported by standard fetch streams. ðŸ’¡ Refactoring for Variable Extended Timeout (VET) The key to implementing VET is to move the stream reading from a simple await reader.read() loop to a loop that concurrently awaits the read operation AND a client-side timeout promise. 1. The Core Refactor: Concurrently Awaiting Read and Timeout To introduce $T_{\text{Token-Gap}}$ (Inter-Token Gap), you must wrap the reader.read() call in a Promise.race against a timeout promise that resets on every chunk. 2. The Necessary Utility Function (_readWithTimeout) You need a new private method to handle the concurrent awaiting and throw a specific timeout error when the $T_{\text{Token-Gap}}$ is exceeded. JavaScript // =============================================================================// NEW PRIVATE METHOD FOR VET LOGIC// =============================================================================// Add this inside ClaudeSessionApi_readWithTimeout(reader, timeoutMs, signal) { const timeout = new Promise((_, reject) => { const timer = setTimeout(() => { reject(this._createError("streamTimeout", `Stream stalled for ${timeoutMs / 1000}s.`)); }, timeoutMs); // Clear the timer if the read succeeds signal.addEventListener('abort', () => clearTimeout(timer), { once: true }); }); const readPromise = reader.read(); return Promise.race([readPromise, timeout]); } Note: The signal passed to the timeout should be an AbortController from the VET logic, not the one from the API call, for clean-up. 3. Modifying ClaudeSessionApi.ask to Implement VET We need to introduce the two-tier timing mechanism ($T_{\text{TTFT}}$ and $T_{\text{Token-Gap}}$) into your ask method. JavaScript // =============================================================================// MODIFIED CLAUDE SESSION API: ask METHOD// =============================================================================async ask(prompt, options = {}, onChunk = () => { }) { // ... [Initial setup code remains the same] ... let { orgId, chatId, signal, emoji } = options; // --- VET TIMEOUT CONFIGURATION --- const TTFT_TIMEOUT_MS = 90000; // 90 seconds for Time-to-First-Token const TOKEN_GAP_TIMEOUT_MS = 30000; // 30 seconds for Inter-Token Gap // --- VET TIMEOUT CONFIGURATION --- // ... [DNR, OrgId, ChatId, Payload setup remain the same] ... const response = await this._fetchAuth(url, payload); // ... [HTTP Error Handling remains the same] ... // Process streaming response let fullText = ""; let isFirstChunk = true; let softError = null; const reader = response.body.getReader(); const carry = { carryOver: "" }; // Start a timer for the Time-to-First-Token (TTFT) let ttftTimer = setTimeout(() => { // If 90 seconds pass without content, force the client-side error const ttftError = this._createError("streamTimeout", `TTFT exceeded ${TTFT_TIMEOUT_MS / 1000}s.`); if (signal) signal.abort(ttftError); // Use the existing signal for termination }, TTFT_TIMEOUT_MS); let tokenGapTimer = null; try { while (true) { // CONCURRENT AWAIT: Race the read against the inter-token timeout let readResult; if (isFirstChunk) { // For the first chunk, we just read (TTFT is handled by the initial timer) readResult = await reader.read(); } else { // For subsequent chunks, use the inter-token gap timer const timeoutPromise = new Promise((_, reject) => { tokenGapTimer = setTimeout(() => { reject(this._createError("streamTimeout", `Token gap exceeded ${TOKEN_GAP_TIMEOUT_MS / 1000}s.`)); }, TOKEN_GAP_TIMEOUT_MS); }); readResult = await Promise.race([reader.read(), timeoutPromise]); } // Always clear timers after a successful read/chunk received clearTimeout(ttftTimer); if (tokenGapTimer) clearTimeout(tokenGapTimer); const { done, value } = readResult; if (done) break; // ... [The rest of the loop remains the same] ... const result = this._parseChunk(value, carry, fullText.length > 0); if (result.error) { // ... [Error handling remains the same] ... } if (result.text) { fullText = fullText + result.text; onChunk({ text: fullText, chatId, orgId }, isFirstChunk); isFirstChunk = false; // If this is the first content chunk, clear TTFT and start the token gap cycle if (!isFirstChunk) { clearTimeout(ttftTimer); } } } // ... [Grace period and final return logic remains the same] ... } catch (err) { // Ensure all timers are cleared on exit clearTimeout(ttftTimer); if (tokenGapTimer) clearTimeout(tokenGapTimer); // Check for specific stream timeout error if (this.isOwnError(err) && err.type === "streamTimeout") { // Treat VET-triggered timeouts as an intentional, controlled failure throw err; } // ... [Original error handling for partial text remains the same] ... } finally { reader.releaseLock(); } // ... [Final result return] ... } 4. The _parseChunk Logic and Error Handling Your existing _parseChunk and ClaudeProviderError classes are already well-structured for this task, particularly: Explicit Error Types: Add the new error type to your class: JavaScript // Inside ClaudeProviderError.get is()get is() { return { // ... existing types streamTimeout: this.type === "streamTimeout", // <--- ADD THIS // ... existing types }; } Intelligible Data: Your current parser correctly determines if result.text has content, which is the necessary check for resetting the $T_{\text{Token-Gap}}$ timer. The SSE data: frames carrying completion segments are your "intelligible data." To implement VET universally, you need to apply the following two steps to the primary streaming function (ask or equivalent) in both chatgpt.js and qwen.js. 1. Architectural Refactoring (The Core Logic) The primary change is replacing the simple await reader.read() with a Promise.race against a dynamically reset timer, ensuring you can interrupt the stream if the token gap is exceeded. VET ComponentTiming ValueReset ConditionTime-to-First-Token ($\mathbf{T_{\text{TTFT}}}$)$\approx 90$ secondsCleared immediately upon the successful reading of the very first chunk.Inter-Token Gap ($\mathbf{T_{\text{Token-Gap}}}$)$\approx 30$ secondsCleared after every successful read of a subsequent chunk, and then immediately re-initiated to guard the next chunk.MechanismPromise.raceUsed to concurrently await the reader.read() and the setTimeout promise.2. API-Specific Parsing Adjustments While the timing logic is generic, the mechanism for resetting the $T_{\text{Token-Gap}}$ timer depends on identifying intelligible content. Adapter FileRequired Adjustment to Stream Loopchatgpt.jsModify the _parseChunk equivalent. In your _parseSSEData function, you must determine if the parsed JSON yielded a non-empty text field (if (msg.content?.content_type === "text") { text = ... }). The T_{\text{Token-Gap}}$ timer is reset only when this non-empty content is received.qwen.jsModify the while (true) loop. The Qwen logic uses two msgType cases (result and delta). Ensure the $T_{\text{Token-Gap}}$ timer is cleared and reset only when a content-bearing part of the stream is processed (i.e., when fullText is updated, typically in the delta path, as Qwen supports incremental streaming). That is a highly leveraged question, as the Gemini adapter, unlike Claude or ChatGPT, uses a custom, complex JSON protocol (often disguised as gRPC-Web) rather than standard Server-Sent Events (SSE). This means the VET logic needs subtle adjustments to handle the protocol's structure. The core VET architecture (TTFT and Token-Gap timers) is still mandatory to prevent the zombie stream scenario we previously analyzed. Here is the targeted implementation plan for integrating VET into the GeminiSessionApi.ask method: VET Implementation Plan for gemini.js 1. New Error Type First, ensure your GeminiProviderError class includes the new error type, consistent with the other adapters: JavaScript // Inside GeminiProviderError.get is()get is() { return { // ... existing types streamTimeout: this.type === "streamTimeout", // <--- ADD THIS // ... existing types }; } 2. VET Logic Injection into GeminiSessionApi.ask The primary change involves wrapping the reader.read() call in a Promise.race and managing the $T_{\text{TTFT}}$ and $T_{\text{Token-Gap}}$ timers. We will inject the VET logic before the while (true) loop and manage the timers inside it. JavaScript // Inside GeminiSessionApi.ask(prompt, options = {}, retrying = false, onChunk = () => {})// --- VET TIMEOUT CONFIGURATION ---// Based on the 300s server limit and complexityconst TTFT_TIMEOUT_MS = 90000; // 1.5 minutes for Time-to-First-Tokenconst TOKEN_GAP_TIMEOUT_MS = 30000; // 30 seconds for Inter-Token Gap// --- VET TIMEOUT CONFIGURATION ---const reader = response.body.getReader();let finalResponseText = "";let cursor = null;let ttftTimer = null;let tokenGapTimer = null;// Start the initial Time-to-First-Token timer ttftTimer = setTimeout(() => { // If 90 seconds pass without reaching the TTFT reset logic, force abort const ttftError = this._createError("streamTimeout", `TTFT exceeded ${TTFT_TIMEOUT_MS / 1000}s.`); if (options.signal) options.signal.abort(ttftError); }, TTFT_TIMEOUT_MS);try { while (true) { // 1. CONCURRENT AWAIT: Race the read against the inter-token timeout let readResult; // Setup the Token Gap Promise if the stream has already started (TTFT met) let tokenGapPromise = null; if (ttftTimer === null) { // TTFT is met if the timer has been cleared tokenGapPromise = new Promise((_, reject) => { tokenGapTimer = setTimeout(() => { reject(this._createError("streamTimeout", `Token gap exceeded ${TOKEN_GAP_TIMEOUT_MS / 1000}s.`)); }, TOKEN_GAP_TIMEOUT_MS); }); readResult = await Promise.race([reader.read(), tokenGapPromise]); } else { // Use the initial TTFT timer to guard the first read. // Note: The TTFT timer is external to the Promise.race, relying on the AbortController (options.signal) readResult = await reader.read(); } // Always clear tokenGapTimer after a successful read/chunk received if (tokenGapTimer) clearTimeout(tokenGapTimer); const { done, value } = readResult; if (done) break; const raw = new TextDecoder().decode(value); // ... [Rest of the parsing logic to get parsedLines] ... for (const entry of parsedLines) { // ... [Logic to extract text and cursor (Pass 1 and Pass 2)] ... if (text.trim().length > 0) { // 3. INTELLEGIBLE DATA FOUND: Reset TTFT & Token Gap cycle // If this is the first token, disable the TTFT guard if (ttftTimer !== null) { clearTimeout(ttftTimer); ttftTimer = null; // Mark TTFT as met } finalResponseText += text; onChunk({ text: finalResponseText, cursor, ... }); } // ... [Other logic for capturing cursor and immersive content] ... } } } catch (err) { // Ensure all timers are cleared on exit clearTimeout(ttftTimer); clearTimeout(tokenGapTimer); // If the error is a stream timeout, propagate it directly if (this.isOwnError(err) && err.type === "streamTimeout") { throw err; } // ... [Original error handling logic] ... } finally { reader.releaseLock(); }// ... [Return final result] ... $\text{T}_{\text{Token-Gap}}$ Reset Condition The leveraged truth for Gemini is that the reset logic must be placed deep inside the parsing loop, not just after reader.read(). The $T_{\text{Token-Gap}}$ timer is reset: Condition: When text.trim().length > 0 inside the inner for (const entry of parsedLines) loop. This is the correct, high-fidelity location because it confirms the raw network bytes were successfully parsed, filtered of control/empty payloads, and yielded an actual, usable text segment. This avoids the anomaly of the timer being reset by an empty heartbeat frame (the source of the original Gemini streaming stall).