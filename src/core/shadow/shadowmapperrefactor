## Implementation Sequence

---

### Phase 1: Shadow Mapper Refactor

Modify your existing files to output the new schema.

---

#### Step 1.1: `StatementTypes.ts`

**Input:** Current file with 5 types
**Output:** 6 stances + 3 signal patterns

**Changes:**

```typescript
// REMOVE
export type StatementType = 
    | 'prescriptive' | 'conflict' | 'prerequisite' | 'conditional' | 'assertive';

// REPLACE WITH
export type Stance = 
    | 'prescriptive'
    | 'cautionary'
    | 'prerequisite'
    | 'dependent'
    | 'assertive'
    | 'uncertain';

export const STANCE_PRIORITY: Stance[] = [
    'cautionary',
    'prerequisite',
    'dependent',
    'prescriptive',
    'uncertain',
    'assertive',
];

export const STANCE_PATTERNS: Record<Stance, RegExp[]> = {
    cautionary: [
        /\bdon'?t\b/i,
        /\bdo\s+not\b/i,
        /\bavoid\b/i,
        /\bnever\b/i,
        /\brisk\b/i,
        /\bcareful\b/i,
        /\bcaution\b/i,
        /\bwarning\b/i,
        /\bdanger\b/i,
        /\bpitfall\b/i,
        /\btrap\b/i,
        /\bmistake\b/i,
        /\berror\b/i,
        /\bproblem\s+with\b/i,
        /\bwatch\s+out\b/i,
        /\bbe\s+aware\b/i,
        /\bbeware\b/i,
    ],
    prerequisite: [
        /\bbefore\b/i,
        /\bfirst\b/i,
        /\bprior\s+to\b/i,
        /\brequires?\b/i,
        /\bneeds?\s+to\s+have\b/i,
        /\bprerequisite\b/i,
        /\bprecondition\b/i,
        /\bmust\s+(come|happen|occur)\s+before\b/i,
        /\bfoundation\s+for\b/i,
        /\bgroundwork\b/i,
        /\bcan'?t\s+.{0,20}\s+without\s+first\b/i,
    ],
    dependent: [
        /\bafter\b/i,
        /\bonce\b/i,
        /\bthen\s+you\s+can\b/i,
        /\bfollowing\s+this\b/i,
        /\bsubsequent\b/i,
        /\bonly\s+after\b/i,
        /\bwhen\s+.{0,20}\s+is\s+(done|complete|ready)\b/i,
        /\bhaving\s+(done|completed|established)\b/i,
    ],
    prescriptive: [
        /\bshould\b/i,
        /\bmust\b/i,
        /\bought\s+to\b/i,
        /\bneed\s+to\b/i,
        /\bhave\s+to\b/i,
        /\bensure\b/i,
        /\bmake\s+sure\b/i,
        /\balways\b/i,
        /\brequired\b/i,
        /\bessential\b/i,
        /\bcritical\s+to\b/i,
        /\bimperative\b/i,
        /\brecommend\b/i,
        /\bsuggest\b/i,
        /\badvise\b/i,
        /\bconsider\b/i,
    ],
    uncertain: [
        /\bmight\b/i,
        /\bmay\b/i,
        /\bcould\b/i,
        /\bpossibly\b/i,
        /\bperhaps\b/i,
        /\bmaybe\b/i,
        /\bunclear\b/i,
        /\bunknown\b/i,
        /\buncertain\b/i,
        /\bdepends\b/i,
        /\bnot\s+sure\b/i,
        /\bhard\s+to\s+(say|know|tell)\b/i,
        /\bdifficult\s+to\s+know\b/i,
        /\b(it|that)\s+varies\b/i,
    ],
    assertive: [
        /\bis\b/i,
        /\bare\b/i,
        /\bwas\b/i,
        /\bwere\b/i,
        /\bdoes\b/i,
        /\bdo\b/i,
        /\bhas\b/i,
        /\bhave\b/i,
        /\bworks?\b/i,
        /\bperforms?\b/i,
        /\bprovides?\b/i,
        /\boffers?\b/i,
        /\bincludes?\b/i,
        /\bexists?\b/i,
    ],
};

export interface SignalPatterns {
    sequence: RegExp[];
    tension: RegExp[];
    conditional: RegExp[];
}

export const SIGNAL_PATTERNS: SignalPatterns = {
    sequence: [
        /\bbefore\b/i,
        /\bafter\b/i,
        /\bfirst\b/i,
        /\bthen\b/i,
        /\bnext\b/i,
        /\bfinally\b/i,
        /\bonce\b/i,
        /\brequires?\b/i,
        /\bdepends\s+on\b/i,
        /\bprior\s+to\b/i,
        /\bsubsequent\b/i,
        /\bfollowing\b/i,
        /\bpreceding\b/i,
        /\bstep\s+\d\b/i,
        /\bphase\s+\d\b/i,
    ],
    tension: [
        /\bbut\b/i,
        /\bhowever\b/i,
        /\balthough\b/i,
        /\bthough\b/i,
        /\bdespite\b/i,
        /\bnevertheless\b/i,
        /\byet\b/i,
        /\binstead\b/i,
        /\brather\s+than\b/i,
        /\bon\s+the\s+other\s+hand\b/i,
        /\bin\s+contrast\b/i,
        /\bconversely\b/i,
        /\bversus\b/i,
        /\bvs\.?\b/i,
        /\bor\b/i,
        /\btrade-?off\b/i,
        /\bbalance\b/i,
        /\btension\b/i,
        /\bcompeting\b/i,
    ],
    conditional: [
        /\bif\b/i,
        /\bwhen\b/i,
        /\bunless\b/i,
        /\bassuming\b/i,
        /\bprovided\s+that\b/i,
        /\bgiven\s+that\b/i,
        /\bin\s+case\b/i,
        /\bcontingent\s+on\b/i,
        /\bsubject\s+to\b/i,
        /\bdepending\s+on\b/i,
        /\bfor\s+(this|that|these)\s+case\b/i,
        /\bin\s+(some|certain|specific)\s+cases\b/i,
    ],
};

// Helper functions
export function getStancePatterns(stance: Stance): RegExp[] {
    return STANCE_PATTERNS[stance];
}

export function getStancePriority(stance: Stance): number {
    return STANCE_PRIORITY.length - STANCE_PRIORITY.indexOf(stance);
}
```

**Remove:** `INCLUSION_PATTERNS`, `getPatternsByType`, `getPriority`

**Keep:** Pattern freezing logic in `index.ts` (update to freeze new objects)

---

#### Step 1.2: `ExclusionRules.ts`

**Changes:**

1. Replace all `StatementType` references with `Stance`
2. Remove rules where `appliesTo` includes `'conflict'` or `'conditional'`
3. Add rules for new stances: `'cautionary'`, `'dependent'`, `'uncertain'`

```typescript
import { Stance } from './StatementTypes';

export interface ExclusionRule {
    id: string;
    appliesTo: Stance[];  // Changed from StatementType
    pattern: RegExp;
    reason: string;
    severity: 'hard' | 'soft';
}

export const EXCLUSION_RULES: ExclusionRule[] = [
    // ═══════════════════════════════════════════════════════════════
    // UNIVERSAL EXCLUSIONS (apply to all stances)
    // ═══════════════════════════════════════════════════════════════
    {
        id: 'question_mark',
        appliesTo: ['prescriptive', 'cautionary', 'prerequisite', 'dependent', 'assertive', 'uncertain'],
        pattern: /\?$/,
        reason: 'Question, not statement',
        severity: 'hard'
    },
    {
        id: 'too_short',
        appliesTo: ['prescriptive', 'cautionary', 'prerequisite', 'dependent', 'assertive', 'uncertain'],
        pattern: /^.{0,15}$/,
        reason: 'Too short to be substantive',
        severity: 'hard'
    },
    {
        id: 'meta_let_me',
        appliesTo: ['prescriptive', 'cautionary', 'prerequisite', 'dependent', 'assertive', 'uncertain'],
        pattern: /^(let me|let's|i('ll| will| would)|allow me to)\b/i,
        reason: 'Meta-framing, not claim',
        severity: 'hard'
    },
    {
        id: 'meta_note',
        appliesTo: ['prescriptive', 'cautionary', 'prerequisite', 'dependent', 'assertive', 'uncertain'],
        pattern: /^(note that|it'?s worth (noting|mentioning)|keep in mind|remember that)\b/i,
        reason: 'Meta-commentary, not claim',
        severity: 'hard'
    },

    // ═══════════════════════════════════════════════════════════════
    // PRESCRIPTIVE EXCLUSIONS (keep existing, they're good)
    // ═══════════════════════════════════════════════════════════════
    {
        id: 'prescriptive_epistemic_should',
        appliesTo: ['prescriptive'],
        pattern: /\bshould\s+(be|have\s+been)\s+(clear|obvious|noted|apparent|evident)\b/i,
        reason: 'Epistemic "should", not prescriptive',
        severity: 'hard'
    },
    {
        id: 'prescriptive_past_tense',
        appliesTo: ['prescriptive'],
        pattern: /\bshould\s+have\s+(been|done|had|made|used)\b/i,
        reason: 'Past counterfactual, not active prescription',
        severity: 'soft'
    },
    {
        id: 'prescriptive_question_form',
        appliesTo: ['prescriptive'],
        pattern: /\bshould\s+(you|we|i|they)\s+.{0,30}\?/i,
        reason: 'Question form',
        severity: 'hard'
    },

    // ═══════════════════════════════════════════════════════════════
    // CAUTIONARY EXCLUSIONS (new)
    // ═══════════════════════════════════════════════════════════════
    {
        id: 'cautionary_hypothetical',
        appliesTo: ['cautionary'],
        pattern: /\b(might|could)\s+(potentially\s+)?(cause|create|lead\s+to)\b/i,
        reason: 'Speculative warning, weak signal',
        severity: 'soft'
    },
    {
        id: 'cautionary_third_party',
        appliesTo: ['cautionary'],
        pattern: /\b(some|others|people)\s+(say|warn|caution)\b/i,
        reason: 'Attributed caution, not asserted',
        severity: 'soft'
    },

    // ═══════════════════════════════════════════════════════════════
    // PREREQUISITE EXCLUSIONS (migrate from current)
    // ═══════════════════════════════════════════════════════════════
    {
        id: 'prereq_temporal_before',
        appliesTo: ['prerequisite'],
        pattern: /\b(long\s+before|just\s+before|shortly\s+before|the\s+day\s+before)\b/i,
        reason: 'Temporal narration, not dependency',
        severity: 'hard'
    },
    {
        id: 'prereq_first_ordinal',
        appliesTo: ['prerequisite'],
        pattern: /^first[,;]?\s+(let\s+me|i\s+want\s+to|i('ll| will)|we\s+should\s+note)\b/i,
        reason: 'Ordinal framing, not prerequisite',
        severity: 'hard'
    },
    {
        id: 'prereq_needs_improvement',
        appliesTo: ['prerequisite'],
        pattern: /\bneeds?\s+(improvement|work|attention|more|further)\b/i,
        reason: 'Assessment, not dependency',
        severity: 'hard'
    },

    // ═══════════════════════════════════════════════════════════════
    // DEPENDENT EXCLUSIONS (new)
    // ═══════════════════════════════════════════════════════════════
    {
        id: 'dependent_temporal_after',
        appliesTo: ['dependent'],
        pattern: /\b(shortly\s+after|right\s+after|just\s+after|the\s+day\s+after|years?\s+after)\b/i,
        reason: 'Temporal narration, not dependency',
        severity: 'hard'
    },
    {
        id: 'dependent_after_thought',
        appliesTo: ['dependent'],
        pattern: /\bafter\s+(all|a\s+while|some\s+time)\b/i,
        reason: 'Idiomatic "after", not sequence',
        severity: 'hard'
    },

    // ═══════════════════════════════════════════════════════════════
    // ASSERTIVE EXCLUSIONS (keep existing, they're good)
    // ═══════════════════════════════════════════════════════════════
    {
        id: 'assertive_definition',
        appliesTo: ['assertive'],
        pattern: /^[A-Z][a-z]+\s+(is|are)\s+(defined\s+as|a\s+type\s+of|the\s+process\s+of)\b/i,
        reason: 'Definition format, not claim',
        severity: 'hard'
    },
    {
        id: 'assertive_example',
        appliesTo: ['assertive'],
        pattern: /\b(for\s+example|for\s+instance|e\.g\.|such\s+as)\b/i,
        reason: 'Example, not claim',
        severity: 'soft'
    },
    {
        id: 'assertive_hypothetical',
        appliesTo: ['assertive'],
        pattern: /\b(imagine|suppose|say\s+you|let'?s\s+say|hypothetically)\b/i,
        reason: 'Hypothetical, not assertion',
        severity: 'hard'
    },

    // ═══════════════════════════════════════════════════════════════
    // UNCERTAIN EXCLUSIONS (new)
    // ═══════════════════════════════════════════════════════════════
    {
        id: 'uncertain_rhetorical',
        appliesTo: ['uncertain'],
        pattern: /\b(who\s+knows|hard\s+to\s+say\s+for\s+sure)\b/i,
        reason: 'Rhetorical uncertainty, not substantive',
        severity: 'soft'
    },
];

// Update helper functions
export function getRulesForType(stance: Stance): ExclusionRule[] {
    return EXCLUSION_RULES.filter(rule => rule.appliesTo.includes(stance));
}

export function getHardRulesForType(stance: Stance): ExclusionRule[] {
    return EXCLUSION_RULES.filter(
        rule => rule.appliesTo.includes(stance) && rule.severity === 'hard'
    );
}

export function getSoftRulesForType(stance: Stance): ExclusionRule[] {
    return EXCLUSION_RULES.filter(
        rule => rule.appliesTo.includes(stance) && rule.severity === 'soft'
    );
}
```

---

#### Step 1.3: `ShadowExtractor.ts`

**Complete rewrite of core logic:**

```typescript
import { Stance, STANCE_PATTERNS, STANCE_PRIORITY, SIGNAL_PATTERNS } from './StatementTypes';
import { ExclusionRule, getRulesForType } from './ExclusionRules';

// ═══════════════════════════════════════════════════════════════════
// OUTPUT TYPES
// ═══════════════════════════════════════════════════════════════════

export interface ShadowStatement {
    id: string;
    text: string;
    
    stance: Stance;
    
    signals: {
        sequence: boolean;
        tension: boolean;
        conditional: boolean;
    };
    
    confidence: number;
    sourceModel: number;
    
    location: {
        paragraphIndex: number;
        sentenceIndex: number;
    };
    fullParagraph: string;
}

export interface ShadowExtractionResult {
    statements: ShadowStatement[];
    excluded: ExcludedStatement[];
    meta: {
        totalSentences: number;
        candidateCount: number;
        statementCount: number;
        excludedCount: number;
        survivalRate: number;
        byStance: Record<Stance, number>;
        bySignal: {
            sequence: number;
            tension: number;
            conditional: number;
        };
        processingTimeMs: number;
    };
}

export interface ExcludedStatement {
    text: string;
    attemptedStance: Stance;
    sourceModel: number;
    excludedBy: string;
    reason: string;
}

// ═══════════════════════════════════════════════════════════════════
// SENTENCE EXTRACTION (keep existing, it's good)
// ═══════════════════════════════════════════════════════════════════

function extractSentences(text: string): string[] {
    const raw = text
        .split(/(?<=[.!?])\s+(?=[A-Z])|(?<=\n)(?=[A-Z])/)
        .map(s => s.trim())
        .filter(s => s.length > 0);

    return raw.filter(s => {
        if (s.length < 15) return false;
        if (/^[{}\[\]<>]|^(const|let|var|function|import|export|class)\s/.test(s)) return false;
        const alphaRatio = (s.match(/[a-zA-Z]/g) || []).length / s.length;
        if (alphaRatio < 0.5) return false;
        return true;
    });
}

// ═══════════════════════════════════════════════════════════════════
// STANCE CLASSIFICATION
// ═══════════════════════════════════════════════════════════════════

interface StanceMatch {
    stance: Stance;
    patternCount: number;
}

function classifyStance(sentence: string): StanceMatch {
    for (const stance of STANCE_PRIORITY) {
        const patterns = STANCE_PATTERNS[stance];
        const matches = patterns.filter(p => p.test(sentence));
        if (matches.length > 0) {
            return { stance, patternCount: matches.length };
        }
    }
    return { stance: 'assertive', patternCount: 1 };
}

// ═══════════════════════════════════════════════════════════════════
// SIGNAL DETECTION
// ═══════════════════════════════════════════════════════════════════

function detectSignals(sentence: string): ShadowStatement['signals'] {
    return {
        sequence: SIGNAL_PATTERNS.sequence.some(p => p.test(sentence)),
        tension: SIGNAL_PATTERNS.tension.some(p => p.test(sentence)),
        conditional: SIGNAL_PATTERNS.conditional.some(p => p.test(sentence)),
    };
}

// ═══════════════════════════════════════════════════════════════════
// EXCLUSION CHECKING
// ═══════════════════════════════════════════════════════════════════

interface ExclusionResult {
    survived: boolean;
    excludedBy: ExclusionRule | null;
    softMatches: ExclusionRule[];
    adjustedConfidence: number;
}

function checkExclusions(
    sentence: string,
    stance: Stance,
    baseConfidence: number
): ExclusionResult {
    const rules = getRulesForType(stance);
    const softMatches: ExclusionRule[] = [];

    for (const rule of rules) {
        if (rule.pattern.test(sentence)) {
            if (rule.severity === 'hard') {
                return {
                    survived: false,
                    excludedBy: rule,
                    softMatches: [],
                    adjustedConfidence: 0
                };
            } else {
                softMatches.push(rule);
            }
        }
    }

    const penaltyFactor = Math.pow(0.85, softMatches.length);
    const adjustedConfidence = baseConfidence * penaltyFactor;

    if (adjustedConfidence < 0.4) {
        return {
            survived: false,
            excludedBy: null,
            softMatches,
            adjustedConfidence
        };
    }

    return {
        survived: true,
        excludedBy: null,
        softMatches,
        adjustedConfidence
    };
}

// ═══════════════════════════════════════════════════════════════════
// MAIN EXTRACTION
// ═══════════════════════════════════════════════════════════════════

export function executeShadowExtraction(
    batchResponses: Array<{ modelIndex: number; content: string }>
): ShadowExtractionResult {
    const startTime = performance.now();

    const statements: ShadowStatement[] = [];
    const excluded: ExcludedStatement[] = [];
    let idCounter = 0;
    let totalSentences = 0;
    let candidateCount = 0;

    const byStance: Record<Stance, number> = {
        prescriptive: 0,
        cautionary: 0,
        prerequisite: 0,
        dependent: 0,
        assertive: 0,
        uncertain: 0,
    };
    const bySignal = { sequence: 0, tension: 0, conditional: 0 };

    for (const response of batchResponses) {
        const paragraphs = response.content.split(/\n\n+/).filter(p => p.trim());

        for (let pIdx = 0; pIdx < paragraphs.length; pIdx++) {
            const paragraph = paragraphs[pIdx];
            const sentences = extractSentences(paragraph);
            totalSentences += sentences.length;

            for (let sIdx = 0; sIdx < sentences.length; sIdx++) {
                const sentence = sentences[sIdx];

                // Classify stance
                const { stance, patternCount } = classifyStance(sentence);
                candidateCount++;

                // Calculate base confidence
                const baseConfidence = Math.min(0.5 + (patternCount * 0.1), 0.9);

                // Check exclusions
                const exclusionResult = checkExclusions(sentence, stance, baseConfidence);

                if (!exclusionResult.survived) {
                    excluded.push({
                        text: sentence,
                        attemptedStance: stance,
                        sourceModel: response.modelIndex,
                        excludedBy: exclusionResult.excludedBy?.id || 'soft_penalty_accumulation',
                        reason: exclusionResult.excludedBy?.reason ||
                            `Confidence too low after penalties`
                    });
                    continue;
                }

                // Detect signals
                const signals = detectSignals(sentence);

                // Build statement
                const statement: ShadowStatement = {
                    id: `s_${idCounter++}`,
                    text: sentence,
                    stance,
                    signals,
                    confidence: exclusionResult.adjustedConfidence,
                    sourceModel: response.modelIndex,
                    location: {
                        paragraphIndex: pIdx,
                        sentenceIndex: sIdx,
                    },
                    fullParagraph: paragraph,
                };

                statements.push(statement);

                // Update counts
                byStance[stance]++;
                if (signals.sequence) bySignal.sequence++;
                if (signals.tension) bySignal.tension++;
                if (signals.conditional) bySignal.conditional++;
            }
        }
    }

    return {
        statements,
        excluded,
        meta: {
            totalSentences,
            candidateCount,
            statementCount: statements.length,
            excludedCount: excluded.length,
            survivalRate: candidateCount > 0 ? statements.length / candidateCount : 0,
            byStance,
            bySignal,
            processingTimeMs: performance.now() - startTime,
        },
    };
}

// ═══════════════════════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════════════════════

export function countByStance(statements: ShadowStatement[]): Record<Stance, number> {
    const counts: Record<Stance, number> = {
        prescriptive: 0, cautionary: 0, prerequisite: 0,
        dependent: 0, assertive: 0, uncertain: 0,
    };
    for (const s of statements) {
        counts[s.stance]++;
    }
    return counts;
}

export function filterBySignal(
    statements: ShadowStatement[],
    signal: 'sequence' | 'tension' | 'conditional'
): ShadowStatement[] {
    return statements.filter(s => s.signals[signal]);
}
```

---

#### Step 1.4: `ShadowDelta.ts`

**Update to new schema:**

```typescript
import { ShadowStatement, ShadowExtractionResult } from './ShadowExtractor';
import { Stance } from './StatementTypes';

// ═══════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════

export interface UnreferencedStatement {
    statement: ShadowStatement;
    queryRelevance: number;
    signalWeight: number;
    adjustedScore: number;
}

export interface ShadowDeltaResult {
    unreferenced: UnreferencedStatement[];
    audit: {
        shadowStatementCount: number;
        referencedCount: number;
        unreferencedCount: number;
        highSignalUnreferencedCount: number;
        byStance: Record<Stance, { total: number; unreferenced: number }>;
    };
    processingTimeMs: number;
}

// ═══════════════════════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════════════════════

function normalizeText(text: string): string {
    return text
        .toLowerCase()
        .replace(/[^\w\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
}

function wordOverlap(a: string, b: string): number {
    const wordsA = new Set(normalizeText(a).split(' ').filter(w => w.length > 2));
    const wordsB = new Set(normalizeText(b).split(' ').filter(w => w.length > 2));

    if (wordsA.size === 0 || wordsB.size === 0) return 0;

    let overlap = 0;
    wordsA.forEach(word => {
        if (wordsB.has(word)) overlap++;
    });

    const unionSize = new Set([...wordsA, ...wordsB]).size;
    return overlap / unionSize;
}

function computeSignalWeight(signals: ShadowStatement['signals']): number {
    let weight = 0;
    if (signals.sequence) weight += 2;
    if (signals.tension) weight += 2;
    if (signals.conditional) weight += 1;
    return weight;
}

// ═══════════════════════════════════════════════════════════════════
// MAIN DELTA FUNCTION
// ═══════════════════════════════════════════════════════════════════

export function computeShadowDelta(
    shadowResult: ShadowExtractionResult,
    referencedStatementIds: Set<string>,
    userQuery: string
): ShadowDeltaResult {
    const startTime = performance.now();

    const byStance: Record<Stance, { total: number; unreferenced: number }> = {
        prescriptive: { total: 0, unreferenced: 0 },
        cautionary: { total: 0, unreferenced: 0 },
        prerequisite: { total: 0, unreferenced: 0 },
        dependent: { total: 0, unreferenced: 0 },
        assertive: { total: 0, unreferenced: 0 },
        uncertain: { total: 0, unreferenced: 0 },
    };

    const unreferenced: UnreferencedStatement[] = [];

    for (const statement of shadowResult.statements) {
        byStance[statement.stance].total++;

        if (!referencedStatementIds.has(statement.id)) {
            byStance[statement.stance].unreferenced++;

            const queryRelevance = wordOverlap(statement.text, userQuery);
            const signalWeight = computeSignalWeight(statement.signals);
            const adjustedScore = statement.confidence * (1 + queryRelevance) * (1 + signalWeight * 0.2);

            unreferenced.push({
                statement,
                queryRelevance,
                signalWeight,
                adjustedScore,
            });
        }
    }

    // Sort by adjusted score descending
    unreferenced.sort((a, b) => b.adjustedScore - a.adjustedScore);

    const highSignalUnreferencedCount = unreferenced.filter(u => u.signalWeight > 0).length;

    return {
        unreferenced,
        audit: {
            shadowStatementCount: shadowResult.statements.length,
            referencedCount: referencedStatementIds.size,
            unreferencedCount: unreferenced.length,
            highSignalUnreferencedCount,
            byStance,
        },
        processingTimeMs: performance.now() - startTime,
    };
}
```

---

#### Step 1.5: `index.ts`

**Update exports:**

```typescript
import { STANCE_PATTERNS, SIGNAL_PATTERNS } from './StatementTypes';
import { EXCLUSION_RULES } from './ExclusionRules';

let _initialized = false;

export function initializeShadowMapper(): void {
    if (_initialized) return;

    Object.freeze(STANCE_PATTERNS);
    Object.freeze(SIGNAL_PATTERNS);
    Object.freeze(EXCLUSION_RULES);

    for (const rule of EXCLUSION_RULES) {
        Object.freeze(rule);
    }

    _initialized = true;
    console.log('[Shadow] Pattern definitions locked. Guardrail 1 active.');
}

initializeShadowMapper();

export * from './StatementTypes';
export * from './ExclusionRules';
export * from './ShadowExtractor';
export * from './ShadowDelta';
```

---

### Phase 2: Build From Plan

After Phase 1 is complete, implement these in order:

---

#### Step 2.1: Claim Assembly (`claimAssembly.ts`)

**Depends on:** Semantic mapper output (you handle the prompt)
**Produces:** `EnrichedClaim[]` with provenance

```typescript
// Use Part 3 from the plan
// Key changes: inherit from ShadowStatement schema

export interface EnrichedClaim {
    id: string;
    label: string;
    text: string;
    stance: Stance;
    gate: string | null;
    
    sourceStatements: ShadowStatement[];
    supporterModels: number[];
    
    // Computed after graph built
    tier: number;
    gatedBy: string[];
    gates: string[];
}
```

---

#### Step 2.2: Traversal Graph (`traversal.ts`)

**Depends on:** Claim assembly + semantic mapper edges
**Produces:** `TraversalGraph` with tier assignments

Use Part 4 from the plan. Add cycle detection:

```typescript
// Addition to Part 4
interface CycleWarning {
    claimIds: string[];
    description: string;
}

// In buildTraversalGraph, track cycles and return them
```

---

#### Step 2.3: Forcing Points (`forcingPoints.ts`)

**Depends on:** Traversal graph
**Produces:** `ForcingPoint[]` with tier ordering

Use Part 5 from the plan. Add multi-way tension handling:

```typescript
// Addition to Part 5
function findTensionGroups(edges: Edge[]): string[][] {
    // Connected component detection for tension edges
    // Returns groups of claim IDs that are all in tension
}

// Multi-way forcing point:
{
    type: 'choice',
    options: [
        { claimId: 'c1', label: '...' },
        { claimId: 'c2', label: '...' },
        { claimId: 'c3', label: '...' },  // 3+ options
    ]
}
```

Update question wording to include claim content:

```typescript
// Instead of generic "Which matters more?"
question: `Which approach: "${claimA.label}" or "${claimB.label}"?`
```

---

#### Step 2.4: Traversal State (`traversalState.ts`)

**Depends on:** Forcing points + traversal graph
**Produces:** State machine for user navigation

Use Part 6 from the plan exactly.

---

### Dependency Graph

```
Phase 1:
StatementTypes.ts ──┐
                    ├──→ ShadowExtractor.ts ──→ ShadowDelta.ts
ExclusionRules.ts ──┘
                              │
                              ↓
Phase 2:                      │
                              │
[Your Semantic Mapper] ←──────┘
        │
        ↓
claimAssembly.ts
        │
        ↓
traversal.ts
        │
        ↓
forcingPoints.ts
        │
        ↓
traversalState.ts
        │
        ↓
[Your Synthesis Prompt]
        │
        ↓
[Your Pipeline Integration]
```

---

### Implementation Checklist

| Step | File | Status |
|------|------|--------|
| 1.1 | `StatementTypes.ts` | Build |
| 1.2 | `ExclusionRules.ts` | Modify |
| 1.3 | `ShadowExtractor.ts` | Rewrite |
| 1.4 | `ShadowDelta.ts` | Rewrite |
| 1.5 | `index.ts` | Update exports |
| 2.1 | `claimAssembly.ts` | Build new |
| 2.2 | `traversal.ts` | Build new |
| 2.3 | `forcingPoints.ts` | Build new |
| 2.4 | `traversalState.ts` | Build new |

---

Hand this to your agent. Each step has clear inputs, outputs, and dependencies.