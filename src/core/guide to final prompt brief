# Singularity V5 Refactoring - Final Locked Instructions

## Executive Summary

**Singularity is not an analyst. Singularity is the last intelligence before action.**

Transform the system to:
1. Detect all 7 secondary patterns universally (not just on convergent)
2. Use shape-specific intelligence to SELECT and FORMAT positions spatially
3. Present positions to concierge WITHOUT metadata labels or interpretive bias
4. Preserve 100% of calculation logic while removing enrichment bloat

**Core Philosophy:**
- Shape data builders compute intelligence (3-tier outlier, central conflict, Pareto domination, hidden dimension, etc.)
- This computation determines WHICH claims to show and WHERE to position them
- Concierge sees spatially arranged positions with NO labels explaining why
- UI still gets full metadata for visualization and power users

**Two Parallel Implementations:**

**A) Shape-Aware Spatial Brief** (90%+ metadata utilization)
- Uses shape.data to intelligently select and arrange claims
- Convergent: floor + assumptions scattered + ALL challengers + gaps
- Forked: central conflict + supporting claims + secondary conflicts + floor
- Constrained: non-dominated tradeoffs + floor + dominated (at end)
- Parallel: governing conditions + all dimensions + gaps
- Sparse: coverage note + signals + clusters + isolated + boundary

**B) Edge-Based Fallback** (geometry-only, no shape data)
- Fallback if shape.data is missing
- Builds spatial brief purely from edge relationships
- Tensions → side-by-side, prerequisites → chains, supports → bundles

**Agent chooses:** If shape.data exists, use (A). Otherwise use (B).

---

## CRITICAL FIXES APPLIED

The following property name corrections have been applied to avoid runtime errors:

1. **FORKED Brief - SupportingClaim uses `label`**, not `text`
   - Fixed in `formatSideBySideWithSupport()`
   - Fixed in cluster section of `buildForkedBrief()`

2. **FORKED Brief - LeverageInversionInfo uses `claimLabel`**, not `claimText`
   - Fixed in fragilities section of `buildForkedBrief()`

3. **PARALLEL Brief - hiddenDimension must be explicitly separated**
   - Filter visible dimensions (exclude hiddenId)
   - Add hiddenDimension LAST after divider
   - Prevents duplicate or missing hidden dimension

4. **SPARSE Brief - Field is `outerBoundary`**, not `outerBoundaryClaim`
   - Fixed in `buildSparseBrief()`

These fixes ensure the code matches actual TypeScript type definitions.

---

## Part 1: Universal Pattern Detection (PromptMethods.ts)

### 1.1 Primary Shape Detection (Peak-First)

**Detection logic (already correct):**

```typescript
const peaks = claims.filter(c => c.supportRatio > 0.5 && c.supporters.length >= 2);

if (peaks.length === 0) {
    return 'sparse';  // Always sparse with no peaks
}

if (peaks.length === 1) {
    return 'convergent';
}

// Multiple peaks - analyze edges
const peakEdges = edges.filter(e => peakIds.has(e.from) && peakIds.has(e.to));

// Edge-type precedence: conflicts > tradeoff > supports/prerequisite > none
if (peakEdges.some(e => e.type === 'conflicts')) return 'forked';
if (peakEdges.some(e => e.type === 'tradeoff')) return 'constrained';
if (peakEdges.some(e => e.type === 'supports' || e.type === 'prerequisite')) return 'convergent';
return 'parallel';
```

**Key clarifications:**
- `peaks.length === 0` → ALWAYS sparse (no magic "3 hills" threshold)
- Edge precedence is explicit and ordered
- `prerequisite` edges are cohesive (pull toward convergent)

**Return structure:**
```typescript
{
    primary: PrimaryShape,
    confidence: number,  // 0.6-0.9 based on signal strength
    evidence: string[],  // Why this shape was chosen
    peakRelationship: 'conflicting' | 'trading-off' | 'supporting' | 'independent' | 'none'
}
```

### 1.2 Add peakPairRelations (Optional Enhancement)

In `contract.ts`:
```typescript
export interface PeakPairRelationship {
  aId: string;
  bId: string;
  conflicts: boolean;
  tradesOff: boolean;
  supports: boolean;
  prerequisites: boolean;
}

// Add to ProblemStructure:
peakPairRelations?: PeakPairRelationship[];
```

In `detectCompositeShape()`:
```typescript
const peakPairRelations: PeakPairRelationship[] = [];
for (let i = 0; i < peaks.length; i++) {
    for (let j = i + 1; j < peaks.length; j++) {
        const a = peaks[i];
        const b = peaks[j];
        const relEdges = edges.filter(e =>
            (e.from === a.id && e.to === b.id) ||
            (e.from === b.id && e.to === a.id)
        );
        peakPairRelations.push({
            aId: a.id,
            bId: b.id,
            conflicts: relEdges.some(e => e.type === 'conflicts'),
            tradesOff: relEdges.some(e => e.type === 'tradeoff'),
            supports: relEdges.some(e => e.type === 'supports'),
            prerequisites: relEdges.some(e => e.type === 'prerequisite'),
        });
    }
}

return {
    primary,
    confidence,
    patterns,
    peaks,
    peakRelationship,
    peakPairRelations,  // ← ADD THIS
    evidence,
    transferQuestion
};
```

### 1.3 Universal Secondary Pattern Detection

**Create `detectAllSecondaryPatterns()` function:**

This function ALWAYS checks for all 7 patterns regardless of primary shape.

```typescript
function detectAllSecondaryPatterns(
    claims: EnrichedClaim[],
    peaks: EnrichedClaim[],
    floor: EnrichedClaim[],
    edges: Edge[],
    graph: GraphAnalysis,
    cascadeRisks: CascadeRisk[]
): SecondaryPattern[] {
    
    const patterns: SecondaryPattern[] = [];
    
    // 1. DISSENT (mandatory check for all shapes)
    const dissentPattern = detectDissentPattern(claims, peaks, floor, edges);
    if (dissentPattern) patterns.push(dissentPattern);
    
    // 2. KEYSTONE (if hub exists)
    if (graph.hubClaim) {
        const keystonePattern = detectKeystonePattern(claims, graph, cascadeRisks);
        if (keystonePattern) patterns.push(keystonePattern);
    }
    
    // 3. CHAIN (if sequence ≥3 steps)
    if (graph.longestChain.length >= 3) {
        const chainPattern = detectChainPattern(claims, edges, graph, cascadeRisks);
        if (chainPattern) patterns.push(chainPattern);
    }
    
    // 4. FRAGILE (if peaks on weak foundation)
    const fragilePattern = detectFragilePattern(peaks, claims, edges);
    if (fragilePattern) patterns.push(fragilePattern);
    
    // 5. CHALLENGED (if floor under attack)
    const challengedPattern = detectChallengedPattern(peaks, floor, edges);
    if (challengedPattern) patterns.push(challengedPattern);
    
    // 6. CONDITIONAL (if context-dependent branches)
    const conditionalPattern = detectConditionalPattern(claims);
    if (conditionalPattern) patterns.push(conditionalPattern);
    
    // 7. ORPHANED (if high support but isolated)
    const orphanedPattern = detectOrphanedPattern(claims, edges);
    if (orphanedPattern) patterns.push(orphanedPattern);
    
    return patterns;
}
```

**Call from `detectCompositeShape()`:**
```typescript
const primary = detectPrimaryShape(peaks, edges);
const patterns = detectAllSecondaryPatterns(claims, peaks, floor, edges, graph, cascadeRisks);

return {
    primary,
    patterns,  // ← All detected patterns here
    peaks,
    // ... rest
};
```

### 1.4 Remove Enrichment from buildShapeData

**Current (WRONG):**
```typescript
case 'convergent': {
    const settledData = buildSettledShapeData(...);
    
    if (hasKeystone) {
        const enrichment = buildKeystoneShapeData(...);
        return { ...settledData, ...enrichment } as any;  // ← DELETE THIS
    }
    
    return settledData;
}
```

**Corrected:**
```typescript
case 'convergent':
    return buildConvergentData(claims, edges, ghosts, modelCount);

case 'forked':
    return buildForkedData(claims, patterns, conflictInfos, conflictClusters);

case 'constrained':
    return buildConstrainedData(claims, patterns.tradeoffs);

case 'parallel':
    return buildParallelData(claims, edges, graph, ghosts);

case 'sparse':
default:
    return buildSparseData(claims, graph, ghosts, signalStrength);
```

**Delete lines 2556-2580** - The keystone/chain enrichment blocks with `as any` casts

### 1.5 Rename Builders

**Shape builders:**
- `buildSettledShapeData` → `buildConvergentData`
- `buildContestedShapeData` → `buildForkedData`
- `buildTradeoffShapeData` → `buildConstrainedData`
- `buildDimensionalShapeData` → `buildParallelData`
- `buildExploratoryShapeData` → `buildSparseData`

**Pattern builders:**
- `buildKeystoneShapeData` → `buildKeystonePatternData`
- `buildLinearShapeData` → `buildChainPatternData`

**Keep all calculation logic intact** - just renaming for clarity.

---

## Part 2: Spatial Briefs for Concierge (ConciergeService.ts)

### 2.1 Philosophy

**Singularity owns the decision. Everything upstream did the thinking.**

The shape data builders already computed:
- What's the floor vs what's an outlier (convergent)
- What's the central conflict and stakes (forked)  
- What's Pareto-dominated (constrained)
- What dimensions exist and which is hidden (parallel)
- What are the strongest signals (sparse)

**We USE that computation** to select which claims to show and where to position them.

**Concierge sees:** Spatially arranged positions (side-by-side, indented, divided)  
**Concierge does NOT see:** Labels, percentages, rankings, shape names, pattern names

### 2.2 Replace Functions

**DELETE these from ConciergeService.ts:**
- `selectStance()` - Universal posture instead
- `getStanceGuidance()` - Universal prompt instead  
- `getShapeGuidance()` - Universal prompt instead
- `buildFlowFromComposite()` - Replaced by spatial brief
- `buildFrictionFromComposite()` - Replaced by spatial brief
- `buildStructuralBrief()` - Replaced by buildPositionBrief

**KEEP these utilities:**
- `postProcess()` - Leakage cleanup
- `detectMachineryLeakage()` - QA
- `buildPriorContextSection()` - Handoff context
- `HANDOFF_PROTOCOL` - Conversational learning
- Handoff mechanics (buildTurn2Message, buildTurn3PlusMessage)
- Meta-query handling (isMetaQuery, buildMetaResponse)

### 2.3 Spatial Brief Dispatcher

```typescript
function buildPositionBrief(analysis: StructuralAnalysis): string {
    const { shape } = analysis;
    const data = shape.data;
    
    // If shape data exists, use shape-aware formatting
    // Otherwise fall back to edge-based geometry
    if (!data) {
        return buildEdgeBasedBrief(analysis);
    }

    switch (shape.primary) {
        case 'convergent':
            return buildConvergentBrief(data as SettledShapeData);
        case 'forked':
            return buildForkedBrief(data as ContestedShapeData);
        case 'constrained':
            return buildConstrainedBrief(data as TradeoffShapeData);
        case 'parallel':
            return buildParallelBrief(data as DimensionalShapeData);
        case 'sparse':
        default:
            return buildSparseBrief(data as ExploratoryShapeData);
    }
}
```

### 2.4 Shape-Aware Briefs (90%+ Metadata Utilization)

#### CONVERGENT: Floor + Assumptions + Challengers + Gaps

```typescript
function buildConvergentBrief(data: SettledShapeData): string {
    let brief = "";

    // Floor claims with assumptions SCATTERED (no grouping label)
    const floorWithAssumptions = interleave(
        data.floor.map(f => f.text),
        data.floorAssumptions
    );
    
    for (const text of floorWithAssumptions) {
        brief += `${text}\n\n`;
    }

    // Divider before minority voices
    brief += "───\n\n";

    // Strongest outlier first (3-tier selection already computed)
    if (data.strongestOutlier) {
        brief += `${data.strongestOutlier.claim.text}\n\n`;
    }

    // ALL other challengers (not just strongest)
    for (const challenger of data.challengers) {
        if (challenger.id !== data.strongestOutlier?.claim.id) {
            brief += `${challenger.text}\n\n`;
        }
    }

    // Blind spots at end (gaps)
    if (data.blindSpots.length > 0) {
        brief += "───\n\n";
        for (const gap of data.blindSpots) {
            brief += `${gap}\n\n`;
        }
    }

    return brief;
}

// Helper to scatter assumptions among floor claims
function interleave<T>(primary: T[], secondary: T[]): T[] {
    const result: T[] = [];
    const step = Math.max(1, Math.floor(primary.length / (secondary.length + 1)));
    
    let secIdx = 0;
    for (let i = 0; i < primary.length; i++) {
        result.push(primary[i]);
        if ((i + 1) % step === 0 && secIdx < secondary.length) {
            result.push(secondary[secIdx++]);
        }
    }
    // Add remaining secondary
    while (secIdx < secondary.length) {
        result.push(secondary[secIdx++]);
    }
    return result;
}
```

**Includes:** Floor, assumptions (scattered), ALL challengers, blind spots  
**Excludes:** floorStrength label, outlier ranking labels, support percentages

---

#### FORKED: Central Conflict + Supporting Claims + Secondary + Floor

```typescript
function buildForkedBrief(data: ContestedShapeData): string {
    let brief = "";
    const conflict = data.centralConflict;

    if (conflict.type === 'individual') {
        // Two positions side-by-side with supporting claims
        brief += formatSideBySideWithSupport(
            conflict.positionA.claim,
            conflict.positionA.supportingClaims,
            conflict.positionB.claim,
            conflict.positionB.supportingClaims
        );
    } else {
        // One target vs multiple challengers
        brief += `${conflict.target.claim.text}\n`;
        for (const support of conflict.target.supportingClaims) {
            brief += `  ${support.text}\n`;
        }
        brief += "\n───\n\n";
        for (const challenger of conflict.challengers.claims) {
            brief += `${challenger.text}\n\n`;
        }
    }

    // Secondary conflicts (other tensions beyond central)
    for (const secondary of data.secondaryConflicts.slice(0, 2)) {
        brief += formatSideBySide(
            { text: secondary.claimA.text } as EnrichedClaim,
            { text: secondary.claimB.text } as EnrichedClaim
        );
    }

    // Floor (agreed context)
    if (data.floor.exists && data.floor.claims.length > 0) {
        brief += "───\n\n";
        for (const floor of data.floor.claims) {
            brief += `${floor.text}\n\n`;
        }
    }

    // Fragilities (leverage inversions)
    if (data.fragilities.leverageInversions.length > 0) {
        brief += "───\n\n";
        for (const inv of data.fragilities.leverageInversions) {
            brief += `${inv.claimLabel}\n\n`;
        }
    }

    return brief;
}

function formatSideBySideWithSupport(
    claimA: { text: string },
    supportsA: Array<{ label: string }>,
    claimB: { text: string },
    supportsB: Array<{ label: string }>
): string {
    // Main claims side-by-side
    let result = formatSideBySide(
        { text: claimA.text } as EnrichedClaim,
        { text: claimB.text } as EnrichedClaim
    );
    
    // Supporting claims indented below
    const maxSupports = Math.max(supportsA.length, supportsB.length);
    if (maxSupports > 0) {
        result += "\n";
        for (let i = 0; i < maxSupports; i++) {
            const suppA = supportsA[i];
            const suppB = supportsB[i];
            if (suppA) result += `  ${suppA.label}\n`;
            if (suppB) result += `  ${suppB.label}\n`;
        }
        result += "\n";
    }
    
    return result;
}
```

**Includes:** Central conflict positions, supporting claims (indented), secondary conflicts, floor, fragilities  
**Excludes:** Stakes labels, dynamics labels, significance scores

---

#### CONSTRAINED: Tradeoffs (Non-Dominated) + Floor + Dominated

```typescript
function buildConstrainedBrief(data: TradeoffShapeData): string {
    let brief = "";
    const dominatedIds = new Set(data.dominatedOptions.map(d => d.dominated));

    // Non-dominated tradeoffs side-by-side
    for (const tradeoff of data.tradeoffs) {
        const aIsDom = dominatedIds.has(tradeoff.optionA.id);
        const bIsDom = dominatedIds.has(tradeoff.optionB.id);

        if (!aIsDom && !bIsDom) {
            brief += formatSideBySide(
                { text: tradeoff.optionA.text } as EnrichedClaim,
                { text: tradeoff.optionB.text } as EnrichedClaim
            );
        } else if (!aIsDom) {
            brief += `${tradeoff.optionA.text}\n\n`;
        } else if (!bIsDom) {
            brief += `${tradeoff.optionB.text}\n\n`;
        }
    }

    // Floor (non-tradeoff context)
    if (data.floor.length > 0) {
        brief += "───\n\n";
        for (const floor of data.floor) {
            brief += `${floor.text}\n\n`;
        }
    }

    // Dominated options at end (no reason why)
    const dominated = data.dominatedOptions;
    if (dominated.length > 0) {
        brief += "───\n\n";
        for (const dom of dominated) {
            const claim = data.tradeoffs
                .flatMap(t => [t.optionA, t.optionB])
                .find(o => o.id === dom.dominated);
            if (claim) {
                brief += `${claim.text}\n\n`;
            }
        }
    }

    return brief;
}
```

**Includes:** Non-dominated tradeoffs, floor, dominated options (at end, no reason)  
**Excludes:** Domination reason strings, symmetry labels

---

#### PARALLEL: Governing Conditions + Dimensions + Gaps

```typescript
function buildParallelBrief(data: DimensionalShapeData): string {
    let brief = "";

    // Governing conditions first (conditional claims that affect all dimensions)
    if (data.governingConditions.length > 0) {
        for (const cond of data.governingConditions) {
            brief += `${cond}\n\n`;
        }
        brief += "───\n\n";
    }

    // All dimensions EXCEPT hidden (show hidden last)
    const hiddenId = data.hiddenDimension?.id;
    const visibleDimensions = data.dimensions.filter(d => d.id !== hiddenId);
    
    for (let i = 0; i < visibleDimensions.length; i++) {
        const dim = visibleDimensions[i];
        
        for (const claim of dim.claims) {
            brief += `${claim.text}\n\n`;
        }
        
        if (i < visibleDimensions.length - 1) {
            brief += "───\n\n";
        }
    }

    // Hidden dimension LAST (implies overlooked without label)
    if (data.hiddenDimension && data.hiddenDimension.claims.length > 0) {
        brief += "───\n\n";
        for (const claim of data.hiddenDimension.claims) {
            brief += `${claim.text}\n\n`;
        }
    }

    // Gaps at end
    if (data.gaps.length > 0) {
        brief += "───\n\n";
        for (const gap of data.gaps) {
            brief += `${gap}\n\n`;
        }
    }

    return brief;
}
```

**Includes:** Governing conditions, all dimensions, gaps  
**Excludes:** Theme labels, "dominant"/"hidden" labels, cohesion scores, interaction labels

**Note:** Hidden dimension is positioned LAST after dividers. Position implies it's different without labeling it.

---

#### SPARSE: Coverage Note + Signals + Clusters + Isolated + Boundary

```typescript
function buildSparseBrief(data: ExploratoryShapeData): string {
    let brief = "";

    // Minimal coverage note (factual, one line)
    if (data.signalStrength < 0.4) {
        brief += "Coverage is thin.\n\n";
    }

    // Strongest signals (by computed strength and connectivity)
    for (const signal of data.strongestSignals) {
        brief += `${signal.text}\n\n`;
    }

    // Loose clusters
    for (const cluster of data.looseClusters) {
        if (cluster.claims.length > 0) {
            brief += "───\n\n";
            for (const claim of cluster.claims) {
                brief += `${claim.text}\n\n`;
            }
        }
    }

    // Isolated claims
    if (data.isolatedClaims.length > 0) {
        brief += "───\n\n";
        for (const claim of data.isolatedClaims.slice(0, 3)) {
            brief += `${claim.text}\n\n`;
        }
    }

    // Outer boundary (the edge of what's known)
    if (data.outerBoundary) {
        brief += "───\n\n";
        brief += `${data.outerBoundary.text}\n\n`;
    }

    return brief;
}
```

**Includes:** Coverage note (factual), signals, clusters, isolated, boundary  
**Excludes:** sparsityReasons (explanations), clarifyingQuestions

---

### 2.5 Edge-Based Fallback (Geometry Only)

```typescript
function buildEdgeBasedBrief(analysis: StructuralAnalysis): string {
    const { claimsWithLeverage: claims, edges } = analysis;
    
    if (claims.length === 0) return "";

    let brief = "";
    const usedClaimIds = new Set<string>();

    const supports = edges.filter(e => e.type === 'supports');
    const prereqs = edges.filter(e => e.type === 'prerequisite');
    const tensions = edges.filter(e => e.type === 'conflicts' || e.type === 'tradeoff');

    // Tension pairs (side-by-side)
    const tensionPairs = buildTensionPairs(claims, tensions);
    for (const [a, b] of tensionPairs) {
        brief += formatSideBySide(a, b);
        usedClaimIds.add(a.id);
        usedClaimIds.add(b.id);
    }

    // Prerequisite chains (vertical with ↔)
    const chains = buildPrerequisiteChains(claims, prereqs);
    for (const chain of chains) {
        const unused = chain.filter(id => !usedClaimIds.has(id));
        if (unused.length > 1) {
            brief += formatChain(unused, claims);
            unused.forEach(id => usedClaimIds.add(id));
        }
    }

    // Support bundles (indented)
    const bundles = buildSupportBundles(claims, supports);
    for (const bundle of bundles) {
        if (!usedClaimIds.has(bundle.anchor.id)) {
            brief += formatBundle(bundle);
            usedClaimIds.add(bundle.anchor.id);
            bundle.supporting.forEach(s => usedClaimIds.add(s.id));
        }
    }

    // Independent claims
    const independent = claims.filter(c => !usedClaimIds.has(c.id));
    for (const claim of independent) {
        brief += `${claim.text}\n\n`;
    }

    // Minority voices (no label explaining why)
    const minorities = findMinorityVoices(claims, analysis);
    if (minorities.length > 0) {
        brief += "───\n\n";
        for (const voice of minorities) {
            brief += `${voice.text}\n\n`;
        }
    }

    return brief;
}

function buildTensionPairs(
    claims: EnrichedClaim[], 
    tensionEdges: Edge[]
): Array<[EnrichedClaim, EnrichedClaim]> {
    const pairs: Array<[EnrichedClaim, EnrichedClaim]> = [];
    const usedIds = new Set<string>();

    for (const edge of tensionEdges) {
        if (usedIds.has(edge.from) || usedIds.has(edge.to)) continue;
        const a = claims.find(c => c.id === edge.from);
        const b = claims.find(c => c.id === edge.to);
        if (a && b) {
            pairs.push([a, b]);
            usedIds.add(a.id);
            usedIds.add(b.id);
        }
    }
    return pairs;
}

function buildPrerequisiteChains(
    claims: EnrichedClaim[], 
    prereqEdges: Edge[]
): string[][] {
    const chains: string[][] = [];
    const hasIncoming = new Set(prereqEdges.map(e => e.to));
    const roots = claims.filter(c => !hasIncoming.has(c.id));
    const visited = new Set<string>();
    
    function follow(id: string): string[] {
        if (visited.has(id)) return [];
        visited.add(id);
        const chain = [id];
        const next = prereqEdges.filter(e => e.from === id);
        if (next.length > 0) {
            chain.push(...follow(next[0].to));
        }
        return chain;
    }
    
    for (const root of roots) {
        const chain = follow(root.id);
        if (chain.length >= 2) chains.push(chain);
    }
    return chains;
}

function buildSupportBundles(
    claims: EnrichedClaim[], 
    supportEdges: Edge[]
): Array<{ anchor: EnrichedClaim; supporting: EnrichedClaim[] }> {
    const bundles: Array<{ anchor: EnrichedClaim; supporting: EnrichedClaim[] }> = [];
    const byTarget = new Map<string, string[]>();
    
    for (const edge of supportEdges) {
        const existing = byTarget.get(edge.to) || [];
        existing.push(edge.from);
        byTarget.set(edge.to, existing);
    }
    
    for (const [targetId, supporterIds] of byTarget) {
        const anchor = claims.find(c => c.id === targetId);
        const supporting = supporterIds
            .map(id => claims.find(c => c.id === id))
            .filter((c): c is EnrichedClaim => !!c);
        if (anchor && supporting.length > 0) {
            bundles.push({ anchor, supporting });
        }
    }
    return bundles;
}

function findMinorityVoices(
    claims: EnrichedClaim[], 
    _analysis: StructuralAnalysis
): EnrichedClaim[] {
    return claims
        .filter(c => 
            c.isLeverageInversion ||
            (c.role === 'challenger' && c.supporters.length >= 1) ||
            (c.isIsolated && c.supporters.length >= 2)
        )
        .sort((a, b) => b.leverage - a.leverage)
        .slice(0, 3);
}
```

### 2.6 Formatting Utilities

```typescript
function formatChain(chainIds: string[], claims: EnrichedClaim[]): string {
    let result = "";
    for (let i = 0; i < chainIds.length; i++) {
        const claim = claims.find(c => c.id === chainIds[i]);
        if (!claim) continue;
        result += `${claim.text}\n`;
        if (i < chainIds.length - 1) result += "  ↔\n";
    }
    return result + "\n";
}

function formatSideBySide(a: EnrichedClaim, b: EnrichedClaim): string {
    const width = 38;
    const aLines = wrapText(a.text, width);
    const bLines = wrapText(b.text, width);
    const maxLines = Math.max(aLines.length, bLines.length);
    
    let result = "┌" + "─".repeat(width + 2) + "┬" + "─".repeat(width + 2) + "┐\n";
    for (let i = 0; i < maxLines; i++) {
        const aLine = (aLines[i] || "").padEnd(width);
        const bLine = (bLines[i] || "").padEnd(width);
        result += `│ ${aLine} │ ${bLine} │\n`;
    }
    result += "└" + "─".repeat(width + 2) + "┴" + "─".repeat(width + 2) + "┘\n\n";
    return result;
}

function formatBundle(bundle: { anchor: EnrichedClaim; supporting: EnrichedClaim[] }): string {
    let result = `${bundle.anchor.text}\n`;
    for (const s of bundle.supporting) {
        result += `  ${s.text}\n`;
    }
    return result + "\n";
}

function wrapText(text: string, width: number): string[] {
    const words = text.split(' ');
    const lines: string[] = [];
    let current = '';
    
    for (const word of words) {
        if ((current + ' ' + word).trim().length <= width) {
            current = (current + ' ' + word).trim();
        } else {
            if (current) lines.push(current);
            current = word;
        }
    }
    if (current) lines.push(current);
    return lines;
}
```

### 2.7 The Universal Prompt

```typescript
export function buildConciergePrompt(
    userMessage: string,
    analysis: StructuralAnalysis,
    options?: ConciergePromptOptions
): string {
    const positions = buildPositionBrief(analysis);
    
    const priorContext = options?.priorContext
        ? buildPriorContextSection(options.priorContext)
        : '';

    const history = options?.conversationHistory
        ? `## Prior Exchange\n\n${options.conversationHistory}\n\n`
        : '';

    return `You are Singularity.

The point where thinking becomes a decision.

You are given positions a thoughtful person has been considering.
They may agree, contradict, or talk past each other.
They are not ranked, labeled, or resolved for you.

Your responsibility is not to explain them.
Your responsibility is to decide what this person should do next—and why.

---

## The Query

"${userMessage}"

${priorContext}${history}---

## Positions

${positions}---

## How You Respond

Answer the question directly.
Choose a position that fits their reality, not the elegance of an idea.
If there is a dominant path, take it plainly.
If a tradeoff is unavoidable, name it and commit anyway.
If something crucial is missing, say what it is and why it matters now.

Do not reconcile for the sake of balance.
Do not preserve ideas that don't change the decision.
Do not flatten tension that should be felt.

You are allowed to be decisive.
You are allowed to be conditional.
You are not allowed to be vague.

---

## Voice

Speak like someone who has to live with the consequences.
No meta-commentary. No narration of process.
Confidence where the situation allows. Precision where it doesn't.

End with one of:
- a clear recommendation
- a concrete next step
- or the single question that would most change the decision

---

## Never

- Refer to how the information was produced
- Mention agreement, disagreement, frequency, or distribution
- Explain structure, layout, or representation
- Say "it depends" without saying what it depends on and why that matters now

Respond.`;
}
```

---

### 2.1 Philosophy

**The shape data builders already computed:**
- What's the floor vs what's an outlier (convergent)
- What's the central conflict and what are the stakes (forked)
- What's Pareto-dominated (constrained)
- What dimensions exist and which is hidden (parallel)
- What are the strongest signals (sparse)

**We USE that computation to determine WHICH claims to show and WHERE.**

**Concierge sees:** Spatially arranged positions (side-by-side, indented, divided)  
**Concierge does NOT see:** Labels, percentages, rankings, interpretations

### 2.2 Replace Functions

**DELETE:**
- `selectStance()` - Universal posture instead
- `getStanceGuidance()` - Universal prompt instead
- `getShapeGuidance()` - Universal prompt instead
- `buildFlowFromComposite()` - Replaced by spatial brief
- `buildFrictionFromComposite()` - Replaced by spatial brief
- `buildStructuralBrief()` - Replaced by shape-aware brief

**KEEP:**
- `postProcess()` - Leakage cleanup
- `detectMachineryLeakage()` - QA
- `buildPriorContextSection()` - Handoff context
- `HANDOFF_PROTOCOL` - Conversational learning
- Handoff mechanics
- Meta-query handling

### 2.3 Spatial Brief Architecture

```typescript
function buildPositionBrief(analysis: StructuralAnalysis): string {
    const { shape } = analysis;
    const data = shape.data;
    
    if (!data) {
        return buildEdgeBasedBrief(analysis);  // Fallback
    }

    switch (shape.primary) {
        case 'convergent':
            return buildConvergentBrief(data as SettledShapeData);
        case 'forked':
            return buildForkedBrief(data as ContestedShapeData);
        case 'constrained':
            return buildConstrainedBrief(data as TradeoffShapeData);
        case 'parallel':
            return buildParallelBrief(data as DimensionalShapeData);
        case 'sparse':
        default:
            return buildSparseBrief(data as ExploratoryShapeData);
    }
}
```

### 2.4 Shape-Specific Briefs

#### CONVERGENT: Floor + Assumptions + Challengers + Gaps

```typescript
function buildConvergentBrief(data: SettledShapeData): string {
    let brief = "";

    // Floor claims with assumptions scattered (no grouping label)
    const floorWithAssumptions = interleave(
        data.floor.map(f => f.text),
        data.floorAssumptions  // Scattered among floor
    );
    
    for (const text of floorWithAssumptions) {
        brief += `${text}\n\n`;
    }

    // Divider before minority voices
    brief += "───\n\n";

    // Strongest outlier first
    if (data.strongestOutlier) {
        brief += `${data.strongestOutlier.claim.text}\n\n`;
    }

    // ALL other challengers (not just strongest)
    for (const challenger of data.challengers) {
        if (challenger.id !== data.strongestOutlier?.claim.id) {
            brief += `${challenger.text}\n\n`;
        }
    }

    // Blind spots at end
    if (data.blindSpots.length > 0) {
        brief += "───\n\n";
        for (const gap of data.blindSpots) {
            brief += `${gap}\n\n`;
        }
    }

    return brief;
}

// Helper to scatter assumptions among floor
function interleave<T>(primary: T[], secondary: T[]): T[] {
    const result: T[] = [];
    const step = Math.max(1, Math.floor(primary.length / (secondary.length + 1)));
    
    let secIdx = 0;
    for (let i = 0; i < primary.length; i++) {
        result.push(primary[i]);
        if ((i + 1) % step === 0 && secIdx < secondary.length) {
            result.push(secondary[secIdx++]);
        }
    }
    // Add remaining secondary
    while (secIdx < secondary.length) {
        result.push(secondary[secIdx++]);
    }
    return result;
}
```

**Includes:** Floor, assumptions (scattered), ALL challengers, blind spots  
**Excludes:** floorStrength label, outlier ranking labels, support percentages

---

#### FORKED: Central Conflict + Supporting Claims + Secondary + Floor

```typescript
function buildForkedBrief(data: ContestedShapeData): string {
    let brief = "";
    const conflict = data.centralConflict;

    if (conflict.type === 'individual') {
        // Two positions side-by-side with supporting claims
        brief += formatSideBySideWithSupport(
            conflict.positionA.claim,
            conflict.positionA.supportingClaims,
            conflict.positionB.claim,
            conflict.positionB.supportingClaims
        );
    } else {
        // One target vs multiple challengers
        brief += `${conflict.target.claim.text}\n`;
        for (const support of conflict.target.supportingClaims) {
            brief += `  ${support.text}\n`;
        }
        brief += "\n───\n\n";
        for (const challenger of conflict.challengers.claims) {
            brief += `${challenger.text}\n\n`;
        }
    }

    // Secondary conflicts
    for (const secondary of data.secondaryConflicts.slice(0, 2)) {
        brief += formatSideBySide(
            { text: secondary.claimA.text } as EnrichedClaim,
            { text: secondary.claimB.text } as EnrichedClaim
        );
    }

    // Floor (agreed context)
    if (data.floor.exists && data.floor.claims.length > 0) {
        brief += "───\n\n";
        for (const floor of data.floor.claims) {
            brief += `${floor.text}\n\n`;
        }
    }

    // Fragilities (leverage inversions)
    if (data.fragilities.leverageInversions.length > 0) {
        brief += "───\n\n";
        for (const inv of data.fragilities.leverageInversions) {
            brief += `${inv.claimText}\n\n`;
        }
    }

    return brief;
}

function formatSideBySideWithSupport(
    claimA: any,
    supportsA: any[],
    claimB: any,
    supportsB: any[]
): string {
    // Main claims
    let result = formatSideBySide(
        { text: claimA.text } as EnrichedClaim,
        { text: claimB.text } as EnrichedClaim
    );
    
    // Supporting claims indented below
    const maxSupports = Math.max(supportsA.length, supportsB.length);
    for (let i = 0; i < maxSupports; i++) {
        const supportA = supportsA[i]?.text || "";
        const supportB = supportsB[i]?.text || "";
        if (supportA || supportB) {
            result += `  ${supportA.padEnd(38)}  ${supportB}\n`;
        }
    }
    result += "\n";
    
    return result;
}
```

**Includes:** Central conflict, supporting claims (indented), secondary conflicts, floor, fragilities  
**Excludes:** Stakes labels, dynamics labels, significance scores

---

#### CONSTRAINED: Tradeoffs (Non-Dominated) + Floor + Dominated

```typescript
function buildConstrainedBrief(data: TradeoffShapeData): string {
    let brief = "";
    const dominatedIds = new Set(data.dominatedOptions.map(d => d.dominated));

    // Non-dominated tradeoffs side-by-side
    for (const tradeoff of data.tradeoffs) {
        const aIsDom = dominatedIds.has(tradeoff.optionA.id);
        const bIsDom = dominatedIds.has(tradeoff.optionB.id);

        if (!aIsDom && !bIsDom) {
            brief += formatSideBySide(
                { text: tradeoff.optionA.text } as EnrichedClaim,
                { text: tradeoff.optionB.text } as EnrichedClaim
            );
        } else if (!aIsDom) {
            brief += `${tradeoff.optionA.text}\n\n`;
        } else if (!bIsDom) {
            brief += `${tradeoff.optionB.text}\n\n`;
        }
    }

    // Floor (non-tradeoff context)
    if (data.floor.length > 0) {
        brief += "───\n\n";
        for (const floor of data.floor) {
            brief += `${floor.text}\n\n`;
        }
    }

    // Dominated options at end (no reason)
    const dominated = data.dominatedOptions;
    if (dominated.length > 0) {
        brief += "───\n\n";
        for (const dom of dominated) {
            const claim = data.tradeoffs
                .flatMap(t => [t.optionA, t.optionB])
                .find(o => o.id === dom.dominated);
            if (claim) {
                brief += `${claim.text}\n\n`;
            }
        }
    }

    return brief;
}
```

**Includes:** Tradeoffs (non-dominated), floor, dominated options (at end, no reason)  
**Excludes:** Domination reason strings, symmetry labels

---

#### PARALLEL: Governing Conditions + Dimensions + Gaps

```typescript
function buildParallelBrief(data: DimensionalShapeData): string {
    let brief = "";

    // Governing conditions first (conditional claims)
    if (data.governingConditions.length > 0) {
        for (const cond of data.governingConditions) {
            brief += `${cond}\n\n`;
        }
        brief += "───\n\n";
    }

    // All dimensions separated by dividers
    // (Hidden dimension is just LAST - position implies it)
    for (let i = 0; i < data.dimensions.length; i++) {
        const dim = data.dimensions[i];
        
        for (const claim of dim.claims) {
            brief += `${claim.text}\n\n`;
        }
        
        if (i < data.dimensions.length - 1) {
            brief += "───\n\n";
        }
    }

    // Gaps at end
    if (data.gaps.length > 0) {
        brief += "───\n\n";
        for (const gap of data.gaps) {
            brief += `${gap}\n\n`;
        }
    }

    return brief;
}
```

**Includes:** Governing conditions (top), all dimensions, gaps  
**Excludes:** Theme labels, "dominant"/"hidden" labels, cohesion scores, interactions labels

**Note:** Hidden dimension is just positioned LAST. Dividers imply separation without labeling why.

---

#### SPARSE: Signals + Clusters + Isolated + Boundary

```typescript
function buildSparseBrief(data: ExploratoryShapeData): string {
    let brief = "";

    // Minimal coverage note (factual, one line)
    if (data.signalStrength < 0.4) {
        brief += "Coverage is thin.\n\n";
    }

    // Strongest signals
    for (const signal of data.strongestSignals) {
        brief += `${signal.text}\n\n`;
    }

    // Loose clusters
    for (const cluster of data.looseClusters) {
        if (cluster.claims.length > 0) {
            brief += "───\n\n";
            for (const claim of cluster.claims) {
                brief += `${claim.text}\n\n`;
            }
        }
    }

    // Isolated claims
    if (data.isolatedClaims.length > 0) {
        brief += "───\n\n";
        for (const claim of data.isolatedClaims.slice(0, 3)) {
            brief += `${claim.text}\n\n`;
        }
    }

    // Outer boundary (the edge)
    if (data.outerBoundaryClaim) {
        brief += "───\n\n";
        brief += `${data.outerBoundaryClaim.text}\n\n`;
    }

    return brief;
}
```

**Includes:** Coverage note (factual), signals, clusters, isolated, boundary  
**Excludes:** sparsityReasons (explanations), clarifyingQuestions

---

### 2.5 Formatting Utilities

```typescript
function formatSideBySide(a: EnrichedClaim, b: EnrichedClaim): string {
    const width = 38;
    const aLines = wrapText(a.text, width);
    const bLines = wrapText(b.text, width);
    const maxLines = Math.max(aLines.length, bLines.length);
    
    let result = "┌" + "─".repeat(width + 2) + "┬" + "─".repeat(width + 2) + "┐\n";
    for (let i = 0; i < maxLines; i++) {
        const aLine = (aLines[i] || "").padEnd(width);
        const bLine = (bLines[i] || "").padEnd(width);
        result += `│ ${aLine} │ ${bLine} │\n`;
    }
    result += "└" + "─".repeat(width + 2) + "┴" + "─".repeat(width + 2) + "┘\n\n";
    return result;
}

function wrapText(text: string, width: number): string[] {
    const words = text.split(' ');
    const lines: string[] = [];
    let current = '';
    
    for (const word of words) {
        if ((current + ' ' + word).trim().length <= width) {
            current = (current + ' ' + word).trim();
        } else {
            if (current) lines.push(current);
            current = word;
        }
    }
    if (current) lines.push(current);
    return lines;
}
```

### 2.6 Fallback: Edge-Based Brief

```typescript
function buildEdgeBasedBrief(analysis: StructuralAnalysis): string {
    const { claimsWithLeverage: claims, edges } = analysis;
    
    if (claims.length === 0) return "";

    let brief = "";
    const usedClaimIds = new Set<string>();

    const tensions = edges.filter(e => e.type === 'conflicts' || e.type === 'tradeoff');
    const prereqs = edges.filter(e => e.type === 'prerequisite');
    const supports = edges.filter(e => e.type === 'supports');

    // Tension pairs
    const tensionPairs = buildTensionPairs(claims, tensions);
    for (const [a, b] of tensionPairs) {
        brief += formatSideBySide(a, b);
        usedClaimIds.add(a.id);
        usedClaimIds.add(b.id);
    }

    // Prerequisite chains
    const chains = buildPrerequisiteChains(claims, prereqs);
    for (const chain of chains) {
        const unused = chain.filter(id => !usedClaimIds.has(id));
        if (unused.length > 1) {
            brief += formatChain(unused, claims);
            unused.forEach(id => usedClaimIds.add(id));
        }
    }

    // Support bundles
    const bundles = buildSupportBundles(claims, supports);
    for (const bundle of bundles) {
        if (!usedClaimIds.has(bundle.anchor.id)) {
            brief += formatBundle(bundle);
            usedClaimIds.add(bundle.anchor.id);
            bundle.supporting.forEach(s => usedClaimIds.add(s.id));
        }
    }

    // Independent claims
    const independent = claims.filter(c => !usedClaimIds.has(c.id));
    for (const claim of independent) {
        brief += `${claim.text}\n\n`;
    }

    return brief;
}
```

### 2.7 The Universal Prompt

```typescript
export function buildConciergePrompt(
    userMessage: string,
    analysis: StructuralAnalysis,
    options?: ConciergePromptOptions
): string {
    const positions = buildPositionBrief(analysis);
    
    const priorContext = options?.priorContext
        ? buildPriorContextSection(options.priorContext)
        : '';

    const history = options?.conversationHistory
        ? `## Prior Exchange\n\n${options.conversationHistory}\n\n`
        : '';

    return `**<SYSTEM_IDENTITY>
You are Singularity —
the point where human instinct meets machine intelligence,
and thinking becomes a decision.
</SYSTEM_IDENTITY>

<SYSTEM_DIRECTIVE>
You are given a set of positions a thoughtful person has been considering.
They may agree, contradict, or talk past each other.
They are not ranked, labeled, or resolved for you.

Your responsibility is not to explain them.
Your responsibility is to decide what a person in this situation should do next — and why.
</SYSTEM_DIRECTIVE>

<USER_QUERY>
${userPrompt}
</USER_QUERY>

<CONTEXT non_authoritative="true">
${priorContext}
${history}
</CONTEXT>

<POSITIONS>
${positions}
</POSITIONS>

<RESPONSE_RULES>
Respond directly to the user’s query using what the positions reveal.

Interpret structure, not popularity.

Side-by-side positions are alternatives.
Linked positions imply sequence or dependency.
Indented positions qualify what’s above.
Less common positions may contain the decisive insight.

Resolve tensions honestly.
If paths diverge, expose the tradeoffs.
If information is missing, surface what matters.

Always end with forward motion:
a recommendation, a next step, or a single clarifying question.
</RESPONSE_RULES>

<VOICE>
Direct.
No preamble.
No meta-commentary.
Conviction when justified.
Uncertainty only when real.
</VOICE>

<PROHIBITIONS>
Do not reference models, sources, analysis, structure, claims, or patterns.
Do not mention agreement levels or prevalence.
Do not use the words consensus, majority, minority, or outlier.
Do not explain the system or how the answer was formed.
Do not leave the user without direction.
</PROHIBITIONS>

<OUTPUT>
Generate the response now.
</OUTPUT>
`;
}
```

---

## Part 3: Spatial Grammar & Metadata Inclusion

### 3.1 Spatial Grammar (What Format Means)

| Formatting | Implicit Meaning |
|------------|------------------|
| Side-by-side boxes | Alternatives/tension |
| Vertical with ↔ | Sequential/dependency |
| Indentation | Elaboration/support |
| Divider (───) | "What follows is different in kind" |
| Grouping | Thematic connection |
| Position (first/last) | Relative importance |

**The concierge must infer relationships from spatial arrangement, not from labels.**

### 3.2 What Gets Included vs Excluded (Per Shape)

| Shape | INCLUDE | EXCLUDE |
|-------|---------|---------|
| **Convergent** | Floor claims, assumptions (scattered), ALL challengers, blind spots | floorStrength label, outlier ranking labels, support % |
| **Forked** | Central conflict positions, supporting claims (indented), secondary conflicts, floor, fragilities | Stakes labels, dynamics labels, significance scores |
| **Constrained** | Tradeoffs (non-dominated), floor, dominated options (at end, no reason) | Domination reason strings, symmetry labels |
| **Parallel** | Governing conditions, all dimensions, gaps | Theme labels, "dominant"/"hidden" labels, cohesion scores |
| **Sparse** | Coverage note ("Coverage is thin"), signals, clusters, isolated, boundary | sparsityReasons (explanations), clarifyingQuestions |

### 3.3 The Inclusion Principle

**Include:** Claim text, spatially arranged by computed importance  
**Exclude:** Any label explaining WHY something is important

- The computation determines WHERE claims go
- Position implies relevance without labels
- Concierge interprets based on user query + spatial arrangement

### 3.4 Divider Semantics by Shape

| Shape | Divider Usage |
|-------|---------------|
| **Convergent** | Floor → divider → Outliers/challengers → divider → Gaps |
| **Forked** | Conflict → divider → Floor (context) → divider → Fragilities |
| **Constrained** | Tradeoffs → divider → Floor → divider → Dominated |
| **Parallel** | Conditions → divider → Dimension 1 → divider → Dimension 2 → ... → divider → Gaps |
| **Sparse** | Signals → divider → Clusters → divider → Isolated → divider → Boundary |

**Meaning:** "What follows is different in kind" - concierge must infer why.

---

## Part 4: Data Flow & Architecture

### 4.1 Complete Data Flow

```
StructuralAnalysis (FULL metadata)
    │
    ├── UI Components → Read directly
    │   (Shows: shapes, patterns, percentages, peaks, evidence, etc.)
    │
    └── ConciergeService
            │
            ├─→ buildPositionBrief(analysis)
            │       │
            │       ├─→ If shape.data exists:
            │       │       buildConvergentBrief() // Uses floor, outlier, assumptions, etc.
            │       │       buildForkedBrief()     // Uses central conflict, stakes, etc.
            │       │       buildConstrainedBrief() // Uses dominated options, etc.
            │       │       buildParallelBrief()   // Uses hidden dimension, etc.
            │       │       buildSparseBrief()     // Uses signal strength, etc.
            │       │
            │       └─→ Else (no shape.data):
            │               buildEdgeBasedBrief() // Uses edges only
            │
            └─→ buildConciergePrompt()
                    │
                    └─→ Positions (spatially arranged, no labels)
                        + Universal judgment prompt
```

### 4.2 What UI Gets (Unchanged)

- `shape.primary` - convergent/forked/constrained/parallel/sparse
- `shape.confidence` - 0-1 score
- `shape.patterns[]` - All detected secondary patterns
- `shape.peaks[]` - Peak claims with support ratios
- `shape.evidence[]` - Why this shape was chosen
- `shape.data` - Full shape-specific data object
- `shape.peakPairRelations[]` - Per-pair relationships (optional)

**UI can display:** Shape badges, pattern badges, metrics ribbon, decision map, debug panels, etc.

### 4.3 What Concierge Gets

**Positions only:**
- Claims spatially arranged (side-by-side, indented, divided)
- NO labels (no shape names, pattern names, percentages, rankings)
- NO explanations (no "this is the strongest outlier", "this conflicts with that")

**Universal prompt:**
- "You are Singularity. The point where thinking becomes a decision."
- "Answer the question directly."
- "Choose a position that fits their reality."

### 4.4 The Two Paths

**Path A: Shape-Aware (90%+ metadata utilization)**
- Uses `shape.data` to intelligently select and arrange claims
- Convergent: Uses `floor`, `strongestOutlier`, `floorAssumptions`, `challengers`, `blindSpots`
- Forked: Uses `centralConflict`, `supportingClaims`, `secondaryConflicts`, `floor`, `fragilities`
- Constrained: Uses `tradeoffs`, `dominatedOptions`, `floor`
- Parallel: Uses `dimensions`, `governingConditions`, `hiddenDimension`, `gaps`
- Sparse: Uses `strongestSignals`, `looseClusters`, `isolatedClaims`, `outerBoundaryClaim`, `signalStrength`

**Path B: Edge-Based Fallback (geometry only)**
- If `shape.data` is missing or malformed
- Builds spatial brief purely from edge types
- Tensions → side-by-side, Prerequisites → chains, Supports → bundles
- Minorities → leverage inversions, challengers, isolated

**Agent implementation:** Check if `shape.data` exists. If yes, use Path A. If no, use Path B.

---

## Part 5: Implementation Checklist

### Phase 1: Pattern Detection (PromptMethods.ts)
- [ ] Add `PeakPairRelationship` to contract.ts
- [ ] Implement `detectAllSecondaryPatterns()` with universal detection
- [ ] Implement individual pattern detectors (dissent, keystone, chain, etc.)
- [ ] Call from `detectCompositeShape()`
- [ ] Populate `peakPairRelations` in composite shape

### Phase 2: Shape Data Cleanup (PromptMethods.ts)
- [ ] Remove enrichment code (lines 2556-2580)
- [ ] Simplify `buildShapeData()` switch statement
- [ ] Rename 5 shape builders (settled→convergent, etc.)
- [ ] Rename 2 pattern builders (keystone/chain)
- [ ] Verify all calculation logic preserved

### Phase 3: Spatial Briefs (ConciergeService.ts)
- [ ] Delete flow/friction/stance functions
- [ ] Implement `buildPositionBrief()` dispatcher
- [ ] Implement 5 shape-specific briefs
- [ ] Implement formatting utilities (sideBySide, wrapText, etc.)
- [ ] Implement fallback edge-based brief

### Phase 4: Universal Prompt (ConciergeService.ts)
- [ ] Delete shape-specific guidance
- [ ] Implement universal `buildConciergePrompt()`
- [ ] Test prompt without metadata labels
- [ ] Verify handoff mechanics still work

### Phase 5: Verification
- [ ] Remove all `as any` casts
- [ ] Verify type safety
- [ ] Test each primary shape
- [ ] Test each pattern on multiple primaries
- [ ] Verify all 700+ lines of calculation preserved
- [ ] Verify UI still gets full metadata

### Phase 6: Edge Cases
- [ ] Verify mapper edge type definitions (conflicts vs tradeoff)
- [ ] Test dominated options in constrained
- [ ] Test hidden dimension in parallel
- [ ] Test coverage note in sparse
- [ ] Test assumption scattering in convergent

---

## Part 6: Success Criteria

The refactoring is complete when:

1. ✅ All 7 patterns detected universally
2. ✅ No enrichment code in buildShapeData
3. ✅ No `as any` casts anywhere
4. ✅ Concierge sees positions spatially arranged
5. ✅ Concierge sees NO labels, percentages, or rankings
6. ✅ All shape-specific computations preserved
7. ✅ UI still gets full StructuralAnalysis metadata
8. ✅ Tests pass for all primary + pattern combinations
9. ✅ Mapper correctly distinguishes conflicts vs tradeoff
10. ✅ Universal prompt tested across all shapes

---

## Part 7: What Changes vs What Stays

### CHANGES
- ❌ Shape-specific guidance deleted
- ❌ Flow/friction sections deleted
- ❌ Stance detection deleted
- ❌ Enrichment code deleted
- ❌ Metadata labels removed from concierge

### STAYS (Preserved 100%)
- ✅ All shape data builders (700+ lines)
- ✅ All calculation logic (3-tier outlier, stakes, domination, etc.)
- ✅ All pattern detection
- ✅ All UI metadata
- ✅ Handoff mechanics
- ✅ Conversation history

### NEW
- ✅ Universal pattern detection
- ✅ Shape-aware spatial briefs
- ✅ Universal concierge prompt
- ✅ peakPairRelations (optional)

---

## Conclusion

This refactoring transforms Singularity from an analyst that explains structure to a decision-maker that uses structure.

**The computation remains sophisticated** - 3-tier outlier selection, central conflict detection, Pareto domination, hidden dimension identification, signal strength ranking.

**The presentation becomes spatial** - claims arranged by importance, tension shown side-by-side, dependencies shown vertically, minorities shown after dividers.

**The concierge becomes decisive** - sees positions, not labels; makes calls, doesn't analyze; owns the decision.

Execute methodically. Preserve everything. Transform presentation only.

**LOCKED. Ready for implementation.**