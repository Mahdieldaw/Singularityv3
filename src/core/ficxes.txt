# Issues 46-53: Additional Fixes

---

## üü† 46. `shared/parsing-utils.ts` (lines 1750-2014)
### Partial/Undefined Delta Fields Cause Runtime Errors

**Problem:** `hasHandoffContent`, `formatHandoffContext`, and `formatHandoffEcho` assume all `ConciergeDelta` fields exist and call `.length` on them, which throws for partial/undefined deltas.

**Current Code:**
```typescript
export function hasHandoffContent(delta: ConciergeDelta): boolean {
  return (
    delta.constraints.length > 0 ||      // ‚ùå Throws if undefined
    delta.eliminatedOptions.length > 0 || // ‚ùå Throws if undefined
    delta.preferences.length > 0 ||       // ‚ùå Throws if undefined
    !!delta.situationalContext ||
    !!delta.commit
  );
}

export function formatHandoffContext(delta: ConciergeDelta): string {
  const parts: string[] = [];
  
  if (delta.constraints.length > 0) {  // ‚ùå Throws if undefined
    parts.push(`Constraints: ${delta.constraints.join('; ')}`);
  }
  // ...
}

export function formatHandoffEcho(delta: ConciergeDelta): string {
  const lines: string[] = ['---CURRENT_HANDOFF---'];
  
  if (delta.constraints.length > 0) {  // ‚ùå Throws if undefined
    lines.push(`constraints: ${delta.constraints.join('; ')}`);
  }
  // ...
}
```

**Fix:**
```typescript
export function hasHandoffContent(delta: ConciergeDelta | null | undefined): boolean {
  if (!delta) return false;
  
  return (
    (delta.constraints?.length ?? 0) > 0 ||
    (delta.eliminatedOptions?.length ?? 0) > 0 ||
    (delta.preferences?.length ?? 0) > 0 ||
    !!delta.situationalContext ||
    !!delta.commit
  );
}

export function formatHandoffContext(delta: ConciergeDelta | null | undefined): string {
  if (!delta) return '';
  
  const parts: string[] = [];
  
  const constraints = delta.constraints ?? [];
  const eliminated = delta.eliminatedOptions ?? [];
  const preferences = delta.preferences ?? [];
  
  if (constraints.length > 0) {
    parts.push(`Constraints: ${constraints.join('; ')}`);
  }
  if (eliminated.length > 0) {
    parts.push(`Eliminated: ${eliminated.join('; ')}`);
  }
  if (preferences.length > 0) {
    parts.push(`Preferences: ${preferences.join('; ')}`);
  }
  if (delta.situationalContext) {
    parts.push(`Context: ${delta.situationalContext}`);
  }
  
  return parts.join('\n');
}

export function formatHandoffEcho(delta: ConciergeDelta | null | undefined): string {
  if (!delta) return '';
  
  const lines: string[] = ['---CURRENT_HANDOFF---'];
  
  const constraints = delta.constraints ?? [];
  const eliminated = delta.eliminatedOptions ?? [];
  const preferences = delta.preferences ?? [];
  
  if (constraints.length > 0) {
    lines.push(`constraints: ${constraints.join('; ')}`);
  }
  if (eliminated.length > 0) {
    lines.push(`eliminated: ${eliminated.join('; ')}`);
  }
  if (preferences.length > 0) {
    lines.push(`preferences: ${preferences.join('; ')}`);
  }
  if (delta.situationalContext) {
    lines.push(`situational: ${delta.situationalContext}`);
  }
  // Never echo commit
  
  lines.push('---END_CURRENT_HANDOFF---');
  return lines.join('\n');
}
```

---

## üü† 47. `src/core/PromptMethods.ts` (lines 551-697)
### `claim.challenges` Treated as Claim ID Without Validation

**Problem:** `detectDissentPattern` unconditionally treats `claim.challenges` as a valid claim ID, but it could be arbitrary free-text that doesn't correspond to any peak.

**Current Code:**
```typescript
const targets = claim.challenges 
  ? [claim.challenges]  // ‚ùå Assumes this is a valid peak ID
  : edges
      .filter(e => e.from === claim.id && e.type === 'challenges')
      .map(e => e.to);

// Later used assuming targets are valid peak IDs
targets.forEach(targetId => {
  const targetClaim = claims.find(c => c.id === targetId);  // May be undefined
  // ...
});
```

**Fix:**
```typescript
const getValidTargets = (claim: EnrichedClaim): string[] => {
  // First, try claim.challenges if it's a valid peak ID
  if (claim.challenges && peakIdsSet.has(claim.challenges)) {
    return [claim.challenges];
  }
  
  // Fall back to edges-based lookup
  const edgeTargets = edges
    .filter(e => e.from === claim.id && e.type === 'challenges')
    .map(e => e.to)
    .filter(targetId => peakIdsSet.has(targetId));  // Only validated IDs
  
  return edgeTargets;
};

// Usage
dissenterClaims.forEach(claim => {
  const targets = getValidTargets(claim);
  
  if (targets.length === 0) {
    // No valid targets - skip or handle differently
    return;
  }
  
  targets.forEach(targetId => {
    const targetClaim = claims.find(c => c.id === targetId);
    if (!targetClaim) return;  // Extra safety check
    
    // ... rest of logic
  });
});
```

**Alternative ‚Äî more explicit validation:**
```typescript
// Build validated targets, filtering out any that aren't real peak IDs
const rawTargets = claim.challenges 
  ? [claim.challenges] 
  : edges
      .filter(e => e.from === claim.id && e.type === 'challenges')
      .map(e => e.to);

// Only keep targets that exist in our peak set
const targets = rawTargets.filter(id => peakIdsSet.has(id));

if (targets.length === 0 && rawTargets.length > 0) {
  console.debug(`[detectDissentPattern] Filtered out invalid targets for claim ${claim.id}:`, rawTargets);
}
```

---

## üü† 48. `src/core/PromptMethods.ts` (lines 376-519)
### "Convergent" Classification Allows Zero Peaks

**Problem:** The condition `peaks.length <= 1` allows convergent classification when there are zero peaks, leading to nonsensical evidence like "0 aligned peaks".

**Current Code:**
```typescript
// Single peak or all peaks support each other ‚Üí CONVERGENT
if (peaks.length <= 1 ||  // ‚ùå Allows 0 peaks
    (peaks.length > 1 && peakConflicts.length === 0 && peakTradeoffs.length === 0 && peakSupports.length > 0)) {
    const avgSupport = peaks.length > 0
        ? peaks.reduce((s, p) => s + p.supportRatio, 0) / peaks.length
        : 0;
    return {
        primary: 'convergent',
        confidence: Math.min(0.9, 0.5 + avgSupport * 0.4),
        evidence: [
            peaks.length === 1
                ? `Single dominant position: "${peaks[0].label}" (${(peaks[0].supportRatio * 100).toFixed(0)}%)`
                : `${peaks.length} aligned peaks with mutual support`,  // ‚ùå "0 aligned peaks"
            // ...
        ]
    };
}
```

**Fix:**
```typescript
// SPARSE check should come first (no peaks)
if (peaks.length === 0 && hills.length < 3) {
    return {
        primary: 'sparse',
        confidence: 0.9,
        evidence: [
            `No claims with >50% support`,
            `Only ${hills.length} claim(s) in contested range`,
            `Insufficient signal to determine structure`
        ]
    };
}

// CONVERGENT: Requires at least one peak
if (peaks.length === 1 || 
    (peaks.length > 1 && peakConflicts.length === 0 && peakTradeoffs.length === 0 && peakSupports.length > 0)) {
    
    // Safe to access peaks[0] since we know peaks.length >= 1
    const avgSupport = peaks.reduce((s, p) => s + p.supportRatio, 0) / peaks.length;
    
    return {
        primary: 'convergent',
        confidence: Math.min(0.9, 0.5 + avgSupport * 0.4),
        evidence: [
            peaks.length === 1
                ? `Single dominant position: "${peaks[0].label}" (${(peaks[0].supportRatio * 100).toFixed(0)}%)`
                : `${peaks.length} aligned peaks with mutual support`,
            peakSupports.length > 0 
                ? `${peakSupports.length} reinforcing connection(s) between peaks` 
                : '',
        ].filter(Boolean) as string[]
    };
}

// Edge case: No peaks but multiple hills - not sparse, not convergent
if (peaks.length === 0) {
    return {
        primary: 'parallel',  // Or a new type like 'contested'
        confidence: 0.5,
        evidence: [
            `No dominant positions (0 peaks)`,
            `${hills.length} claims in contested range`,
            `Landscape is unsettled`
        ]
    };
}
```

---

## üü° 49. `src/core/context-resolver.js` (lines 252-268)
### Adapter Readiness Not Checked Before Use

**Problem:** Code calls `this.sessionManager.adapter.getTurnsBySessionId()` without verifying the adapter exists or is ready, causing runtime errors.

**Current Code:**
```javascript
if (!structuralTurnId) {
  try {
    // ‚ùå No check if adapter exists or is ready
    const allTurns = await this.sessionManager.adapter.getTurnsBySessionId(sessionId);
    
    for (const turn of allTurns.reverse()) {
      const analysis = this._extractStoredAnalysisFromTurn(turn);
      if (analysis) return analysis;
      
      const computed = this._computeStoredAnalysisFromMapperArtifact(turn);
      if (computed) return computed;
    }
  } catch (e) {
    console.debug("[ContextResolver] Failed to scan turns:", e);
  }
}
```

**Fix:**
```javascript
if (!structuralTurnId) {
  // Check adapter exists and is ready before use
  const adapter = this.sessionManager?.adapter;
  const adapterReady = adapter && (
    typeof adapter.isReady === 'function' ? adapter.isReady() : true
  );
  
  if (!adapterReady) {
    console.debug("[ContextResolver] Adapter not ready, skipping turn scan");
    return null;
  }
  
  try {
    const allTurns = await adapter.getTurnsBySessionId(sessionId);
    
    if (!Array.isArray(allTurns)) {
      console.debug("[ContextResolver] getTurnsBySessionId returned non-array");
      return null;
    }
    
    for (const turn of allTurns.reverse()) {
      const analysis = this._extractStoredAnalysisFromTurn(turn);
      if (analysis) return analysis;
      
      const computed = this._computeStoredAnalysisFromMapperArtifact(turn);
      if (computed) return computed;
    }
  } catch (e) {
    console.debug("[ContextResolver] Failed to scan turns:", e);
  }
}
```

**Alternative ‚Äî add adapter check helper:**
```javascript
// Add to ContextResolver class
_isAdapterReady() {
  const adapter = this.sessionManager?.adapter;
  if (!adapter) return false;
  if (typeof adapter.isReady === 'function') return adapter.isReady();
  // If no isReady method, assume ready if adapter exists
  return true;
}

// Usage
if (!structuralTurnId && this._isAdapterReady()) {
  try {
    const allTurns = await this.sessionManager.adapter.getTurnsBySessionId(sessionId);
    // ...
  } catch (e) {
    console.debug("[ContextResolver] Failed to scan turns:", e);
  }
}
```

---

## üü¢ 50. `src/core/preflight-validator.js` (lines 100-113)
### Stale/Misleading Comment

**Problem:** Comment says "We reuse the mapping lock for now" but code actually checks `locks.singularity`.

**Current Code:**
```javascript
// We reuse the mapping lock for now  ‚ùå STALE/MISLEADING
const candidate = selectBestProvider('singularity', authStatus, availableProviders);
if (locks.singularity) {
    if (candidate) {
        warnings.push(`Singularity provider "${singularity}" is unauthorized; using "${candidate}" for this request`);
        singularity = candidate;
    } else {
        warnings.push(`Singularity provider "${singularity}" is unauthorized and no fallback available`);
        singularity = 'gemini';
    }
} else {
    singularity = candidate || 'gemini';
}
```

**Fix Option A ‚Äî Update the comment:**
```javascript
// Check singularity lock to determine fallback behavior
const candidate = selectBestProvider('singularity', authStatus, availableProviders);
if (locks.singularity) {
    // ... rest unchanged
}
```

**Fix Option B ‚Äî Remove the comment entirely:**
```javascript
const candidate = selectBestProvider('singularity', authStatus, availableProviders);
if (locks.singularity) {
    // ... rest unchanged
}
```

---

## üü¢ 51. `ui/components/cognitive/SingularityOutputView.tsx` (lines 26-33)
### `String(error)` Fallback Yields "[object Object]"

**Problem:** For `SingularityError` objects without `message` or `error`, `String(error)` produces unhelpful "[object Object]".

**Current Code:**
```typescript
const getErrorMessage = (error: unknown): string => {
  if (error instanceof Error) return error.message;
  if (typeof error === 'string') return error;
  if (isSingularityError(error)) {
    return error.message || error.error || String(error);  // ‚ùå "[object Object]"
  }
  return 'Unknown error occurred';
};
```

**Fix:**
```typescript
const getErrorMessage = (error: unknown): string => {
  if (error instanceof Error) return error.message;
  if (typeof error === 'string') return error;
  if (isSingularityError(error)) {
    // Only return message or error if present
    if (error.message) return error.message;
    if (error.error) return error.error;
    // Fall through to default instead of String(error)
  }
  return 'Unknown error occurred';
};
```

**Alternative ‚Äî try JSON.stringify for debugging:**
```typescript
const getErrorMessage = (error: unknown): string => {
  if (error instanceof Error) return error.message;
  if (typeof error === 'string') return error;
  if (isSingularityError(error)) {
    if (error.message) return error.message;
    if (error.error) return error.error;
  }
  
  // For unknown objects, try to provide some useful info in dev
  if (process.env.NODE_ENV === 'development' && typeof error === 'object' && error !== null) {
    try {
      const serialized = JSON.stringify(error);
      if (serialized !== '{}') return `Error: ${serialized.slice(0, 100)}`;
    } catch {
      // Ignore serialization errors
    }
  }
  
  return 'Unknown error occurred';
};
```

---

## üü† 52. `ui/hooks/chat/useChat.ts` (lines 102-105)
### Missing `mappingEnabled` in Dependency Array

**Problem:** `sendMessage` callback closes over `mappingEnabled` but it's not in the dependency array, causing stale closure bugs.

**Current Code:**
```typescript
const sendMessage = React.useCallback(async (content: string) => {
  // Uses mappingEnabled to compute shouldUseMapping
  const shouldUseMapping = mappingEnabled && hasMultipleProviders;
  const effectiveMappingProvider = shouldUseMapping ? mappingProvider : null;
  
  // ... rest of function
}, [
  hasMultipleProviders,
  mappingProvider,
  singularityProvider,
  // ‚ùå mappingEnabled is MISSING
  providers,
  // ... other deps
]);
```

**Fix:**
```typescript
const sendMessage = React.useCallback(async (content: string) => {
  const shouldUseMapping = mappingEnabled && hasMultipleProviders;
  const effectiveMappingProvider = shouldUseMapping ? mappingProvider : null;
  
  // ... rest of function
}, [
  mappingEnabled,  // ‚úÖ Added
  hasMultipleProviders,
  mappingProvider,
  singularityProvider,
  providers,
  // ... other deps
]);
```

**Full dependency audit:**
```typescript
const sendMessage = React.useCallback(async (content: string) => {
  // All variables used inside:
  // - mappingEnabled ‚úì
  // - hasMultipleProviders ‚úì
  // - mappingProvider ‚úì
  // - singularityProvider ‚úì
  // - providers ‚úì
  // - sessionId
  // - currentTurnId
  // - setIsLoading
  // - appendMessage
  // - etc.
  
}, [
  // Must include ALL non-stable references
  mappingEnabled,
  hasMultipleProviders,
  mappingProvider,
  singularityProvider,
  providers,
  sessionId,
  currentTurnId,
  setIsLoading,
  appendMessage,
  // ... any other used values
]);
```

**Consider using eslint-plugin-react-hooks** to catch these:
```json
// .eslintrc.json
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

---

## üü¢ 53. Verification: `shared/parsing-utils.ts` ‚Äî `createEmptyHandoff`

**Verify that `createEmptyHandoff` provides proper defaults:**

```typescript
export function createEmptyHandoff(): ConciergeDelta {
  return {
    constraints: [],        // ‚úÖ Empty array, not undefined
    eliminatedOptions: [],  // ‚úÖ Empty array, not undefined
    preferences: [],        // ‚úÖ Empty array, not undefined
    situationalContext: null,
    commit: null
  };
}
```

‚úÖ **If the above exists, no changes needed for `createEmptyHandoff`.**

**But callers should still use defensive checks** (Issue #46) because:
1. Partial deltas may come from external sources (API, storage)
2. TypeScript can't guarantee runtime shape matches compile-time types
3. `parseHandoffBlock` might return incomplete objects on malformed input

