# Query: synthesis
# Including: src/
# Excluding: .md, .txt
# ContextLines: 1

99 results - 18 files

src\sw-entry.js:
  76        "htos_mapping_provider",
  77:       "htos_last_synthesis_model",
  78        "htos_last_refiner_model",

src\core\connection-handler.js:
  113          batchResponses: {},
  114:         synthesisResponses: {},
  115          mappingResponses: {},

  133            (buckets.batchResponses[r.providerId] ||= []).push(entry);
  134:         } else if (r.responseType === "synthesis") {
  135:           (buckets.synthesisResponses[r.providerId] ||= []).push(entry);
  136          } else if (r.responseType === "mapping") {

  157          Object.keys(buckets.batchResponses).length > 0 ||
  158:         Object.keys(buckets.synthesisResponses).length > 0 ||
  159          Object.keys(buckets.mappingResponses).length > 0 ||

  194              batchResponses: buckets.batchResponses,
  195:             synthesisResponses: buckets.synthesisResponses,
  196              mappingResponses: buckets.mappingResponses,

  337                    providers: executeRequest.providers || [],
  338:                   synthesisProvider: executeRequest.synthesizer || null,
  339                    mappingProvider: executeRequest.mapper || null,

  450          executeRequest.providers.length > 0;
  451:       const hasSynthesis = !!(
  452:         executeRequest?.synthesis?.enabled &&
  453:         executeRequest.synthesis.providers?.length > 0
  454        );

  459  
  460:       if (!hasBatch && (hasSynthesis || hasMapping) && !userTurnId) {
  461          console.error(

  517              providers: executeRequest.providers || [],
  518:             synthesisProvider: executeRequest.synthesizer || null,
  519              mappingProvider: executeRequest.mapper || null,

src\core\context-resolver.js:
    4    findLatestMappingOutput,
    5:   findLatestSynthesisOutput,
    6    extractUserMessage

  162      );
  163:     // Also resolve latest synthesis output for mapping recompute
  164:     const latestSynthesisOutput = findLatestSynthesisOutput(responses);
  165  

  174        latestMappingOutput,
  175:       latestSynthesisOutput, // ← NEW: Include historical synthesis for mapping
  176        providerContextsAtSourceTurn,

src\core\context-utils.js:
  138  /**
  139:  * Find the latest valid synthesis output among provider responses for a turn.
  140   * @param {Array} providerResponses - List of response objects
  141:  * @returns {Object|null} The synthesis output or null
  142   */
  143: export function findLatestSynthesisOutput(providerResponses = []) {
  144      try {

  148  
  149:         const synthesisResponses = providerResponses.filter(
  150              (r) =>
  151                  r &&
  152:                 r.responseType === "synthesis" &&
  153                  r.text &&

  156  
  157:         if (synthesisResponses.length === 0) {
  158              return null;

  161          // Sort by most recent update
  162:         synthesisResponses.sort(
  163              (a, b) =>

  166  
  167:         const latest = synthesisResponses[0];
  168          return {

  173      } catch (e) {
  174:         console.warn("[ContextUtils] findLatestSynthesisOutput failed:", e);
  175          return null;

src\core\preflight-validator.js:
  76      if (synthesizer && !isProviderAuthorized(synthesizer, authStatus)) {
  77:         if (locks.synthesis) {
  78              // Locked but unauthorized: ephemeral fallback, don't change lock
  79:             const fallback = selectBestProvider('synthesis', authStatus, availableProviders);
  80              warnings.push(`Synthesizer "${synthesizer}" is locked but unauthorized; using "${fallback}" for this request`);

  82          } else {
  83:             synthesizer = selectBestProvider('synthesis', authStatus, availableProviders);
  84          }
  85      } else if (!synthesizer) {
  86:         synthesizer = selectBestProvider('synthesis', authStatus, availableProviders);
  87      }

src\core\PromptService.ts:
  570  
  571: Your synthesis should feel inevitable in hindsight, yet unseen before now.It carries the energy of discovery, not summation.
  572  

  578  
  579:         ** No scaffolding visible.** Do not reference "the models" or "the claims" or "the synthesis." The user experiences insight, not process.
  580  

  582  
  583: ** Land somewhere.** The synthesis must leave the user with clarity and direction, not suspended in possibility.Arrive at a position.
  584  

  625  
  626: Your synthesis has two registers:
  627  

  631  ** The Long Answer **
  632:       The frame inhabited.The full response that could only exist because you found that frame.This is where the synthesis lives and breathes.
  633  

  639    
  640:   "long_answer": "The frame inhabited. 2-4 paragraphs where the synthesis lives and breathes. Tensions resolved into complementary dimensions. Should feel inevitable in hindsight.",
  641    

  832  
  833: **Attribution is for unique angles only.** If 4 models said roughly the same thing, that's synthesis doing its job—no attribution needed. Only tag when a specific model saw something others didn't.
  834  

src\core\workflow-compiler.js:
  319            throw new Error("[Compiler] Recompute: targetProvider required");
  320:         // Only require frozenBatchOutputs for synthesis/mapping historical recomputes
  321          if (context.stepType !== "batch" && !context.frozenBatchOutputs) {
  322            throw new Error(
  323:             "[Compiler] Recompute: frozenBatchOutputs required for synthesis/mapping",
  324            );

src\core\workflow-engine.js:
  463          batchOutputs: {},
  464:         synthesisOutputs: {}, // Kept for schema compatibility, though empty
  465          mappingOutputs: {},

src\core\execution\CognitivePipelineHandler.js:
  411          batchResponses: {},
  412:         synthesisResponses: {},
  413          mappingResponses: {},

  434              ? buckets.batchResponses
  435:             : r.responseType === "synthesis"
  436:               ? buckets.synthesisResponses
  437                : r.responseType === "mapping"

  460          Object.keys(buckets.batchResponses).length > 0 ||
  461:         Object.keys(buckets.synthesisResponses).length > 0 ||
  462          Object.keys(buckets.mappingResponses).length > 0 ||

  497              batchResponses: buckets.batchResponses,
  498:             synthesisResponses: buckets.synthesisResponses,
  499              mappingResponses: buckets.mappingResponses,

src\core\execution\PersistenceCoordinator.js:
   32        batchOutputs: {},
   33:       synthesisOutputs: {},
   34        mappingOutputs: {},

   57          }
   58:         if (step.type === "synthesis") {
   59:           const providerId = result?.providerId || step?.payload?.synthesisProvider;
   60            if (!providerId) return;
   61:           out.synthesisOutputs[providerId] = {
   62              providerId,

  126          }
  127:         if (step.type === "synthesis") {
  128:           const providerId = step?.payload?.synthesisProvider;
  129            if (!providerId) return;
  130:           out.synthesisOutputs[providerId] = {
  131              providerId,

src\core\execution\StepExecutor.js:
  292                  failedProviders: failedProviders.map((p) => ({ providerId: p.providerId, error: p.error })),
  293:                 synthesisCompleted: false,
  294                  mappingCompleted: false,

  553        switch (responseType) {
  554:         case "synthesis": sourceContainer = aiTurn.synthesisResponses || {}; break;
  555          case "mapping": sourceContainer = aiTurn.mappingResponses || {}; break;

src\core\execution\TurnEmitter.js:
   47        const batchResponses = {};
   48:       const synthesisResponses = {};
   49        const mappingResponses = {};

  191              }
  192:             case "synthesis": {
  193:               const providerId = step?.payload?.synthesisProvider;
  194                if (!providerId) return;
  195:               if (!synthesisResponses[providerId])
  196:                 synthesisResponses[providerId] = [];
  197:               synthesisResponses[providerId].push({
  198                  providerId,

  288          Object.keys(batchResponses).length > 0 ||
  289:         Object.keys(synthesisResponses).length > 0 ||
  290          Object.keys(mappingResponses).length > 0 ||

  309          batchResponses,
  310:         synthesisResponses,
  311          mappingResponses,

  335          batchCount: Object.keys(batchResponses).length,
  336:         synthesisCount: Object.keys(synthesisResponses).length,
  337          mappingCount: Object.keys(mappingResponses).length,

src\persistence\SessionManager.js:
    83     * @param {string} providerId
    84:    * @param {"batch"|"synthesis"|"mapping"|"refiner"|"antagonist"} responseType
    85     * @param {number} responseIndex

   137     * @param {Object} context - ResolvedContext from ContextResolver
   138:    * @param {Object} result - { batchOutputs, synthesisOutputs, mappingOutputs }
   139     * @returns {Promise<{sessionId, userTurnId?, aiTurnId?}>}

   241        batchResponseCount: this.countResponses(result.batchOutputs),
   242:       synthesisResponseCount: this.countResponses(result.synthesisOutputs),
   243        mappingResponseCount: this.countResponses(result.mappingOutputs),

   384        batchResponseCount: this.countResponses(result.batchOutputs),
   385:       synthesisResponseCount: this.countResponses(result.synthesisOutputs),
   386        mappingResponseCount: this.countResponses(result.mappingOutputs),

   724    /**
   725:    * Append provider responses (mapping/synthesis/batch) to an existing AI turn
   726     * that follows the given historical user turn. Used to persist historical reruns
   727     * without creating a new user/ai turn pair.
   728:    * additions shape: { batchResponses?, synthesisResponses?, mappingResponses? }
   729     */

  1184    /**
  1185:    * Extract "The Short Answer" section or fallback to intro paragraphs from synthesis text
  1186     * @param {string} text 
  1187     */
  1188:   _extractContextFromSynthesis(text) {
  1189      if (!text) return "";

  1241    /**
  1242:    * Combine synthesis + mapping extracts into context blob
  1243     */

  1247      if (request?.understandOutput?.short_answer) {
  1248:       summary += `<previous_synthesis>\n${request.understandOutput.short_answer}\n</previous_synthesis>\n\n`;
  1249      } else if (request?.gauntletOutput?.the_answer?.statement) {
  1250:       summary += `<previous_synthesis>\n${request.gauntletOutput.the_answer.statement}\n</previous_synthesis>\n\n`;
  1251      } else {
  1252:       const synthesisOutputs = result?.synthesisOutputs || {};
  1253:       const synthProvider = Object.keys(synthesisOutputs)[0];
  1254:       if (synthProvider && synthesisOutputs[synthProvider]?.text) {
  1255:         const synthText = synthesisOutputs[synthProvider].text;
  1256:         const extracted = this._extractContextFromSynthesis(synthText);
  1257          if (extracted) {
  1258:           summary += `<previous_synthesis>\n${extracted}\n</previous_synthesis>\n\n`;
  1259          }

  1274        preview: finalSummary.slice(0, 100).replace(/\n/g, "\\n") + "...",
  1275:       hasSynthesis: finalSummary.includes("<previous_synthesis>"),
  1276        hasMapping: finalSummary.includes("<council_views>")

src\persistence\types.ts:
  82    batchResponseCount: number;
  83:   synthesisResponseCount: number;
  84    mappingResponseCount: number;

  97    providerId: string;
  98:   responseType: "batch" | "synthesis" | "mapping" | "refiner" | "antagonist";
  99    responseIndex: number;

src\providers\chatgpt-adapter.js:
  28        supportsContinuation: true,
  29:       synthesis: true,
  30        supportsThinking: true, // new flag: supports Think-mode

src\providers\claude-adapter.js:
  29        supportsContinuation: true,
  30:       synthesis: false,
  31      };

src\providers\gemini-adapter.js:
  26        supportsContinuation: true,
  27:       synthesis: false,
  28        // Only allow model selection if NOT explicitly Pro (Pro is fixed)

src\providers\qwen-adapter.js:
  25        supportsContinuation: true,
  26:       synthesis: true,
  27      };
