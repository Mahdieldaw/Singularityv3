## A. Persistence Layer Deep Dive

**Purpose:** This document defines the persistent truth of the system: what we store, how we store it, and why. It documents the schema, indices, transactional patterns, and key invariants that enable the system's core features like `extend` and `recompute`.

**Scope:** The persistence layer is responsible for three primary tasks:

1.  **Append-only History:** All provider responses are stored immutably.
2.  **Live Continuation:** A separate, fast-lookup store holds the "live" metadata needed to continue a conversation.
3.  **Timeline Integrity:** The layer maintains pointers and counts to ensure the main conversational timeline is always consistent.

### Core Schema (IndexedDB)

The database (`OpusDeusDB`) is comprised of several key object stores.

#### 1. `sessions` (SessionRecord)

Holds high-level metadata for an entire conversation.

- **Fields:**
  - `id` (string): Primary Key
  - `title` (string)
  - `createdAt` (number)
  - `updatedAt` (number)
  - `lastTurnId` (string | null): Pointer to the `id` of the latest `AiTurnRecord` on the _main timeline_. This is critical for `extend` context lookups.
  - `turnCount` (number)
- **Truth:** `lastTurnId` is the single source of truth for identifying the "end" of a conversation's main branch.

#### 2. `turns` (TurnRecord = UserTurnRecord | AiTurnRecord)

Stores the record of each user prompt and the AI's response metadata.

- **`UserTurnRecord` Fields:** `id`, `type: 'user'`, `sessionId`, `threadId`, `createdAt`, `text`, `sequence`.
- **`AiTurnRecord` Fields:**
  - `id` (string): Primary Key
  - `type: 'ai'`, `role: 'assistant'`
  - `sessionId` (string)
  - `userTurnId` (string): Foreign key to the `UserTurnRecord` that triggered this.
  - `threadId` (string), `sequence` (number)
  - `createdAt` (number), `updatedAt` (number)
  - **`batchResponseCount` (number)**
  - **`synthesisResponseCount` (number)**
  - **`mappingResponseCount` (number)**
  - **`providerContexts` (Record<string, any> | null)**: A _snapshot_ of provider metadata (e.g., `conversationId`) at the moment this turn was finalized. This is essential for the `recompute` primitive.
- **Truth:** This record **does not** contain the text of AI responses. It only stores _counts_ and the _historical snapshot_ of contexts. The full response data lives in `provider_responses`.

#### 3. `provider_responses` (ProviderResponseRecord)

An append-only log of every individual response from every provider, for every step.

- **Fields:**
  - `id` (string): Primary Key
  - `sessionId` (string)
  - **`aiTurnId` (string)**: Foreign key to the `AiTurnRecord`. This is the primary lookup index.
  - `providerId` (string)
  - **`responseType` ('batch' | 'synthesis' | 'mapping')**: The workflow step that generated this response.
  - `responseIndex` (number): Order of response for a given `aiTurnId` + `providerId` + `responseType` (e.g., for multiple recomputes).
  - `text` (string)
  - `status` (string: 'completed', 'error', etc.)
  - `createdAt` (number), `updatedAt` (number)
  - `meta` (any): Provider-specific metadata, including error details.
- **Indices:** `byAiTurnId` (critical for `recompute`), `bySessionId`, `byProviderId`.
- **Truth:** This is the immutable log. Records are _never_ overwritten; new `recompute` results are _new_ records with the same `aiTurnId` but a new `id` and higher `responseIndex`.

#### 4. `provider_contexts` (ProviderContextRecord)

The "hot path" store for live conversation continuity.

- **Primary Key:** `[sessionId, providerId]` (compound key).
- **Fields:**
  - `contextData` (any): A blob of provider-specific continuation info (e.g., `{ conversationId, parentMessageId, threadId }`).
  - `updatedAt` (number)
- **Indices:** `bySessionId`, `byProviderId`.
- **Truth:** This store holds the _live continuation state_ used by the `extend` primitive. It is separate from the historical `providerContexts` snapshots stored in the `turns` table.

### Invariants and Guarantees

- **Append-only Responses:** A `ProviderResponseRecord`, once written, is never mutated. New `recompute` results are appended as new records.
- **Turn Counts:** The `AiTurnRecord` counts (`batchResponseCount`, etc.) reflect the number of `ProviderResponseRecord` entries written for that turn at finalization.
- **Session Integrity:** `SessionRecord.lastTurnId` is _only_ updated by the `extend` or `initialize` primitives. `recompute` operations _do not_ change this pointer.
- **Live Context:** There is exactly one `ProviderContextRecord` per `[sessionId, providerId]`. It is updated at the end of any `extend` flow.
- **Canonical IDs:** `userTurnId` and `aiTurnId` are generated by the backend and are canonical and stable. No ID swapping occurs at any layer.

### Read/Write Flows

#### Flow 1: `Initialize` / `Extend` (The "Live" Write Path)

1.  **Resolve:** `ContextResolver` calls `adapter.getContextsBySessionId(sessionId)` to read the _live_ continuation state from the `provider_contexts` store.
2.  **Compile:** `WorkflowCompiler` builds the full step list (batch → mapping → synthesis).
3.  **Execute:** `WorkflowEngine` runs all steps.
4.  **Persist (`SessionManager`):** Upon completion, a single database transaction is executed to:
    a. Write all new `ProviderResponseRecord` entries (for batch, mapping, and synthesis) to the `provider_responses` store.
    b. Update the `ProviderContextRecord` for each provider in `provider_contexts` with the new, live continuation metadata.
    c. Write the new `AiTurnRecord` to the `turns` table, storing the _counts_ of responses and a _snapshot_ of the contexts from step (b).
    d. Update the `SessionRecord` in the `sessions` table, setting its `lastTurnId` to the new `AiTurnRecord`'s ID and incrementing `turnCount`.
5.  **Finalize:** The `WorkflowEngine` emits the `TURN_FINALIZED` message to the UI.

#### Flow 2: `Recompute` (The "Historical" Write Path)

1.  **Resolve:** `ContextResolver`:
    a. Loads the source `AiTurnRecord` (e.g., `ai-turn-123`).
    b. Loads its associated `UserTurnRecord` (using `ai-turn-123.userTurnId`).
    c. Loads all `ProviderResponseRecord`s where `aiTurnId === 'ai-turn-123'` using the `byAiTurnId` index.
    d. Uses the `providerContexts` _snapshot_ from the `AiTurnRecord` as the context for the step.
2.  **Compile:** `WorkflowCompiler` builds a _single_ step (`synthesis` or `mapping`) hydrated with the "frozen" data from the `ResolvedContext`.
3.  **Execute:** `WorkflowEngine` runs the single recomputed step.
4.  **Persist (`SessionManager`):** Upon completion, a single database transaction is executed to:
    a. Write a _new_ `ProviderResponseRecord` (e.g., a `synthesis` result for Claude), linking it to the _original_ `aiTurnId` (`ai-turn-123`).
    b. Write a _new_ `AiTurnRecord` (e.g., `ai-recompute-456`), linking it to the _original_ `userTurnId`.
    c. **Critically:** The `SessionRecord` is **NOT** updated. `lastTurnId` remains unchanged.
5.  **Finalize:** The `WorkflowEngine` emits `WORKFLOW_STEP_UPDATE (completed)` to the UI. No `TURN_FINALIZED` is emitted, as the main timeline did not advance.

### Transaction & Error Handling

- All writes for a given turn are grouped into a single transactional unit via `withTransaction`.
- If a provider fails during a step, a `ProviderResponseRecord` is still written with `status: 'error'` and the error message in the `meta` field. This ensures the turn history is complete.
- If all providers fail in the main `prompt` step, the engine emits `WORKFLOW_STEP_UPDATE (failed)` and `WORKFLOW_COMPLETE (error)` to the UI. The failed state is persisted with zero-count `AiTurnRecord` and error `ProviderResponseRecord` entries.

### Performance & Observability

- **Performance:** The hot path (`extend`) is optimized by querying the `provider_contexts` store directly, avoiding a full scan of the `turns` table. The `recompute` path is optimized using the `byAiTurnId` index on `provider_responses`.
- **Observability:** The `PersistenceMonitor` (`src/debug/PersistenceMonitor.js`) can be enabled to watch all database operations, track performance, and verify invariants during development.

### Key Files & References

- **Schema:** `src/persistence/database.ts` (Store definitions, keys, indices)
- **Types:** `src/persistence/types.ts` (Interfaces for all records)
- **Adapter:** `src/persistence/SimpleIndexedDBAdapter.ts` (Low-level read/write methods)
- **Logic:** `src/persistence/SessionManager.js` (Orchestrates `persist` logic)
- **Transactions:** `src/persistence/transactions.ts` (Transaction boundaries)
- **Validation:** `src/persistence/schemaVerification.ts` (Schema health checks)

### FAQ / Gotchas

- **DO NOT** embed response payloads inside `AiTurnRecord`. Store counts only.
- **DO NOT** overwrite `ProviderResponseRecord` entries. Append new ones for recomputes.
- **DO** ensure `provider_contexts` writes maintain the `[sessionId, providerId]` uniqueness.
- **REMEMBER:** `recompute` reads historical `ProviderResponseRecord` entries but writes _new_ ones.
- **REMEMBER:** The `providerContexts` snapshot in `AiTurnRecord` is for _history_ (`recompute`). The `provider_contexts` _store_ is for _live_ (`extend`).

---
