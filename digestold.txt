Directory structure:
└── Singularityv3/
    ├── README.md
    ├── Architecture Overview.md
    ├── bundle-analysis-report2ndold.txt
    ├── bundle-analysis-reportlatest.txt
    ├── bundle-analysis-reportold.txt
    ├── manifest.json
    ├── package.json
    ├── postcss.config.js
    ├── tailwind.config.js
    ├── tsconfig.json
    ├── update.md
    ├── docs/
    │   ├── contributing.md
    │   ├── debugging.md
    │   ├── dnr-utils.md
    │   ├── flows.md
    │   ├── privacy.md
    │   └── style-guide.md
    ├── scripts/
    │   ├── analyze-bundle.js
    │   ├── build-common.js
    │   ├── build-dev.js
    │   ├── build-prod.js
    │   ├── build-with-analysis.js
    │   └── postbuild.js
    ├── shared/
    │   ├── artifact-processor.ts
    │   ├── contract.ts
    │   ├── messaging.ts
    │   ├── parsing-utils.ts
    │   ├── provider-config.ts
    │   ├── provider-limits.ts
    │   └── provider-locks.ts
    ├── src/
    │   ├── cs-openai.js
    │   ├── offscreen-entry.js
    │   ├── offscreen.css
    │   ├── offscreen.html
    │   ├── oi.html
    │   ├── oi.js
    │   ├── sw-entry.js
    │   ├── core/
    │   │   ├── auth-manager.js
    │   │   ├── connection-handler.js
    │   │   ├── context-resolver.js
    │   │   ├── context-utils.js
    │   │   ├── dnr-auditor.js
    │   │   ├── dnr-utils.js
    │   │   ├── error-classifier.js
    │   │   ├── lifecycle-manager.js
    │   │   ├── PersistenceMonitor.js
    │   │   ├── preflight-validator.js
    │   │   ├── PromptService.ts
    │   │   ├── provider-health-tracker.js
    │   │   ├── request-lifecycle-manager.js
    │   │   ├── ResponseProcessor.ts
    │   │   ├── service-registry.js
    │   │   ├── vendor-exports.js
    │   │   ├── workflow-compiler.js
    │   │   └── workflow-engine.js
    │   ├── HTOS/
    │   │   ├── BusController.js
    │   │   ├── NetRulesManager.js
    │   │   └── OffscreenBootstrap.js
    │   ├── persistence/
    │   │   ├── Readme.md
    │   │   ├── database.ts
    │   │   ├── index.ts
    │   │   ├── schemaVerification.ts
    │   │   ├── SessionManager.d.ts
    │   │   ├── SessionManager.js
    │   │   ├── SimpleIndexedDBAdapter.ts
    │   │   ├── transactions.ts
    │   │   └── types.ts
    │   ├── providers/
    │   │   ├── chatgpt-adapter.js
    │   │   ├── chatgpt.js
    │   │   ├── claude-adapter.js
    │   │   ├── claude.js
    │   │   ├── gemini-adapter.js
    │   │   ├── gemini.js
    │   │   ├── qwen-adapter.js
    │   │   └── qwen.js
    │   ├── shared/
    │   │   └── auth-config.ts
    │   ├── think/
    │   │   ├── computeThinkFlag.d.ts
    │   │   ├── computeThinkFlag.js
    │   │   └── constants.js
    │   └── utils/
    │       └── ErrorHandler.js
    └── ui/
        ├── Readme.md
        ├── App.tsx
        ├── constants.ts
        ├── index.html
        ├── index.tsx
        ├── tsconfig.json
        ├── assets/
        │   └── singularity_brand.md
        ├── components/
        │   ├── AiTurnBlock.tsx
        │   ├── ArtifactOverlay.tsx
        │   ├── Banner.tsx
        │   ├── ChatInput.tsx
        │   ├── CopyButton.tsx
        │   ├── CouncilOrbs.tsx
        │   ├── CouncilOrbsVertical.tsx
        │   ├── DecisionMapGraph.tsx
        │   ├── DecisionMapSheet.tsx
        │   ├── DraftCard.tsx
        │   ├── ErrorBoundary.tsx
        │   ├── Header.tsx
        │   ├── HistoryPanel.tsx
        │   ├── Icons.tsx
        │   ├── LaunchpadDrawer.tsx
        │   ├── LaunchpadTab.tsx
        │   ├── MarkdownDisplay.tsx
        │   ├── MessageRow.tsx
        │   ├── ModelResponsePanel.tsx
        │   ├── NudgeChipBar.tsx
        │   ├── ProviderErrorCard.tsx
        │   ├── ProviderPill.tsx
        │   ├── RenameDialog.tsx
        │   ├── SettingsPanel.tsx
        │   ├── SplitPaneRightPanel.tsx
        │   ├── Toast.tsx
        │   ├── UserTurnBlock.tsx
        │   ├── WelcomeScreen.tsx
        │   ├── antagonist/
        │   │   ├── antagonist.css
        │   │   ├── AntagonistCard.tsx
        │   │   ├── AntagonistSelector.tsx
        │   │   ├── DimensionDropdown.tsx
        │   │   └── index.ts
        │   └── refinerui/
        │       ├── RefinerCardsSection.tsx
        │       ├── RefinerDot.tsx
        │       ├── SignalCard.tsx
        │       └── TrustSignalsPanel.tsx
        ├── constants/
        │   └── errorMessages.ts
        ├── hooks/
        │   ├── useAntagonistOutput.ts
        │   ├── useCitationEvents.ts
        │   ├── useClipActions.ts
        │   ├── useConnectionMonitoring.ts
        │   ├── useHistoryLoader.ts
        │   ├── useInitialization.ts
        │   ├── useLaunchpadDrafts.ts
        │   ├── useRefinerOutput.ts
        │   ├── chat/
        │   │   ├── useChat.ts
        │   │   ├── usePortMessageHandler.ts
        │   │   └── useRoundActions.ts
        │   ├── providers/
        │   │   ├── useProviderActions.ts
        │   │   ├── useProviderStatus.ts
        │   │   ├── useRetryProvider.ts
        │   │   └── useSmartProviderDefaults.ts
        │   └── ui/
        │       ├── useKey.ts
        │       └── useLoadingWatchdog.ts
        ├── providers/
        │   ├── providerIcons.tsx
        │   └── providerRegistry.ts
        ├── services/
        │   ├── extension-api.ts
        │   └── port-health-manager.ts
        ├── state/
        │   └── atoms.ts
        ├── styles/
        │   ├── input.css
        │   ├── math-styles.css
        │   └── tokens.ts
        ├── types/
        │   ├── env.d.ts
        │   ├── index.ts
        │   ├── jotai-immer.d.ts
        │   └── think-shims.d.ts
        ├── utils/
        │   ├── cn.ts
        │   ├── copy-format-utils.ts
        │   ├── graphAdapter.ts
        │   ├── math-renderer.ts
        │   ├── provider-helpers.ts
        │   ├── provider-id-mapper.ts
        │   ├── refiner-helpers.ts
        │   ├── safeLazy.ts
        │   ├── signalUtils.ts
        │   ├── smart-defaults.ts
        │   ├── streamingBuffer.ts
        │   └── turn-helpers.ts
        └── views/
            └── ChatView.tsx

================================================
FILE: README.md
================================================
# Singularity

Singularity is a Chrome extension (Manifest V3) that orchestrates multiâ€‘model AI conversations with realâ€‘time streaming, local persistence, and reproducibility. It helps you compare providers sideâ€‘byâ€‘side, compose their outputs, and keep a complete audit trail of every turn.

## Key Features

- **Parallel Fan-out**: Query multiple providers (ChatGPT, Claude, Gemini, Qwen) simultaneously.
- **Pipeline Workflows**: Optional breakdown into "mapping" (options analysis) and "synthesis" (consensus) steps.
- **Optimistic UI**: Immediate rendering with canonical backend ID reconciliation.
- **Local Persistence**: Append-only history in IndexedDB with fast lookups.
- **Recompute**: Re-run past steps without altering the timeline.

## Documentation

- **[Architecture Blueprint](Architecture%20Overview.md)**: High-level system map and philosophy.
- **[Critical Flows](docs/flows.md)**: Detailed sequence diagrams (Initialize, Recompute, Error).
- **[Debugging Guide](docs/debugging.md)**: Message tracing, state inspection, and common issues.readme
- **[Contributing](docs/contributing.md)**: Guide for adding new providers and primitives.
- **[Style Guide](docs/style-guide.md)**: Logo assets, sizing, and branding guidelines.
- **[Core DNR Utilities](docs/dnr-utils.md)**: Guide for managing network rules and Arkose injection.
- **[Privacy & Security](docs/privacy.md)**: Data handling and security policy.

## Architecture Summary

The system follows a clear **Resolve â†’ Compile â†’ Execute** pipeline:

1.  **Resolve**: Fetches context (continuation IDs, history) for the request.
2.  **Compile**: Generates a workflow plan (DAG of steps).
3.  **Execute**: Runs steps (batch prompt, mapping, synthesis), streams partial results via a central message bus, and persists to IndexedDB.

The frontend uses **Jotai** for state management (Map-based for O(1) access) and a **StreamingBuffer** for smooth 60fps updates during heavy IO.

## Directory Structure

- `src/core`: Backend pipeline (connection, resolver, compiler, engine).
- `src/providers`: LLM adapters (ChatGPT, Claude, Gemini).
- `src/persistence`: IndexedDB storage manager and schema.
- `ui`: React frontend (Vite).
- `ui/state`: Global Jotai atoms.
- `ui/assets`: Static assets and logos.
- `shared`: Types, contracts, and constants.

## Submodule Notes

### Core: DNR Utilities (`src/core`)

The `src/core` directory includes robust utilities for managing Chrome's **Declarative Net Request (DNR)** API, primarily for **Arkose Enforcement (AE)** header injection.
   
See **[docs/dnr-utils.md](docs/dnr-utils.md)** for the full architecture, API reference, and usage examples.



================================================
FILE: Architecture Overview.md
================================================
---

# Singularity System Architecture Overview

**Version:** 2.0  
**Last Updated:** 2025-01-XX  
**Purpose:** Complete architectural blueprint for contributors working on any layer of the system

---

## Table of Contents

1. [System Philosophy](https://claude.ai/chat/90e57a76-883e-4eaf-9601-5170a9f32a9b#1-system-philosophy)
2. [Data Contracts: The Language of the System](https://claude.ai/chat/90e57a76-883e-4eaf-9601-5170a9f32a9b#2-data-contracts)
3. [Backend: The Resolve → Compile → Execute Pipeline](https://claude.ai/chat/90e57a76-883e-4eaf-9601-5170a9f32a9b#3-backend-pipeline)
4. [UI State Management: The Frontend Brain](https://claude.ai/chat/90e57a76-883e-4eaf-9601-5170a9f32a9b#4-ui-state-management)
5. [Rendering Layer: State to Pixels](https://claude.ai/chat/90e57a76-883e-4eaf-9601-5170a9f32a9b#5-rendering-layer)
6. [Critical Flows](https://claude.ai/chat/90e57a76-883e-4eaf-9601-5170a9f32a9b#6-critical-flows)
7. [Debugging Guide](https://claude.ai/chat/90e57a76-883e-4eaf-9601-5170a9f32a9b#7-debugging-guide)

---

## 1. System Philosophy

### Core Principles

**Immutable History, Live Context**  
The system maintains a complete, immutable record of every conversation turn while keeping a separate, hot-path index (`provider_contexts`) for fast continuation lookups. This dual-layer design enables both historical integrity and real-time performance.

**Three Primitives, One Truth**  
All workflows reduce to three primitives:

- `initialize`: Start a new conversation
- `extend`: Continue with live context
- `recompute`: Re-run historical steps without advancing the timeline

**Optimistic UI, Canonical Backend**  
The UI renders immediately using optimistic IDs and placeholder data. The backend sends `TURN_CREATED` and `TURN_FINALIZED` messages with canonical IDs. The UI replaces optimistic data with canonical data upon finalization, never remapping IDs.

**Streaming-First**  
Every AI response streams character-by-character via `PARTIAL_RESULT` messages. The UI uses a `StreamingBuffer` to batch DOM updates, achieving 60fps rendering even during multi-provider fan-out.

---

## 2. Data Contracts: The Language of the System

### 2.1 Request Primitives (`shared/contract.ts`)

These are the only three message shapes the backend accepts:

```typescript
// Start a new conversation
interface InitializeRequest {
  type: "initialize";
  sessionId?: string | null; // Backend generates if null
  userMessage: string;
  providers: ProviderKey[];
  includeMapping: boolean;
  includeSynthesis: boolean;
  synthesizer?: ProviderKey;
  mapper?: ProviderKey;
  useThinking?: boolean;
  clientUserTurnId?: string; // Optimistic ID from UI
}

// Continue existing conversation
interface ExtendRequest {
  type: "extend";
  sessionId: string; // Required
  userMessage: string;
  providers: ProviderKey[];
  includeMapping: boolean;
  includeSynthesis: boolean;
  synthesizer?: ProviderKey;
  mapper?: ProviderKey;
  useThinking?: boolean;
  clientUserTurnId?: string;
}

// Re-run historical step
interface RecomputeRequest {
  type: "recompute";
  sessionId: string;
  sourceTurnId: string; // AI turn to recompute
  stepType: "synthesis" | "mapping";
  targetProvider: ProviderKey;
  useThinking?: boolean;
}
```

### 2.2 Real-Time Messages (Backend → UI)

The backend sends these messages over a persistent `chrome.runtime.Port`:

```typescript
// Workflow lifecycle
interface TurnCreatedMessage {
  type: "TURN_CREATED";
  sessionId: string;
  userTurnId: string; // Canonical ID
  aiTurnId: string; // Canonical ID
}

// Streaming updates (sent hundreds of times per turn)
interface PartialResultMessage {
  type: "PARTIAL_RESULT";
  sessionId: string;
  stepId: string; // e.g., "batch-123", "synthesis-gemini-456"
  providerId: ProviderKey;
  chunk: { text: string; meta?: any };
}

// Step completion
interface WorkflowStepUpdateMessage {
  type: "WORKFLOW_STEP_UPDATE";
  sessionId: string;
  stepId: string;
  status: "completed" | "failed";
  result?: {
    results?: Record<string, ProviderResponse>; // For batch
    providerId?: string; // For synthesis/mapping
    text?: string;
    meta?: any;
  };
  error?: string;
}

// Final canonical data
interface TurnFinalizedMessage {
  type: "TURN_FINALIZED";
  sessionId: string;
  userTurnId: string;
  aiTurnId: string;
  turn: {
    user: UserTurn;
    ai: AiTurn;
  };
}
```

### 2.3 Core Data Shapes (`ui/types.ts`)

**Turn Types (UI State)**

```typescript
interface UserTurn {
  type: "user";
  id: string;
  text: string;
  createdAt: number;
  sessionId: string | null;
}

interface AiTurn {
  type: "ai";
  id: string;
  userTurnId: string;
  sessionId: string;
  threadId: string;
  createdAt: number;

  // Response storage (keys are provider IDs)
  batchResponses: Record<string, ProviderResponse>;
  synthesisResponses: Record<string, ProviderResponse[]>;
  mappingResponses: Record<string, ProviderResponse[]>;

  // Metadata
  meta?: {
    isOptimistic?: boolean;
    requestedFeatures?: {
      synthesis: boolean;
      mapping: boolean;
    };
  };
}

interface ProviderResponse {
  providerId: ProviderKey;
  text: string;
  status: "pending" | "streaming" | "completed" | "error";
  createdAt: number;
  updatedAt?: number;
  meta?: {
    conversationId?: string;
    error?: string;
  };
}
```

**Persistence Records (Database Schema)**

```typescript
// sessions table
interface SessionRecord {
  id: string;
  title: string;
  createdAt: number;
  updatedAt: number;
  lastTurnId: string | null; // Points to latest AI turn on main timeline
  turnCount: number;
}

// turns table (polymorphic)
type TurnRecord = UserTurnRecord | AiTurnRecord;

interface AiTurnRecord {
  id: string;
  type: "ai";
  role: "assistant";
  sessionId: string;
  userTurnId: string;
  threadId: string;
  sequence: number;
  createdAt: number;
  updatedAt: number;

  // Counts only; actual responses live in provider_responses
  batchResponseCount: number;
  synthesisResponseCount: number;
  mappingResponseCount: number;

  // Snapshot of contexts at this point in time (for recompute)
  providerContexts?: Record<string, any>;
}

// provider_responses table (append-only log)
interface ProviderResponseRecord {
  id: string;
  sessionId: string;
  aiTurnId: string;
  providerId: string;
  responseType: "batch" | "synthesis" | "mapping";
  responseIndex: number;
  text: string;
  status: string;
  createdAt: number;
  updatedAt: number;
  meta?: any;
}

// provider_contexts store (live continuation metadata)
// Primary Key: [sessionId, providerId]
// contextData holds provider-specific continuation info used by the 'extend' primitive
interface ProviderContextRecord {
  sessionId: string;
  providerId: string;
  contextData: any; // e.g., { conversationId, parentMessageId, threadId }
  updatedAt: number;
}
```

---

## 3. Backend Pipeline: Resolve → Compile → Execute

### 3.1 Entry Point: Connection Handler

**File:** `src/core/connection-handler.js`

See: [src/core/connection-handler.js](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/src/core/connection-handler.js)

### 3.2 Context Resolver: Data Fetcher

**File:** `src/core/context-resolver.js`

**Purpose:** Fetch minimum required data for each primitive. This is the performance bottleneck—must be fast.

See: [src/core/context-resolver.js](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/src/core/context-resolver.js)

### 3.3 Workflow Compiler: Instruction Generator

**File:** `src/core/workflow-compiler.js`

**Purpose:** Pure function that converts request + context into imperative steps.

See: [src/core/workflow-compiler.js](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/src/core/workflow-compiler.js)

### 3.4 Workflow Engine: Step Executor

**File:** `src/core/workflow-engine.js`

**Purpose:** Execute steps in sequence, stream results to UI, persist on completion.

See: [src/core/workflow-engine.js](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/src/core/workflow-engine.js)

### 3.5 System Prompts: Synthesizer and Mapper

**File:** `src/core/workflow-engine.js`

**Purpose:** These prompts define how the synthesis and mapping steps transform batch outputs.

#### Synthesizer Prompt (buildSynthesisPrompt)

The synthesizer creates a unified response that "could only exist" from seeing all models:

See: [src/core/workflow-engine.js](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/src/core/workflow-engine.js)

**Output Contract:**
- **The Short Answer:** 1-2 paragraph overview
- **The Long Answer:** Full synthesis

---

#### Mapper Prompt (buildMappingPrompt)

The mapper is a "provenance tracker and option cataloger" that reveals consensus patterns and divergence:

See: [src/core/workflow-engine.js](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/src/core/workflow-engine.js)

**Output Contract:**
1. **Narrative:** Prose with embedded citations `[1,2,3]` and **bold canonical labels**
2. **Delimiter:** `===ALL_AVAILABLE_OPTIONS===`
3. **Options List:** Grouped by theme, with citations
4. **Delimiter:** `===GRAPH_TOPOLOGY===`
5. **JSON Graph:** Nodes (with supporters) + Edges (with relationship types)

---

### 3.6 Pre-Flight Refinement: PromptRefinerService

**File:** `src/services/PromptRefinerService.ts`

**Purpose:** Two-stage pipeline (Composer → Analyst) that refines user prompts before batch fan-out.

#### Composer Role

The Composer is the "user's voice, clarified"—a hinge between user and the batch pipeline.

See: [src/services/PromptRefinerService.ts](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/src/services/PromptRefinerService.ts)

**Output Contract:**
- `REFINED_PROMPT:` — The polished prompt to send
- `NOTES:` — 2-4 sentences explaining intent/changes

---

#### Analyst Role

The Analyst is the "mirror held up to the composed prompt before it launches."

See: [src/services/PromptRefinerService.ts](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/src/services/PromptRefinerService.ts)

**Output Contract:**
- `AUDIT:` — Negative-space analysis (what's being left behind)
- `VARIANTS:` — 1-3 alternative framings (numbered list)
- `GUIDANCE:` — 2-4 sentences mapping variants to user priorities

---

#### Pipeline Flow

```
User Fragment 
  ↓
Composer (refines prompt, preserves voice)
  ↓
Analyst (reveals negative space, offers variants)
  ↓
User Reviews (chooses refined prompt or variant)
  ↓
Batch Fan-Out
```

**Key Methods:**
- `refineWithAuthorAnalyst()` — Run full Composer → Analyst pipeline
- `runComposer()` — Run Composer only
- `runAnalyst()` — Run Analyst only

---

## 4. UI State Management: The Frontend Brain

### 4.1 State Architecture (`ui/state/atoms.ts`)

**Core Principle:** Map-based storage for O(1) lookups, array of IDs for ordering.

See: [ui/state/atoms.ts](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/ui/state/atoms.ts)

### 4.2 Message Handler: Backend → State Bridge

**File:** `ui/hooks/usePortMessageHandler.ts`

**Purpose:** Translate backend messages into state updates. This is the most critical UI hook.

See: [ui/hooks/usePortMessageHandler.ts](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/ui/hooks/usePortMessageHandler.ts)

### 4.3 Action Hook: User Intent → Backend Messages

**File:** `ui/hooks/useChat.ts`

See: [ui/hooks/useChat.ts](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/ui/hooks/useChat.ts)

---

## 5. Rendering Layer: State to Pixels

### 5.1 Top-Level Layout (`ui/App.tsx`)

See: [ui/App.tsx](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/ui/App.tsx)

### 5.2 Chat View: Virtualized Turn List (`ui/views/ChatView.tsx`)

See: [ui/views/ChatView.tsx](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/ui/views/ChatView.tsx)

### 5.3 AI Turn Block: Synthesis-Focused Renderer (`ui/components/AiTurnBlock.tsx`)

**Purpose:** Renders synthesis response front-and-center as a conversation bubble, with tabs to switch between multiple synthesis takes.

**Current Layout (v2):**
- Synthesis bubble is the main content (not side-by-side with mapping)
- Mapping has moved to Decision Map Sheet (bottom sheet)
- Provider batch responses shown in right split pane via `ModelResponsePanel`
- Council Orbs strip below each synthesis bubble for model navigation

**Key Props:**
See: [ui/components/AiTurnBlock.tsx](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/ui/components/AiTurnBlock.tsx)

**Synthesis Tab System:**


**Interaction Flow:**
1. **Click any orb** → Opens right split pane with that provider's batch response
2. **Click center orb (crown)** → No-op (crown shows synthesizer)
3. **Click orb strip background** → Opens Decision Map Sheet
4. **Click synthesis tab** → Switches to that provider's synthesis

**Visual Structure:**
```
┌─────────────────────────────────────┐
│  User Prompt Card                   │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│  Synthesis Bubble                   │
│  ┌─────────────────────────────────┐│
│  │ [Tab: Claude] [Tab: Gemini (2)]││
│  ├─────────────────────────────────┤│
│  │ The Short Answer...             ││
│  │ The Long Answer...              ││
│  │ (Markdown rendered)             ││
│  └─────────────────────────────────┘│
│  ┌─────────────────────────────────┐│
│  │  ○ ○ ● ○ ○  Council Orbs        ││
│  └─────────────────────────────────┘│
└─────────────────────────────────────┘
```

**Right Split Pane (ModelResponsePanel):**
- Opens when user clicks an orb
- Shows full batch response for that provider
- Independent scroll from main thread
- Draggable divider (default 60/40 split)

**Decision Map Sheet (DecisionMapSheet):**
- Opens when user clicks orb strip background
- Bottom sheet with Graph/Narrative/Options tabs
- See Section 5.4 for details

### 5.4 Interactive Components: Council Orbs, Decision Map, Nudge Bar, Launchpad

#### Council Orbs (`ui/components/CouncilOrbs.tsx`)

**Purpose:** Visual representation of active models for each turn, with role assignment via long-press menu.

**Key Features:**
- **Voice Provider (Center):** The "crown" model that synthesizes
- **Priority Ordering:** Models arranged by priority (closest to center = highest)
- **Long-Press Menu:** Assign roles (Synthesizer, Mapper, Composer, Analyst)
- **Variants:**
  - `tray` — Config orbs above chat input (for next turn)
  - `historical` — Orbs attached to past synthesis bubbles
  - `welcome` — Orbs on welcome screen
  - `divider` — Orbs on split-pane divider
  - `active` — Currently executing turn

**Props:**
See: [ui/components/CouncilOrbs.tsx](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/ui/components/CouncilOrbs.tsx)

**Visual States:**
- **Active:** Full color, 100% opacity, slight glow
- **Inactive:** Grayscale, 40% opacity
- **Hover:** Scale 1.1x, stronger glow
- **Selected (in menu):** Border highlight

---

#### Decision Map Sheet (`ui/components/DecisionMapSheet.tsx`)

**Purpose:** Bottom sheet for visualizing decision map with three tabs.

**Tabs:**

1. **Graph Tab** (default)
   - Force-directed visualization using D3 (via `DecisionMapGraph.tsx`)
   - Node size = supporter count
   - Edge types: conflicts (red), complements (green), prerequisite (blue)
   - Click node → Detail view with provenance

2. **Narrative Tab**
   - Prose explanation of consensus/divergence
   - Embedded citations `[1,2,3]` clickable
   - **Bold canonical labels** link to options

3. **Options Tab**
   - Collapsible theme sections
   - Each option shows: **[Label]** + description + citations
   - Click citation → Jump to that model's response

**Data Flow:**
See: [ui/components/DecisionMapSheet.tsx](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/ui/components/DecisionMapSheet.tsx)

**Key Components:**
- `SupporterOrbs` — Mini orbs showing which models support a claim
- `MapperSelector` — Dropdown to recompute with different mapper
- `DetailView` — Full provenance for a selected node

---

#### Nudge Chip Bar (`ui/components/NudgeChipBar.tsx`)

**Purpose:** Pre-flight suggestions that appear above chat input after user pauses typing.

**Variants:**
- `default` — "Let Composer perfect it" / "Let Analyst sharpen it"
- `chain_analyst` — After Composer ran: "Now pressure-test with Analyst?"
- `chain_composer` — After Analyst ran: "Now perfect this audited version?"

**Props:**
See: [ui/components/NudgeChipBar.tsx](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/ui/components/NudgeChipBar.tsx)

**Visual Design:**
- Floating pill above input with backdrop blur
- Two chips separated by divider
- Shows model name in small mono font `[gemini-flash]`
- Progress ring animates around perimeter when `type="sending"`

---

#### Launchpad Drawer (`ui/components/LaunchpadDrawer.tsx`)

**Purpose:** Left-edge drawer for managing draft prompts from Composer and Analyst.

**Features:**
- **Auto-capture:** Composer outputs and Analyst variants saved as draft cards
- **Actions per card:**
  - Send (directly to batch)
  - Send to Composer (refine further)
  - Send to Analyst (get audit)
  - Delete
- **Reordering:** Drag to reorder priority
- **Persistence:** Stored in `launchpadDraftsAtom` (IndexedDB via atomWithStorage)

**Draft Card Structure:**
See: [ui/components/LaunchpadDrawer.tsx](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/ui/components/LaunchpadDrawer.tsx)

**Visual Design:**
- 420px wide, full height
- Backdrop blur overlay
- Empty state: "Ready for lift-off" with rocket emoji
- Cards show source badge (Composer/Analyst) and timestamp

---

## 6. Critical Flows

### 6.1 Flow: User Sends First Message (Initialize)

**Actors:** User, UI, ConnectionHandler, ContextResolver, Compiler, WorkflowEngine, Orchestrator, SessionManager

See: [Introduction Flow in docs/flows.md](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/docs/flows.md#1-user-sends-first-message-initialize)

### 6.2 Flow: User Re-runs Synthesis with Different Model (Recompute)

**Actors:** User, UI, ConnectionHandler, ContextResolver, Compiler, WorkflowEngine, Orchestrator, SessionManager

See: [Recompute Flow in docs/flows.md](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/docs/flows.md#2-user-re-runs-synthesis-with-different-model-recompute)

### 6.3 Flow: Provider Fails (Error Handling)

See: [Error Handling Flow in docs/flows.md](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/docs/flows.md#3-provider-fails-error-handling)

---

## 7. Debugging Guide

See: [docs/debugging.md](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/docs/debugging.md)

---

## 8. Extension Points

See: [docs/contributing.md](file:///c:/Users/Mahdi/OneDrive/Desktop/Singularityv3/docs/contributing.md)

---

## Appendix A: File Index

**Backend Core:**

- `src/core/connection-handler.js` - Entry point, orchestrates Resolve → Compile → Execute
- `src/core/context-resolver.js` - Fetches data for primitives
- `src/core/workflow-compiler.js` - Converts primitives to steps
- `src/core/workflow-engine.js` - Executes steps, manages streaming, contains Synthesizer + Mapper prompts
- `src/core/workflow-orchestrator.js` (FaultTolerantOrchestrator) - Provider fan-out

**Pre-Flight Refinement:**

- `src/services/PromptRefinerService.ts` - Composer + Analyst pipeline for prompt refinement

**Persistence:**

- `src/persistence/SessionManager.js` - Conversation data manager
- `src/persistence/SimpleIndexedDBAdapter.js` - Database abstraction
- `src/persistence/types.ts` - Database schema types

**Contracts:**

- `shared/contract.ts` - Request/response types
- `shared/parsing-utils.ts` - Shared parsing functions (extractOptionsAndStrip, extractGraphTopologyAndStrip)
- `ui/types.ts` - UI-specific types

**UI State:**

- `ui/state/atoms.ts` - Jotai state definitions (includes Composer, Analyst, Launchpad, Decision Map atoms)
- `ui/hooks/usePortMessageHandler.ts` - Backend → State bridge
- `ui/hooks/useChat.ts` - User actions → Backend messages
- `ui/hooks/useLaunchpadDrafts.ts` - Launchpad draft management

**UI Components:**

- `ui/App.tsx` - Top-level layout
- `ui/views/ChatView.tsx` - Virtualized turn list
- `ui/components/AiTurnBlock.tsx` - Synthesis-focused renderer with tabs
- `ui/components/ModelResponsePanel.tsx` - Right split pane for batch responses
- `ui/components/ChatInput.tsx` - Prompt input
- `ui/components/ChatInputConnected.tsx` - Connected input wrapper
- `ui/components/CouncilOrbs.tsx` - Horizontal orb strip with long-press menu
- `ui/components/CouncilOrbsVertical.tsx` - Vertical orb strip variant
- `ui/components/DecisionMapSheet.tsx` - Bottom sheet with Graph/Narrative/Options tabs
- `ui/components/experimental/DecisionMapGraph.tsx` - D3 force-directed graph visualization
- `ui/components/NudgeChipBar.tsx` - Pre-flight Composer/Analyst suggestions
- `ui/components/LaunchpadDrawer.tsx` - Left-edge draft management drawer
- `ui/components/DraftCard.tsx` - Individual draft card in Launchpad

---

## Appendix B: Performance Characteristics

**Hot Paths (optimized):**

- `extend` request resolution: **~5ms** (indexed lookup on `provider_contexts`)
- PARTIAL_RESULT → DOM update: **16ms** (batched via StreamingBuffer)
- Turn data access: **O(1)** (Map-based `turnsMapAtom`)

**Cold Paths (acceptable):**

- `recompute` request resolution: **~50ms** (multiple DB reads)
- History session load: **~200ms** (reconstruct full session from records)
- Initial app boot: **~500ms** (IndexedDB init + provider registry)

**Limits:**

- Max turn storage: **~10,000 turns** (beyond this, archive old sessions)
- Streaming buffer size: **50 updates** (flushed every 16ms)
- Provider fan-out: **5 concurrent** (hardcoded in orchestrator)

---

**End of Document**

This unified architecture overview provides a complete picture of the system. For hands-on work:

- Backend contributors: Focus on sections 2.1, 3, and 6
- Frontend contributors: Focus on sections 2.2, 2.3, 4, 5, and 6
- Full-stack contributors: Read sequentially

-



================================================
FILE: bundle-analysis-report2ndold.txt
================================================

================================================================================
BUNDLE SIZE ANALYSIS REPORT
Generated: 12/19/2025, 1:42:17 AM
================================================================================

================================================================================
UI BUNDLE (Main Application)
================================================================================

Summary:
  Total Input:  3.30 MB
  Bundle Size:  68.00 B
  Compression:  0.0%

Top 100 Largest Modules:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 595.65 KB    18542L (17.6%  ) katex/dist/katex.mjs
  2. 184.62 KB    1L     (5.5%   ) ui/assets/logos/logo-icon.svg
  3. 128.60 KB    323L   (3.8%   ) react-dom/cjs/react-dom.production.min.js
  4. 88.88 KB     3317L  (2.6%   ) react-virtuoso/dist/index.mjs
  5. 82.60 KB     2487L  (2.4%   ) react-resizable-panels/dist/react-resizable-panels.browser.js
  6. 69.66 KB     1620L  (2.1%   ) framer-motion/dist/es/projection/node/create-projection-node.mjs
  7. 50.83 KB     1241L  (1.5%   ) ui/components/AiTurnBlock.tsx
  8. 46.55 KB     1182L  (1.4%   ) ui/components/DecisionMapSheet.tsx
  9. 39.34 KB     1324L  (1.2%   ) unified/lib/index.js
 10. 37.30 KB     1300L  (1.1%   ) immer/dist/immer.mjs
 11. 37.11 KB     773L   (1.1%   ) ui/components/CouncilOrbs.tsx
 12. 36.67 KB     944L   (1.1%   ) ui/hooks/usePortMessageHandler.ts
 13. 34.25 KB     968L   (1.0%   ) shared/parsing-utils.ts
 14. 31.26 KB     734L   (0.9%   ) ui/components/experimental/DecisionMapGraph.tsx
 15. 30.59 KB     1047L  (0.9%   ) usehooks-ts/dist/index.js
 16. 28.33 KB     1177L  (0.8%   ) mdast-util-from-markdown/lib/index.js
 17. 26.30 KB     653L   (0.8%   ) ui/components/ChatInput.tsx
 18. 26.13 KB     1060L  (0.8%   ) micromark/lib/compile.js
 19. 25.76 KB     682L   (0.8%   ) ui/components/HistoryPanel.tsx
 20. 22.99 KB     755L   (0.7%   ) jotai/esm/vanilla/utils.mjs
 21. 21.39 KB     499L   (0.6%   ) framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
 22. 21.24 KB     657L   (0.6%   ) jotai/esm/vanilla/internals.mjs
 23. 20.96 KB     630L   (0.6%   ) ui/hooks/useChat.ts
 24. 20.24 KB     819L   (0.6%   ) micromark-extension-gfm-table/lib/syntax.js
 25. 19.80 KB     854L   (0.6%   ) micromark-extension-gfm-autolink-literal/lib/syntax.js
 26. 19.29 KB     788L   (0.6%   ) hast-util-to-jsx-runtime/lib/index.js
 27. 19.20 KB     559L   (0.6%   ) ui/hooks/useRoundActions.ts
 28. 19.13 KB     634L   (0.6%   ) hast-util-to-text/lib/index.js
 29. 18.19 KB     876L   (0.5%   ) micromark-core-commonmark/lib/html-flow.js
 30. 18.15 KB     478L   (0.5%   ) framer-motion/dist/es/render/VisualElement.mjs
 31. 17.79 KB     457L   (0.5%   ) ui/utils/copy-format-utils.ts
 32. 17.58 KB     352L   (0.5%   ) ui/components/ModelResponsePanel.tsx
 33. 17.54 KB     554L   (0.5%   ) ui/state/atoms.ts
 34. 16.55 KB     644L   (0.5%   ) vfile/lib/index.js
 35. 16.11 KB     363L   (0.5%   ) framer-motion/dist/es/render/utils/animation-state.mjs
 36. 14.82 KB     611L   (0.4%   ) micromark/lib/create-tokenizer.js
 37. 14.79 KB     321L   (0.4%   ) ui/components/DraftCard.tsx
 38. 14.70 KB     474L   (0.4%   ) mdast-util-to-hast/lib/state.js
 39. 14.49 KB     349L   (0.4%   ) ui/components/MarkdownDisplay.tsx
 40. 14.01 KB     568L   (0.4%   ) property-information/lib/svg.js
 41. 13.05 KB     678L   (0.4%   ) micromark-core-commonmark/lib/html-text.js
 42. 12.87 KB     350L   (0.4%   ) motion-dom/dist/es/animation/JSAnimation.mjs
 43. 12.50 KB     445L   (0.4%   ) react-markdown/lib/index.js
 44. 12.43 KB     437L   (0.4%   ) shared/contract.ts
 45. 12.36 KB     560L   (0.4%   ) micromark-core-commonmark/lib/label-end.js
 46. 12.19 KB     485L   (0.4%   ) micromark-extension-gfm-footnote/lib/syntax.js
 47. 11.78 KB     399L   (0.3%   ) src/persistence/SimpleIndexedDBAdapter.ts
 48. 11.61 KB     353L   (0.3%   ) ui/utils/turn-helpers.ts
 49. 11.49 KB     254L   (0.3%   ) ui/components/refinerui/RefinerCardsSection.tsx
 50. 11.48 KB     311L   (0.3%   ) ui/components/refinerui/TrustSignalsPanel.tsx
 51. 11.48 KB     400L   (0.3%   ) unist-util-visit-parents/lib/index.js
 52. 11.17 KB     404L   (0.3%   ) src/persistence/database.ts
 53. 11.15 KB     427L   (0.3%   ) vfile/lib/minpath.browser.js
 54. 11.08 KB     250L   (0.3%   ) framer-motion/dist/es/animation/sequence/create.mjs
 55. 10.81 KB     402L   (0.3%   ) src/persistence/transactions.ts
 56. 10.61 KB     362L   (0.3%   ) micromark/lib/initialize/document.js
 57. 10.53 KB     378L   (0.3%   ) lodash.debounce/index.js
 58. 10.03 KB     394L   (0.3%   ) markdown-table/index.js
 59. 9.92 KB      279L   (0.3%   ) ui/views/ChatView.tsx
 60. 9.91 KB      105L   (0.3%   ) ui/assets/gemini.svg
 61. 9.62 KB      324L   (0.3%   ) motion-dom/dist/es/value/index.mjs
 62. 9.50 KB      258L   (0.3%   ) hast-util-to-html/lib/index.js
 63. 9.40 KB      314L   (0.3%   ) unist-util-visit/lib/index.js
 64. 9.06 KB      460L   (0.3%   ) micromark-core-commonmark/lib/code-fenced.js
 65. 9.01 KB      321L   (0.3%   ) ui/services/extension-api.ts
 66. 8.82 KB      366L   (0.3%   ) hastscript/lib/create-h.js
 67. 8.78 KB      297L   (0.3%   ) unist-util-is/lib/index.js
 68. 8.53 KB      359L   (0.3%   ) hast-util-to-html/lib/omission/closing.js
 69. 8.45 KB      323L   (0.2%   ) property-information/lib/html.js
 70. 8.43 KB      318L   (0.2%   ) mdast-util-math/lib/index.js
 71. 8.02 KB      315L   (0.2%   ) vfile-message/lib/index.js
 72. 7.99 KB      301L   (0.2%   ) mdast-util-gfm-table/lib/index.js
 73. 7.99 KB      241L   (0.2%   ) ui/utils/refiner-helpers.ts
 74. 7.59 KB      279L   (0.2%   ) hast-util-is-element/lib/index.js
 75. 7.49 KB      253L   (0.2%   ) mdast-util-to-hast/lib/footer.js
 76. 7.44 KB      251L   (0.2%   ) micromark-util-subtokenize/lib/splice-buffer.js
 77. 7.39 KB      266L   (0.2%   ) hast-util-to-html/lib/handle/element.js
 78. 7.28 KB      176L   (0.2%   ) motion-dom/dist/es/animation/generators/spring/index.mjs
 79. 7.24 KB      156L   (0.2%   ) motion-dom/dist/es/view/start.mjs
 80. 7.05 KB      101L   (0.2%   ) motion-dom/dist/es/index.mjs
 81. 7.00 KB      241L   (0.2%   ) micromark-core-commonmark/lib/attention.js
 82. 6.93 KB      171L   (0.2%   ) ui/components/SettingsPanel.tsx
 83. 6.90 KB      246L   (0.2%   ) micromark-util-character/index.js
 84. 6.83 KB      217L   (0.2%   ) ui/components/Icons.tsx
 85. 6.79 KB      172L   (0.2%   ) framer-motion/dist/es/animation/optimized-appear/start.mjs
 86. 6.77 KB      27L    (0.2%   ) react/cjs/react.production.min.js
 87. 6.77 KB      167L   (0.2%   ) framer-motion/dist/es/components/AnimatePresence/index.mjs
 88. 6.69 KB      228L   (0.2%   ) micromark-util-subtokenize/index.js
 89. 6.66 KB      345L   (0.2%   ) micromark-extension-math/lib/math-flow.js
 90. 6.62 KB      135L   (0.2%   ) ui/components/LaunchpadDrawer.tsx
 91. 6.55 KB      281L   (0.2%   ) mdast-util-gfm-autolink-literal/lib/index.js
 92. 6.54 KB      262L   (0.2%   ) mdast-util-find-and-replace/lib/index.js
 93. 6.24 KB      179L   (0.2%   ) motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs
 94. 6.22 KB      154L   (0.2%   ) micromark-extension-gfm-footnote/lib/html.js
 95. 6.10 KB      213L   (0.2%   ) micromark-core-commonmark/lib/list.js
 96. 6.00 KB      141L   (0.2%   ) framer-motion/dist/es/motion/utils/use-visual-element.mjs
 97. 5.74 KB      132L   (0.2%   ) motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs
 98. 5.73 KB      156L   (0.2%   ) framer-motion/dist/es/gestures/pan/PanSession.mjs
 99. 5.68 KB      148L   (0.2%   ) framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
100. 5.66 KB      85L    (0.2%   ) framer-motion/dist/es/index.mjs

Top 15 Heaviest Packages:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 595.65 KB    (17.6%  ) katex/dist
  2. 380.77 KB    (11.3%  ) framer-motion/dist
  3. 178.12 KB    (5.3%   ) motion-dom/dist
  4. 128.60 KB    (3.8%   ) react-dom/cjs
  5. 110.96 KB    (3.3%   ) micromark-core-commonmark/lib
  6. 88.88 KB     (2.6%   ) react-virtuoso/dist
  7. 82.60 KB     (2.4%   ) react-resizable-panels/dist
  8. 66.76 KB     (2.0%   ) micromark/lib
  9. 64.60 KB     (1.9%   ) mdast-util-to-markdown/lib
 10. 52.64 KB     (1.6%   ) jotai/esm
 11. 51.40 KB     (1.5%   ) mdast-util-to-hast/lib
 12. 40.71 KB     (1.2%   ) unified/lib
 13. 37.30 KB     (1.1%   ) immer/dist
 14. 36.16 KB     (1.1%   ) hast-util-to-html/lib
 15. 34.12 KB     (1.0%   ) property-information/lib

================================================================================
RECOMMENDATIONS:
================================================================================
1. Focus on modules larger than 50 KB
2. Consider lazy loading for heavy features
3. Check if you're importing full libraries vs specific components
4. Use dynamic imports for code splitting
5. Review if all imported packages are actually used

For interactive visualization: npm run analyze:ui
================================================================================




================================================
FILE: bundle-analysis-reportlatest.txt
================================================

================================================================================
BUNDLE SIZE ANALYSIS REPORT
Generated: 12/20/2025, 2:18:20 PM
================================================================================

================================================================================
UI BUNDLE (Main Application)
================================================================================

Summary:
  Total Input:  3.12 MB
  Bundle Size:  1.12 KB
  Compression:  0.0%

Top 100 Largest Modules:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 595.65 KB    18542L (18.6%  ) katex/dist/katex.mjs
  2. 128.60 KB    323L   (4.0%   ) react-dom/cjs/react-dom.production.min.js
  3. 88.88 KB     3317L  (2.8%   ) react-virtuoso/dist/index.mjs
  4. 82.60 KB     2487L  (2.6%   ) react-resizable-panels/dist/react-resizable-panels.browser.js
  5. 69.66 KB     1620L  (2.2%   ) framer-motion/dist/es/projection/node/create-projection-node.mjs
  6. 44.70 KB     1138L  (1.4%   ) ui/components/DecisionMapSheet.tsx
  7. 44.48 KB     1057L  (1.4%   ) ui/components/AiTurnBlock.tsx
  8. 39.34 KB     1324L  (1.2%   ) unified/lib/index.js
  9. 37.30 KB     1300L  (1.2%   ) immer/dist/immer.mjs
 10. 36.57 KB     942L   (1.1%   ) ui/hooks/usePortMessageHandler.ts
 11. 36.26 KB     772L   (1.1%   ) ui/components/CouncilOrbs.tsx
 12. 36.02 KB     167L   (1.1%   ) ui/assets/logos/logo-icon.png
 13. 31.14 KB     733L   (1.0%   ) ui/components/experimental/DecisionMapGraph.tsx
 14. 30.59 KB     1047L  (1.0%   ) usehooks-ts/dist/index.js
 15. 28.36 KB     827L   (0.9%   ) shared/parsing-utils.ts
 16. 28.33 KB     1177L  (0.9%   ) mdast-util-from-markdown/lib/index.js
 17. 26.13 KB     1060L  (0.8%   ) micromark/lib/compile.js
 18. 26.07 KB     748L   (0.8%   ) ui/components/HistoryPanel.tsx
 19. 25.47 KB     647L   (0.8%   ) ui/components/ChatInput.tsx
 20. 22.99 KB     755L   (0.7%   ) jotai/esm/vanilla/utils.mjs
 21. 21.39 KB     499L   (0.7%   ) framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
 22. 21.24 KB     657L   (0.7%   ) jotai/esm/vanilla/internals.mjs
 23. 20.85 KB     627L   (0.7%   ) ui/hooks/useChat.ts
 24. 20.24 KB     819L   (0.6%   ) micromark-extension-gfm-table/lib/syntax.js
 25. 19.80 KB     854L   (0.6%   ) micromark-extension-gfm-autolink-literal/lib/syntax.js
 26. 19.29 KB     788L   (0.6%   ) hast-util-to-jsx-runtime/lib/index.js
 27. 19.20 KB     559L   (0.6%   ) ui/hooks/useRoundActions.ts
 28. 19.13 KB     634L   (0.6%   ) hast-util-to-text/lib/index.js
 29. 18.19 KB     876L   (0.6%   ) micromark-core-commonmark/lib/html-flow.js
 30. 18.15 KB     478L   (0.6%   ) framer-motion/dist/es/render/VisualElement.mjs
 31. 17.70 KB     458L   (0.6%   ) ui/utils/copy-format-utils.ts
 32. 17.44 KB     550L   (0.5%   ) ui/state/atoms.ts
 33. 17.18 KB     344L   (0.5%   ) ui/components/ModelResponsePanel.tsx
 34. 16.55 KB     644L   (0.5%   ) vfile/lib/index.js
 35. 16.11 KB     363L   (0.5%   ) framer-motion/dist/es/render/utils/animation-state.mjs
 36. 14.82 KB     611L   (0.5%   ) micromark/lib/create-tokenizer.js
 37. 14.78 KB     321L   (0.5%   ) ui/components/DraftCard.tsx
 38. 14.70 KB     474L   (0.5%   ) mdast-util-to-hast/lib/state.js
 39. 14.01 KB     568L   (0.4%   ) property-information/lib/svg.js
 40. 13.05 KB     678L   (0.4%   ) micromark-core-commonmark/lib/html-text.js
 41. 12.87 KB     350L   (0.4%   ) motion-dom/dist/es/animation/JSAnimation.mjs
 42. 12.50 KB     445L   (0.4%   ) react-markdown/lib/index.js
 43. 12.43 KB     437L   (0.4%   ) shared/contract.ts
 44. 12.36 KB     560L   (0.4%   ) micromark-core-commonmark/lib/label-end.js
 45. 12.19 KB     485L   (0.4%   ) micromark-extension-gfm-footnote/lib/syntax.js
 46. 11.78 KB     399L   (0.4%   ) src/persistence/SimpleIndexedDBAdapter.ts
 47. 11.48 KB     353L   (0.4%   ) ui/utils/turn-helpers.ts
 48. 11.48 KB     400L   (0.4%   ) unist-util-visit-parents/lib/index.js
 49. 11.17 KB     404L   (0.3%   ) src/persistence/database.ts
 50. 11.15 KB     427L   (0.3%   ) vfile/lib/minpath.browser.js
 51. 11.08 KB     250L   (0.3%   ) framer-motion/dist/es/animation/sequence/create.mjs
 52. 10.79 KB     402L   (0.3%   ) src/persistence/transactions.ts
 53. 10.61 KB     362L   (0.3%   ) micromark/lib/initialize/document.js
 54. 10.53 KB     378L   (0.3%   ) lodash.debounce/index.js
 55. 10.18 KB     294L   (0.3%   ) ui/components/MarkdownDisplay.tsx
 56. 10.03 KB     394L   (0.3%   ) markdown-table/index.js
 57. 10.03 KB     282L   (0.3%   ) ui/views/ChatView.tsx
 58. 9.91 KB      105L   (0.3%   ) ui/assets/gemini.svg
 59. 9.62 KB      324L   (0.3%   ) motion-dom/dist/es/value/index.mjs
 60. 9.50 KB      258L   (0.3%   ) hast-util-to-html/lib/index.js
 61. 9.40 KB      314L   (0.3%   ) unist-util-visit/lib/index.js
 62. 9.28 KB      205L   (0.3%   ) ui/components/refinerui/RefinerCardsSection.tsx
 63. 9.06 KB      460L   (0.3%   ) micromark-core-commonmark/lib/code-fenced.js
 64. 9.00 KB      321L   (0.3%   ) ui/services/extension-api.ts
 65. 8.82 KB      366L   (0.3%   ) hastscript/lib/create-h.js
 66. 8.78 KB      297L   (0.3%   ) unist-util-is/lib/index.js
 67. 8.53 KB      359L   (0.3%   ) hast-util-to-html/lib/omission/closing.js
 68. 8.45 KB      323L   (0.3%   ) property-information/lib/html.js
 69. 8.43 KB      318L   (0.3%   ) mdast-util-math/lib/index.js
 70. 8.02 KB      315L   (0.3%   ) vfile-message/lib/index.js
 71. 7.99 KB      301L   (0.2%   ) mdast-util-gfm-table/lib/index.js
 72. 7.84 KB      222L   (0.2%   ) ui/components/refinerui/TrustSignalsPanel.tsx
 73. 7.59 KB      279L   (0.2%   ) hast-util-is-element/lib/index.js
 74. 7.49 KB      253L   (0.2%   ) mdast-util-to-hast/lib/footer.js
 75. 7.44 KB      251L   (0.2%   ) micromark-util-subtokenize/lib/splice-buffer.js
 76. 7.39 KB      266L   (0.2%   ) hast-util-to-html/lib/handle/element.js
 77. 7.28 KB      176L   (0.2%   ) motion-dom/dist/es/animation/generators/spring/index.mjs
 78. 7.24 KB      156L   (0.2%   ) motion-dom/dist/es/view/start.mjs
 79. 7.05 KB      101L   (0.2%   ) motion-dom/dist/es/index.mjs
 80. 7.00 KB      241L   (0.2%   ) micromark-core-commonmark/lib/attention.js
 81. 6.92 KB      171L   (0.2%   ) ui/components/SettingsPanel.tsx
 82. 6.90 KB      246L   (0.2%   ) micromark-util-character/index.js
 83. 6.83 KB      217L   (0.2%   ) ui/components/Icons.tsx
 84. 6.79 KB      172L   (0.2%   ) framer-motion/dist/es/animation/optimized-appear/start.mjs
 85. 6.77 KB      27L    (0.2%   ) react/cjs/react.production.min.js
 86. 6.77 KB      167L   (0.2%   ) framer-motion/dist/es/components/AnimatePresence/index.mjs
 87. 6.69 KB      228L   (0.2%   ) micromark-util-subtokenize/index.js
 88. 6.66 KB      345L   (0.2%   ) micromark-extension-math/lib/math-flow.js
 89. 6.62 KB      135L   (0.2%   ) ui/components/LaunchpadDrawer.tsx
 90. 6.55 KB      281L   (0.2%   ) mdast-util-gfm-autolink-literal/lib/index.js
 91. 6.54 KB      262L   (0.2%   ) mdast-util-find-and-replace/lib/index.js
 92. 6.24 KB      179L   (0.2%   ) motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs
 93. 6.22 KB      154L   (0.2%   ) micromark-extension-gfm-footnote/lib/html.js
 94. 6.10 KB      213L   (0.2%   ) micromark-core-commonmark/lib/list.js
 95. 6.00 KB      141L   (0.2%   ) framer-motion/dist/es/motion/utils/use-visual-element.mjs
 96. 5.74 KB      132L   (0.2%   ) motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs
 97. 5.73 KB      156L   (0.2%   ) framer-motion/dist/es/gestures/pan/PanSession.mjs
 98. 5.68 KB      148L   (0.2%   ) framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
 99. 5.66 KB      85L    (0.2%   ) framer-motion/dist/es/index.mjs
100. 5.54 KB      199L   (0.2%   ) ui/services/port-health-manager.ts

Top 15 Heaviest Packages:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 595.65 KB    (18.6%  ) katex/dist
  2. 380.77 KB    (11.9%  ) framer-motion/dist
  3. 178.12 KB    (5.6%   ) motion-dom/dist
  4. 128.60 KB    (4.0%   ) react-dom/cjs
  5. 110.96 KB    (3.5%   ) micromark-core-commonmark/lib
  6. 88.88 KB     (2.8%   ) react-virtuoso/dist
  7. 82.60 KB     (2.6%   ) react-resizable-panels/dist
  8. 66.76 KB     (2.1%   ) micromark/lib
  9. 64.60 KB     (2.0%   ) mdast-util-to-markdown/lib
 10. 52.64 KB     (1.6%   ) jotai/esm
 11. 51.40 KB     (1.6%   ) mdast-util-to-hast/lib
 12. 40.71 KB     (1.3%   ) unified/lib
 13. 37.30 KB     (1.2%   ) immer/dist
 14. 36.16 KB     (1.1%   ) hast-util-to-html/lib
 15. 34.12 KB     (1.1%   ) property-information/lib

================================================================================
SERVICE WORKER BUNDLE
================================================================================

Summary:
  Total Input:  587.99 KB
  Bundle Size:  214.29 KB
  Compression:  36.4%

Top 100 Largest Modules:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 74.30 KB     2185L  (12.6%  ) src/core/workflow-engine.js
  2. 39.39 KB     1228L  (6.7%   ) src/persistence/SessionManager.js
  3. 37.75 KB     1218L  (6.4%   ) src/providers/chatgpt.js
  4. 33.72 KB     925L   (5.7%   ) src/sw-entry.js
  5. 28.36 KB     827L   (4.8%   ) shared/parsing-utils.ts
  6. 25.97 KB     614L   (4.4%   ) src/core/PromptService.ts
  7. 25.82 KB     921L   (4.4%   ) src/HTOS/BusController.js
  8. 24.54 KB     698L   (4.2%   ) src/core/connection-handler.js
  9. 24.12 KB     899L   (4.1%   ) src/utils/ErrorHandler.js
 10. 19.12 KB     672L   (3.3%   ) src/core/dnr-utils.js
 11. 17.53 KB     394L   (3.0%   ) src/core/ResponseProcessor.ts
 12. 17.04 KB     554L   (2.9%   ) src/providers/claude.js
 13. 16.49 KB     550L   (2.8%   ) src/providers/gemini.js
 14. 15.79 KB     574L   (2.7%   ) src/HTOS/NetRulesManager.js
 15. 15.46 KB     476L   (2.6%   ) src/core/workflow-compiler.js
 16. 14.41 KB     465L   (2.5%   ) src/core/request-lifecycle-manager.js
 17. 12.80 KB     415L   (2.2%   ) src/providers/chatgpt-adapter.js
 18. 12.63 KB     432L   (2.1%   ) src/providers/qwen.js
 19. 11.78 KB     399L   (2.0%   ) src/persistence/SimpleIndexedDBAdapter.ts
 20. 11.65 KB     366L   (2.0%   ) src/core/auth-manager.js
 21. 11.17 KB     404L   (1.9%   ) src/persistence/database.ts
 22. 10.79 KB     402L   (1.8%   ) src/persistence/transactions.ts
 23. 10.77 KB     355L   (1.8%   ) src/providers/gemini-adapter.js
 24. 9.80 KB      320L   (1.7%   ) src/providers/claude-adapter.js
 25. 8.56 KB      346L   (1.5%   ) src/core/PersistenceMonitor.js
 26. 8.37 KB      285L   (1.4%   ) src/providers/qwen-adapter.js
 27. 7.91 KB      250L   (1.3%   ) src/core/context-resolver.js
 28. 6.06 KB      187L   (1.0%   ) src/core/context-utils.js
 29. 5.26 KB      146L   (0.9%   ) shared/artifact-processor.ts
 30. 4.32 KB      172L   (0.7%   ) src/core/lifecycle-manager.js
 31. 4.08 KB      106L   (0.7%   ) src/core/preflight-validator.js
 32. 3.79 KB      125L   (0.6%   ) src/core/provider-health-tracker.js
 33. 3.65 KB      145L   (0.6%   ) src/core/error-classifier.js
 34. 3.08 KB      120L   (0.5%   ) src/persistence/index.ts
 35. 3.07 KB      152L   (0.5%   ) src/persistence/types.ts
 36. 1.66 KB      55L    (0.3%   ) shared/provider-config.ts
 37. 1.57 KB      51L    (0.3%   ) src/persistence/schemaVerification.ts
 38. 1.52 KB      55L    (0.3%   ) shared/provider-locks.ts
 39. 1.45 KB      45L    (0.2%   ) src/core/service-registry.js
 40. 1.21 KB      45L    (0.2%   ) src/shared/auth-config.ts
 41. 665.00 B     16L    (0.1%   ) shared/provider-limits.ts
 42. 588.00 B     24L    (0.1%   ) src/core/vendor-exports.js

================================================================================
CONTENT SCRIPT BUNDLE
================================================================================

Summary:
  Total Input:  6.92 KB
  Bundle Size:  4.54 KB
  Compression:  65.6%

Top 100 Largest Modules:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 6.92 KB      255L   (100.0% ) src/cs-openai.js

================================================================================
OFFSCREEN BUNDLE
================================================================================

Summary:
  Total Input:  34.65 KB
  Bundle Size:  12.56 KB
  Compression:  36.2%

Top 100 Largest Modules:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 25.82 KB     921L   (74.5%  ) src/HTOS/BusController.js
  2. 8.46 KB      262L   (24.4%  ) src/HTOS/OffscreenBootstrap.js
  3. 374.00 B     11L    (1.1%   ) src/offscreen-entry.js

================================================================================
OI BUNDLE
================================================================================

Summary:
  Total Input:  40.82 KB
  Bundle Size:  23.24 KB
  Compression:  56.9%

Top 100 Largest Modules:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 40.82 KB     1270L  (100.0% ) src/oi.js

================================================================================
RECOMMENDATIONS:
================================================================================
1. Focus on modules larger than 50 KB
2. Consider lazy loading for heavy features
3. Check if you're importing full libraries vs specific components
4. Use dynamic imports for code splitting
5. Review if all imported packages are actually used

For interactive visualization: npm run analyze:ui
================================================================================




================================================
FILE: bundle-analysis-reportold.txt
================================================

================================================================================
BUNDLE SIZE ANALYSIS REPORT
Generated: 11/27/2025, 12:11:48 AM
================================================================================

================================================================================
UI BUNDLE (Main Application)
================================================================================

Summary:
  Total Input:  2.09 MB
  Bundle Size:  5.58 KB
  Compression:  0.3%

Top 30 Largest Modules:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 595.65 KB    (27.8%  ) katex/dist/katex.mjs
  2. 128.60 KB    (6.0%   ) react-dom/cjs/react-dom.production.min.js
  3. 88.88 KB     (4.2%   ) react-virtuoso/dist/index.mjs
  4. 51.57 KB     (2.4%   ) ui/components/CompactModelTray.tsx
  5. 50.97 KB     (2.4%   ) ui/components/AiTurnBlock.tsx
  6. 39.34 KB     (1.8%   ) unified/lib/index.js
  7. 37.30 KB     (1.7%   ) immer/dist/immer.mjs
  8. 30.59 KB     (1.4%   ) usehooks-ts/dist/index.js
  9. 28.33 KB     (1.3%   ) mdast-util-from-markdown/lib/index.js
 10. 26.59 KB     (1.2%   ) ui/hooks/usePortMessageHandler.ts
 11. 26.13 KB     (1.2%   ) micromark/lib/compile.js
 12. 22.99 KB     (1.1%   ) jotai/esm/vanilla/utils.mjs
 13. 22.42 KB     (1.0%   ) ui/components/ProviderResponseBlock.tsx
 14. 21.24 KB     (1.0%   ) jotai/esm/vanilla/internals.mjs
 15. 20.24 KB     (0.9%   ) micromark-extension-gfm-table/lib/syntax.js
 16. 19.80 KB     (0.9%   ) micromark-extension-gfm-autolink-literal/lib/syntax.js
 17. 19.29 KB     (0.9%   ) hast-util-to-jsx-runtime/lib/index.js
 18. 19.13 KB     (0.9%   ) hast-util-to-text/lib/index.js
 19. 18.98 KB     (0.9%   ) ui/hooks/useChat.ts
 20. 18.19 KB     (0.8%   ) micromark-core-commonmark/lib/html-flow.js
 21. 16.55 KB     (0.8%   ) vfile/lib/index.js
 22. 14.82 KB     (0.7%   ) micromark/lib/create-tokenizer.js
 23. 14.70 KB     (0.7%   ) mdast-util-to-hast/lib/state.js
 24. 14.01 KB     (0.7%   ) property-information/lib/svg.js
 25. 13.78 KB     (0.6%   ) ui/components/ChatInput.tsx
 26. 13.59 KB     (0.6%   ) ui/hooks/useRoundActions.ts
 27. 13.05 KB     (0.6%   ) micromark-core-commonmark/lib/html-text.js
 28. 12.50 KB     (0.6%   ) react-markdown/lib/index.js
 29. 12.36 KB     (0.6%   ) micromark-core-commonmark/lib/label-end.js
 30. 12.19 KB     (0.6%   ) micromark-extension-gfm-footnote/lib/syntax.js

Top 15 Heaviest Packages:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 595.65 KB    (27.8%  ) katex/dist
  2. 128.60 KB    (6.0%   ) react-dom/cjs
  3. 110.96 KB    (5.2%   ) micromark-core-commonmark/lib
  4. 88.88 KB     (4.2%   ) react-virtuoso/dist
  5. 66.76 KB     (3.1%   ) micromark/lib
  6. 64.60 KB     (3.0%   ) mdast-util-to-markdown/lib
  7. 52.64 KB     (2.5%   ) jotai/esm
  8. 51.40 KB     (2.4%   ) mdast-util-to-hast/lib
  9. 40.71 KB     (1.9%   ) unified/lib
 10. 37.30 KB     (1.7%   ) immer/dist
 11. 34.12 KB     (1.6%   ) property-information/lib
 12. 30.81 KB     (1.4%   ) vfile/lib
 13. 30.61 KB     (1.4%   ) micromark-extension-gfm-table/lib
 14. 30.59 KB     (1.4%   ) usehooks-ts/dist
 15. 28.33 KB     (1.3%   ) mdast-util-from-markdown/lib

================================================================================
SERVICE WORKER BUNDLE
================================================================================

Summary:
  Total Input:  475.97 KB
  Bundle Size:  201.29 KB
  Compression:  42.3%

Top 30 Largest Modules:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 59.91 KB     (12.6%  ) src/sw-entry.js
  2. 58.25 KB     (12.2%  ) src/core/workflow-engine.js
  3. 37.75 KB     (7.9%   ) src/providers/chatgpt.js
  4. 30.65 KB     (6.4%   ) src/persistence/SessionManager.js
  5. 27.35 KB     (5.7%   ) src/services/PromptRefinerService.ts
  6. 25.82 KB     (5.4%   ) src/HTOS/BusController.js
  7. 19.12 KB     (4.0%   ) src/core/dnr-utils.js
  8. 16.69 KB     (3.5%   ) src/providers/claude.js
  9. 15.79 KB     (3.3%   ) src/HTOS/NetRulesManager.js
 10. 15.03 KB     (3.2%   ) src/providers/gemini.js
 11. 14.41 KB     (3.0%   ) src/core/request-lifecycle-manager.js
 12. 14.25 KB     (3.0%   ) src/utils/ErrorHandler.js
 13. 14.14 KB     (3.0%   ) src/core/connection-handler.js
 14. 13.34 KB     (2.8%   ) src/core/workflow-compiler.js
 15. 12.26 KB     (2.6%   ) src/core/context-resolver.js
 16. 12.18 KB     (2.6%   ) src/providers/chatgpt-adapter.js
 17. 11.45 KB     (2.4%   ) src/persistence/SimpleIndexedDBAdapter.ts
 18. 11.17 KB     (2.3%   ) src/persistence/database.ts
 19. 10.98 KB     (2.3%   ) src/providers/qwen.js
 20. 10.81 KB     (2.3%   ) src/persistence/transactions.ts
 21. 8.56 KB      (1.8%   ) src/debug/PersistenceMonitor.js
 22. 7.81 KB      (1.6%   ) src/providers/gemini-adapter.js
 23. 7.49 KB      (1.6%   ) src/providers/claude-adapter.js
 24. 6.19 KB      (1.3%   ) src/providers/qwen-adapter.js
 25. 4.32 KB      (0.9%   ) src/core/lifecycle-manager.js
 26. 3.08 KB      (0.6%   ) src/persistence/index.ts
 27. 3.07 KB      (0.6%   ) src/persistence/types.ts
 28. 1.76 KB      (0.4%   ) src/HTOS/ServiceWorkerBootstrap.js
 29. 1.68 KB      (0.4%   ) src/persistence/schemaVerification.ts
 30. 678.00 B     (0.1%   ) src/core/vendor-exports.js

================================================================================
CONTENT SCRIPT BUNDLE
================================================================================

Summary:
  Total Input:  6.92 KB
  Bundle Size:  4.60 KB
  Compression:  66.5%

Top 30 Largest Modules:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 6.92 KB      (100.0% ) src/cs-openai.js

================================================================================
OFFSCREEN BUNDLE
================================================================================

Summary:
  Total Input:  34.65 KB
  Bundle Size:  16.05 KB
  Compression:  46.3%

Top 30 Largest Modules:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 25.82 KB     (74.5%  ) src/HTOS/BusController.js
  2. 8.46 KB      (24.4%  ) src/HTOS/OffscreenBootstrap.js
  3. 374.00 B     (1.1%   ) src/offscreen-entry.js

================================================================================
OI BUNDLE
================================================================================

Summary:
  Total Input:  40.82 KB
  Bundle Size:  23.62 KB
  Compression:  57.9%

Top 30 Largest Modules:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. 40.82 KB     (100.0% ) src/oi.js

================================================================================
RECOMMENDATIONS:
================================================================================
1. Focus on modules larger than 50 KB
2. Consider lazy loading for heavy features
3. Check if you're importing full libraries vs specific components
4. Use dynamic imports for code splitting
5. Review if all imported packages are actually used

For interactive visualization: npm run analyze:ui
================================================================================




================================================
FILE: manifest.json
================================================
{
  "manifest_version": 3,
  "name": "HTOS",
  "version": "0.1",
  "background": {
    "service_worker": "bg.js"
  },
  "permissions": [
    "alarms",
    "declarativeNetRequest",
    "offscreen",
    "storage",
    "tabs",
    "cookies"
  ],
  "host_permissions": [
    "https://*/*",
    "http://localhost:3000/*",
    "https://x.com/*"
  ],
  "content_scripts": [
    {
      "matches": [
        "https://*.openai.com/*"
      ],
      "js": [
        "cs-openai.js"
      ],
      "run_at": "document_start",
      "all_frames": true
    }
  ],
  "action": {
    "default_title": "HTOS"
  },
  "icons": {
    "16": "icons/icon16.png",
    "32": "icons/icon32.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  },
  "web_accessible_resources": [
    {
      "resources": [
        "main-world-injector.js",
        "oi.html",
        "oi.js",
        "src/oi.js"
      ],
      "matches": [
        "<all_urls>"
      ]
    }
  ],
  "content_security_policy": {
    "extension_pages": "script-src 'self' 'wasm-unsafe-eval'; object-src 'self'"
  }
}


================================================
FILE: package.json
================================================
{
  "name": "project-htos",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "build": "npm run build:dev",
    "build:dev": "npm run build:css && node scripts/build-dev.js && node scripts/postbuild.js",
    "build:prod": "npm run build:css && node scripts/build-prod.js && node scripts/postbuild.js",
    "build:analyze": "npm run build:css && node scripts/build-with-analysis.js && node scripts/postbuild.js",
    "analyze": "node scripts/analyze-bundle.js",
    "analyze:save": "node scripts/analyze-bundle.js --save",
    "analyze:ui": "npx esbuild-visualizer --metadata dist/analysis/meta-ui.json --open",
    "analyze:bg": "npx esbuild-visualizer --metadata dist/analysis/meta-bg.json --open",
    "build:css": "tailwindcss -i ./ui/styles/input.css -o ./ui/styles/index.css --minify",
    "dev:css": "tailwindcss -i ./ui/styles/input.css -o ./ui/styles/index.css --watch",
    "watch": "npm run build:css -- --watch & npm run build -- --watch",
    "clean": "node -e \"require('fs').rmSync('dist', {recursive: true, force: true});\"",
    "test": "jest --passWithNoTests",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@tanstack/react-virtual": "^3.13.12",
    "d3-force": "^3.0.0",
    "framer-motion": "^12.23.25",
    "jotai": "^2.15.0",
    "jotai-devtools": "^0.13.0",
    "jotai-immer": "^0.4.1",
    "rangy": "^1.3.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-markdown": "^10.1.0",
    "react-resizable-panels": "^3.0.6",
    "react-syntax-highlighter": "^16.1.0",
    "react-virtuoso": "^4.14.1",
    "react-window": "^1.8.7",
    "reactflow": "^11.11.4",
    "remark-gfm": "^4.0.1",
    "unist-util-visit": "^5.0.0",
    "usehooks-ts": "^3.1.1",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.1.4",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^14.5.1",
    "@types/chrome": "^0.1.24",
    "@types/jest": "^29.5.5",
    "@types/node": "^24.5.2",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@types/react-syntax-highlighter": "^15.5.13",
    "@types/uuid": "^9.0.8",
    "autoprefixer": "^10.4.22",
    "cpy-cli": "^5.0.0",
    "esbuild": "^0.25.10",
    "esbuild-visualizer": "^0.7.0",
    "http-server": "^14.1.1",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "katex": "^0.16.25",
    "postcss": "^8.5.6",
    "rehype-katex": "^7.0.1",
    "rehype-stringify": "^10.0.1",
    "remark-math": "^6.0.0",
    "remark-parse": "^11.0.0",
    "remark-rehype": "^11.1.2",
    "tailwindcss": "^3.4.18",
    "ts-jest": "^29.1.1",
    "typescript": "^5.9.2",
    "unified": "^11.0.5"
  }
}


================================================
FILE: postcss.config.js
================================================
module.exports = {
    plugins: {
        tailwindcss: {},
        autoprefixer: {},
    },
}



================================================
FILE: tailwind.config.js
================================================
const defaultTheme = require('tailwindcss/defaultTheme');

/** @type {import('tailwindcss').Config} */
module.exports = {
    darkMode: 'class',
    content: [
        "./ui/**/*.{js,jsx,ts,tsx}",
        "./src/**/*.{js,jsx,ts,tsx}",
        "./public/**/*.html"
    ],
    theme: {
        extend: {
            fontFamily: {
                // If you license Suisse Intl, replace 'Inter' with 'Suisse Intl'
                sans: [
                    'Inter',
                    'Inter Fallback',
                    'ui-sans-serif',
                    'system-ui',
                    'sans-serif',
                    ...defaultTheme.fontFamily.sans,
                ],
                mono: [
                    'DM Mono',
                    'ui-monospace',
                    'SFMono-Regular',
                    'Menlo',
                    'monospace',
                    ...defaultTheme.fontFamily.mono,
                ],
            },

            colors: {
                // Primary brand: Convergence Blue
                brand: {
                    50: '#E2E8F0',
                    100: '#CBD5E0',
                    200: '#A0AEC0',
                    300: '#718096',
                    400: '#4A5568',
                    500: '#2D3748', // Convergence Blue
                    600: '#1A202C',
                    700: '#111827',
                },

                // Surfaces â€“ Void Black base, subtle lifts
                surface: {
                    DEFAULT: '#0A0A0B',              // Void Black (app background)
                    soft: '#0B1013',              // subtle variation for chat area
                    raised: '#111827',              // primary card background
                    highest: '#0F172A',              // trays/modals/popovers
                    highlight: 'rgba(148,163,184,0.16)', // subtle hover
                    overlay: 'rgba(0,0,0,0.75)',    // dark overlay for insets
                    code: '#020617',             // code blocks
                    modal: '#020617',             // modal panels
                },

                input: {
                    DEFAULT: '#0A0F1A',              // input bars
                    subtle: '#020617',
                },

                overlay: {
                    backdrop: '#020617',             // use /70, /80 for opacity
                },

                text: {
                    primary: '#F8F9FA',            // Platinum White
                    secondary: '#E2E8F0',            // slightly dimmed
                    muted: '#A0AEC0',            // subtle labels
                    brand: '#A0AEC0',            // brand-tinted headings if needed
                },

                border: {
                    subtle: 'rgba(148,163,184,0.28)',
                    strong: 'rgba(148,163,184,0.5)',
                    brand: '#2D3748',
                },

                chip: {
                    DEFAULT: 'rgba(15,23,42,0.85)',
                    active: 'rgba(45,55,72,0.75)',   // Convergence Blue-tinted
                    soft: 'rgba(15,23,42,0.6)',
                },

                // Brand-aligned status colors
                intent: {
                    success: '#4A9B8E',  // Neural Teal
                    warning: '#F6AD55',  // Insight Amber
                    danger: '#FC8181',  // Warning Coral
                    info: '#63B3ED',  // supplementary blue for info
                },
            },

            borderRadius: {
                '2xl': '12px',
                '3xl': '1.5rem',
                pill: '9999px',
            },

            boxShadow: {
                card: '0 12px 30px rgba(0,0,0,0.7)',
                'card-sm': '0 2px 8px rgba(0,0,0,0.35)',
                elevated: '0 20px 45px rgba(0,0,0,0.85)',
                'glow-brand': '0 0 0 2px rgba(45,55,72,0.7), 0 10px 30px rgba(45,55,72,0.5)',
                'glow-brand-soft': '0 0 18px rgba(45,55,72,0.55)',
                overlay: '0 20px 25px -5px rgba(0,0,0,0.7), 0 10px 10px -5px rgba(0,0,0,0.6)',
            },

            backgroundImage: {
                // Singularity Gradient: Void Black â†’ Convergence Blue â†’ Platinum White
                'singularity-gradient':
                    'linear-gradient(135deg, #0A0A0B 0%, #2D3748 50%, #F8F9FA 100%)',

                // App background â€“ Void Black â†’ Convergence Blue â†’ Void Black (horizontal gradient)
                'app-gradient':
                    'linear-gradient(90deg, #0A0A0B 0%, #2D3748 50%, #0A0A0B 100%)',

                // Processing Gradient: Neural Teal â†’ Insight Amber
                'processing-gradient':
                    'linear-gradient(90deg, #4A9B8E 0%, #F6AD55 100%)',

                // Header gradient â€“ mostly black with a soft Convergence glow from top
                'header-gradient':
                    'radial-gradient(circle at top, rgba(45,55,72,0.35), transparent 55%), linear-gradient(180deg, #0A0A0B, #0A0A0B)',
            },

            keyframes: {
                'slide-up': {
                    '0%': { opacity: '0', transform: 'translateY(12px)' },
                    '100%': { opacity: '1', transform: 'translateY(0)' },
                },
            },
            animation: {
                'slide-up': 'slide-up 0.3s ease-out',
            },
        },
    },
    plugins: [],
};



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2021",
    "baseUrl": ".",
    "lib": [
      "DOM",
      "ES2021"
    ],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "strict": true,
    "noImplicitAny": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "isolatedModules": true,
    "noEmit": true,
    "typeRoots": [
      "./node_modules/@types",
      "./ui/types"
    ],
    "paths": {
      "react-window": [
        "./ui/types/react-window.d.ts"
      ],
      "react-window/*": [
        "./ui/types/react-window.d.ts"
      ],
      "@shared/*": [
        "./shared/*"
      ]
    },
    "types": [
      "react",
      "react-dom",
      "chrome",
      "node"
    ]
  },
  "include": [
    "./**/*.ts",
    "./**/*.tsx",
    "./**/*.d.ts",
    "src/utils/logger.js"
  ],
  "exclude": [
    "dist",
    "node_modules"
  ]
}


================================================
FILE: update.md
================================================
## Overview

Update the synthesis bubble to:

1. Move council orbs between short and long answer
2. Add decision map button and risk badge to orb strip
3. Connect new refiner output structure to UI
4. Update trust panel with new meta fields

---

## New Refiner Output Structure

The refiner now outputs this structure:

TypeScript

```
interface RefinerOutput {
  signals: Array<{
    type: "divergence" | "overclaim" | "gap" | "blindspot";
    priority: "blocker" | "risk" | "enhancement";
    content: string;
    source: string;
    impact: string;
  }>;
  
  unlistedOptions: Array<{
    title: string;
    description: string;
    source: string;
  }>;
  
  nextStep: {
    action: "proceed" | "verify" | "reframe" | "research";
    target: string;
    why: string;
  };
  
  reframe: {
    issue: string;
    suggestion: string;
    unlocks: string;
  } | null;
  
  meta: {
    reliabilitySummary: string;
    biggestRisk: string;
    strategicPattern: string | null;
    honestAssessment: string;
  };
}
```

---

```

---

## Synthesis Bubble Layout

New structure:

text

```
┌──────────────────────────────────────────────────────┐
│ ⛔ Cannot proceed without:          ← BLOCKER BANNER │
│    • [blocker signal]                  (if any)     │
├──────────────────────────────────────────────────────┤
│                                                      │
│  [SHORT ANSWER]                                      │
│  1-2 paragraphs, always above fold                   │
│                                                      │
├──────────────────────────────────────────────────────┤
│               📊    🔍³              │
│                map  trust           │
├──────────────────────────────────────────────────────┤
│                                                      │
│  [LONG ANSWER]                                       │
│  Full reasoning, scrollable                          │
│                                                      │
├──────────────────────────────────────────────────────┤
│  → Verify: [target]                ← NEXT STEP       │
│    [why]                                             │
└──────────────────────────────────────────────────────┘
┌──────────────────────────────────────────────────────┐
│  ◉ ◉ ◉ 👑 ◉ ◉                                             ⚡    │
│  └─ orbs ────┘                                   
│                                                                         redo   │
└──────────────────────────────────────────────────────┘

```

---

## Part 1: Blocker Banner

**Location:** Above short answer (top of synthesis bubble)

**Visibility:** Only if `blockerSignals.length > 0`

**Design:**

text

```
┌──────────────────────────────────────────────────────┐
│ ⛔ Cannot proceed without:                           │
│                                                      │
│ • [signal.content]                                   │
│   [signal.source]                               [→]  │
│                                                      │
│ • [another blocker if exists]                   [→]  │
└──────────────────────────────────────────────────────┘
```

**Styling:**

- Background: Red subtle
- Left border: 3px solid red
- Border radius: 6px
- Padding: 12px 16px

**Behavior:**

- Each signal row is clickable
- Click → Opens trust panel scrolled to that signal

---
### Part 2: Refiner Controls Strip (New)

**Location:** Between short answer and long answer

**Contains:**

- Decision map button (`📊`)
- Trust icon with badge (`🔍³`)

**Does NOT contain:**

- Council orbs (stay at bottom)
- Recompute button (stays with orbs)

**Layout:**

text

```
┌──────────────────────────────────────────────────────┐
│                      📊 Map    🔍³ Trust             │
└──────────────────────────────────────────────────────┘
```

**CSS:**

CSS

```
.refiner-strip {
  display: flex;
  justify-content: center;
  gap: 16px;
  padding: 12px 0;
  border-top: 1px solid var(--border-subtle);
  border-bottom: 1px solid var(--border-subtle);
  margin: 16px 0;
}

.refiner-strip-button {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: var(--surface-subtle);
  border-radius: 16px;
  cursor: pointer;
  font-size: 13px;
}

.refiner-strip-button:hover {
  background: var(--surface-hover);
}
```

---

## What Stays Unchanged

|Element|Status|
|---|---|
|Council orbs position|Unchanged — bottom of bubble|
|Orb click behavior|Unchanged — opens split pane|
|Recompute button position|Unchanged — with orbs|
|Invisible strip click|Remove — replaced by explicit map button|

---

## Benefits

1. **Less disruption** — Orbs stay where users expect them
2. **Clear separation** — Model responses (orbs) vs refiner analysis (new strip)
3. **Simpler change** — Just adding one new element, not relocating existing ones
4. **Logical grouping** — Recompute stays with orbs (it reruns models, not refiner)
## Part 2: Orb Strip Relocation


---

## Part 3: Orb Strip Elements


### 3B: Decision Map Button (new)

**Icon:** `📊` (or similar graph icon from your design system)

**Behavior:**

- Click → Opens decision map sheet
- Replaces the invisible strip click behavior

**Styling:**

CSS

```
.map-button {
  padding: 6px;
  background: var(--surface-subtle);
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}

.map-button:hover {
  background: var(--surface-hover);
}
```

### 3C: Trust Icon with Badge (updated)

**Icon:** `🔍` (or existing trust icon)

**Badge logic:**

TypeScript

```
function getTrustBadge(signals: Signal[]) {
  const { blockerSignals, riskSignals } = categorizeSignals(signals);
  
  if (blockerSignals.length > 0) {
    return { count: blockerSignals.length, type: 'blocker' };
  }
  
  if (riskSignals.length > 0) {
    return { count: riskSignals.length, type: 'risk' };
  }
  
  return null;
}
```

**Display states:**

|State|Display|
|---|---|
|No signals|`🔍` (no badge)|
|Has risks|`🔍` with amber badge showing count|
|Has blockers|`🔍` with red badge showing count|
|Loading|`🔍` with subtle pulse animation|

**Behavior:**

- Click → Opens trust panel

**Badge styling:**

CSS

```
.trust-icon-container {
  position: relative;
  cursor: pointer;
}

.trust-badge {
  position: absolute;
  top: -6px;
  right: -6px;
  min-width: 18px;
  height: 18px;
  font-size: 11px;
  font-weight: 600;
  border-radius: 9px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
}

.trust-badge--risk {
  background: var(--amber);
}

.trust-badge--blocker {
  background: var(--red);
}

.trust-badge--loading {
  background: var(--gray);
  animation: pulse 1.5s infinite;
}
```

### 3D: Recompute Button (existing)

Keep existing `⚡` button and behavior.

---

## Part 4: NextStepFooter Component update with colors

**Location:** Bottom of synthesis bubble, after long answer

**Props:**

TypeScript

```
interface NextStepFooterProps {
  nextStep: {
    action: "proceed" | "verify" | "reframe" | "research";
    target: string;
    why: string;
  } | null;
  isLoading?: boolean;
}
```

**Design:**

text

```
┌──────────────────────────────────────────────────────┐
│ → Verify: Your budget constraints and timeline       │
│   Core recommendation depends on resources assumed   │
└──────────────────────────────────────────────────────┘
```

**Action word styling:**

|Action|Color|
|---|---|
|proceed|Green|
|verify|Amber|
|reframe|Blue|
|research|Purple|

**CSS:**

CSS

```
.next-step-footer {
  padding: 12px 16px;
  background: var(--surface-subtle);
  border-left: 3px solid var(--accent);
  border-radius: 0 6px 6px 0;
  margin-top: 16px;
}

.next-step-action {
  font-weight: 600;
}

.next-step-target {
  font-weight: 400;
}

.next-step-why {
  font-size: 13px;
  color: var(--text-secondary);
  margin-top: 4px;
}
```

**Loading state:**

text

```
┌──────────────────────────────────────────────────────┐
│ → ...                                                │
└──────────────────────────────────────────────────────┘
```

---

## Part 5: Trust Panel Updates

### Structure

text

```
┌─────────────────────────────────────────────────────┐
│ TRUST PANEL                                         │
├─────────────────────────────────────────────────────┤
│                                                     │
│ Risks (3)                       ← if riskSignals    │
│ ┌─────────────────────────────────────────────────┐ │
│ │ [SignalCard - risk 1]                           │ │
│ ├─────────────────────────────────────────────────┤ │
│ │ [SignalCard - risk 2]                           │ │
│ ├─────────────────────────────────────────────────┤ │
│ │ [SignalCard - risk 3]                           │ │
│ └─────────────────────────────────────────────────┘ │
│                                                     │
├─────────────────────────────────────────────────────┤
│                                                     │
│ Additional Context (4)          ← enhancementSignals│
│ ┌─────────────────────────────────────────────────┐ │
│ │ [SignalCard - enhancement 1]                    │ │
│ ├─────────────────────────────────────────────────┤ │
│ │ [SignalCard - enhancement 2]                    │ │
│ └─────────────────────────────────────────────────┘ │
│                                                     │
├─────────────────────────────────────────────────────┤
│ 
├─────────────────────────────────────────────────────┤
│                                                     │
│ Refiner's Take                  ← meta (NEW)        │
│ ┌─────────────────────────────────────────────────┐ │
│ │                                                 │ │
│ │ [meta.reliabilitySummary]                       │ │
│ │ Full paragraph text...                          │ │
│ │                                                 │ │
│ ├─────────────────────────────────────────────────┤ │
│ │                                                 │ │
│ │ Strategic Pattern            ← if not null      │ │
│ │ [meta.strategicPattern]                         │ │
│ │ Full paragraph text...                          │ │
│ │                                                 │ │
│ ├─────────────────────────────────────────────────┤ │
│ │                                                 │ │
│ │ Biggest Risk                                    │ │
│ │ [meta.biggestRisk]                              │ │
│ │                                                 │ │
│ ├─────────────────────────────────────────────────┤ │
│ │                                                 │ │
│ │ Honest Assessment                               │ │
│ │ [meta.honestAssessment]                         │ │
│ │                                                 │ │
│ └─────────────────────────────────────────────────┘ │
│                                                     │
├─────────────────────────────────────────────────────┤
│ ▶ Raw Output (Debug - collapsed)                   │
└─────────────────────────────────────────────────────┘
```

### Section Visibility

|Section|Show When|
|---|---|
|Risks|`riskSignals.length > 0`|
|Additional Context|`enhancementSignals.length > 0`|
|Refiner's Take|Always (meta always present)|
|Raw Output|Always (collapsed by default)|

---

## Part 6: SignalCard Component

Reusable component for displaying any signal.

**Props:**

TypeScript

```
interface SignalCardProps {
  signal: {
    type: "divergence" | "overclaim" | "gap" | "blindspot";
    priority: "blocker" | "risk" | "enhancement";
    content: string;
    source: string;
    impact: string;
  };
  onClick?: () => void;
}
```

**Design:**

text

```
┌─────────────────────────────────────────────────────┐
│ ⚠️ Models disagreed                    ← type label │
│                                                     │
│ [content text]                                      │
│                                                     │
│ → [impact text]                                     │
│                                                     │
│ Source: [source]                              [→]   │
└─────────────────────────────────────────────────────┘
```

**Type labels:**

|Type|Icon|Label|
|---|---|---|
|divergence|⚠️|"Models disagreed"|
|overclaim|⚠️|"May be overstated"|
|gap|💡|"Context dropped"|
|blindspot|🕳|"Not addressed"|

**Priority colors:**

|Priority|Background|Border|
|---|---|---|
|blocker|Red subtle|Red|
|risk|Amber subtle|Amber|
|enhancement|Blue subtle|Blue|

**CSS:**

CSS

```
.signal-card {
  padding: 12px 16px;
  border-radius: 6px;
  border-left: 3px solid;
  cursor: pointer;
}

.signal-card--blocker {
  background: var(--red-subtle);
  border-color: var(--red);
}

.signal-card--risk {
  background: var(--amber-subtle);
  border-color: var(--amber);
}

.signal-card--enhancement {
  background: var(--blue-subtle);
  border-color: var(--blue);
}

.signal-card-type {
  font-weight: 500;
  font-size: 13px;
  margin-bottom: 8px;
}

.signal-card-content {
  font-size: 14px;
  margin-bottom: 8px;
}

.signal-card-impact {
  font-size: 13px;
  color: var(--text-secondary);
  margin-bottom: 8px;
}

.signal-card-source {
  font-size: 12px;
  color: var(--text-tertiary);
  display: flex;
  justify-content: space-between;
}
```

**Behavior:**

- Click → Opens split pane to source model (if source is specific model)
- Click → Scrolls to relevant section (if source is "all" or "none")

---

## Part 7: ReframeBanner Updates

Update existing ReframingBanner to use new prop structure.

**Old props:**

TypeScript

```
{
  issue: string;
  betterQuestion: string;  // OLD
  unlocks: string;
}
```

**New props:**

TypeScript

```
{
  issue: string;
  suggestion: string;  // NEW - renamed
  unlocks: string;
}
```

**Change:** Rename `betterQuestion` to `suggestion` throughout component.

**Location:** Above blocker banner (very top of synthesis bubble if present)

---

## Part 8: Parser Updates double check old signals no changes, add new

Update the refiner output parser to extract new structure.

**Keep:** Dual-mode parsing (JSON detection + freeform text extraction)

**New fields to extract:**

|Field|Type|Required|
|---|---|---|
|signals|Array|Yes (can be empty)|
|signals[].type|String|Yes|
|signals[].priority|String|Yes|
|signals[].content|String|Yes|
|signals[].source|String|Yes|
|signals[].impact|String|Yes|
|unlistedOptions|Array|Yes (can be empty)|
|nextStep|Object|Yes|
|nextStep.action|String|Yes|
|nextStep.target|String|Yes|
|nextStep.why|String|Yes|
|reframe|Object or null|Yes|
|meta|Object|Yes|
|meta.reliabilitySummary|String|Yes|
|meta.biggestRisk|String|Yes|
|meta.strategicPattern|String or null|Yes|
|meta.honestAssessment|String|Yes|

---

## Part 9: Remove/Update Existing Components

### Remove

|Component|Reason|
|---|---|

|Invisible strip click in council orbs|Replaced by explicit map button|

### Update

|Component|Change|
|---|---|
|ReframingBanner|Rename prop `betterQuestion` → `suggestion`|
|TrustSignalsPanel|New structure with signals + meta sections| 
|Council orbs decision map new icon|Move from bottom to between short/long answer|

---

## Part 10: Loading States

|Element|Loading State|
|---|---|
|Trust badge|Subtle pulse animation, no count|
|Blocker banner|Not shown until refiner completes|
|NextStepFooter|`→ ...` placeholder|
|Trust panel|"Analyzing..." in Refiner's Take section|
|SignalCards|Not shown until refiner completes|

---

## Summary

|Create|Purpose|
|---|---|

|Trust badge logic|Shows risk/blocker count on trust icon|

|Update|Change|
|---|---|
|
Add map button, update trust icon with badge|
|Trust panel|Add Risks, Additional Context, Refiner's Take sections|
|ReframeBanner|Rename prop|
|Parser|New output structure|

|Remove|Reason|
|---|---|
|Invisible strip click|Replaced by button|


================================================
FILE: docs/contributing.md
================================================
# Contributing & Extensions

## 1. Adding a New Provider

1. **Create adapter** (`src/providers/newprovider-adapter.js`):

```javascript
export class NewProviderAdapter {
  async sendPrompt(request, onPartial, signal) {
    const response = await fetch("https://api.newprovider.com/chat", {
      method: "POST",
      signal,
      body: JSON.stringify({ message: request.originalPrompt }),
    });

    const reader = response.body.getReader();
    let fullText = "";

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = new TextDecoder().decode(value);
      fullText += chunk;
      onPartial({ text: chunk });
    }

    return {
      text: fullText,
      meta: { conversationId: response.headers.get("X-Conversation-Id") },
    };
  }
}
```

2. **Register in service worker** (`sw-entry.js`):

```javascript
import { NewProviderAdapter } from "./providers/newprovider-adapter.js";

providerRegistry.register(
  "newprovider",
  new NewProviderController(),
  new NewProviderAdapter(),
);
```

3. **Add UI config** (`ui/constants.ts`):

```typescript
export const LLM_PROVIDERS_CONFIG: LLMProvider[] = [
  // ... existing providers
  {
    id: "newprovider",
    name: "New Provider",
    color: "#ff6b6b",
    emoji: "🆕",
  },
];
```

## 2. Adding a New Workflow Primitive

Example: Add `regenerate` primitive to re-run the last turn with different settings.

1. **Define contract** (`shared/contract.ts`):

```typescript
interface RegenerateRequest {
  type: "regenerate";
  sessionId: string;
  providers: ProviderKey[];
  includeMapping: boolean;
  includeSynthesis: boolean;
}

export type PrimitiveWorkflowRequest =
  | InitializeRequest
  | ExtendRequest
  | RecomputeRequest
  | RegenerateRequest; // ← Add here
```

2. **Add resolver logic** (`context-resolver.js`):

```javascript
async resolve(request) {
  if (request.type === 'regenerate') {
    const session = await this.sessionManager.adapter.get('sessions', request.sessionId);
    const lastAiTurn = await this.sessionManager.adapter.get('turns', session.lastTurnId);
    const userTurn = await this.sessionManager.adapter.get('turns', lastAiTurn.userTurnId);

    return {
      type: 'regenerate',
      sessionId: request.sessionId,
      lastUserMessage: userTurn.text,
      providerContexts: {} // Fresh contexts
    };
  }
}
```

3. **Add compiler logic** (`workflow-compiler.js`):

```javascript
compile(request, resolvedContext) {
  if (request.type === 'regenerate') {
    return {
      workflowId: `wf-${Date.now()}`,
      context: { sessionId: request.sessionId },
      steps: [{
        stepId: `batch-${Date.now()}`,
        type: 'prompt',
        payload: {
          prompt: resolvedContext.lastUserMessage,
          providers: request.providers
        }
      }]
    };
  }
}
```

4. **Add UI action** (`ui/hooks/useChat.ts`):

```typescript
const regenerate = useCallback(async () => {
  const request: RegenerateRequest = {
    type: "regenerate",
    sessionId: currentSessionId!,
    providers: activeProviders,
    includeMapping: mappingEnabled,
    includeSynthesis: !!synthesisProvider,
  };

  await api.executeWorkflow(request);
}, [currentSessionId, activeProviders]);
```



================================================
FILE: docs/debugging.md
================================================
# Debugging Guide

## 1. Message Flow Tracing

**Enable debug logs:**

```typescript
// In usePortMessageHandler.ts
const STREAMING_DEBUG_UI = true; // See every PARTIAL_RESULT

// In workflow-engine.js
const STREAMING_DEBUG = true; // See backend streaming deltas
```

**Expected message sequence for a normal prompt:**

1. `TURN_CREATED` (once)
2. `PARTIAL_RESULT` (hundreds of times)
3. `WORKFLOW_STEP_UPDATE` {status:'completed', stepId:'batch-...'} (once per provider)
4. `WORKFLOW_STEP_UPDATE` {status:'completed', stepId:'mapping-...'} (if requested)
5. `WORKFLOW_STEP_UPDATE` {status:'completed', stepId:'synthesis-...'} (if requested)
6. `WORKFLOW_COMPLETE` (once)
7. `TURN_FINALIZED` (once)

**If you see:**

- **No TURN_CREATED**: Connection handler rejected the request (check primitive validation)
- **PARTIAL_RESULT but no completion**: Orchestrator is stuck (check provider adapter errors)
- **WORKFLOW_COMPLETE but no TURN_FINALIZED**: Persistence failed (check IndexedDB errors)
- **"Generating..." never stops**: UI missed a completion message (check stepId parsing)

## 2. State Inspection

**In browser DevTools console:**

```javascript
// Inspect current UI state
window.__JOTAI_STORE__ = jotaiStore;
const turnsMap = jotaiStore.get(turnsMapAtom);
const turnIds = jotaiStore.get(turnIdsAtom);
console.log("Turns:", Array.from(turnsMap.entries()));

// Inspect backend state
chrome.runtime.sendMessage({ type: "GET_HEALTH_STATUS" }, (response) => {
  console.log("Backend health:", response);
});

// Check persistence layer
const db = await window.indexedDB.open("HTOSPersistenceDB", 1);
const tx = db.transaction(["turns"], "readonly");
const turns = await tx.objectStore("turns").getAll();
console.log("Persisted turns:", turns);
```

## 3. Common Issues

**Issue: "Synthesis generating..." never completes**

**Root cause:** UI is checking `status === 'pending'` but backend sent `status === 'streaming'`.

**Fix:** Normalize status checks:
```typescript
const isGenerating = ["pending", "streaming"].includes(latest?.status);
```

---

**Issue: Recompute shows "No synthesis yet"**

**Root cause:** `activeRecomputeState.providerId` doesn't match `activeSynthesisClipProviderId`.

**Fix:** Ensure recompute target check uses `||` logic:
```typescript
const isSynthesisTarget = !!(
  activeRecomputeState &&
  activeRecomputeState.aiTurnId === aiTurn.id &&
  activeRecomputeState.stepType === "synthesis" &&
  (!activeSynthPid || activeRecomputeState.providerId === activeSynthPid)
);
```

---

**Issue: "All providers failed" but one succeeded**

**Root cause:** Backend `executePromptStep` checks `hasAnyValidResults` incorrectly.

**Fix:** Ensure validation checks `text.trim().length > 0`:
```javascript
const hasAnyValidResults = Object.values(formattedResults).some(
  (r) => r.status === "completed" && r.text && r.text.trim().length > 0,
);
```

---

**Issue: Continuation request fails with "Missing context"**

**Root cause:** `provider_contexts` store is stale or empty.

**Debug:**
```javascript
// Check live contexts
const contexts = await db
  .transaction(["provider_contexts"])
  .objectStore("provider_contexts")
  .getAll();
console.log("Live contexts:", contexts);

// Force refresh
await sessionManager.updateProviderContextsBatch(sessionId, results, true);
```



================================================
FILE: docs/dnr-utils.md
================================================
# HTOS Core DNR Utilities

This document details the core utilities for managing Chrome's Declarative Net Request (DNR) API within the extension.

## Overview

The DNR utilities provide a robust, session-aware system for managing network request modifications, particularly for Arkose Enforcement (AE) header injection. The system handles service worker restarts, rule persistence, and provides debugging capabilities.

## Architecture

### Key Components

- **`dnr-utils.js`** - Core DNR utility class with header modification methods
- **`NetRulesManager.js`** - High-level network rules management with ArkoseController
- **`dnr-auditor.js`** - Debugging and audit functionality

### Design Principles

1. **DNR First** - All network modifications use declarative rules, not runtime interception
2. **Session Persistence** - Rules survive service worker restarts via chrome.storage.local
3. **Provider Scoping** - Rules are tagged by provider (chatgpt, claude, etc.) for easy cleanup
4. **Temporary Rules** - Support for time-limited rules with automatic cleanup
5. **Debug Support** - Built-in debugging via chrome.declarativeNetRequest.onRuleMatchedDebug

## API Reference

### DNRUtils Class

#### Static Methods

##### `initialize()`

Initializes the DNR utility system and restores persisted rules.

```javascript
await DNRUtils.initialize();
```

##### `registerHeaderRule(options)`

Registers a header modification rule with comprehensive options.

**Parameters:**

- `options.urlFilter` (string) - URL pattern to match (required)
- `options.headers` (object) - Headers to add/modify (required)
- `options.provider` (string) - Provider identifier for scoping
- `options.tabId` (number) - Limit rule to specific tab
- `options.duration` (number) - Auto-expire after milliseconds
- `options.priority` (number) - Rule priority (default: 1)
- `options.resourceTypes` (array) - Resource types to match (default: ['xmlhttprequest'])

**Returns:** Promise<string> - Rule ID

```javascript
const ruleId = await DNRUtils.registerHeaderRule({
  urlFilter: "https://chatgpt.com/*",
  headers: {
    "Openai-Sentinel-Chat-Requirements-Token": "token123",
    "Openai-Sentinel-Proof-Token": "proof456",
  },
  provider: "chatgpt",
  duration: 300000, // 5 minutes
});
```

##### `registerTemporaryHeaderRule(options, duration)`

Convenience method for temporary header rules.

```javascript
const ruleId = await DNRUtils.registerTemporaryHeaderRule(
  {
    urlFilter: "https://claude.ai/*",
    headers: { Authorization: "Bearer token" },
    provider: "claude",
  },
  60000,
); // 1 minute
```

##### `removeRule(ruleId)`

Removes a specific rule by ID.

```javascript
await DNRUtils.removeRule(ruleId);
```

##### `removeProviderRules(provider)`

Removes all rules associated with a provider.

```javascript
await DNRUtils.removeProviderRules("chatgpt");
```

##### `getActiveRules()`

Retrieves all active rules (dynamic and session).

```javascript
const rules = await DNRUtils.getActiveRules();
console.log("Active rules:", rules);
```

#### Debug Methods

##### `enableDebugMode()`

Enables debug logging for rule matches.

```javascript
DNRUtils.enableDebugMode();
```

##### `disableDebugMode()`

Disables debug logging.

```javascript
DNRUtils.disableDebugMode();
```

#### Cleanup Methods

##### `startPeriodicCleanup(intervalMs)`

Starts automatic cleanup of expired rules.

```javascript
DNRUtils.startPeriodicCleanup(60000); // Check every minute
```

##### `stopPeriodicCleanup()`

Stops automatic cleanup.

```javascript
DNRUtils.stopPeriodicCleanup();
```

### ArkoseController (NetRulesManager.js)

#### Methods

##### `injectAEHeaders(options)`

High-level method for AE header injection.

**Parameters:**

- `options.urlFilter` (string) - URL pattern to match
- `options.headers` (object) - AE headers to inject
- `options.provider` (string) - Provider identifier
- `options.duration` (number) - Rule duration in milliseconds

```javascript
await ArkoseController.injectAEHeaders({
  urlFilter: "https://chatgpt.com/*",
  headers: {
    "Openai-Sentinel-Chat-Requirements-Token": sentinelToken,
    "Openai-Sentinel-Proof-Token": powToken,
    "Openai-Sentinel-Arkose-Token": arkoseToken,
  },
  provider: "chatgpt",
  duration: 300000,
});
```

##### `removeAEHeaderRule(ruleId)`

Removes a specific AE header rule.

```javascript
await ArkoseController.removeAEHeaderRule(ruleId);
```

##### `removeAllAEHeaderRules(provider)`

Removes all AE header rules for a provider.

```javascript
await ArkoseController.removeAllAEHeaderRules("chatgpt");
```

## Usage Examples

### Basic Header Injection

```javascript
import { DNRUtils } from "./dnr-utils.js";

// Initialize the system
await DNRUtils.initialize();

// Inject authentication headers
const ruleId = await DNRUtils.registerHeaderRule({
  urlFilter: "https://api.example.com/*",
  headers: {
    Authorization: "Bearer " + token,
    "X-API-Key": apiKey,
  },
  provider: "example-provider",
  duration: 3600000, // 1 hour
});

// Later, remove the rule
await DNRUtils.removeRule(ruleId);
```

### Provider-Scoped Management

```javascript
// Add multiple rules for a provider
const rule1 = await DNRUtils.registerHeaderRule({
  urlFilter: "https://chatgpt.com/backend-api/*",
  headers: { "X-Custom-Header": "value1" },
  provider: "chatgpt",
});

const rule2 = await DNRUtils.registerHeaderRule({
  urlFilter: "https://chatgpt.com/api/*",
  headers: { "X-Another-Header": "value2" },
  provider: "chatgpt",
});

// Remove all rules for the provider at once
await DNRUtils.removeProviderRules("chatgpt");
```

### Tab-Specific Rules

```javascript
// Inject headers only for a specific tab
const ruleId = await DNRUtils.registerHeaderRule({
  urlFilter: "https://example.com/*",
  headers: { "X-Tab-Specific": "true" },
  tabId: 123,
  provider: "tab-provider",
});
```

### Automatic Cleanup

```javascript
// Start periodic cleanup (recommended in service worker)
DNRUtils.startPeriodicCleanup(300000); // Check every 5 minutes

// Register temporary rules that will be cleaned up automatically
const ruleId = await DNRUtils.registerTemporaryHeaderRule(
  {
    urlFilter: "https://temp.example.com/*",
    headers: { "X-Temporary": "true" },
    provider: "temp-provider",
  },
  60000,
); // Expires in 1 minute
```



================================================
FILE: docs/flows.md
================================================
# Critical Flows

## 1. User Sends First Message (Initialize)

**Actors:** User, UI, ConnectionHandler, ContextResolver, Compiler, WorkflowEngine, Orchestrator, SessionManager

```mermaid
sequenceDiagram
    participant User
    participant UI
    participant CH as ConnectionHandler
    participant CR as ContextResolver
    participant Compiler
    participant Engine as WorkflowEngine
    participant Orch as Orchestrator
    participant SM as SessionManager

    User->>UI: Types "Hello" + clicks Send
    UI->>UI: Create optimistic UserTurn
    UI->>UI: Add to turnsMap + turnIds
    UI->>CH: ExtendRequest{type:'initialize', userMessage:'Hello'}

    CH->>CR: resolve(request)
    CR->>CR: type='initialize' â†’ return empty context
    CR-->>CH: ResolvedContext{type:'initialize'}

    CH->>Compiler: compile(request, context)
    Compiler->>Compiler: Generate [promptStep]
    Compiler-->>CH: WorkflowRequest{steps:[...]}

    CH->>UI: TURN_CREATED{userTurnId, aiTurnId, sessionId}
    UI->>UI: Create optimistic AiTurn with meta.requestedFeatures
    UI->>UI: Add aiTurn to turnsMap + turnIds

    CH->>Engine: execute(workflowRequest)

    Engine->>Orch: executeParallelFanout('Hello', [claude,gemini])

    loop For each provider
        Orch->>Provider: POST /chat {message:'Hello'}
        Provider-->>Orch: Stream chunk
        Orch->>Engine: onPartial(providerId, chunk)
        Engine->>UI: PARTIAL_RESULT{providerId, chunk.text}
        UI->>UI: streamingBuffer.addDelta()
        UI->>UI: Batch update turnsMap (16ms)
    end

    Orch-->>Engine: onAllComplete(results)
    Engine->>UI: WORKFLOW_STEP_UPDATE{stepId:'batch-123', status:'completed'}
    UI->>UI: Mark batchResponses as completed

    Engine->>SM: persist(request, context, results)
    SM->>DB: Write SessionRecord
    SM->>DB: Write UserTurnRecord
    SM->>DB: Write AiTurnRecord
    SM->>DB: Write ProviderResponseRecords
    SM->>DB: Write ProviderContextRecords (live index)
    SM-->>Engine: Persist complete

    Engine->>UI: TURN_FINALIZED{turn:{user, ai}}
    UI->>UI: Merge canonical data into turnsMap
    UI->>UI: Set meta.isOptimistic = false
    UI->>UI: setIsLoading(false)
```

## 2. User Re-runs Synthesis with Different Model (Recompute)

**Actors:** User, UI, ConnectionHandler, ContextResolver, Compiler, WorkflowEngine, Orchestrator, SessionManager

```mermaid
sequenceDiagram
    participant User
    participant UI
    participant CH as ConnectionHandler
    participant CR as ContextResolver
    participant Compiler
    participant Engine as WorkflowEngine
    participant Orch as Orchestrator
    participant SM as SessionManager

    User->>UI: Clicks "gemini" clip on historical turn
    UI->>UI: setActiveRecomputeState({aiTurnId, stepType:'synthesis', providerId:'gemini'})
    UI->>CH: RecomputeRequest{sourceTurnId, stepType:'synthesis', targetProvider:'gemini'}

    CH->>CR: resolve(request)
    CR->>DB: get('turns', sourceTurnId) â†’ AiTurnRecord
    CR->>DB: get('turns', aiTurn.userTurnId) â†’ UserTurnRecord
    CR->>DB: getByIndex('provider_responses', 'byAiTurnId', sourceTurnId)
    CR->>CR: Build frozenBatchOutputs from responses
    CR->>CR: Find latestMappingOutput from responses
    CR->>CR: Extract providerContextsAtSourceTurn from AiTurnRecord
    CR-->>CH: ResolvedContext{type:'recompute', frozenBatchOutputs, ...}

    CH->>Compiler: compile(request, context)
    Compiler->>Compiler: Generate single synthesisStep with sourceHistorical
    Compiler-->>CH: WorkflowRequest{steps:[synthesisStep]}

    CH->>Engine: execute(workflowRequest)

    Engine->>Engine: resolveSourceData() â†’ use frozenBatchOutputs
    Engine->>Orch: executeParallelFanout(synthPrompt, ['gemini'])

    Orch->>Provider: POST /chat {message:synthPrompt}
    Provider-->>Orch: Stream chunk
    Orch->>Engine: onPartial('gemini', chunk)
    Engine->>UI: PARTIAL_RESULT{providerId:'gemini', chunk.text}
    UI->>UI: streamingBuffer.addDelta() on active turn

    Orch-->>Engine: onAllComplete(results)
    Engine->>UI: WORKFLOW_STEP_UPDATE{stepId:'synthesis-gemini-456', status:'completed'}
    UI->>UI: Add new synthesis response to synthesisResponses['gemini']

    Engine->>SM: persist(request, context, results)
    SM->>DB: Write NEW AiTurnRecord (linked to original userTurnId)
    SM->>DB: Write NEW ProviderResponseRecord
    SM->>DB: DO NOT update sessions.lastTurnId (historical branch)
    SM-->>Engine: Persist complete

    Engine->>UI: TURN_FINALIZED (no-op for recompute)
    UI->>UI: setActiveRecomputeState(null)
    UI->>UI: setIsLoading(false)
```

## 3. Provider Fails (Error Handling)

**Actors:** WorkflowEngine, Orchestrator, Provider, UI

```mermaid
sequenceDiagram
    participant Engine as WorkflowEngine
    participant Orch as Orchestrator
    participant Provider
    participant UI

    Engine->>Orch: executeParallelFanout('prompt', [claude,gemini])

    Orch->>Provider: POST /chat (claude)
    Provider-->>Orch: Stream chunks âœ“

    Orch->>Provider: POST /chat (gemini)
    Provider-->>Orch: 503 Overloaded âœ—

    Orch->>Orch: Catch error for gemini
    Orch->>Orch: Create error result {providerId:'gemini', status:'error'}

    Orch-->>Engine: onAllComplete(results={claude:âœ“, gemini:âœ—})

    alt At least one success
        Engine->>UI: WORKFLOW_STEP_UPDATE{status:'completed', stepId:'batch-... ', result:{results:{claude:âœ“, gemini:âœ—}}}
        UI->>UI: Render claude success, render gemini error card
        Engine->>Engine: Continue to synthesis/mapping with claude only
    else All failed
        Engine->>UI: WORKFLOW_STEP_UPDATE{status:'failed', stepId:'batch-... ', error:'All providers failed'}
        Engine->>UI: WORKFLOW_COMPLETE{error:'A critical error occurred.'}
        UI->>UI: setIsLoading(false)
    end
```



================================================
FILE: docs/privacy.md
================================================
# Privacy & Security

## Core Principles

- **No secrets committed to code**: Keep credentials in environment variables or provider settings.
- **Data stays local**: Conversation history and state are stored locally in your browserâ€™s IndexedDB. No data is sent to a central server other than the AI providers you explicitly configure.
- **"Code is truth"**: We prioritize observed behavior and running systems over assumptions.

## Data Handling

- **API Keys**: Stored in local storage or session memory, never transmitted except to the provider API.
- **History**: Persisted in `HTOSPersistenceDB` (IndexedDB) within the browser extension sandbox.



================================================
FILE: docs/style-guide.md
================================================
# Singularity Style Guide & Assets

Official Singularity branding assets with sizing guidelines for the UI.

All assets are located in: `ui/assets/logos/`

---

## 📦 Available Assets

| Variant | Files | Use Case |
|---------|-------|----------|
| **Full Lockup** | `logo-full.svg/png` | Orb + "SINGULARITY AI" |
| **Wordmark** | `logo-name.svg/png` | "SINGULARITY AI" text only |
| **Icon** | `logo-icon.svg/png` | Orb only |

Each comes in **two sizes**:
- **Regular** (`logo-*.svg/png`) - ~512px, optimized
- **Large** (`logo-*-large.svg/png`) - ~1024px, high-res

**Prefer SVG** for UI elements (scales perfectly). Use PNG only for raster contexts.

---

## 🎯 Sizing Guide by Context

### 1. **Full Lockup** (Orb + "SINGULARITY AI")
*"This is the product" moment*

#### **Welcome / Empty State Screen**
```tsx
import logoFull from '../assets/logos/logo-full.svg';
<img src={logoFull} alt="Singularity AI" className="h-32 w-auto" />
// Size: 128px height (h-32)
```

#### **About / Settings Modal Header**
```tsx
<img src={logoFull} alt="Singularity AI" className="h-10 w-auto" />
// Size: 40px height (h-10)
```

#### **Marketing / Landing Page**
```tsx
<img src={logoFull} alt="Singularity AI" className="h-48 md:h-64 w-auto" />
// Size: 192-256px height (h-48 to h-64)
```

**Don't spam it** - Use sparingly for impact.

---

### 2. **Wordmark** ("SINGULARITY AI" text)
*Your everyday app identity*

#### **Top-Left App Bar** (Header)
```tsx
import logoName from '../assets/logos/logo-name.svg';

// Desktop - with small orb
<div className="flex items-center gap-2">
  <img src={logoIcon} alt="" className="h-5 w-5" />  {/* 20px orb */}
  <img src={logoName} alt="Singularity AI" className="h-6 w-auto" />  {/* 24px text */}
</div>

// Mobile/Compact - text only
<img src={logoName} alt="Singularity AI" className="h-5 w-auto" />
// Size: 20px height (h-5)
```

#### **Dialog / Modal Headers**
```tsx
<img src={logoName} alt="Singularity AI" className="h-4 w-auto opacity-60" />
// Size: 16px height (h-4), subtle
```

**Tip:** You can use just "Singularity" (drop "AI") in nav if cleaner. Keep full "SINGULARITY AI" for welcome/marketing.

---

### 3. **Icon Only** (Orb)
*Square / tiny / chrome-y contexts*

#### **Extension Manifest Icons**
Use PNG for extension icons (Chrome requirement):
```json
"icons": {
  "16": "icons/icon16.png",   // from logo-icon, resized
  "32": "icons/icon32.png",
  "48": "icons/icon48.png",
  "128": "icons/icon128.png"
}
```

#### **Favicon**
```html
<link rel="icon" href="/icons/icon16.png" />
```

#### **Collapsed Nav / Mobile**
```tsx
<img src={logoIcon} alt="Singularity" className="h-8 w-8" />
// Size: 32px square (h-8 w-8)
```

#### **Loading Spinner / Micro-Brand**
```tsx
<img src={logoIcon} alt="" className="h-6 w-6 animate-pulse" />
// Size: 24px square (h-6 w-6)
```

**Don't overuse** - Once or twice per view is enough.

---

## 💡 Integration Tips

### **Dark UI Compatibility**
Your teal/white orb pops nicely on dark backgrounds. Just ensure:
- ✅ Padding around logos (don't jam against edges)
- ✅ Don't place bright orb on bright highlight panels
- ✅ Use `opacity-60` or `opacity-80` for subtle branding moments

### **Font Matching**
If the wordmark uses a specific font/weight:
- Keep SVG wordmark as-is for the logo
- Match nav "Singularity" text weight/letter-spacing as closely as practical

### **Responsive Behavior**
```tsx
// Desktop
<img src={logoFull} className="h-10 w-auto" />

// Mobile - switch to icon only
<img src={logoIcon} className="h-8 w-8 md:hidden" />
<img src={logoFull} className="hidden md:block h-10 w-auto" />
```

---

## 📏 Quick Size Reference

| Context | Asset | Tailwind Class | Pixels |
|---------|-------|----------------|--------|
| Welcome hero | `logo-full.svg` | `h-32` | 128px |
| Header (desktop) | `logo-name.svg` | `h-6` | 24px |
| Header icon | `logo-icon.svg` | `h-5 w-5` | 20px |
| Modal header | `logo-name.svg` | `h-4` | 16px |
| Nav collapsed | `logo-icon.svg` | `h-8 w-8` | 32px |
| Loading spinner | `logo-icon.svg` | `h-6 w-6` | 24px |
| Extension icon | `icon*.png` | - | 16/32/48/128 |



================================================
FILE: scripts/analyze-bundle.js
================================================
const fs = require("fs");

// Check if we should save to file
const saveToFile = process.argv.includes("--save") || process.argv.includes("-save");

function formatBytes(bytes) {
    if (bytes === 0) return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${(bytes / Math.pow(k, i)).toFixed(2)} ${sizes[i]}`;
}

function analyzeMetafile(metaPath, bundleName) {
    if (!fs.existsSync(metaPath)) {
        return `\n${bundleName}: Metafile not found (Run 'npm run build:analyze' first)\n`;
    }

    const metafile = JSON.parse(fs.readFileSync(metaPath, "utf8"));
    let output = "";

    output += `\n${"=".repeat(80)}\n`;
    output += `${bundleName}\n`;
    output += `${"=".repeat(80)}\n\n`;

    // Analyze inputs
    const inputs = Object.entries(metafile.inputs)
        .map(([path, info]) => ({ path, bytes: info.bytes }))
        .sort((a, b) => b.bytes - a.bytes);

    const totalInputBytes = inputs.reduce((sum, i) => sum + i.bytes, 0);

    // Get outputs
    const outputs = Object.entries(metafile.outputs);
    const mainOutput = outputs.find(([_, info]) => !info.entryPoint) || outputs[0];
    const outputBytes = mainOutput ? mainOutput[1].bytes : 0;

    output += `Summary:\n`;
    output += `  Total Input:  ${formatBytes(totalInputBytes)}\n`;
    output += `  Bundle Size:  ${formatBytes(outputBytes)}\n`;
    output += `  Compression:  ${((outputBytes / totalInputBytes) * 100).toFixed(1)}%\n\n`;

    output += `Top 100 Largest Modules:\n`;
    output += `${"â”€".repeat(80)}\n`;

    inputs.slice(0, 100).forEach((item, idx) => {
        const percentage = ((item.bytes / totalInputBytes) * 100).toFixed(1);
        const sizeStr = formatBytes(item.bytes).padEnd(12);
        const pctStr = `${percentage}%`.padEnd(7);

        // Try to get line count
        let linesStr = "      ";
        try {
            if (fs.existsSync(item.path)) {
                const content = fs.readFileSync(item.path, "utf8");
                const lines = content.split("\n").length;
                linesStr = `${lines}L`.padEnd(6);
            }
        } catch (e) {
            // ignore errors
        }

        // Shorten path for readability
        let displayPath = item.path;
        if (displayPath.includes("node_modules")) {
            const parts = displayPath.split("node_modules/");
            displayPath = parts[parts.length - 1];
        } else if (displayPath.includes("ui/")) {
            displayPath = displayPath.substring(displayPath.indexOf("ui/"));
        } else if (displayPath.includes("src/")) {
            displayPath = displayPath.substring(displayPath.indexOf("src/"));
        }

        output += `${(idx + 1).toString().padStart(3)}. ${sizeStr} ${linesStr} (${pctStr}) ${displayPath}\n`;
    });

    // Find packages
    const pkgs = {};
    inputs.forEach((item) => {
        const match = item.path.match(/node_modules\/(@?[^\/]+(?:\/[^\/]+)?)/);
        if (match) {
            const pkg = match[1];
            if (!pkgs[pkg]) pkgs[pkg] = 0;
            pkgs[pkg] += item.bytes;
        }
    });

    const largestPkgs = Object.entries(pkgs)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15);

    if (largestPkgs.length > 0) {
        output += `\nTop 15 Heaviest Packages:\n`;
        output += `${"â”€".repeat(80)}\n`;
        largestPkgs.forEach(([pkg, bytes], idx) => {
            const sizeStr = formatBytes(bytes).padEnd(12);
            const percentage = ((bytes / totalInputBytes) * 100).toFixed(1);
            const pctStr = `${percentage}%`.padEnd(7);

            output += `${(idx + 1).toString().padStart(3)}. ${sizeStr} (${pctStr}) ${pkg}\n`;
        });
    }

    return output;
}

// Analyze all bundles
const bundles = [
    { file: "dist/analysis/meta-ui.json", name: "UI BUNDLE (Main Application)" },
    { file: "dist/analysis/meta-bg.json", name: "SERVICE WORKER BUNDLE" },
    { file: "dist/analysis/meta-cs-openai.json", name: "CONTENT SCRIPT BUNDLE" },
    { file: "dist/analysis/meta-offscreen.json", name: "OFFSCREEN BUNDLE" },
    { file: "dist/analysis/meta-oi.json", name: "OI BUNDLE" },
];

// Check for filter argument
const filterArg = process.argv.find(arg => !arg.startsWith("--") && !arg.includes("analyze-bundle.js") && !arg.includes("node.exe"));
const activeBundles = filterArg
    ? bundles.filter(b => b.name.toLowerCase().includes(filterArg.toLowerCase()))
    : bundles;

if (filterArg && activeBundles.length === 0) {
    console.log(`No bundles found matching filter: "${filterArg}"`);
    console.log("Available bundles:", bundles.map(b => b.name).join(", "));
    process.exit(0);
}

let fullReport = "";
fullReport += `\n${"=".repeat(80)}\n`;
fullReport += `BUNDLE SIZE ANALYSIS REPORT\n`;
fullReport += `Generated: ${new Date().toLocaleString()}\n`;
fullReport += `${"=".repeat(80)}\n`;

activeBundles.forEach((bundle) => {
    fullReport += analyzeMetafile(bundle.file, bundle.name);
});

fullReport += `\n${"=".repeat(80)}\n`;
fullReport += `RECOMMENDATIONS:\n`;
fullReport += `${"=".repeat(80)}\n`;
fullReport += `1. Focus on modules larger than 50 KB\n`;
fullReport += `2. Consider lazy loading for heavy features\n`;
fullReport += `3. Check if you're importing full libraries vs specific components\n`;
fullReport += `4. Use dynamic imports for code splitting\n`;
fullReport += `5. Review if all imported packages are actually used\n`;
fullReport += `\nFor interactive visualization: npm run analyze:ui\n`;
fullReport += `${"=".repeat(80)}\n\n`;

// Output results
if (saveToFile) {
    fs.writeFileSync("bundle-analysis-report.txt", fullReport, "utf8");
    console.log("âœ“ Report saved to: bundle-analysis-report.txt\n");
} else {
    console.log(fullReport);
}



================================================
FILE: scripts/build-common.js
================================================
const esbuild = require("esbuild");

/**
 * Shared build function for all bundles
 * @param {boolean} isProduction - Whether to build for production
 * @param {boolean} generateMeta - Whether to generate metafiles for analysis
 */
async function buildAll(isProduction = false, generateMeta = false) {
    const mode = isProduction ? "production" : "development";
    console.log(`\nðŸ”¨ Building in ${mode.toUpperCase()} mode${generateMeta ? " with analysis" : ""}...\n`);

    const commonOptions = {
        bundle: true,
        platform: "browser",
        target: "chrome110",
        logLevel: "info",
        legalComments: "none",
        metafile: generateMeta,
        ...(isProduction && {
            define: {
                "process.env.NODE_ENV": '"production"',
            },
            minify: true,
            drop: ["console", "debugger"],
        }),
    };

    const results = [];

    // Build service worker
    console.log("Building bg.js...");
    const swResult = await esbuild.build({
        ...commonOptions,
        entryPoints: ["src/sw-entry.js"],
        format: "iife",
        outfile: "dist/bg.js",
    });
    results.push({ name: "bg", result: swResult });

    // Build content script
    console.log("Building cs-openai.js...");
    const csResult = await esbuild.build({
        ...commonOptions,
        entryPoints: ["src/cs-openai.js"],
        format: "iife",
        outfile: "dist/cs-openai.js",
    });
    results.push({ name: "cs-openai", result: csResult });

    // Build offscreen
    console.log("Building offscreen.js...");
    const offscreenResult = await esbuild.build({
        ...commonOptions,
        entryPoints: ["src/offscreen-entry.js"],
        format: "esm",
        outfile: "dist/offscreen.js",
    });
    results.push({ name: "offscreen", result: offscreenResult });

    // Build oi
    console.log("Building oi.js...");
    const oiResult = await esbuild.build({
        ...commonOptions,
        entryPoints: ["src/oi.js"],
        format: "iife",
        outfile: "dist/oi.js",
    });
    results.push({ name: "oi", result: oiResult });

    // Build UI
    console.log("Building ui/index.js...");
    const uiResult = await esbuild.build({
        ...commonOptions,
        entryPoints: ["ui/index.tsx"],
        format: "esm",
        splitting: true,
        outdir: "dist/ui",
        loader: { ".ts": "ts", ".tsx": "tsx", ".svg": "file", ".png": "file", ".jpg": "file", ".jpeg": "file" },
        assetNames: "[name]",  // Remove hashes from asset filenames for stable Chrome extension paths
        publicPath: "/ui/",    // Ensure CSS references assets relative to extension root
        jsx: "automatic",
    });
    results.push({ name: "ui", result: uiResult });

    return results;
}

module.exports = { buildAll };



================================================
FILE: scripts/build-dev.js
================================================
const { buildAll } = require("./build-common");

async function buildDev() {
    try {
        await buildAll(false, false); // Development mode, no metafiles
        console.log("\n✅ Development build complete!");
        console.log("📝 Includes helpful error messages and debugging tools");
    } catch (err) {
        console.error("Build failed:", err);
        process.exit(1);
    }
}

buildDev();



================================================
FILE: scripts/build-prod.js
================================================
const { buildAll } = require("./build-common");
const fs = require("fs");

function formatBytes(bytes) {
    return (bytes / 1024).toFixed(2) + " KB";
}

async function buildProd() {
    try {
        const results = await buildAll(true, false); // Production mode, no metafiles

        console.log("\nâœ… Production build complete!");
        console.log("ðŸš€ Optimized and minified for deployment");
        console.log("\nBundle sizes:");

        // Show bundle sizes
        const files = [
            { path: "dist/bg.js", name: "Service Worker" },
            { path: "dist/cs-openai.js", name: "Content Script" },
            { path: "dist/offscreen.js", name: "Offscreen" },
            { path: "dist/oi.js", name: "OI Bundle" },
            { path: "dist/ui/index.js", name: "UI Bundle" },
        ];

        files.forEach(({ path, name }) => {
            if (fs.existsSync(path)) {
                const size = fs.statSync(path).size;
                console.log(`  ${name.padEnd(20)} ${formatBytes(size)}`);
            }
        });
    } catch (err) {
        console.error("Build failed:", err);
        process.exit(1);
    }
}

buildProd();



================================================
FILE: scripts/build-with-analysis.js
================================================
const { buildAll } = require("./build-common");
const fs = require("fs");

async function buildWithMeta() {
    console.log("Building with metafile generation for analysis...\n");

    // Ensure analysis directory exists
    fs.mkdirSync("dist/analysis", { recursive: true });

    // Build with production optimizations and metafiles
    const results = await buildAll(true, true);

    // Save metafiles
    results.forEach(({ name, result }) => {
        if (result.metafile) {
            const metaPath = `dist/analysis/meta-${name}.json`;
            fs.writeFileSync(metaPath, JSON.stringify(result.metafile));
            console.log(`âœ“ Saved metafile: ${metaPath}`);
        }
    });

    console.log("\nðŸ“Š Metafiles saved to dist/analysis/");
    console.log("Run 'npm run analyze:text' to visualize bundle composition");
}

buildWithMeta().catch((err) => {
    console.error(err);
    process.exit(1);
});



================================================
FILE: scripts/postbuild.js
================================================
const fs = require("fs");
const p = require("path");

// ensure dirs
fs.mkdirSync("dist/ui", { recursive: true });
fs.mkdirSync("dist/icons", { recursive: true });

// NOTE: main-world-injector.js is now built by esbuild into dist/main-world-injector.js

// copy manifest
fs.copyFileSync("manifest.json", "dist/manifest.json");

// copy & tweak UI html
if (fs.existsSync("ui/index.html")) {
  let html = fs.readFileSync("ui/index.html", "utf8");
  html = html
    .replace("index.tsx", "index.js")
    .replace("/icons/icon-16.png", "/icons/icon16.png");
  fs.writeFileSync("dist/ui/index.html", html);
}

// optional assets
if (fs.existsSync("ui/styles/index.css")) {
  fs.mkdirSync("dist/ui/styles", { recursive: true });
  fs.copyFileSync("ui/styles/index.css", "dist/ui/styles/index.css");
}
if (fs.existsSync("src/offscreen.html"))
  fs.copyFileSync("src/offscreen.html", "dist/offscreen.html");
if (fs.existsSync("src/offscreen.css"))
  fs.copyFileSync("src/offscreen.css", "dist/offscreen.css");
if (fs.existsSync("src/oi.html"))
  fs.copyFileSync("src/oi.html", "dist/oi.html");

// copy fonts
if (fs.existsSync("ui/fonts")) {
  fs.mkdirSync("dist/ui/fonts", { recursive: true });
  const fonts = fs.readdirSync("ui/fonts");
  for (const font of fonts) {
    fs.copyFileSync(p.join("ui/fonts", font), p.join("dist/ui/fonts", font));
  }
}

/// icons - copy all PNG icons for the extension  
const map = [
  ["icon-16.png", "icon16.png"],
  ["icon-32.png", "icon32.png"],
  ["icon-48.png", "icon48.png"],
  ["Icon-48.png", "icon48.png"],  // fallback for capitalized version
  ["icon-128.png", "icon128.png"],
  ["icon-192.png", "icon192.png"],
];
for (const [src, dst] of map) {
  if (fs.existsSync(src)) {
    fs.copyFileSync(src, p.join("dist/icons", dst));
    console.log(`[postbuild] Copied ${src} â†’ dist/icons/${dst}`);
  }
}



================================================
FILE: shared/artifact-processor.ts
================================================
/**
 * ArtifactProcessor - Provider-agnostic artifact extraction
 * 
 * Extracts rich content (SVG, HTML, Markdown) from AI responses and
 * separates them from the main text for specialized rendering.
 */

export interface Artifact {
    title: string;
    identifier: string;
    content: string;
    type: string; // MIME type: 'image/svg+xml', 'text/html', 'text/markdown'
}

export interface ProcessedResponse {
    cleanText: string;
    artifacts: Artifact[];
}

export class ArtifactProcessor {
    private artifactRegex = /<document\s+([^>]+)>([\s\S]*?)<\/document>/g;
    private attrRegex = /(\w+)=(?:"([^"]*)"|'([^']*)'|([^>\s]+))/g;

    /**
     * Process AI response text and extract artifacts
     * @param rawText - The full response text from the AI
     * @returns Processed response with clean text and extracted artifacts
     */
    process(rawText: string): ProcessedResponse {
        if (!rawText || typeof rawText !== 'string') {
            return { cleanText: '', artifacts: [] };
        }

        const artifacts: Artifact[] = [];

        // Extract all <document> tags
        let cleanText = rawText;
        let match: RegExpExecArray | null;

        while ((match = this.artifactRegex.exec(rawText)) !== null) {
            const [fullMatch, attrString, content] = match;

            // Parse attributes
            const attributes: Record<string, string> = {};
            let attrMatch: RegExpExecArray | null;

            // Reset regex for attribute parsing
            this.attrRegex.lastIndex = 0;
            while ((attrMatch = this.attrRegex.exec(attrString)) !== null) {
                const key = attrMatch[1];
                const value = attrMatch[2] || attrMatch[3] || attrMatch[4] || '';
                attributes[key] = value;
            }

            // Auto-detect type if missing (pass identifier for filename-based detection)
            const identifier = attributes.identifier || `artifact-${Date.now()}`;
            let type = attributes.type || this.detectType(content, identifier);

            artifacts.push({
                title: attributes.title || 'Untitled Artifact',
                identifier: identifier,
                content: content.trim(),
                type: type,
            });

            // Remove artifact from main text
            cleanText = cleanText.replace(fullMatch, '');
        }

        return {
            cleanText: cleanText.trim(),
            artifacts,
        };
    }

    /**
     * Auto-detect artifact type from content and identifier
     * Supports both Claude's type attribute and Gemini's filename-based identifiers
     */
    private detectType(content: string, identifier?: string): string {
        // 1. Check identifier extension (Gemini pattern)
        if (identifier) {
            const ext = identifier.toLowerCase();
            if (ext.endsWith('.md')) return 'text/markdown';
            if (ext.endsWith('.svg')) return 'image/svg+xml';
            if (ext.endsWith('.html') || ext.endsWith('.htm')) return 'text/html';
            if (ext.endsWith('.py')) return 'text/x-python';
            if (ext.endsWith('.js')) return 'application/javascript';
            if (ext.endsWith('.json')) return 'application/json';
            if (ext.endsWith('.xml')) return 'application/xml';
            if (ext.endsWith('.css')) return 'text/css';
        }

        // 2. Check content signature (Claude pattern)
        const trimmed = content.trim();

        if (trimmed.startsWith('<svg')) {
            return 'image/svg+xml';
        }
        if (trimmed.startsWith('<!DOCTYPE html') || trimmed.includes('<html')) {
            return 'text/html';
        }
        if (trimmed.startsWith('```')) {
            return 'text/markdown';
        }

        return 'text/plain';
    }

    /**
     * Format a single artifact into the <document> XML format
     */
    formatArtifact(artifact: { title: string; identifier: string; content: string }): string {
        return `\n\n<document title="${artifact.title}" identifier="${artifact.identifier}">\n${artifact.content}\n</document>`;
    }

    /**
     * Inject images into text by replacing placeholders or appending
     * @param text - The text containing placeholders like [Image of Title]
     * @param images - Array of image objects { url, title }
     */
    injectImages(text: string, images: Array<{ url: string; title: string }>): string {
        if (!text || !images || images.length === 0) return text;

        let newText = text;
        images.forEach((img) => {
            // Pattern: [Image of Title]
            // We escape the title for regex safety
            const escapedTitle = img.title.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const pattern = new RegExp(`\\[Image of ${escapedTitle}\\]`, 'g');

            const markdownImage = `![${img.title}](${img.url})`;

            // If the placeholder exists, replace it
            if (pattern.test(newText)) {
                newText = newText.replace(pattern, markdownImage);
            } else {
                // If placeholder not found, append to bottom
                newText += `\n\n${markdownImage}`;
            }
        });

        return newText;
    }
}



================================================
FILE: shared/contract.ts
================================================
// ============================================================================
// CORE TYPES & ENUMS
// ============================================================================
export type ProviderKey =
  | "claude"
  | "gemini"
  | "gemini-pro"
  | "chatgpt"
  | "qwen";
export type WorkflowStepType = "prompt" | "synthesis" | "mapping" | "refiner" | "antagonist";
export type SynthesisStrategy = "continuation" | "fresh";

// ============================================================================
// SECTION 1: WORKFLOW PRIMITIVES (UI -> BACKEND)
// These are the three fundamental requests the UI can send to the backend.
// ============================================================================

export type PrimitiveWorkflowRequest =
  | InitializeRequest
  | ExtendRequest
  | RecomputeRequest;

/**
 * Starts a new conversation thread.
 */
export interface InitializeRequest {
  type: "initialize";
  sessionId?: string | null; // Optional: can be omitted to let the backend create a new session.
  userMessage: string;
  providers: ProviderKey[];
  includeMapping: boolean;
  includeSynthesis: boolean;
  includeRefiner?: boolean;
  includeAntagonist?: boolean;
  synthesizer?: ProviderKey;
  mapper?: ProviderKey;
  refiner?: ProviderKey;
  antagonist?: ProviderKey;
  useThinking?: boolean;
  providerMeta?: Partial<Record<ProviderKey, any>>;
  clientUserTurnId?: string; // Optional: client-side provisional ID for the user's turn.
}

/**
 * Continues an existing conversation with a new user message.
 */
export interface ExtendRequest {
  type: "extend";
  sessionId: string;
  userMessage: string;
  providers: ProviderKey[];
  forcedContextReset?: ProviderKey[]; // Optional: Explicitly force new context for specific providers
  includeMapping: boolean;
  includeSynthesis: boolean;
  synthesizer?: ProviderKey;
  mapper?: ProviderKey;
  refiner?: ProviderKey;
  antagonist?: ProviderKey;
  includeRefiner?: boolean;
  includeAntagonist?: boolean;
  useThinking?: boolean;
  providerMeta?: Partial<Record<ProviderKey, any>>;
  clientUserTurnId?: string; // Optional: client-side provisional ID for the user's turn.
}

/**
 * Re-runs a synthesis or mapping step for a historical turn with a different provider.
 */
export interface RecomputeRequest {
  type: "recompute";
  sessionId: string;
  sourceTurnId: string;
  stepType: "synthesis" | "mapping" | "batch" | "refiner" | "antagonist";
  targetProvider: ProviderKey;
  userMessage?: string;
  useThinking?: boolean;
}

// ============================================================================
// SECTION 2: COMPILED WORKFLOW (BACKEND-INTERNAL)
// These are the low-level, imperative steps produced by the WorkflowCompiler.
// ============================================================================

export interface PromptStepPayload {
  prompt: string;
  providers: ProviderKey[];
  providerContexts?: Record<
    ProviderKey,
    { meta: any; continueThread: boolean }
  >;
  providerMeta?: Partial<Record<ProviderKey, any>>;
  useThinking?: boolean;
}

export interface SynthesisStepPayload {
  synthesisProvider: ProviderKey;
  strategy: SynthesisStrategy;
  sourceStepIds?: string[];
  sourceHistorical?: {
    turnId: string;
    responseType: "batch" | "synthesis" | "mapping";
  };
  originalPrompt: string;
  useThinking?: boolean;
  continueConversationId?: string;
  attemptNumber?: number;
  preferredMappingProvider?: ProviderKey;
}

export interface MappingStepPayload
  extends Omit<SynthesisStepPayload, "synthesisProvider"> {
  mappingProvider: ProviderKey;
}

export interface RefinerStepPayload {
  refinerProvider: ProviderKey;
  sourceStepIds?: string[];
  synthesisStepIds?: string[];
  mappingStepIds?: string[];
  sourceHistorical?: {
    turnId: string;
    responseType: string;
  };
  originalPrompt: string;
}

export interface AntagonistStepPayload {
  antagonistProvider: ProviderKey;
  sourceStepIds?: string[];
  synthesisStepIds?: string[];
  mappingStepIds?: string[];
  refinerStepIds?: string[];
  sourceHistorical?: {
    turnId: string;
    responseType: string;
  };
  originalPrompt: string;
}

export interface WorkflowStep {
  stepId: string;
  type: WorkflowStepType;
  payload: PromptStepPayload | SynthesisStepPayload | MappingStepPayload | RefinerStepPayload | AntagonistStepPayload;
}

export interface WorkflowContext {
  sessionId: string;
  threadId: string;
  targetUserTurnId: string;
}

export interface WorkflowRequest {
  workflowId: string;
  context: WorkflowContext;
  steps: WorkflowStep[];
}

// ============================================================================
// SECTION 2b: RESOLVED CONTEXT (Output of ContextResolver)
// ============================================================================

export type ResolvedContext =
  | InitializeContext
  | ExtendContext
  | RecomputeContext;

export interface InitializeContext {
  type: "initialize";
  providers: ProviderKey[];
}

export interface ExtendContext {
  type: "extend";
  sessionId: string;
  lastTurnId: string;
  providerContexts: Record<ProviderKey, { meta: any; continueThread: boolean }>;
}

export interface RecomputeContext {
  type: "recompute";
  sessionId: string;
  sourceTurnId: string;
  frozenBatchOutputs: Record<ProviderKey, ProviderResponse>;
  latestMappingOutput?: { providerId: string; text: string; meta: any } | null;
  providerContextsAtSourceTurn: Record<ProviderKey, { meta: any }>;
  stepType: "synthesis" | "mapping" | "batch" | "refiner";
  targetProvider: ProviderKey;
  sourceUserMessage: string;
}

// ============================================================================
// SECTION 3: REAL-TIME MESSAGING (BACKEND -> UI)
// These are messages sent from the backend to the UI for real-time updates.
// ============================================================================

export interface PartialResultMessage {
  type: "PARTIAL_RESULT";
  sessionId: string;
  stepId: string;
  providerId: ProviderKey;
  chunk: { text?: string; meta?: any };
}

export interface WorkflowStepUpdateMessage {
  type: "WORKFLOW_STEP_UPDATE";
  sessionId: string;
  stepId: string;
  status: "completed" | "failed";
  result?: {
    results?: Record<string, ProviderResponse>; // For batch steps
    providerId?: string; // For single-provider steps
    text?: string;
    status?: string;
    meta?: any;
  };
  error?: string;
}

export interface WorkflowCompleteMessage {
  type: "WORKFLOW_COMPLETE";
  sessionId: string;
  workflowId: string;
  finalResults?: Record<string, any>;
  error?: string;
}

// Real-time workflow progress telemetry for UI (optional but recommended)
export interface WorkflowProgressMessage {
  type: 'WORKFLOW_PROGRESS';
  sessionId: string;
  aiTurnId: string;
  phase: 'batch' | 'synthesis' | 'mapping';
  providerStatuses: ProviderStatus[];
  completedCount: number;
  totalCount: number;
  estimatedTimeRemaining?: number; // milliseconds
}

export interface TurnCreatedMessage {
  type: "TURN_CREATED";
  sessionId: string;
  userTurnId: string;
  aiTurnId: string;
  providers?: ProviderKey[];
  synthesisProvider?: ProviderKey | null;
  mappingProvider?: ProviderKey | null;
  refinerProvider?: ProviderKey | null;
  antagonistProvider?: ProviderKey | null;
}

export interface TurnFinalizedMessage {
  type: "TURN_FINALIZED";
  sessionId: string;
  userTurnId: string;
  aiTurnId: string;
  turn: {
    user: {
      id: string;
      type: "user";
      text: string;
      createdAt: number;
      sessionId: string;
    };
    ai: AiTurn;
  };
}

export type PortMessage =
  | PartialResultMessage
  | WorkflowStepUpdateMessage
  | WorkflowCompleteMessage
  | WorkflowProgressMessage
  | WorkflowPartialCompleteMessage
  | RetryProviderRequest
  | TurnFinalizedMessage
  | TurnCreatedMessage;

// ============================================================================
// SECTION 3b: ERROR RESILIENCE & RETRIES (SHARED TYPES)
// ============================================================================

/**
 * Error classification for user-facing messaging and retry logic
 */
export type ProviderErrorType =
  | 'rate_limit'      // 429 - Retryable after cooldown
  | 'auth_expired'    // 401/403 - Requires re-login
  | 'timeout'         // Request took too long - Retryable
  | 'circuit_open'    // Too many recent failures - Auto-retry later
  | 'content_filter'  // Response blocked by provider - Not retryable
  | 'input_too_long'  // Input exceeds provider limit - Not retryable
  | 'network'         // Connection failed - Retryable
  | 'unknown';        // Catch-all - Maybe retryable

export interface ProviderError {
  type: ProviderErrorType;
  message: string;
  retryable: boolean;
  retryAfterMs?: number;    // For rate limits
  requiresReauth?: boolean; // For auth errors
}

/**
 * Enhanced provider status in WORKFLOW_PROGRESS
 */
export interface ProviderStatus {
  providerId: string;
  status: 'queued' | 'active' | 'streaming' | 'completed' | 'failed' | 'skipped';
  progress?: number;
  error?: ProviderError;       // Detailed error info when status === 'failed'
  skippedReason?: string;      // Why it was skipped (e.g., "circuit open")
}

/**
 * Retry request from frontend
 */
export interface RetryProviderRequest {
  type: 'RETRY_PROVIDERS';
  sessionId: string;
  aiTurnId: string;
  providerIds: string[];       // Which providers to retry
  retryScope: 'batch' | 'synthesis' | 'mapping'; // Which phase to retry
}

/**
 * Partial completion message - sent when workflow completes with some failures
 */
export interface WorkflowPartialCompleteMessage {
  type: 'WORKFLOW_PARTIAL_COMPLETE';
  sessionId: string;
  aiTurnId: string;
  successfulProviders: string[];
  failedProviders: Array<{
    providerId: string;
    error: ProviderError;
  }>;
  synthesisCompleted: boolean;
  mappingCompleted: boolean;
}

// ============================================================================
// SECTION 4: PERSISTENT DATA MODELS
// These are the core data entities representing the application's state.
// ============================================================================

// ============================================================================
// GRAPH TOPOLOGY TYPES
// ============================================================================

export interface GraphNode {
  id: string;
  label: string;
  theme: string;
  supporters: (number | string)[];
  support_count: number;
}

export interface GraphEdge {
  source: string;
  target: string;
  type: 'conflicts' | 'complements' | 'prerequisite' | string;
  reason: string;
}

export interface GraphTopology {
  nodes: GraphNode[];
  edges: GraphEdge[];
}

export interface ProviderResponse {
  providerId: string;
  text: string;
  status: "pending" | "streaming" | "completed" | "error";
  createdAt: number;
  updatedAt?: number;
  attemptNumber?: number;
  artifacts?: Array<{
    title: string;
    identifier: string;
    content: string;
    type: string;
  }>;
  meta?: {
    conversationId?: string;
    parentMessageId?: string;
    tokenCount?: number;
    thinkingUsed?: boolean;
    _rawError?: string;
    graphTopology?: GraphTopology;
    allAvailableOptions?: string;
    citationSourceOrder?: Record<string | number, string>;
    synthesizer?: string;
    mapper?: string;
    [key: string]: any; // Keep index signature for genuinely unknown provider metadata, but we've explicitly typed the known ones.
  };
}

export interface AiTurn {
  id: string;
  type: "ai";
  sessionId: string | null;
  threadId: string;
  userTurnId: string;
  createdAt: number;
  isComplete?: boolean;
  // Arrays for all response buckets for uniform handling
  batchResponses: Record<string, ProviderResponse[]>;
  synthesisResponses: Record<string, ProviderResponse[]>;
  mappingResponses: Record<string, ProviderResponse[]>;
  refinerResponses?: Record<string, ProviderResponse[]>;
  antagonistResponses?: Record<string, ProviderResponse[]>;
  meta?: {
    branchPointTurnId?: string;
    replacesId?: string;
    isHistoricalRerun?: boolean;
    synthForUserTurnId?: string;
    [key: string]: any;
  };
}

export interface Thread {
  id: string;
  sessionId: string;
  parentThreadId: string | null;
  branchPointTurnId: string | null;
  name: string;
  color: string;
  isActive: boolean;
  createdAt: number;
  lastActivity: number;
}

// ============================================================================
// TYPE GUARDS
// ============================================================================
export function isPromptPayload(payload: any): payload is PromptStepPayload {
  return "prompt" in payload && "providers" in payload;
}
export function isSynthesisPayload(
  payload: any,
): payload is SynthesisStepPayload {
  return "synthesisProvider" in payload;
}
export function isMappingPayload(payload: any): payload is MappingStepPayload {
  return "mappingProvider" in payload;
}
export function isRefinerPayload(payload: any): payload is RefinerStepPayload {
  return "refinerProvider" in payload;
}
export function isUserTurn(turn: any): turn is { type: "user" } {
  return !!turn && typeof turn === "object" && turn.type === "user";
}
export function isAiTurn(turn: any): turn is { type: "ai" } {
  return !!turn && typeof turn === "object" && turn.type === "ai";
}



================================================
FILE: shared/messaging.ts
================================================
// shared/messaging.ts
// Centralized message type constants used between UI and background SW

export const EXECUTE_WORKFLOW = "EXECUTE_WORKFLOW";
export const WORKFLOW_COMPLETE = "WORKFLOW_COMPLETE";
export const WORKFLOW_FAILED = "WORKFLOW_FAILED";
export const WORKFLOW_STEP_UPDATE = "WORKFLOW_STEP_UPDATE";
export const TURN_FINALIZED = "TURN_FINALIZED";
export const TURN_CREATED = "TURN_CREATED";
export const SYNTHESIS_COMPLETE = "SYNTHESIS_COMPLETE";
export const SYNTHESIS_PARTIAL = "SYNTHESIS_PARTIAL";

export const GET_FULL_HISTORY = "GET_FULL_HISTORY";
export const GET_HISTORY_SESSION = "GET_HISTORY_SESSION";
export const GET_LAST_ESCALATION = "GET_LAST_ESCALATION";
export const GET_SYSTEM_STATUS = "GET_SYSTEM_STATUS";

// Maintenance / cleanup
export const DELETE_SESSION = "DELETE_SESSION";
export const DELETE_SESSIONS = "DELETE_SESSIONS";
// Rename existing session title
export const RENAME_SESSION = "RENAME_SESSION";

// ChatGPT Provider Messages
export const CHATGPT_CHECK_REQUIREMENTS = "CHATGPT_CHECK_REQUIREMENTS";
export const CHATGPT_TEST_ARKOSE = "CHATGPT_TEST_ARKOSE";
export const CHATGPT_GET_STATUS = "CHATGPT_GET_STATUS";
export const CHATGPT_GENERATE_PROOF = "CHATGPT_GENERATE_PROOF";
export const CHATGPT_RETRIEVE_ARKOSE = "CHATGPT_RETRIEVE_ARKOSE";
export const REFINE_PROMPT = "REFINE_PROMPT";
export const REFRESH_AUTH_STATUS = "REFRESH_AUTH_STATUS";



================================================
FILE: shared/parsing-utils.ts
================================================
/**
 * Shared Parsing Utilities for ALL_AVAILABLE_OPTIONS and GRAPH_TOPOLOGY
 * 
 * Single source of truth for parsing mapping responses.
 * Used by both backend (workflow-engine.js) and frontend (DecisionMapSheet.tsx).
 */

// ============================================================================
// TYPES
// ============================================================================

export interface GraphNode {
    id: string;
    label: string;
    theme: string;
    supporters: (string | number)[];
    support_count: number;
}

export interface GraphEdge {
    source: string;
    target: string;
    reason: string;
    type: 'conflicts' | 'complements' | 'prerequisite' | string;
}

export interface GraphTopology {
    nodes: GraphNode[];
    edges: GraphEdge[];
}

// ============================================================================
// NORMALIZATION
// ============================================================================


/**
 * Normalize markdown escapes and unicode variants
 */
export function normalizeText(text: string): string {
    return text
        .replace(/\\=/g, '=')
        .replace(/\\_/g, '_')
        .replace(/\\\*/g, '*')
        .replace(/\\-/g, '-')
        .replace(/[＝═⁼˭꓿﹦]/g, '=')
        .replace(/[‗₌]/g, '=')
        .replace(/\u2550/g, '=')
        .replace(/\uFF1D/g, '=');
}

// ============================================================================
// GRAPH_TOPOLOGY PARSING
// ============================================================================

/**
 * Pattern to match GRAPH_TOPOLOGY headers in various formats
 */
const GRAPH_TOPOLOGY_PATTERN = /\n#{1,3}\s*[^\w\n].*?GRAPH[_\s]*TOPOLOGY|\n?[🔬📊🗺️]*\s*={0,}GRAPH[_\s]*TOPOLOGY={0,}|\n?[🔬📊🗺️]\s*GRAPH[_\s]*TOPOLOGY|={3,}\s*GRAPH[_\s]*TOPOLOGY\s*={3,}/i;

/**
 * Find position of GRAPH_TOPOLOGY header in text
 */
export function findGraphTopologyPosition(text: string): number {
    const match = text.match(GRAPH_TOPOLOGY_PATTERN);
    return match && typeof match.index === 'number' ? match.index : -1;
}

/**
 * Extract GRAPH_TOPOLOGY JSON from text and return cleaned text
 */
export function extractGraphTopologyAndStrip(text: string): { text: string; topology: GraphTopology | null } {
    if (!text || typeof text !== 'string') return { text: text || '', topology: null };

    const normalized = normalizeText(text);
    const match = normalized.match(GRAPH_TOPOLOGY_PATTERN);

    if (!match || typeof match.index !== 'number') {
        return { text: normalized, topology: null };
    }

    const start = match.index + match[0].length;
    let rest = normalized.slice(start).trim();

    // Handle code block wrapped JSON
    const codeBlockMatch = rest.match(/^```(?:json)?\s*\n([\s\S]*?)\n```/);
    if (codeBlockMatch) {
        rest = codeBlockMatch[1].trim();
    }

    // Find JSON object
    let i = 0;
    while (i < rest.length && rest[i] !== '{') i++;
    if (i >= rest.length) return { text: normalized.slice(0, match.index).trim(), topology: null };

    // Parse JSON with balanced braces
    let depth = 0;
    let inStr = false;
    let esc = false;

    for (let j = i; j < rest.length; j++) {
        const ch = rest[j];
        if (inStr) {
            if (esc) {
                esc = false;
            } else if (ch === '\\') {
                esc = true;
            } else if (ch === '"') {
                inStr = false;
            }
            continue;
        }
        if (ch === '"') {
            inStr = true;
            continue;
        }
        if (ch === '{') {
            depth++;
        } else if (ch === '}') {
            depth--;
            if (depth === 0) {
                try {
                    let jsonText = rest.slice(i, j + 1);
                    // Fix unquoted S in supporters arrays
                    jsonText = jsonText.replace(/("supporters"\s*:\s*\[)\s*S\s*([,\]])/g, '$1"S"$2');
                    const topology = JSON.parse(jsonText);
                    const before = normalized.slice(0, match.index).trim();
                    const after = rest.slice(j + 1).trim();
                    const newText = after ? `${before}\n${after}` : before;
                    return { text: newText, topology };
                } catch {
                    break;
                }
            }
        }
    }

    return { text: normalized.slice(0, match.index).trim(), topology: null };
}

// ============================================================================
// ALL_AVAILABLE_OPTIONS PARSING
// ============================================================================

/**
 * Patterns to match ALL_AVAILABLE_OPTIONS headers
 */
const OPTIONS_PATTERNS = [
    // Markdown H2/H3 header with any emoji prefix: ## 🛠️ ALL_AVAILABLE_OPTIONS
    { re: /\n#{1,3}\s*[^\w\n].*?ALL[_\s]*AVAILABLE[_\s]*OPTIONS.*?\n/i, minPosition: 0.15 },

    // Emoji-prefixed format (🛠️ ALL_AVAILABLE_OPTIONS) - standalone
    { re: /\n?[🛠️🔧⚙️🛠]\s*ALL[_\s]*AVAILABLE[_\s]*OPTIONS\s*\n/i, minPosition: 0.15 },

    // Standard delimiter with === or --- or unicode equivalent wrapper
    { re: /\n?[=\-─━═＝]{2,}\s*ALL[_\s]*AVAILABLE[_\s]*OPTIONS\s*[=\-─━═＝]{2,}\n?/i, minPosition: 0 },
    { re: /\n?[=\-─━═＝]{2,}\s*ALL[_\s]*OPTIONS\s*[=\-─━═＝]{2,}\n?/i, minPosition: 0 },

    // Markdown wrapped variants or multi-char blocks
    { re: /\n\*\*\s*[=\-─━═＝]{2,}\s*ALL[_\s]*AVAILABLE[_\s]*OPTIONS\s*[=\-─━═＝]{2,}\s*\*\*\n?/i, minPosition: 0 },
    { re: /\n\*{0,2}[=\-─━═＝]{3,}\s*ALL[_\s]*AVAILABLE[_\s]*OPTIONS\s*[=\-─━═＝]{3,}\*{0,2}\n/i, minPosition: 0 },
    { re: /\n###\s*[=\-─━═＝]{2,}\s*ALL[_\s]*AVAILABLE[_\s]*OPTIONS\s*[=\-─━═＝]{2,}\n?/i, minPosition: 0 },

    // Heading styles
    { re: /\n\*\*\s*All\s+Available\s+Options:?\s*\*\*\n/i, minPosition: 0.25 },
    { re: /\n##\s+All\s+Available\s+Options:?\n/i, minPosition: 0.25 },
    { re: /\n###\s+All\s+Available\s+Options:?\n/i, minPosition: 0.25 },

    // Looser patterns
    { re: /\nAll\s+Available\s+Options:\n/i, minPosition: 0.3 },
    { re: /\n\*\*\s*Options:?\s*\*\*\n/i, minPosition: 0.3 },
    { re: /\n##\s+Options:?\n/i, minPosition: 0.3 },
];

/**
 * Clean narrative text by removing trailing separators and leftover header fragments
 */
export function cleanNarrativeText(text: string): string {
    return text
        .replace(/\n---+\s*$/, '')
        .replace(/\n#{1,3}\s*[🛠️🔧⚙️🛠]?\s*ALL[_\s]*AVAILABLE[_\s]*OPTIONS.*$/i, '')
        .replace(/\n#{1,3}\s*[🛠️🔧⚙️🛠]\s*$/i, '')
        .replace(/[🛠️🔧⚙️🛠]\s*$/i, '')
        .trim();
}

/**
 * Clean options text by removing trailing GRAPH_TOPOLOGY header
 */
export function cleanOptionsText(text: string): string {
    const graphTopoPos = findGraphTopologyPosition(text);
    if (graphTopoPos > 0) {
        return text.slice(0, graphTopoPos).trim();
    }
    return text.trim();
}

/**
 * Extract ALL_AVAILABLE_OPTIONS from text and return cleaned narrative
 */
export function extractOptionsAndStrip(text: string): { text: string; options: string | null } {
    if (!text || typeof text !== 'string') return { text: text || '', options: null };

    let normalized = normalizeText(text);

    // First, find and strip GRAPH_TOPOLOGY section
    const graphTopoStart = findGraphTopologyPosition(normalized);
    if (graphTopoStart > 0) {
        normalized = normalized.slice(0, graphTopoStart).trim();
    }

    // Find best matching options delimiter
    let bestMatch: { index: number; length: number } | null = null;
    let bestScore = -1;

    for (const pattern of OPTIONS_PATTERNS) {
        const match = normalized.match(pattern.re);
        if (match && typeof match.index === 'number') {
            const position = match.index / normalized.length;
            if (position < pattern.minPosition) continue;
            const score = position * 100;
            if (score > bestScore) {
                bestScore = score;
                bestMatch = { index: match.index, length: match[0].length };
            }
        }
    }

    if (!bestMatch) return { text: normalized, options: null };

    const afterDelimiter = normalized.substring(bestMatch.index + bestMatch.length).trim();
    const listPreview = afterDelimiter.slice(0, 400);

    // Validate that what follows looks like structured content
    const hasListStructure = /^\s*[-*•]\s+|\n\s*[-*•]\s+|^\s*\d+\.\s+|\n\s*\d+\.\s+|^\s*\*\*[^*]+\*\*|^\s*Theme\s*:|^\s*###?\s+|^\s*[A-Z][^:\n]{2,}:|^[\u{1F300}-\u{1FAD6}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/iu.test(listPreview);
    const hasSubstantiveContent = afterDelimiter.length > 50 && (afterDelimiter.includes('\n') || afterDelimiter.includes(':'));

    if (!hasListStructure && !hasSubstantiveContent) {
        return { text: normalized, options: null };
    }

    const narrative = cleanNarrativeText(normalized.substring(0, bestMatch.index));
    const options = cleanOptionsText(afterDelimiter);

    return { text: narrative, options: options || null };
}

/**
 * Parse mapping response - convenience function that extracts both options and topology
 */
export function parseMappingResponse(response: string | null | undefined): {
    narrative: string;
    options: string | null;
    optionTitles: string[];
    graphTopology: any | null;
} {
    if (!response) return { narrative: '', options: null, optionTitles: [], graphTopology: null };

    // First extract graph topology
    const { text: textWithoutTopology, topology } = extractGraphTopologyAndStrip(response);

    // Then extract options from remaining text
    const { text: narrative, options } = extractOptionsAndStrip(textWithoutTopology);

    // Extract option titles if options were found
    const optionTitles = options ? parseOptionTitles(options) : [];

    return {
        narrative: cleanNarrativeText(narrative),
        options: options ? cleanOptionsText(options) : null,
        optionTitles,
        graphTopology: topology,
    };
}

/**
 * Extract bold titles from options text
 */
export function parseOptionTitles(optionsText: string): string[] {
    if (!optionsText) return [];
    const titles: string[] = [];
    const lines = optionsText.split('\n');
    for (const line of lines) {
        // Match: **Bold Title** (with optional colon/dash after)
        const match = line.match(/\*\*([^*]+)\*\*/);
        if (match) {
            const title = match[1].trim();
            // Avoid duplicates
            if (title && !titles.includes(title)) {
                titles.push(title);
            }
        }
    }
    return titles;
}

// ============================================================================
// REFINER OUTPUT PARSING (NEW STRUCTURE)
// ============================================================================

export type LeapAction = "proceed" | "verify" | "reframe" | "research";

export type SignalPriority = "blocker" | "risk" | "enhancement";

export type NextStepAction = LeapAction;

export interface Gem {
    insight: string;
    source: string;
    impact: string;
    action?: string;
}

export interface Signal {
    type: string;
    content: string;
    source?: string;
    priority: SignalPriority;
    impact?: string;
}

export interface Outlier {
    position: string;
    source: string;
    why: string;
}

export interface Attribution {
    claim: string;
    source: string;
}

export interface Leap {
    action: LeapAction;
    target: string;
    why: string;
    answer?: string;
    analysis?: string;
    justification?: string;
}

export interface RefinerOutput {
    synthesisPlus: string | null;
    gem: Gem | null;
    outlier: Outlier | null;
    attributions: Attribution[];
    leap: Leap;
    signals?: Signal[];
    unlistedOptions?: Array<{ title: string; description: string; source?: string }>;
    reframe?: { issue?: string; suggestion: string; unlocks?: string } | null;
    rawText?: string;
}

/**
 * Parse Refiner output from markdown text or JSON
 */
export function parseRefinerOutput(text: string): RefinerOutput {
    if (!text || typeof text !== 'string') {
        return createEmptyRefinerOutput();
    }

    const normalized = normalizeText(text);

    // 1. Try JSON parsing first (for robustness)
    const jsonResult = tryParseJsonRefinerOutput(normalized);
    if (jsonResult) {
        return { ...jsonResult, rawText: text };
    }

    // 2. Fallback to Regex extraction with robust patterns
    return {
        synthesisPlus: extractSynthesisPlus(normalized),
        gem: extractGem(normalized),
        outlier: extractOutlier(normalized),
        attributions: extractAttributions(normalized),
        leap: extractLeap(normalized),
        rawText: text,
    };
}

function createEmptyRefinerOutput(rawText: string = ''): RefinerOutput {
    return {
        synthesisPlus: null,
        gem: null,
        outlier: null,
        attributions: [],
        leap: { action: 'proceed', target: '', why: '' },
        signals: [],
        unlistedOptions: [],
        reframe: null,
        rawText,
    };
}


// ============================================================================
// JSON PARSING
// ============================================================================

function tryParseJsonRefinerOutput(text: string): Omit<RefinerOutput, 'rawText'> | null {
    try {
        let jsonText = text.trim();

        // Handle code blocks
        const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/i);
        if (codeBlockMatch) {
            jsonText = codeBlockMatch[1].trim();
        }

        // Handle double-stringified JSON
        if (jsonText.startsWith('"') && jsonText.endsWith('"')) {
            try {
                const unquoted = JSON.parse(jsonText);
                if (typeof unquoted === 'string') {
                    jsonText = unquoted.trim();
                } else if (typeof unquoted === 'object') {
                    return normalizeRefinerObject(unquoted);
                }
            } catch {
                // Continue with original text
            }
        }

        // Find JSON boundaries
        const firstBrace = jsonText.indexOf('{');
        const lastBrace = jsonText.lastIndexOf('}');

        if (firstBrace === -1 || lastBrace === -1) return null;

        const candidate = jsonText.substring(firstBrace, lastBrace + 1);
        const parsed = JSON.parse(candidate);

        if (parsed && typeof parsed === 'object') {
            return normalizeRefinerObject(parsed);
        }
    } catch {
        // Silent failure, fall back to regex parsing
    }
    return null;
}

function normalizeRefinerObject(parsed: any): Omit<RefinerOutput, 'rawText'> | null {
    const hasLegacyShape = 'synthesisPlus' in parsed || 'gem' in parsed || 'leap' in parsed;
    const hasSignalShape = 'final_word' in parsed || 'the_one' in parsed || 'the_step' in parsed || 'the_echo' in parsed;

    if (!hasLegacyShape && !hasSignalShape) {
        return null;
    }

    const rawFinalWord = parsed.synthesisPlus ?? parsed.final_word ?? null;
    const synthesisPlus = rawFinalWord != null ? String(rawFinalWord) : null;

    const gemSource = parsed.gem || parsed.the_one || null;
    let gem: Gem | null = null;
    if (gemSource && typeof gemSource === 'object') {
        gem = {
            insight: String(gemSource.insight || ''),
            source: String(gemSource.source || ''),
            impact: String(gemSource.impact || ''),
            action: gemSource.action ? String(gemSource.action) : undefined,
        };
    }

    const outlierSource = parsed.outlier || parsed.the_echo || null;
    let outlier: Outlier | null = null;
    if (outlierSource && typeof outlierSource === 'object') {
        outlier = {
            position: String(outlierSource.position || ''),
            source: String(outlierSource.source || ''),
            why: String(outlierSource.why || ''),
        };
    }

    const attributions: Attribution[] = Array.isArray(parsed.attributions)
        ? parsed.attributions.map((a: any) => ({
            claim: String(a.claim || ''),
            source: String(a.source || ''),
        }))
        : [];

    const stepSource = parsed.the_step || parsed.leap || {};
    const answer = stepSource.answer != null ? String(stepSource.answer) : '';
    const analysis = stepSource.analysis != null ? String(stepSource.analysis) : '';
    const stepWhy = stepSource.why != null ? String(stepSource.why) : '';
    const justification = stepSource.justification != null ? String(stepSource.justification) : '';

    let action: LeapAction = 'proceed';
    const answerLower = answer.toLowerCase();
    if (answerLower.includes('verify')) action = 'verify';
    else if (answerLower.includes('reframe')) action = 'reframe';
    else if (answerLower.includes('research')) action = 'research';
    else if (answerLower.includes('proceed')) action = 'proceed';

    const target = analysis || String(stepSource.target || '');

    const leap: Leap = {
        action,
        target,
        why: stepWhy,
        answer: answer || undefined,
        analysis: analysis || undefined,
        justification: justification || undefined,
    };

    const signals: Signal[] = Array.isArray(parsed.signals)
        ? parsed.signals.map((s: any) => ({
            type: String(s.type || ''),
            content: String(s.content || ''),
            source: s.source ? String(s.source) : undefined,
            priority: (s.priority as SignalPriority) || 'enhancement',
            impact: s.impact ? String(s.impact) : undefined,
        }))
        : [];

    const unlistedOptions: Array<{ title: string; description: string; source?: string }> = Array.isArray(parsed.unlistedOptions)
        ? parsed.unlistedOptions.map((opt: any) => ({
            title: String(opt.title || ''),
            description: String(opt.description || ''),
            source: opt.source ? String(opt.source) : undefined,
        }))
        : [];

    const reframe = parsed.reframe && typeof parsed.reframe === 'object'
        ? {
            issue: parsed.reframe.issue ? String(parsed.reframe.issue) : undefined,
            suggestion: String(parsed.reframe.suggestion || ''),
            unlocks: parsed.reframe.unlocks ? String(parsed.reframe.unlocks) : undefined,
        }
        : null;

    return {
        synthesisPlus,
        gem,
        outlier,
        attributions,
        leap,
        signals,
        unlistedOptions,
        reframe,
    };
}


// ============================================================================
// CORE HELPERS
// ============================================================================

/**
 * Extract a named section from markdown text.
 * Handles: ## Header, ### Header, **Header**:, Header:, etc.
 */
function extractSection(text: string, sectionName: string): string {
    if (!text || !sectionName) return '';

    const escapedName = sectionName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');

    // Patterns from strictest to loosest for main section
    const patterns = [
        // ## Section Name or ### Section Name
        new RegExp(
            `(?:^|\\n)#{1,3}\\s*[^\\w\\n]*${escapedName}[^\\n]*\\n([\\s\\S]*?)(?=\\n#{1,3}\\s|\\n---\\s*\\n|$)`,
            'i'
        ),
        // **Section Name**: or **Section Name**
        new RegExp(
            `\\*\\*\\s*${escapedName}\\s*\\*\\*[:\\s]*\\n?([\\s\\S]*?)(?=\\n\\*\\*[A-Z]|\\n#{1,3}\\s|\\n---\\s*\\n|$)`,
            'i'
        ),
        // Section Name: (plain)
        new RegExp(
            `(?:^|\\n)${escapedName}[:\\s]+\\n?([\\s\\S]*?)(?=\\n[A-Z][a-z]+[:\\s]+\\n|\\n#{1,3}\\s|\\n---\\s*\\n|$)`,
            'i'
        ),
    ];

    for (const pattern of patterns) {
        const match = text.match(pattern);
        if (match?.[1]?.trim()) {
            return match[1].trim();
        }
    }

    return '';
}

/**
 * Extract a labeled value from text.
 * Handles: **Label**: value, - **Label**: value, Label: value
 */
function extractLabeledValue(text: string, label: string): string | null {
    if (!text || !label) return null;

    const escaped = label.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');

    const patterns = [
        // - **Label**: value (list item with bold)
        new RegExp(`[-*•]\\s*\\*\\*${escaped}\\*\\*[:\\s]*([^\\n]+)`, 'i'),
        // **Label**: value (inline bold)
        new RegExp(`\\*\\*${escaped}\\*\\*[:\\s]*([^\\n]+)`, 'i'),
        // Label: value (plain)
        new RegExp(`(?:^|\\n)${escaped}[:\\s]+([^\\n]+)`, 'i'),
    ];

    for (const pattern of patterns) {
        const match = text.match(pattern);
        if (match?.[1]?.trim()) {
            return match[1].trim();
        }
    }

    return null;
}


// ============================================================================
// NEW EXTRACTORS
// ============================================================================

/**
 * Extract synthesisPlus content from text
 */
function extractSynthesisPlus(text: string): string | null {
    const section = extractSection(text, 'Synthesis+') ||
        extractSection(text, 'SynthesisPlus') ||
        extractSection(text, 'Enhanced Synthesis') ||
        extractSection(text, 'Enhanced Answer');

    return section || null;
}

/**
 * Extract gem insight from text
 */
function extractGem(text: string): Gem | null {
    const section = extractSection(text, 'Gem') ||
        extractSection(text, 'Key Insight') ||
        extractSection(text, 'Hidden Gem');

    if (!section) return null;

    const insight = extractLabeledValue(section, 'insight') ||
        extractLabeledValue(section, 'finding') ||
        section.split('\n')[0]?.trim() || '';
    const source = extractLabeledValue(section, 'source') || '';
    const impact = extractLabeledValue(section, 'impact') || '';
    const action = extractLabeledValue(section, 'action') || undefined;

    if (!insight) return null;

    return { insight, source, impact, action };
}

/**
 * Extract outlier position from text
 */
function extractOutlier(text: string): Outlier | null {
    const section = extractSection(text, 'Outlier') ||
        extractSection(text, 'Dissenting View') ||
        extractSection(text, 'Contrary Position');

    if (!section) return null;

    const position = extractLabeledValue(section, 'position') ||
        extractLabeledValue(section, 'view') ||
        section.split('\n')[0]?.trim() || '';
    const source = extractLabeledValue(section, 'source') || '';
    const why = extractLabeledValue(section, 'why') ||
        extractLabeledValue(section, 'reason') || '';

    if (!position) return null;

    return { position, source, why };
}

/**
 * Extract attributions from text
 */
function extractAttributions(text: string): Attribution[] {
    const section = extractSection(text, 'Attributions') ||
        extractSection(text, 'Sources') ||
        extractSection(text, 'Claims');

    if (!section) return [];

    const attributions: Attribution[] = [];

    // Pattern: - Claim text (Source) or - **Claim**: Source
    const pattern = /[-*•]\s*(?:\*\*)?([^*:\n(]+)(?:\*\*)?[:\s]*(?:\(([^)]+)\)|([^\n]+))?/gi;
    let match;
    while ((match = pattern.exec(section)) !== null) {
        const claim = match[1].trim();
        const source = (match[2] || match[3] || '').trim();
        if (claim) {
            attributions.push({ claim, source });
        }
    }

    return attributions;
}

/**
 * Extract leap (next step) from text
 */
function extractLeap(text: string): Leap {
    const section = extractSection(text, 'Leap') ||
        extractSection(text, 'Next Step') ||
        extractSection(text, 'Recommended Action') ||
        extractSection(text, 'Action');

    const defaultLeap: Leap = { action: 'proceed', target: '', why: '', answer: 'proceed' };

    if (!section) return defaultLeap;

    // Try to extract structured format
    const actionMatch = section.match(/\*?\*?(proceed|verify|reframe|research)\*?\*?[:\s]+(.+)/i);

    if (actionMatch) {
        const action = actionMatch[1].toLowerCase() as LeapAction;
        const rest = actionMatch[2].trim();

        // Try to split into target and why
        const whyMatch = rest.match(/(.+?)(?:\s*[—\-]+\s*(?:because|why)[:\s]*(.+))?$/i);

        const target = whyMatch?.[1]?.trim() || rest;
        const why = whyMatch?.[2]?.trim() || '';
        return {
            action,
            target,
            why,
            answer: action,
            analysis: target,
        };
    }

    const actionValue = extractLabeledValue(section, 'action');
    const action: LeapAction = (['proceed', 'verify', 'reframe', 'research'].includes(actionValue?.toLowerCase() || '')
        ? actionValue!.toLowerCase()
        : 'proceed') as LeapAction;
    const labeledTarget = extractLabeledValue(section, 'target') || '';
    const why = extractLabeledValue(section, 'why') || extractLabeledValue(section, 'reason') || '';

    if (labeledTarget) {
        return { action, target: labeledTarget, why, answer: action, analysis: labeledTarget };
    }

    // Fallback: use first sentence as target, infer action from keywords
    const firstSentence = section.split(/[.!?]\s/)[0];
    let inferredAction: LeapAction = 'proceed';
    if (/verify|check|confirm|validate/i.test(section)) inferredAction = 'verify';
    if (/reframe|rephrase|reconsider/i.test(section)) inferredAction = 'reframe';
    if (/research|investigate|explore|look into/i.test(section)) inferredAction = 'research';

    const target = firstSentence?.trim() || section.slice(0, 100);
    return {
        action: inferredAction,
        target,
        why: '',
        answer: inferredAction,
        analysis: target,
    };
}

// ============================================================================
// ANTAGONIST OUTPUT PARSING
// ============================================================================

export interface AntagonistDimension {
    variable: string;
    options: string;
    why: string;
}

export interface ParsedBracket {
    variable: string;
    options: string[];
    startIndex: number;
    endIndex: number;
    fullMatch: string;
}

export interface AntagonistOutput {
    the_prompt: {
        text: string | null;
        dimensions: AntagonistDimension[];
        grounding: string | null;
        payoff: string | null;
    };
    the_audit: {
        missed: Array<{ approach: string; source: string }>;
    };
    rawText?: string;
}

/**
 * Create empty antagonist output
 */
export function createEmptyAntagonistOutput(rawText: string = ''): AntagonistOutput {
    return {
        the_prompt: {
            text: null,
            dimensions: [],
            grounding: null,
            payoff: null,
        },
        the_audit: {
            missed: [],
        },
        rawText,
    };
}

/**
 * Parse Antagonist output from raw text (JSON or markdown)
 */
export function parseAntagonistOutput(raw: string): AntagonistOutput | null {
    if (!raw || typeof raw !== 'string') {
        return null;
    }

    try {
        // Try direct JSON parse
        const parsed = JSON.parse(raw);
        return validateAntagonistOutput(parsed, raw);
    } catch {
        // Try extracting JSON from markdown code blocks
        const jsonMatch = raw.match(/```json?\s*([\s\S]*?)```/);
        if (jsonMatch) {
            try {
                const parsed = JSON.parse(jsonMatch[1]);
                return validateAntagonistOutput(parsed, raw);
            } catch {
                // Fall through to brace extraction
            }
        }

        // Try finding JSON object boundaries
        const firstBrace = raw.indexOf('{');
        const lastBrace = raw.lastIndexOf('}');
        if (firstBrace !== -1 && lastBrace > firstBrace) {
            try {
                const candidate = raw.substring(firstBrace, lastBrace + 1);
                const parsed = JSON.parse(candidate);
                return validateAntagonistOutput(parsed, raw);
            } catch {
                // Failed to parse
            }
        }

        return null;
    }
}

/**
 * Validate and normalize antagonist output structure
 */
function validateAntagonistOutput(obj: any, rawText: string): AntagonistOutput | null {
    // Check required structure exists
    if (!obj || typeof obj !== 'object') return null;
    if (!obj.the_prompt || !obj.the_audit) return null;

    // Normalize null states (when decision is already obvious)
    if (obj.the_prompt.text === null) {
        return {
            the_prompt: {
                text: null,
                dimensions: [],
                grounding: null,
                payoff: null,
            },
            the_audit: {
                missed: Array.isArray(obj.the_audit.missed) ? obj.the_audit.missed : [],
            },
            rawText,
        };
    }

    // Validate dimensions array
    const dimensions: AntagonistDimension[] = Array.isArray(obj.the_prompt.dimensions)
        ? obj.the_prompt.dimensions.map((d: any) => ({
            variable: String(d.variable || ''),
            options: String(d.options || ''),
            why: String(d.why || ''),
        }))
        : [];

    // Validate missed array
    const missed: Array<{ approach: string; source: string }> = Array.isArray(obj.the_audit.missed)
        ? obj.the_audit.missed.map((m: any) => ({
            approach: String(m.approach || ''),
            source: String(m.source || ''),
        }))
        : [];

    return {
        the_prompt: {
            text: obj.the_prompt.text != null ? String(obj.the_prompt.text) : null,
            dimensions,
            grounding: obj.the_prompt.grounding != null ? String(obj.the_prompt.grounding) : null,
            payoff: obj.the_prompt.payoff != null ? String(obj.the_prompt.payoff) : null,
        },
        the_audit: {
            missed,
        },
        rawText,
    };
}

/**
 * Parse bracketed variables from antagonist prompt text
 * Format: [variable: option1 / option2 / option3]
 */
export function parseBrackets(text: string): ParsedBracket[] {
    if (!text) return [];

    const regex = /\[([^:]+):\s*([^\]]+)\]/g;
    const brackets: ParsedBracket[] = [];
    let match;

    while ((match = regex.exec(text)) !== null) {
        brackets.push({
            variable: match[1].trim(),
            options: match[2].split('/').map(o => o.trim()),
            startIndex: match.index,
            endIndex: match.index + match[0].length,
            fullMatch: match[0],
        });
    }

    return brackets;
}

/**
 * Build final prompt by filling in user selections
 */
export function buildFinalPrompt(text: string, selections: Record<string, string>): string {
    let result = text;

    Object.entries(selections).forEach(([variable, value]) => {
        // Replace [variable: option1 / option2] with just the selected value
        const regex = new RegExp(`\\[${variable.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}:[^\\]]+\\]`, 'gi');
        result = result.replace(regex, value);
    });

    return result;
}




================================================
FILE: shared/provider-config.ts
================================================
export const PROVIDER_PRIORITIES = {
    /**
     * For synthesis: Quality of prose/narrative consolidation
     * Claude > Gemini 2.0 Exp > Qwen > Gemini 2.5 Pro > ChatGPT > Gemini
     */
    synthesis: ['claude', 'gemini-exp', 'qwen', 'gemini-pro', 'chatgpt', 'gemini'],

    /**
     * For mapping: Structured reasoning / decision tree quality
     * Gemini > Qwen > ChatGPT > Gemini Exp > Claude > Gemini Pro
     */
    mapping: ['gemini', 'qwen', 'chatgpt', 'gemini-exp', 'claude', 'gemini-pro'],
    antagonist: ['gemini', 'qwen', 'chatgpt', 'gemini-exp', 'claude', 'gemini-pro'],
    refiner: ['gemini', 'qwen', 'chatgpt', 'gemini-exp', 'claude', 'gemini-pro'],

    /**
     * For batch queries: Balance of speed + quality
     */
    batch: ['claude', 'gemini-exp', 'qwen', 'gemini-pro', 'chatgpt', 'gemini'],
} as const;

export type ProviderRole = keyof typeof PROVIDER_PRIORITIES;

/**
 * Shared selection logic - used identically in UI and backend
 */
export function selectBestProvider(
    role: ProviderRole,
    authStatus: Record<string, boolean>,
    availableProviders?: string[]
): string | null {
    const priority = PROVIDER_PRIORITIES[role];

    for (const providerId of priority) {
        // Must be explicitly authorized (not undefined, not false)
        const isAuth = authStatus[providerId] === true;
        // If available list provided, must be in it
        const isAvailable = !availableProviders || availableProviders.includes(providerId);

        if (isAuth && isAvailable) {
            return providerId;
        }
    }

    return null;
}

/**
 * Check if a specific provider is authorized
 */
export function isProviderAuthorized(
    providerId: string,
    authStatus: Record<string, boolean>
): boolean {
    return authStatus[providerId.toLowerCase()] === true;
}



================================================
FILE: shared/provider-limits.ts
================================================
/**
 * Shared provider limits configuration.
 * Defines maximum input characters and warning thresholds for each provider.
 */
export const PROVIDER_LIMITS = {
    chatgpt: { maxInputChars: 32000, warnThreshold: 25000 },
    claude: { maxInputChars: 100000, warnThreshold: 80000 },
    gemini: { maxInputChars: 100000, warnThreshold: 80000 },
    'gemini-pro': { maxInputChars: 120000, warnThreshold: 100000 },
    'gemini-exp': { maxInputChars: 100000, warnThreshold: 80000 },
    qwen: { maxInputChars: 100000, warnThreshold: 80000 },
} as const;

export type ProviderLimits = typeof PROVIDER_LIMITS;
export type ProviderId = keyof ProviderLimits;



================================================
FILE: shared/provider-locks.ts
================================================
const STORAGE_KEY = 'htos_provider_locks';

export interface ProviderLocks {
    synthesis: boolean;
    mapping: boolean;
    antagonist: boolean;
    refiner: boolean;
}

const DEFAULT_LOCKS: ProviderLocks = { synthesis: false, mapping: false, antagonist: false, refiner: false };

/**
 * Read locks from chrome.storage.local
 * Works in both UI and service worker
 */
export async function getProviderLocks(): Promise<ProviderLocks> {
    try {
        const data = await chrome.storage.local.get(STORAGE_KEY);
        return { ...DEFAULT_LOCKS, ...(data[STORAGE_KEY] || {}) };
    } catch {
        return DEFAULT_LOCKS;
    }
}

/**
 * Write locks to chrome.storage.local
 */
export async function setProviderLock(
    role: 'synthesis' | 'mapping' | 'antagonist' | 'refiner',
    locked: boolean
): Promise<void> {
    const current = await getProviderLocks();
    current[role] = locked;
    await chrome.storage.local.set({ [STORAGE_KEY]: current });
}

/**
 * Subscribe to lock changes (for UI reactivity)
 */
export function subscribeToLockChanges(
    callback: (locks: ProviderLocks) => void
): () => void {
    const listener = (
        changes: { [key: string]: chrome.storage.StorageChange },
        area: string
    ) => {
        if (area === 'local' && changes[STORAGE_KEY]) {
            const newValue = changes[STORAGE_KEY].newValue || {};
            callback({ ...DEFAULT_LOCKS, ...newValue });
        }
    };

    chrome.storage.onChanged.addListener(listener);
    return () => chrome.storage.onChanged.removeListener(listener);
}



================================================
FILE: src/cs-openai.js
================================================
(() => {
  // HTOS OpenAI Content Script - Arkose Integration
  // Only runs on openai.com domains for targeted Arkose handling

  let htosApp;

  // Initialize HTOS global if not present
  (() => {
    const appName = "__htos_app";
    const env = "production";
    const isDev = false;

    htosApp = globalThis[appName];
    if (htosApp) {
      return;
    }

    const baseApp = {
      name: appName,
      env: env,
      version: "0.1.0",
      get: (key) => (key in baseApp ? baseApp[key] : null),
    };

    const createLogger = (namespace) => {
      const log = (level, ...args) => {
        if (isDev || level === "error") {
          const color = namespace
            .split("")
            .reduce((acc, char) => char.charCodeAt(0) + ((acc << 5) - acc), 0);
          const r = (color & 0xff0000) >> 16;
          const g = (color & 0x00ff00) >> 8;
          const b = color & 0x0000ff;
          console[level](
            `%c[HTOS:${namespace}]`,
            `color: rgb(${r}, ${g}, ${b})`,
            ...args,
          );
        }
      };

      return {
        log: (...args) => log("log", ...args),
        warn: (...args) => log("warn", ...args),
        error: (...args) => log("error", ...args),
      };
    };

    const appProxy = new Proxy(baseApp, {
      get(target, prop) {
        if (prop === "assign") {
          return (obj) => Object.assign(target, obj);
        }
        if (!(prop in target)) {
          target[prop] = {};
          const logger = createLogger(prop);
          Object.assign(target[prop], logger);
        }
        return target[prop];
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      },
    });

    globalThis[appName] = appProxy;
    htosApp = appProxy;
  })();

  // Arkose Controller for OpenAI
  (() => {
    const { arkose } = htosApp;

    arkose.controller = {
      init() {
        arkose.log("Initializing OpenAI Arkose controller");

        if (this._isArkoseIframe()) {
          arkose.log("Detected Arkose iframe, setting up patches");
          this._config = this._getConfig();
          if (this._config) {
            this._patchFetch();
            this._patchHeadAppendChild();
            this._patchEnforcement();
          }
        } else {
          arkose.log("Main page context, no additional setup needed");
        }
      },

      _isArkoseIframe() {
        return window !== window.top && window.name.startsWith("ae:");
      },

      _getConfig() {
        try {
          const configStr = window.name.replace("ae:", "");
          return JSON.parse(configStr);
        } catch (error) {
          arkose.error("Failed to parse Arkose config:", error);
          return null;
        }
      },

      _patchFetch() {
        const siteParam = this._config.siteParam;
        const chatUrl = this._config.chatUrl;

        this._execute(`
          const originalFetch = globalThis.fetch;
          globalThis.fetch = function(...args) {
            const opts = args[1];
            if (
              typeof opts?.body === 'string' &&
              opts.body.startsWith('${this._config.bodyStartsWith}')
            ) {
              opts.body = opts.body.replace(
                /&${siteParam}=[^&]+/,
                '&${siteParam}=${encodeURIComponent(chatUrl)}'
              );
            }
            return originalFetch.call(this, ...args);
          };
        `);

        arkose.log("Patched fetch for Arkose URL modification");
      },

      _patchHeadAppendChild() {
        const dataSiteParam = this._config.dataSiteParam;
        const chatUrl = this._config.chatUrl;

        this._execute(`
          const originalAppendChild = HTMLElement.prototype.appendChild;
          HTMLElement.prototype.appendChild = function(...args) {
            const elem = args[0];
            if (
              this === document.head &&
              elem?.tagName === 'SCRIPT' &&
              elem.src
            ) {
              const url = new URL(elem.src);
              const site = url.searchParams.get('${dataSiteParam}');
              if (site) {
                url.searchParams.set('${dataSiteParam}', '${chatUrl}');
                elem.src = url.href;
              }
            }
            return originalAppendChild.call(this, ...args);
          };
        `);

        arkose.log("Patched appendChild for Arkose script modification");
      },

      _patchEnforcement() {
        if (!this._config.enforcement) {
          return;
        }

        const enfConfig = JSON.stringify(this._config.enforcement);

        this._execute(`
          const _sent_ = Symbol('sent');
          const _isSDK_ = Symbol('isSDK');
          const enforcement = JSON.parse('${enfConfig}');
          
          Object.defineProperty(Object.prototype, enforcement.$sent, {
            get() {
              return this[_sent_];
            },
            set(value) {
              if (value && value[enforcement.$ef]) {
                applyObject(value[enforcement.$ef], enforcement.ef);
              }
              this[_sent_] = value;
              return true;
            }
          });
          
          Object.defineProperty(Object.prototype, enforcement.$isSDK, {
            get() {
              applyObject(this, enforcement.config);
              return this[_isSDK_];
            },
            set(value) {
              this[_isSDK_] = value;
              return true;
            }
          });
          
          function isObject(obj) {
            return Object.prototype.toString.call(obj) === '[object Object]';
          }
          
          function applyObject(target, source) {
            for (const key in source) {
              if (isObject(target[key])) {
                applyObject(target[key], source[key]);
              } else {
                target[key] = source[key];
              }
            }
          }
        `);

        arkose.log("Applied Arkose enforcement patches");
      },

      _execute(code) {
        // Secure code execution in page context
        const wrappedCode = code
          .replace(/^\s*/, "(() => {")
          .replace(/\s*$/, "})();");
        const element = document.createElement("div");
        element.setAttribute("onreset", wrappedCode);
        element.dispatchEvent(new Event("reset"));
      },
    };
  })();

  // Main Controller
  (() => {
    const { main } = htosApp;

    main.controller = {
      init() {
        main.log("HTOS OpenAI content script initializing");
        htosApp.arkose.controller.init();
        main.log("HTOS OpenAI content script ready");
      },
    };
  })();

  // Startup
  (() => {
    const { startup } = htosApp;

    startup.openaiController = {
      init() {
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", () => {
            htosApp.main.controller.init();
          });
        } else {
          htosApp.main.controller.init();
        }
      },
    };

    startup.openaiController.init();
  })();
})();



================================================
FILE: src/offscreen-entry.js
================================================
// src/offscreen-entry.js
// This runs in the offscreen document with window/DOM APIs available

import { OffscreenBootstrap } from "./HTOS/OffscreenBootstrap.js";

// The module is loaded, so just run the initialization.
// No need for globals.
OffscreenBootstrap.init().catch((err) => {
  console.error("[HTOS Offscreen Entry] Bootstrap initialization failed:", err);
});



================================================
FILE: src/offscreen.css
================================================
/* Offscreen document styles */
body {
  margin: 0;
  padding: 0;
  /* Avoid forcing a solid black background globally -- use transparent to prevent visual overlay
       if this stylesheet is accidentally applied to the visible UI. The offscreen document should
       be invisible and not affect the main UI rendering. */
  background: transparent;
  overflow: hidden;
}



================================================
FILE: src/offscreen.html
================================================
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>HTOS Offscreen</title>
    <!-- The offscreen.css is fine if you need it, but likely not -->
    <link rel="stylesheet" href="offscreen.css" />
  </head>
  <body>
    <!-- Load the compiled offscreen bundle produced by the build -->
    <script type="module" src="/offscreen.js"></script>
  </body>
</html>



================================================
FILE: src/oi.html
================================================
<!doctype html>
<html>
  <head></head>
  <body>
    <!-- This script will contain the Arkose/PoW logic -->
    <script src="oi.js"></script>
  </body>
</html>



================================================
FILE: src/oi.js
================================================
// project uses canonical global only (no HTOS aliases)

(() => {
  console.log("[oi.js] Script loading started at", location.href);
  let A;
  (() => {
    // use the project's expected global name so this bundle can be pasted into oi.js
    const e = "__htos_global";
    const t = "production";
    const i = false;
    A = globalThis[e];
    if (A) {
      return;
    }
    const r = {
      // use canonical app name expected by the project so BusController matches
      name: e,
      env: t,
      get: (A) => (A in r ? r[A] : null),
      ...{
        version: "11.2.3",
      },
    };
    const n = (function A(e) {
      const t = e === r;
      const n = t && i;
      const a = {};
      const c = (A) => Object.assign(e, A);
      const h = new Proxy(e, {
        get(i, r) {
          if (r === "assign") {
            return c;
          }
          if (t && !String(r).startsWith("$")) {
            return e[r];
          }
          if (!(r in e)) {
            e[r] = {};
            if (t) {
              const A = s.bind(null, "log", r, false);
              const t = s.bind(null, "log", r, true);
              const i = s.bind(null, "warn", r, false);
              const n = s.bind(null, "warn", r, true);
              const a = s.bind(null, "error", r, false);
              const c = s.bind(null, "error", r, true);
              const h = o.bind(null, r);
              Object.defineProperties(e[r], {
                log: {
                  get: () => A,
                },
                logDev: {
                  get: () => t,
                },
                warn: {
                  get: () => i,
                },
                warnDev: {
                  get: () => n,
                },
                error: {
                  get: () => a,
                },
                errorDev: {
                  get: () => c,
                },
                Error: {
                  get: () => h,
                },
              });
            }
            a[r] = A(e[r]);
            if (n) {
              globalThis[r] = e[r];
            }
          }
          if (r in a) {
            return a[r];
          } else {
            return e[r];
          }
        },
        set: (A, t, i) => {
          e[t] = i;
          a[t] = i;
          if (n) {
            globalThis[t] = e[t];
          }
          return true;
        },
      });
      return h;
    })(r);
    function s(A, e, t, ...i) {
      if (t) {
        return;
      }
      const [r, n, s] = (function (A) {
        let e = 0;
        A.split("").forEach((t, i) => {
          e = A.charCodeAt(i) + ((e << 5) - e);
        });
        return [(e & 16711680) >> 16, (e & 65280) >> 8, e & 255];
      })(e);
      console[A](`%c[${e}]`, `color: rgb(${r}, ${n}, ${s})`, ...i);
    }
    function o(A, e, ...t) {
      if (t.length > 0) {
        s("error", A, false, e, ...t);
      }
      return new Error(`[${A}] ${e}`);
    }
    globalThis[e] = n;
    A = n;

    // removed HTOS compatibility adapters (no legacy __app_htos aliases)
  })();
  (() => {
    function e(A, e, t, i) {
      return new (t ||= Promise)(function (r, n) {
        function s(A) {
          try {
            a(i.next(A));
          } catch (A) {
            n(A);
          }
        }
        function o(A) {
          try {
            a(i.throw(A));
          } catch (A) {
            n(A);
          }
        }
        function a(A) {
          var e;
          if (A.done) {
            r(A.value);
          } else {
            ((e = A.value),
            e instanceof t
              ? e
              : new t(function (A) {
                  A(e);
                })).then(s, o);
          }
        }
        a((i = i.apply(A, e || [])).next());
      });
    }
    if (typeof SuppressedError == "function") {
      SuppressedError;
    }
    var i = class {
      constructor() {
        this.mutex = Promise.resolve();
      }
      lock() {
        let A = () => {};
        this.mutex = this.mutex.then(() => new Promise(A));
        return new Promise((e) => {
          A = e;
        });
      }
      dispatch(A) {
        return e(this, undefined, undefined, function* () {
          const e = yield this.lock();
          try {
            return yield Promise.resolve(A());
          } finally {
            e();
          }
        });
      }
    };
    var r =
      typeof globalThis != "undefined"
        ? globalThis
        : typeof self != "undefined"
          ? self
          : typeof window != "undefined"
            ? window
            : global;
    var n = r.Buffer ?? null;
    var s = r.TextEncoder ? new r.TextEncoder() : null;
    function o(A, e) {
      return (
        (((A & 15) + ((A >> 6) | ((A >> 3) & 8))) << 4) |
        ((e & 15) + ((e >> 6) | ((e >> 3) & 8)))
      );
    }
    var a = "a".charCodeAt(0) - 10;
    var c = "0".charCodeAt(0);
    function h(A, e, t) {
      let i = 0;
      for (let r = 0; r < t; r++) {
        let t = e[r] >>> 4;
        A[i++] = t > 9 ? t + a : t + c;
        t = e[r] & 15;
        A[i++] = t > 9 ? t + a : t + c;
      }
      return String.fromCharCode.apply(null, A);
    }
    var l =
      n !== null
        ? (A) => {
            if (typeof A == "string") {
              const e = n.from(A, "utf8");
              return new Uint8Array(e.buffer, e.byteOffset, e.length);
            }
            if (n.isBuffer(A)) {
              return new Uint8Array(A.buffer, A.byteOffset, A.length);
            }
            if (ArrayBuffer.isView(A)) {
              return new Uint8Array(A.buffer, A.byteOffset, A.byteLength);
            }
            throw new Error("Invalid data type!");
          }
        : (A) => {
            if (typeof A == "string") {
              return s.encode(A);
            }
            if (ArrayBuffer.isView(A)) {
              return new Uint8Array(A.buffer, A.byteOffset, A.byteLength);
            }
            throw new Error("Invalid data type!");
          };
    var I = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var g = new Uint8Array(256);
    for (let A = 0; A < I.length; A++) {
      g[I.charCodeAt(A)] = A;
    }
    function B(A) {
      const e = (function (A) {
        let e = Math.floor(A.length * 0.75);
        const t = A.length;
        if (A[t - 1] === "=") {
          e -= 1;
          if (A[t - 2] === "=") {
            e -= 1;
          }
        }
        return e;
      })(A);
      const t = A.length;
      const i = new Uint8Array(e);
      let r = 0;
      for (let e = 0; e < t; e += 4) {
        const t = g[A.charCodeAt(e)];
        const n = g[A.charCodeAt(e + 1)];
        const s = g[A.charCodeAt(e + 2)];
        const o = g[A.charCodeAt(e + 3)];
        i[r] = (t << 2) | (n >> 4);
        r += 1;
        i[r] = ((n & 15) << 4) | (s >> 2);
        r += 1;
        i[r] = ((s & 3) << 6) | (o & 63);
        r += 1;
      }
      return i;
    }
    var u = 16384;
    var Q = new i();
    var w = new Map();
    function C(A, t) {
      return e(this, undefined, undefined, function* () {
        let i = null;
        let r = null;
        let n = false;
        if (typeof WebAssembly == "undefined") {
          throw new Error("WebAssembly is not supported in this environment!");
        }
        const s = () =>
          new DataView(i.exports.memory.buffer).getUint32(
            i.exports.STATE_SIZE,
            true,
          );
        const a = Q.dispatch(() =>
          e(this, undefined, undefined, function* () {
            if (!w.has(A.name)) {
              const e = B(A.data);
              const t = WebAssembly.compile(e);
              w.set(A.name, t);
            }
            const e = yield w.get(A.name);
            i = yield WebAssembly.instantiate(e, {});
          }),
        );
        const c = (A = null) => {
          n = true;
          i.exports.Hash_Init(A);
        };
        const I = (A) => {
          if (!n) {
            throw new Error("update() called before init()");
          }
          ((A) => {
            let e = 0;
            while (e < A.length) {
              const t = A.subarray(e, e + u);
              e += t.length;
              r.set(t);
              i.exports.Hash_Update(t.length);
            }
          })(l(A));
        };
        const g = new Uint8Array(t * 2);
        const C = (A, e = null) => {
          if (!n) {
            throw new Error("digest() called before init()");
          }
          n = false;
          i.exports.Hash_Final(e);
          if (A === "binary") {
            return r.slice(0, t);
          } else {
            return h(g, r, t);
          }
        };
        const E = (A) =>
          typeof A == "string" ? A.length < 4096 : A.byteLength < u;
        let f = E;
        switch (A.name) {
          case "argon2":
          case "scrypt":
            f = () => true;
            break;
          case "blake2b":
          case "blake2s":
            f = (A, e) => e <= 512 && E(A);
            break;
          case "blake3":
            f = (A, e) => e === 0 && E(A);
            break;
          case "xxhash64":
          case "xxhash3":
          case "xxhash128":
            f = () => false;
        }
        yield (() =>
          e(this, undefined, undefined, function* () {
            if (!i) {
              yield a;
            }
            const A = i.exports.Hash_GetBuffer();
            const e = i.exports.memory.buffer;
            r = new Uint8Array(e, A, u);
          }))();
        return {
          getMemory: () => r,
          writeMemory: (A, e = 0) => {
            r.set(A, e);
          },
          getExports: () => i.exports,
          setMemorySize: (A) => {
            i.exports.Hash_SetMemorySize(A);
            const e = i.exports.Hash_GetBuffer();
            const t = i.exports.memory.buffer;
            r = new Uint8Array(t, e, A);
          },
          init: c,
          update: I,
          digest: C,
          save: () => {
            if (!n) {
              throw new Error(
                "save() can only be called after init() and before digest()",
              );
            }
            const e = i.exports.Hash_GetState();
            const t = s();
            const r = i.exports.memory.buffer;
            const a = new Uint8Array(r, e, t);
            const c = new Uint8Array(4 + t);
            (function (A, e) {
              const t = e.length >> 1;
              for (let i = 0; i < t; i++) {
                const t = i << 1;
                A[i] = o(e.charCodeAt(t), e.charCodeAt(t + 1));
              }
            })(c, A.hash);
            c.set(a, 4);
            return c;
          },
          load: (e) => {
            if (!(e instanceof Uint8Array)) {
              throw new Error(
                "load() expects an Uint8Array generated by save()",
              );
            }
            const t = i.exports.Hash_GetState();
            const r = s();
            const a = 4 + r;
            const c = i.exports.memory.buffer;
            if (e.length !== a) {
              throw new Error(
                `Bad state length (expected ${a} bytes, got ${e.length})`,
              );
            }
            if (
              !(function (A, e) {
                if (A.length !== e.length * 2) {
                  return false;
                }
                for (let t = 0; t < e.length; t++) {
                  const i = t << 1;
                  if (e[t] !== o(A.charCodeAt(i), A.charCodeAt(i + 1))) {
                    return false;
                  }
                }
                return true;
              })(A.hash, e.subarray(0, 4))
            ) {
              throw new Error(
                "This state was written by an incompatible hash implementation",
              );
            }
            const h = e.subarray(4);
            new Uint8Array(c, t, r).set(h);
            n = true;
          },
          calculate: (A, e = null, n = null) => {
            if (!f(A, e)) {
              c(e);
              I(A);
              return C("hex", n);
            }
            const s = l(A);
            r.set(s);
            i.exports.Hash_Calculate(s.length, e, n);
            return h(g, r, t);
          },
          hashLength: t,
        };
      });
    }
    new i();
    new i();
    new DataView(new ArrayBuffer(4));
    new i();
    new i();
    new i();
    new i();
    new i();
    new i();
    new i();
    var E = {
      name: "sha3",
      data: "AGFzbQEAAAABFARgAAF/YAF/AGACf38AYAN/f38AAwgHAAEBAgEAAwUEAQECAgYOAn8BQZCNBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKqBwHBQBBgAoL1wMAQQBCADcDgI0BQQBCADcD+IwBQQBCADcD8IwBQQBCADcD6IwBQQBCADcD4IwBQQBCADcD2IwBQQBCADcD0IwBQQBCADcDyIwBQQBCADcDwIwBQQBCADcDuIwBQQBCADcDsIwBQQBCADcDqIwBQQBCADcDoIwBQQBCADcDmIwBQQBCADcDkIwBQQBCADcDiIwBQQBCADcDgIwBQQBCADcD+IsBQQBCADcD8IsBQQBCADcD6IsBQQBCADcD4IsBQQBCADcD2IsBQQBCADcD0IsBQQBCADcDyIsBQQBCADcDwIsBQQBCADcDuIsBQQBCADcDsIsBQQBCADcDqIsBQQBCADcDoIsBQQBCADcDmIsBQQBCADcDkIsBQQBCADcDiIsBQQBCADcDgIsBQQBCADcD+IoBQQBCADcD8IoBQQBCADcD6IoBQQBCADcD4IoBQQBCADcD2IoBQQBCADcD0IoBQQBCADcDyIoBQQBCADcDwIoBQQBCADcDuIoBQQBCADcDsIoBQQBCADcDqIoBQQBCADcDoIoBQQBCADcDmIoBQQBCADcDkIoBQQBCADcDiIoBQQBCADcDgIoBQQBBwAwgAEEBdGtBA3Y2AoyNAUEAQQA2AoiNAQuMAwEIfwJAQQAoAoiNASIBQQBIDQBBACABIABqQQAoAoyNASICcDYCiI0BAkACQCABDQBBgAohAwwBCwJAIAIgAWsiBCAAIAQgAEkbIgNFDQAgA0EDcSEFQQAhBgJAIANBBEkNACABQYCKAWohByADQXxxIQhBACEGA0AgByAGaiIDQcgBaiAGQYAKai0AADoAACADQckBaiAGQYEKai0AADoAACADQcoBaiAGQYIKai0AADoAACADQcsBaiAGQYMKai0AADoAACAIIAZBBGoiBkcNAAsLIAVFDQAgAUHIiwFqIQMDQCADIAZqIAZBgApqLQAAOgAAIAZBAWohBiAFQX9qIgUNAAsLIAQgAEsNAUHIiwEgAhADIAAgBGshACAEQYAKaiEDCwJAIAAgAkkNAANAIAMgAhADIAMgAmohAyAAIAJrIgAgAk8NAAsLIABFDQBBACECQcgBIQYDQCAGQYCKAWogAyAGakG4fmotAAA6AAAgBkEBaiEGIAAgAkEBaiICQf8BcUsNAAsLC+QLAS1+IAApA0AhAkEAKQPAigEhAyAAKQM4IQRBACkDuIoBIQUgACkDMCEGQQApA7CKASEHIAApAyghCEEAKQOoigEhCSAAKQMgIQpBACkDoIoBIQsgACkDGCEMQQApA5iKASENIAApAxAhDkEAKQOQigEhDyAAKQMIIRBBACkDiIoBIREgACkDACESQQApA4CKASETQQApA8iKASEUAkACQCABQcgASw0AQQApA9CKASEVQQApA+CKASEWQQApA9iKASEXDAELQQApA+CKASAAKQNghSEWQQApA9iKASAAKQNYhSEXQQApA9CKASAAKQNQhSEVIBQgACkDSIUhFCABQekASQ0AQQBBACkD6IoBIAApA2iFNwPoigFBAEEAKQPwigEgACkDcIU3A/CKAUEAQQApA/iKASAAKQN4hTcD+IoBQQBBACkDgIsBIAApA4ABhTcDgIsBIAFBiQFJDQBBAEEAKQOIiwEgACkDiAGFNwOIiwELIAMgAoUhGCAFIASFIRkgByAGhSEHIAkgCIUhCCALIAqFIRogDSAMhSEJIA8gDoUhCiARIBCFIQsgEyAShSEMQQApA7iLASESQQApA5CLASETQQApA+iKASEbQQApA6CLASEcQQApA/iKASENQQApA7CLASEdQQApA4iLASEOQQApA8CLASEPQQApA5iLASEeQQApA/CKASEQQQApA6iLASERQQApA4CLASEfQcB+IQADQCAaIAcgC4UgF4UgH4UgEYVCAYmFIBSFIBCFIB6FIA+FIQIgDCAZIAqFIBaFIA6FIB2FQgGJhSAIhSAVhSANhSAchSIDIAeFISAgCSAIIAyFIBWFIA2FIByFQgGJhSAYhSAbhSAThSAShSIEIA+FISEgGCAKIBQgGoUgEIUgHoUgD4VCAYmFIBmFIBaFIA6FIB2FIgWFQjeJIiIgCyAYIAmFIBuFIBOFIBKFQgGJhSAHhSAXhSAfhSARhSIGIAqFQj6JIiNCf4WDIAMgEYVCAokiJIUhDyANIAKFQimJIiUgBCAQhUIniSImQn+FgyAihSERIBIgBYVCOIkiEiAGIA6FQg+JIidCf4WDIAMgF4VCCokiKIUhDiAEIBqFQhuJIikgKCAIIAKFQiSJIipCf4WDhSENIAYgGYVCBokiKyADIAuFQgGJIixCf4WDIBwgAoVCEokiLYUhECArIAQgHoVCCIkiLiAbIAWFQhmJIhtCf4WDhSEXIAYgHYVCPYkiGSAEIBSFQhSJIgQgCSAFhUIciSIIQn+Fg4UhFCAIIBlCf4WDIAMgH4VCLYkiA4UhGCAZIANCf4WDIBUgAoVCA4kiCYUhGSAEIAMgCUJ/hYOFIQcgCSAEQn+FgyAIhSEIIAwgAoUiAiAhQg6JIgNCf4WDIBMgBYVCFYkiBIUhCSAGIBaFQiuJIgUgAyAEQn+Fg4UhCiAEIAVCf4WDICBCLIkiBIUhCyAAQdAJaikDACAFIARCf4WDhSAChSEMICcgKEJ/hYMgKoUiBSEfIAMgBCACQn+Fg4UiAiEaICogKUJ/hYMgEoUiAyEeIC0gLkJ/hYMgG4UiBCEWICYgJCAlQn+Fg4UiBiEdIBsgK0J/hYMgLIUiKCEVICMgJiAiQn+Fg4UiIiEcIC4gLCAtQn+Fg4UiJiEbICcgKSASQn+Fg4UiJyETICMgJEJ/hYMgJYUiIyESIABBCGoiAA0AC0EAIBE3A6iLAUEAIAU3A4CLAUEAIBc3A9iKAUEAIAc3A7CKAUEAIAs3A4iKAUEAIA83A8CLAUEAIAM3A5iLAUEAIBA3A/CKAUEAIBQ3A8iKAUEAIAI3A6CKAUEAIAY3A7CLAUEAIA43A4iLAUEAIAQ3A+CKAUEAIBk3A7iKAUEAIAo3A5CKAUEAICI3A6CLAUEAIA03A/iKAUEAICg3A9CKAUEAIAg3A6iKAUEAIAw3A4CKAUEAICM3A7iLAUEAICc3A5CLAUEAICY3A+iKAUEAIBg3A8CKAUEAIAk3A5iKAQv4AgEFf0HkAEEAKAKMjQEiAUEBdmshAgJAQQAoAoiNASIDQQBIDQAgASEEAkAgASADRg0AIANByIsBaiEFQQAhAwNAIAUgA2pBADoAACADQQFqIgMgAUEAKAKIjQEiBGtJDQALCyAEQciLAWoiAyADLQAAIAByOgAAIAFBx4sBaiIDIAMtAABBgAFyOgAAQciLASABEANBAEGAgICAeDYCiI0BCwJAIAJBBEkNACACQQJ2IgNBA3EhBUEAIQQCQCADQX9qQQNJDQAgA0H8////A3EhAUEAIQNBACEEA0AgA0GACmogA0GAigFqKAIANgIAIANBhApqIANBhIoBaigCADYCACADQYgKaiADQYiKAWooAgA2AgAgA0GMCmogA0GMigFqKAIANgIAIANBEGohAyABIARBBGoiBEcNAAsLIAVFDQAgBUECdCEBIARBAnQhAwNAIANBgApqIANBgIoBaigCADYCACADQQRqIQMgAUF8aiIBDQALCwsGAEGAigEL0QYBA39BAEIANwOAjQFBAEIANwP4jAFBAEIANwPwjAFBAEIANwPojAFBAEIANwPgjAFBAEIANwPYjAFBAEIANwPQjAFBAEIANwPIjAFBAEIANwPAjAFBAEIANwO4jAFBAEIANwOwjAFBAEIANwOojAFBAEIANwOgjAFBAEIANwOYjAFBAEIANwOQjAFBAEIANwOIjAFBAEIANwOAjAFBAEIANwP4iwFBAEIANwPwiwFBAEIANwPoiwFBAEIANwPgiwFBAEIANwPYiwFBAEIANwPQiwFBAEIANwPIiwFBAEIANwPAiwFBAEIANwO4iwFBAEIANwOwiwFBAEIANwOoiwFBAEIANwOgiwFBAEIANwOYiwFBAEIANwOQiwFBAEIANwOIiwFBAEIANwOAiwFBAEIANwP4igFBAEIANwPwigFBAEIANwPoigFBAEIANwPgigFBAEIANwPYigFBAEIANwPQigFBAEIANwPIigFBAEIANwPAigFBAEIANwO4igFBAEIANwOwigFBAEIANwOoigFBAEIANwOgigFBAEIANwOYigFBAEIANwOQigFBAEIANwOIigFBAEIANwOAigFBAEHADCABQQF0a0EDdjYCjI0BQQBBADYCiI0BIAAQAkHkAEEAKAKMjQEiAEEBdmshAwJAQQAoAoiNASIBQQBIDQAgACEEAkAgACABRg0AIAFByIsBaiEFQQAhAQNAIAUgAWpBADoAACABQQFqIgEgAEEAKAKIjQEiBGtJDQALCyAEQciLAWoiASABLQAAIAJyOgAAIABBx4sBaiIBIAEtAABBgAFyOgAAQciLASAAEANBAEGAgICAeDYCiI0BCwJAIANBBEkNACADQQJ2IgFBA3EhBUEAIQQCQCABQX9qQQNJDQAgAUH8////A3EhAEEAIQFBACEEA0AgAUGACmogAUGAigFqKAIANgIAIAFBhApqIAFBhIoBaigCADYCACABQYgKaiABQYiKAWooAgA2AgAgAUGMCmogAUGMigFqKAIANgIAIAFBEGohASAAIARBBGoiBEcNAAsLIAVFDQAgBUECdCEAIARBAnQhAQNAIAFBgApqIAFBgIoBaigCADYCACABQQRqIQEgAEF8aiIADQALCwsL2AEBAEGACAvQAZABAAAAAAAAAAAAAAAAAAABAAAAAAAAAIKAAAAAAAAAioAAAAAAAIAAgACAAAAAgIuAAAAAAAAAAQAAgAAAAACBgACAAAAAgAmAAAAAAACAigAAAAAAAACIAAAAAAAAAAmAAIAAAAAACgAAgAAAAACLgACAAAAAAIsAAAAAAACAiYAAAAAAAIADgAAAAAAAgAKAAAAAAACAgAAAAAAAAIAKgAAAAAAAAAoAAIAAAACAgYAAgAAAAICAgAAAAAAAgAEAAIAAAAAACIAAgAAAAIA=",
      hash: "f2f6f5b2",
    };
    var f = new i();
    var d = null;
    function p(A) {
      if ([224, 256, 384, 512].includes(A)) {
        return null;
      } else {
        return new Error("Invalid variant! Valid values: 224, 256, 384, 512");
      }
    }
    new i();
    new i();
    new i();
    new i();
    new i();
    new i();
    new i();
    new ArrayBuffer(8);
    new i();
    new ArrayBuffer(8);
    new i();
    new ArrayBuffer(8);
    new i();
    new i();
    new i();
    A.$hashWasm = {
      sha3: function (A, t = 512) {
        if (p(t)) {
          return Promise.reject(p(t));
        }
        const i = t / 8;
        if (d === null || d.hashLength !== i) {
          return (function (A, t, i) {
            return e(this, undefined, undefined, function* () {
              const e = yield A.lock();
              const r = yield C(t, i);
              e();
              return r;
            });
          })(f, E, i).then((e) => (d = e).calculate(A, t, 6));
        }
        try {
          const e = d.calculate(A, t, 6);
          return Promise.resolve(e);
        } catch (A) {
          return Promise.reject(A);
        }
      },
    };
  })();
  (() => {
    const { $utils: e } = A;
    e.createPromise = () => {
      let A = null;
      let e = null;
      const t = new Promise((t, i) => {
        A = t;
        e = i;
      });
      Object.defineProperty(t, "resolve", {
        get: () => A,
      });
      Object.defineProperty(t, "reject", {
        get: () => e,
      });
      return t;
    };
  })();
  (() => {
    const { $utils: e } = A;
    e.is = {
      null: (A) => A === null,
      defined: (A) => A !== undefined,
      undefined: (A) => A === undefined,
      nil: (A) => A == null,
      boolean: (A) => typeof A == "boolean",
      number: (A) => typeof A == "number",
      string: (A) => typeof A == "string",
      symbol: (A) => typeof A == "symbol",
      function: (A) => typeof A == "function",
      map: (A) => A instanceof Map,
      set: (A) => A instanceof Set,
      url: (A) => A instanceof URL,
      blob: (A) => A instanceof Blob,
      file: (A) => A instanceof File,
      error: (A) => A instanceof Error,
      regexp: (A) => A instanceof RegExp,
      array: (A) => Array.isArray(A),
      object: (A) => Object.prototype.toString.call(A) === "[object Object]",
      nan: (A) => Number.isNaN(A),
      nonPrimitive: (A) => e.is.object(A) || e.is.array(A),
      numeric: (A) => !e.is.nan(Number(A)),
      empty: (A) =>
        !!e.is.nil(A) ||
        (e.is.array(A)
          ? A.length === 0
          : e.is.object(A)
            ? Object.keys(A).length === 0
            : !!e.is.string(A) && A.trim().length === 0),
    };
  })();
  (() => {
    const { $utils: e, $bus: t } = A;
    e.objectUrl = {
      create(A, i = false) {
        if (!URL.createObjectURL) {
          return t.send("utils.objectUrl.create", A, i);
        }
        const r = URL.createObjectURL(A);
        if (i) {
          const A = e.is.number(i) ? i : 60000;
          setTimeout(() => URL.revokeObjectURL(r), A);
        }
        return r;
      },
      revoke(A) {
        if (!URL.revokeObjectURL) {
          return t.send("utils.objectUrl.revoke", A);
        }
        URL.revokeObjectURL(A);
      },
    };
  })();
  (() => {
    const { $utils: e } = A;
    e.pickRandom = (A) => A[Math.floor(Math.random() * A.length)];
  })();
  Array.prototype.toReversed &&= function () {
    return [...this].reverse();
  };
  Array.prototype.at ||= function (A) {
    return this[A >= 0 ? A : this.length + A];
  };
  Array.prototype.findLastIndex ||= function (A, e) {
    for (let t = this.length - 1; t >= 0; t--) {
      if (A.call(e, this[t], t, this)) {
        return t;
      }
    }
    return -1;
  };
  (() => {
    const { $utils: e } = A;
    e.sleep = async (A) =>
      new Promise((e) => {
        setTimeout(e, A);
      });
  })();
  (() => {
    const { $utils: e } = A;
    e.waitFor = async (A, { interval: t = 100, timeout: i = 60000 } = {}) => {
      if (i <= 0) {
        throw new Error("$utils.waitFor: timeout exceeded");
      }
      const r = Date.now();
      const n = await A();
      if (n) {
        return n;
      }
      await e.sleep(t);
      const s = Date.now() - r;
      return e.waitFor(A, {
        interval: t,
        timeout: i - s,
      });
    };
  })();
  (() => {
    const { $ai: e, $utils: t, $bus: i, $hashWasm: r } = A;
    e.arkoseController = {
      init() {
        this._arkose = null;
        this._setupPromise = null;
        this._firstTimeFetchToken = true;
        this._fetchTokenPromise = t.createPromise();
        i.on("ai.retrieveArkoseToken", this._retrieveArkoseToken, this);
        i.on("ai.generateProofToken", this._generateProofToken, this);
      },
      async _retrieveArkoseToken({ dx: A, config: e, accessToken: i }) {
        await this._ensureSetup(e, i);
        this._arkose.setConfig({
          [e.dataKey]: {
            [e.blobKey]: A,
          },
        });
        if (this._firstTimeFetchToken) {
          this._arkose.run();
          this._firstTimeFetchToken = false;
        } else {
          this._fetchTokenPromise = t.createPromise();
          this._arkose.reset();
        }
        const r = setTimeout(
          () => this._fetchTokenPromise.reject("Token fetching timed out"),
          e.tokenFetchTimeout,
        );
        const n = await this._fetchTokenPromise;
        clearTimeout(r);
        return n;
      },
      async _generateProofToken({
        seed: A,
        difficulty: e,
        scripts: i,
        dpl: n,
      }) {
        try {
          const s = (A) => {
            const e = JSON.stringify(A);
            return btoa(String.fromCharCode(...new TextEncoder().encode(e)));
          };
          const o = performance.now();
          const a = Object.keys(Object.getPrototypeOf(navigator));
          const c = t.pickRandom(a);
          const h = [
            navigator.hardwareConcurrency + screen.width + screen.height,
            new Date().toString(),
            performance.memory.jsHeapSizeLimit,
            Math.random(),
            navigator.userAgent,
            t.pickRandom(i),
            n,
            navigator.language,
            navigator.languages.join(","),
            Math.random(),
            `${c}-${navigator[c]}`,
            t.pickRandom(Object.keys(document)),
            t.pickRandom(Object.keys(window)),
            performance.now(),
            crypto.randomUUID(),
          ];
          for (let i = 1; i < 100000; i++) {
            if (i % 1000 == 0) {
              await t.sleep(150);
            }
            h[3] = i;
            h[9] = Math.round(performance.now() - o);
            const n = s(h);
            if ((await r.sha3(`${A}${n}`)).substring(0, e.length) <= e) {
              return n;
            }
          }
          return null;
        } catch (error) {
          console.error("[oi.js] _generateProofToken error:", error);
          // Return structured error instead of throwing
          return { error: error.message || "Failed to generate proof token" };
        }
      },
      async _ensureSetup(A, e) {
        if (this._setupPromise) {
          return this._setupPromise;
        }
        this._setupPromise = t.createPromise();
        this._patchArkoseIframe(A);
        window.useArkoseSetupEnforcement = async (e) => {
          e.setConfig({
            ...A.params,
            [A.selectorKey]: "#challenge",
            [A.onErrorKey]: (A) => {
              this._fetchTokenPromise.reject(A);
            },
            [A.onCompletedKey]: (e) => {
              this._fetchTokenPromise.resolve(e[A.resultTokenKey]);
            },
          });
          this._arkose = e;
        };
        if (!document.getElementById("challenge")) {
          const A = document.createElement("div");
          A.id = "challenge";
          document.body.appendChild(A);
        }
        const i = document.createElement("script");
        const r = A.script;
        Object.entries(r).forEach(([A, e]) => i.setAttribute(A, e));
        document.head.appendChild(i);
        await new Promise((e, t) => {
          const r = setTimeout(() => {
            t("Script loading timed out");
          }, A.scriptLoadTimeout);
          i.onload = () => {
            clearTimeout(r);
            i.setAttribute("data-status", "loaded");
            e();
          };
          i.onerror = () => {
            clearTimeout(r);
            i.setAttribute("data-status", "failed");
            t("Script loading failed");
          };
        });
        this._setupPromise.resolve();
      },
      _patchArkoseIframe(A) {
        const e = HTMLElement.prototype.appendChild;
        HTMLElement.prototype.appendChild = function (...i) {
          const r = i[0];
          if (
            r &&
            t.is.string(r.tagName) &&
            r.tagName.toLowerCase() === "iframe" &&
            r.src.startsWith(A.iframeUrl)
          ) {
            r.setAttribute("name", `ae:${JSON.stringify(A)}`);
          }
          return e.call(this, ...i);
        };
      },
    };
  })();
  (() => {
    const { $ai: e } = A;
    e.controller = {
      init() {
        e.arkoseController.init();
      },
    };
  })();

  // register canonical ai handlers (no HTOS fallbacks). These bind the
  // public A.$ai.retrieveArkoseToken / A.$ai.generateProofToken to the
  // internal arkoseController methods so callers can use the canonical names.
  (() => {
    const { $ai: e } = A;
    try {
      if (e && e.arkoseController) {
        e.retrieveArkoseToken =
          e.retrieveArkoseToken ||
          e.arkoseController._retrieveArkoseToken.bind(e.arkoseController);
        e.generateProofToken =
          e.generateProofToken ||
          e.arkoseController._generateProofToken.bind(e.arkoseController);
      }
    } catch (err) {
      /* ignore */
    }
  })();

  (() => {
    const { $bus: e, $env: t, $utils: i } = A;
    e.controller = {
      async init() {
        e.on = this.on.bind(this);
        e.off = this.off.bind(this);
        e.once = this.once.bind(this);
        e.send = this._wrapThrowIfError(this.send);
        e.call = this._wrapThrowIfError(this.call);
        e.poll = this.poll.bind(this);
        e.getTabId = this.getTabId.bind(this);
        this._locus = t.getLocus();
        this._serialize = this._serialize.bind(this);
        this._handlers = {};
        if (this._is("pp")) {
          this._setupPp();
          this._tabId = await e.getTabId();
        } else if (this._is("bg")) {
          this._blobs = {};
          this._channel = new BroadcastChannel("bus.channel");
          this._setupBg();
        } else if (this._is("cs")) {
          await this._setupCs();
        } else if (this._is("nj")) {
          this._setupNj();
        } else if (this._is("os")) {
          e.setIframe = (A) => (this._iframe = A);
          this._iframe = null;
          this._channel = new BroadcastChannel("bus.channel");
          this._setupOs();
        } else if (this._is("oi")) {
          this._setupOi();
        }
      },
      on(A, e, t = null) {
        this._on(A, null, e, t);
      },
      off(A, e = null) {
        this._off(A, null, e);
      },
      once(A, e) {
        const t = async (...i) => {
          this.off(A, t);
          return await e(...i);
        };
        this.on(A, t);
      },
      async send(A, ...t) {
        if (i.is.numeric(A)) {
          const e = Number(A);
          A = t[0];
          t = t.slice(1);
          return await this._pick([
            this._sendToCs(e, A, ...t),
            this._sendToExt(e, A, ...t),
          ]);
        }
        if (this._is("pp")) {
          return await this._sendToExt(A, ...t);
        }
        if (this._is("nj")) {
          return await this._sendToPage(A, ...t);
        }
        if (this._is("oi")) {
          return await this._sendToParent(A, ...t);
        }
        if (this._is("bg", "cs", "os")) {
          return await this._pick([
            this._sendToExt(A, ...t),
            this._callHandlers(
              {
                name: A,
                args: t,
              },
              (A) => A.proxy,
            ),
          ]);
        }
        if (this._is("fg")) {
          if (A === "store.actions") {
            return;
          }
          if (A === "idb.change") {
            return;
          }
          e.log(A, ...t);
        }
      },
      async call(A, ...e) {
        return this._callHandlers(
          {
            name: A,
            args: e,
          },
          (A) => !A.proxy,
        );
      },
      async poll(A, ...e) {
        return await i.waitFor(() => this.send(A, ...e));
      },
      async getTabId() {
        if (this._is("bg")) {
          return null;
        }
        if (this._is("pp")) {
          const A = new URL(location.href).searchParams.get("tabId");
          if (A) {
            return Number(A);
          }
        }
        const { tabId: A } = await this.send("bus.getTabData");
        return A;
      },
      _on(A, e, t, i = null) {
        this._handlers[A] ||= [];
        if (this._is("cs", "nj", "oi") && this._handlers[A].length === 0) {
          this._sendToProxier("bus.proxy", A, true);
        }
        const r = {
          fn: t,
          name: A,
        };
        if (e) {
          r.proxy = e;
        }
        if (i) {
          r.this = i;
        }
        this._handlers[A].push(r);
      },
      _off(A, e = null, t = null) {
        if (this._handlers[A]) {
          this._handlers[A] = this._handlers[A].filter((A) => {
            const i = !t || t === A.fn;
            const r = e === (A.proxy || null);
            return !i || !r;
          });
          if (this._handlers[A].length === 0) {
            delete this._handlers[A];
            if (this._is("cs", "nj", "oi")) {
              this._sendToProxier("bus.proxy", A, false);
            }
          }
        }
      },
      _setupPp() {},
      _setupBg() {},
      async _setupCs() {},
      _setupNj() {},
      _setupOs() {},
      _setupOi() {
        window.addEventListener("message", async ({ data: A }) => {
          if (!this._isBusMsg(A)) {
            return;
          }
          const e = await this._callHandlers(A);
          window.parent.postMessage(
            {
              resId: A.reqId,
              result: e,
            },
            "*",
          );
        });
      },
      async _sendToExt(A, ...t) {
        let r = null;
        if (i.is.numeric(A)) {
          r = Number(A);
          A = t[0];
          t = t.slice(1);
        }
        const n = this._serialize(t);
        const s = this._createBusMsg({
          name: A,
          argsStr: n,
          target: r,
        });
        const o = await new Promise((A) => {
          try {
            chrome.runtime.sendMessage(s, (e) => {
              if (chrome.runtime.lastError) {
                A(null);
              } else {
                A(e);
              }
            });
          } catch (t) {
            if (t.message === "Extension context invalidated.") {
              return;
            }
            e.error(t);
            A(null);
          }
        });
        return await this._deserialize(o);
      },
      async _sendToCs(A, e, ...t) {
        if (!chrome.tabs?.sendMessage) {
          return await this.send("bus.sendToCs", A, e, ...t);
        }
        const i = this._serialize(t);
        const r = this._createBusMsg({
          name: e,
          argsStr: i,
          target: "cs",
        });
        const n = await new Promise((e) => {
          chrome.tabs.sendMessage(A, r, (A) => {
            if (chrome.runtime.lastError) {
              e(null);
            } else {
              e(A);
            }
          });
        });
        return await this._deserialize(n);
      },
      async _sendToPage(A, ...e) {
        const t = this._generateId();
        const i = this._createBusMsg({
          name: A,
          args: e,
          reqId: t,
          locus: this._locus,
        });
        window.postMessage(i, "*");
        return await this._waitForResponseMessage(t);
      },
      async _sendToIframe(A, ...e) {
        if (!this._iframe) {
          return null;
        }
        const t = this._generateId();
        const i = this._createBusMsg({
          name: A,
          args: e,
          reqId: t,
        });
        this._iframe.contentWindow.postMessage(i, "*");
        return await this._waitForResponseMessage(t);
      },
      async _sendToParent(A, ...e) {
        const t = this._generateId();
        const i = this._createBusMsg({
          name: A,
          args: e,
          reqId: t,
        });
        parent.postMessage(i, "*");
        return await this._waitForResponseMessage(t);
      },
      async _sendToProxier(A, ...e) {
        if (this._is("cs")) {
          return await this._sendToExt(A, ...e);
        } else if (this._is("nj")) {
          return await this._sendToPage(A, ...e);
        } else if (this._is("oi")) {
          return await this._sendToParent(A, ...e);
        } else {
          return undefined;
        }
      },
      _waitForResponseMessage: async (A) =>
        await new Promise((e) => {
          const t = ({ data: i }) => {
            if (!!i && i.resId === A) {
              window.removeEventListener("message", t);
              e(i.result);
            }
          };
          window.addEventListener("message", t);
        }),
      _callHandlers({ name: A, args: t, argsStr: i } = {}, r = null) {
        let n = this._handlers[A];
        if (n) {
          if (r) {
            n = n.filter(r);
          }
          if (n.length === 0) {
            return null;
          } else {
            return new Promise(async (resolve) => {
              // If args were serialized, deserialize them; ensure args is an array
              if (i) {
                const des = await this._deserialize(i);
                if (Array.isArray(des)) {
                  t = des;
                } else if (des === null || des === undefined) {
                  t = [];
                } else {
                  t = [des];
                }
              }
              if (!t) t = [];
              resolve(
                await this._pick(
                  n.map(async (handler) => {
                    try {
                      return await handler.fn.call(handler.this, ...t);
                    } catch (err) {
                      e.error(`failed to handle "${handler.name}".`, err);
                      return err;
                    }
                  }),
                ),
              );
            });
          }
        } else {
          return null;
        }
      },
      _removeProxyHandlers(A) {
        Object.keys(this._handlers).forEach((e) => {
          this._handlers[e] = this._handlers[e].filter((e) => e.proxy !== A);
          if (this._handlers[e].length === 0) {
            delete this._handlers[e];
          }
        });
      },
      _serialize(A) {
        if (i.is.nil(A)) {
          return null;
        } else {
          return JSON.stringify(A, (A, e) => {
            if (i.is.blob(e)) {
              if (this._is("bg")) {
                const A = this._generateId();
                this._blobs[A] = e;
                return `bus.blob.${A}`;
              }
              return `bus.blob.${i.objectUrl.create(e, true)}`;
            }
            if (i.is.error(e)) {
              return `bus.error.${e.message}`;
            } else {
              return e;
            }
          });
        }
      },
      async _deserialize(A) {
        if (!i.is.string(A)) {
          return null;
        }
        const e = new Map();
        const t = JSON.parse(A, (A, t) => {
          const r = i.is.string(t);
          if (r && t.startsWith("bus.blob.")) {
            e.set(t, t.slice("bus.blob.".length));
            return t;
          } else if (r && t.startsWith("bus.error.")) {
            return new Error(t.slice("bus.error.".length));
          } else {
            return t;
          }
        });
        await Promise.all(
          [...e.keys()].map(async (A) => {
            let t;
            const i = e.get(A);
            t = i.startsWith("blob:")
              ? i
              : await this._sendToExt("bus.blobIdToObjectUrl", i);
            const r = await fetch(t).then((A) => A.blob());
            e.set(A, r);
          }),
        );
        return this._applyBlobs(t, e);
      },
      _applyBlobs(A, e) {
        if (e.has(A)) {
          return e.get(A);
        }
        if (i.is.array(A) || i.is.object(A)) {
          for (const t in A) {
            A[t] = this._applyBlobs(A[t], e);
          }
        }
        return A;
      },
      async _blobIdToObjectUrl(A) {},
      async _blobToObjectUrl(A) {},
      _is(...A) {
        return A.includes(this._locus);
      },
      // Accept messages from both canonical names to ensure cross-context compatibility
      _isBusMsg: (e) =>
        e && e.$bus && (e.appName === A.name || e.appName === "htos"),
      _createBusMsg: (e) => ({
        $bus: true,
        appName: A.name,
        ...e,
      }),
      _generateId: () =>
        `bus-${Date.now()}-${Math.random().toString(36).slice(2)}`,
      _wrapThrowIfError(A) {
        return async (...e) => {
          const t = await A.call(this, ...e);
          if (i.is.error(t)) {
            throw t;
          }
          return t;
        };
      },
      _pick: async (A = []) =>
        A.length === 0
          ? null
          : await new Promise((e) => {
              let t = 0;
              A.forEach(async (r) => {
                const n = await r;
                if (i.is.nil(n)) {
                  if (t === A.length - 1) {
                    return e(null);
                  } else {
                    t++;
                    return;
                  }
                } else {
                  return e(n);
                }
              });
            }),
    };
  })();
  (() => {
    const { $env: e } = A;
    e.getLocus = () => {
      const { protocol: A, host: e, pathname: t, href: i } = location;
      // CRITICAL FIX: Check for oi.html BEFORE other chrome-extension checks!
      // When running inside offscreen iframe, we're chrome-extension://xxx/oi.html
      if (
        i === "https://htos.io/oi" ||
        i === "http://localhost:3000/oi" ||
        t === "/oi.html" || // EXACT match for extension context
        t.endsWith("/oi.html") ||
        t.endsWith("/oi") ||
        i.includes("/oi.html") ||
        i.includes("/oi")
      ) {
        console.log('[oi.js getLocus] Detected as "oi" context:', {
          protocol: A,
          pathname: t,
          href: i,
        });
        return "oi";
      } else if (A !== "chrome-extension:" && chrome?.runtime?.getURL) {
        return "cs";
      } else if (e === "localhost:3050") {
        return "fg";
      } else if (A !== "chrome-extension:") {
        return "nj";
      } else if (t === "/htos.html") {
        return "pp";
      } else if (t === "/offscreen.html") {
        return "os";
      } else {
        // This would incorrectly catch oi.html without the fix above!
        console.warn(
          '[oi.js getLocus] Defaulting to "bg" context - this may be wrong!',
          { protocol: A, pathname: t, href: i },
        );
        return "bg";
      }
    };
  })();
  (() => {
    const { $startup: e, $bus: t, $ai: i } = A;
    e.controller = {
      async init() {
        await t.controller.init();
        await i.controller.init();
        t.on("startup.oiReady", () => true);
        e.logDev("oi ready");
      },
    };
    e.controller.init();
  })();
})();



================================================
FILE: src/sw-entry.js
================================================
// ============================================================================
// UNIFIED SERVICE WORKER ENTRY POINT
// Combines persistence layer, provider management, and message routing
// ============================================================================
// === bg: idempotent listener registration ===

// Core Infrastructure Imports
import {
  NetRulesManager,
  CSPController,
  UserAgentController,
  ArkoseController,
  BusController,
  LifecycleManager,
  HTOSRequestLifecycleManager,
  utils,
} from "./core/vendor-exports.js";
import { WorkflowCompiler } from "./core/workflow-compiler.js";
import { ContextResolver } from "./core/context-resolver.js";

import { ClaudeAdapter } from "./providers/claude-adapter.js";
import { GeminiAdapter } from "./providers/gemini-adapter.js";
import { ChatGPTAdapter } from "./providers/chatgpt-adapter.js";
import { QwenAdapter } from "./providers/qwen-adapter.js";
import { ClaudeProviderController } from "./providers/claude.js";
import { GeminiProviderController } from "./providers/gemini.js";
import { ChatGPTProviderController } from "./providers/chatgpt.js";
import { QwenProviderController } from "./providers/qwen.js";
import { DNRUtils } from "./core/dnr-utils.js";
import { ConnectionHandler } from "./core/connection-handler.js";
import { authManager } from './core/auth-manager.js';

// Persistence Layer Imports
import { SessionManager } from "./persistence/SessionManager.js";
import { initializePersistenceLayer } from "./persistence/index.js";
import { errorHandler } from "./utils/ErrorHandler.js";
import { persistenceMonitor } from "./core/PersistenceMonitor.js";

// Global Services Registry
import { services } from "./core/service-registry.js";
import { PromptService } from "./core/PromptService.ts";
import { ResponseProcessor } from "./core/ResponseProcessor.ts";

// ============================================================================
// FEATURE FLAGS (Source of Truth)
// ============================================================================
const HTOS_PERSISTENCE_ENABLED = true;

// Ensure fetch is correctly bound
try {
  if (typeof fetch === "function" && typeof globalThis !== "undefined") {
    globalThis.fetch = fetch.bind(globalThis);
  }
} catch (_) { }

// Initialize BusController globally (needed for message bus)
self.BusController = BusController;

// ============================================================================
// LIFECYCLE & STARTUP HANDLERS (Unified)
// ============================================================================

/**
 * Unified startup handler
 * Drives the async initialization sequence for both install and startup events.
 */
async function handleStartup(reason) {
  console.log(`[SW] Startup detected (${reason})`);

  // 1. Initialize Auth Manager
  await authManager.initialize();

  // 2. Load User Preferences (Dependency Injection)
  // We read directly from storage to avoid global state drift
  let prefs = {};
  try {
    prefs = await chrome.storage.local.get([
      "htos_mapping_provider",
      "htos_last_synthesis_model",
      "htos_last_refiner_model"
    ]);
    console.log("[SW] User preferences loaded:", prefs);
  } catch (e) {
    console.warn("[SW] Failed to load preferences:", e);
  }

  // 3. Initialize Global Services with injected prefs
  await initializeGlobalServices(prefs);
}

chrome.runtime.onStartup.addListener(() => handleStartup("startup"));

chrome.runtime.onInstalled.addListener((details) => {
  handleStartup(`installed: ${details.reason}`);
});

// ============================================================================
// CORE SERVICE INITIALIZATION
// ============================================================================

async function initializePersistence() {
  // Check registry first
  if (services.get('persistenceLayer')) {
    return services.get('persistenceLayer');
  }

  const operationId = persistenceMonitor.startOperation(
    "INITIALIZE_PERSISTENCE",
    { useAdapter: true },
  );

  try {
    const pl = await initializePersistenceLayer();
    services.register('persistenceLayer', pl);

    // Legacy global for debug only
    self.__HTOS_PERSISTENCE_LAYER = pl;

    persistenceMonitor.recordConnection("HTOSPersistenceDB", 1, [
      "sessions", "threads", "turns", "provider_responses", "provider_contexts", "metadata",
    ]);
    console.log("[SW] ✅ Persistence layer initialized");
    persistenceMonitor.endOperation(operationId, { success: true });
    return pl;
  } catch (error) {
    persistenceMonitor.endOperation(operationId, null, error);
    const handledError = await errorHandler.handleError(error, {
      operation: "initializePersistence",
      context: { useAdapter: true },
    });
    console.error("[SW] ❌ Failed to initialize:", handledError);
    throw handledError;
  }
}

async function initializeSessionManager(pl) {
  // Check registry first
  if (services.get('sessionManager') && services.get('sessionManager').adapter?.isReady()) {
    return services.get('sessionManager');
  }

  const persistence = pl || services.get('persistenceLayer');
  try {
    console.log("[SW] Creating new SessionManager");
    const sm = new SessionManager();


    await sm.initialize({ adapter: persistence?.adapter });
    services.register('sessionManager', sm);
    console.log("[SW] ✅ SessionManager initialized");
    return sm;
  } catch (error) {
    console.error("[SW] ❌ Failed to initialize SessionManager:", error);
    throw error;
  }
}

// ============================================================================
// PROVIDER ADAPTER REGISTRY
// ============================================================================
class ProviderRegistry {
  constructor() {
    this.adapters = new Map();
    this.controllers = new Map();
  }
  register(providerId, controller, adapter) {
    this.controllers.set(providerId, controller);
    this.adapters.set(providerId, adapter);
  }
  getAdapter(providerId) {
    return this.adapters.get(String(providerId).toLowerCase());
  }
  getController(providerId) {
    return this.controllers.get(String(providerId).toLowerCase());
  }
  listProviders() {
    return Array.from(this.adapters.keys());
  }
  isAvailable(providerId) {
    return this.adapters.has(String(providerId).toLowerCase());
  }
}

async function initializeProviders() {
  console.log("[SW] Initializing providers...");

  if (services.get('providerRegistry')) {
    return services.get('providerRegistry').listProviders();
  }

  const providerRegistry = new ProviderRegistry();

  const providerConfigs = [
    { name: "claude", Controller: ClaudeProviderController, Adapter: ClaudeAdapter },
    { name: "gemini", Controller: GeminiProviderController, Adapter: GeminiAdapter },
    {
      name: "gemini-pro",
      Controller: GeminiProviderController,
      Adapter: class extends GeminiAdapter { constructor(controller) { super(controller, "gemini-pro"); } },
    },
    {
      name: "gemini-exp",
      Controller: GeminiProviderController,
      Adapter: class extends GeminiAdapter { constructor(controller) { super(controller, "gemini-exp"); } },
    },
    { name: "chatgpt", Controller: ChatGPTProviderController, Adapter: ChatGPTAdapter },
    { name: "qwen", Controller: QwenProviderController, Adapter: QwenAdapter },
  ];

  const initialized = [];
  for (const config of providerConfigs) {
    try {
      const controller = new config.Controller();
      if (typeof controller.init === "function") await controller.init();
      const adapter = new config.Adapter(controller);
      if (typeof adapter.init === "function") await adapter.init();
      providerRegistry.register(config.name, controller, adapter);
      initialized.push(config.name);
    } catch (e) {
      console.error(`[SW] Failed to initialize ${config.name}:`, e);
    }
  }

  services.register('providerRegistry', providerRegistry);

  if (initialized.length > 0) {
    console.info(`[SW] ✅ Providers initialized: ${initialized.join(", ")}`);
  }
  return providerRegistry.listProviders();
}

// ============================================================================
// ORCHESTRATOR WRAPPER & INIT
// ============================================================================
class FaultTolerantOrchestrator {
  constructor(registry) {
    this.activeRequests = new Map();
    // Use registry directly or pass needed services
    this.registry = registry;
  }

  // Delegate lifecycle manager access to the registry (if we register it)
  get lifecycleManager() {
    return this.registry.get('lifecycleManager');
  }

  // ... (Full implementation of executeParallelFanout from prior version needed here?)
  // NOTE: For brevity in this refactor, I assume the rest of orchestrator logic 
  // is preserved or imported. To be safe, I must include the implementation or logic.
  // The user prompt implied we are FIXING things, so I should probably keep the implementation.
  // I'll keep the implementation from the original file but cleaner.

  async executeSingle(prompt, providerId, options = {}) {
    const { timeout = 60000 } = options;

    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`Request to ${providerId} timed out after ${timeout}ms`));
      }, timeout);

      this.executeParallelFanout(prompt, [providerId], {
        ...options,
        onPartial: options.onPartial || (() => { }),
        onError: (error) => {
          clearTimeout(timeoutId);
          reject(error);
        },
        onAllComplete: (results, errors) => {
          clearTimeout(timeoutId);

          if (errors.has(providerId)) {
            reject(errors.get(providerId));
          } else if (results.has(providerId)) {
            resolve(results.get(providerId));
          } else {
            reject(new Error(`No result from ${providerId}`));
          }
        },
      });
    });
  }

  async _prefetchGeminiTokens(providerRegistry, providers, providerMeta) {
    if (!providerRegistry) return;

    const GEMINI_VARIANT_IDS = ['gemini', 'gemini-pro', 'gemini-exp'];
    const targets = (providers || []).filter((pid) =>
      GEMINI_VARIANT_IDS.includes(String(pid).toLowerCase()),
    );

    if (targets.length < 2) return;

    const concurrencyLimit = Math.min(2, targets.length);
    const queue = [...targets];

    const worker = async () => {
      while (queue.length > 0) {
        const pid = queue.shift();
        if (!pid) return;

        try {
          const controller = providerRegistry.getController(pid);
          if (!controller?.geminiSession?._fetchToken) continue;

          const jitterMs = 50 + Math.floor(Math.random() * 101);
          await new Promise((resolve) => setTimeout(resolve, jitterMs));

          const token = await controller.geminiSession._fetchToken();
          if (!providerMeta[pid]) providerMeta[pid] = {};
          providerMeta[pid]._prefetchedToken = token;
        } catch (_) {
        }
      }
    };

    await Promise.all(
      Array.from({ length: concurrencyLimit }, () => worker()),
    );
  }

  async executeParallelFanout(prompt, providers, options = {}) {
    // ... [Logic identical to original but using this.registry.get('providerRegistry')] ... 
    // Implementing purely to ensure availability
    const {
      sessionId = `req-${Date.now()}`,
      onPartial = () => { },
      onAllComplete = () => { },
      useThinking = false,
      providerContexts = {},
      providerMeta = {},
    } = options;

    if (this.lifecycleManager) this.lifecycleManager.keepalive(true);

    const results = new Map();
    const errors = new Map();
    const abortControllers = new Map();
    this.activeRequests.set(sessionId, { abortControllers });

    const providerRegistry = this.registry.get('providerRegistry');

    await this._prefetchGeminiTokens(providerRegistry, providers, providerMeta);

    const providerPromises = providers.map((providerId) => {
      return (async () => {
        const abortController = new AbortController();
        abortControllers.set(providerId, abortController);

        const adapter = providerRegistry?.getAdapter(providerId);
        if (!adapter) {
          return { providerId, status: "rejected", reason: new Error(`Provider ${providerId} not available`) };
        }

        let aggregatedText = "";
        const startTime = Date.now();

        const request = {
          originalPrompt: prompt,
          sessionId,
          meta: {
            ...(providerContexts[providerId]?.meta || {}),
            ...(providerMeta?.[providerId] || {}),
            useThinking,
          },
        };

        try {
          const providerContext = providerContexts[providerId]?.meta || providerContexts[providerId] || null;
          const onChunk = (chunk) => {
            const textChunk = typeof chunk === "string" ? chunk : chunk.text;
            if (textChunk) aggregatedText += textChunk;
            onPartial(providerId, typeof chunk === "string" ? { text: chunk } : chunk);
          };

          // Inject token
          if (providerMeta?.[providerId]?._prefetchedToken && adapter.controller?.geminiSession) {
            adapter.controller.geminiSession.sharedState = {
              ...adapter.controller.geminiSession.sharedState,
              prefetchedToken: providerMeta[providerId]._prefetchedToken,
            };
          }

          let result;
          if (typeof adapter.ask === "function") {
            result = await adapter.ask(request.originalPrompt, providerContext, sessionId, onChunk, abortController.signal);
          } else {
            result = await adapter.sendPrompt(request, onChunk, abortController.signal);
          }

          if (!result.text && aggregatedText) result.text = aggregatedText;

          // ✅ Granular completion signal
          if (options.onProviderComplete) {
            options.onProviderComplete(providerId, { status: "fulfilled", value: result });
          }

          return { providerId, status: "fulfilled", value: result };

        } catch (error) {
          if (aggregatedText) {
            const val = { text: aggregatedText, meta: {}, softError: { name: error.name, message: error.message } };
            if (options.onProviderComplete) {
              options.onProviderComplete(providerId, { status: "fulfilled", value: val });
            }
            return { providerId, status: "fulfilled", value: val };
          }
          return { providerId, status: "rejected", reason: error };
        }
      })();
    });

    Promise.all(providerPromises).then((settledResults) => {
      settledResults.forEach((item) => {
        if (item.status === "fulfilled") results.set(item.providerId, item.value);
        else errors.set(item.providerId, item.reason);
      });
      onAllComplete(results, errors);
      this.activeRequests.delete(sessionId);
      if (this.lifecycleManager) this.lifecycleManager.keepalive(false);
    });
  }

  _abortRequest(sessionId) {
    const request = this.activeRequests.get(sessionId);
    if (request) {
      request.abortControllers.forEach(c => c.abort());
      this.activeRequests.delete(sessionId);
      if (this.lifecycleManager) this.lifecycleManager.keepalive(false);
    }
  }
}

async function initializeOrchestrator() {
  if (services.get('orchestrator')) return services.get('orchestrator');

  try {
    const lm = new LifecycleManager();
    services.register('lifecycleManager', lm);

    // Legacy global
    self.lifecycleManager = lm;

    const orchestrator = new FaultTolerantOrchestrator(services);
    services.register('orchestrator', orchestrator);

    // Legacy global
    self.faultTolerantOrchestrator = orchestrator;

    console.log("[SW] ✓ FaultTolerantOrchestrator initialized");
    return orchestrator;
  } catch (e) {
    console.error("[SW] Orchestrator init failed", e);
  }
}

// ============================================================================
// GLOBAL SERVICES (Unified Init)
// ============================================================================

let globalServicesPromise = null;

async function initializeGlobalServices(injectedPrefs = {}) {
  // If already running or complete strings, return it.
  // But we want to support re-init with new prefs if strictly requested (rare).
  // For now, simple singleton promise pattern.
  if (globalServicesPromise) return globalServicesPromise;

  globalServicesPromise = (async () => {
    console.log("[SW] 🚀 Initializing global services...", injectedPrefs);

    // Ensure auth manager is ready (idempotent)
    await authManager.initialize();
    services.register('authManager', authManager);

    await initializeGlobalInfrastructure();
    const pl = await initializePersistence();
    const sm = await initializeSessionManager(pl);
    await initializeProviders();
    await initializeOrchestrator();

    // Inject prefs into Compiler
    const compiler = new WorkflowCompiler(sm, injectedPrefs);
    services.register('compiler', compiler);

    const contextResolver = new ContextResolver(sm);
    services.register('contextResolver', contextResolver);

    const promptService = new PromptService();
    services.register('promptService', promptService);

    const responseProcessor = new ResponseProcessor();
    services.register('responseProcessor', responseProcessor);

    console.log("[SW] ✅ Global services registry ready");

    // Return object map for consumers expecting specific structure
    return {
      orchestrator: services.get('orchestrator'),
      sessionManager: sm,
      compiler,
      contextResolver,
      persistenceLayer: pl,
      promptService,
      responseProcessor,
      authManager,
      providerRegistry: services.get('providerRegistry')
    };
  })();
  return globalServicesPromise;
}

async function initializeGlobalInfrastructure() {
  console.log("[SW] Initializing global infrastructure...");
  try {
    await NetRulesManager.init();
    CSPController.init();
    await UserAgentController.init();
    await ArkoseController.init();
    await DNRUtils.initialize();
    await OffscreenController.init();
    await BusController.init();
    self.bus = BusController;
  } catch (e) {
    console.error("[SW] Infra init failed", e);
  }
}

// ============================================================================
// PERSISTENT OFFSCREEN DOCUMENT CONTROLLER
// ============================================================================
const OffscreenController = {
  _initialized: false,
  async init() {
    if (this._initialized) return;
    try {
      if (!(await chrome.offscreen.hasDocument())) {
        await chrome.offscreen.createDocument({
          url: "offscreen.html",
          reasons: [chrome.offscreen.Reason.BLOBS, chrome.offscreen.Reason.DOM_PARSER],
          justification: "HTOS needs persistent offscreen DOM.",
        });
      }
    } catch (_) { }
    this._initialized = true;
  }
};

// ============================================================================
// UNIFIED MESSAGE HANDLER
// ============================================================================
async function handleUnifiedMessage(message, sender, sendResponse) {
  try {
    const svcs = await initializeGlobalServices();
    const sm = svcs.sessionManager;

    if (!sm) {
      sendResponse({ success: false, error: "Service not ready" });
      return true;
    }

    switch (message.type) {
      case "REFRESH_AUTH_STATUS":
        authManager.getAuthStatus(true).then(s => sendResponse({ success: true, data: s })).catch(e => sendResponse({ success: false, error: e.message }));
        return true;

      case "VERIFY_AUTH_TOKEN":
        (async () => {
          const pid = message.payload?.providerId;
          const res = pid ? { [pid]: await authManager.verifyProvider(pid) } : await authManager.verifyAll();
          sendResponse({ success: true, data: res });
        })().catch(e => sendResponse({ success: false, error: e.message }));
        return true;

      case "RUN_ANALYST": {
        (async () => {
          const { fragment, context, authoredPrompt, analystModel, originalPrompt } = message.payload;
          const prompt = svcs.promptService.buildAnalystPrompt(originalPrompt || fragment, context, authoredPrompt);
          const result = await svcs.orchestrator.executeSingle(prompt, analystModel, { timeout: 60000 });
          const content = svcs.responseProcessor.extractContent(result.text);
          const parsed = svcs.responseProcessor.parseAnalystResponse(content);
          sendResponse({ success: true, data: { ...parsed, raw: content } });
        })().catch(e => sendResponse({ success: false, error: e.message }));
        return true;
      }

      case "RUN_COMPOSER": {
        (async () => {
          const { draftPrompt, context, composerModel, analystCritique } = message.payload;
          const prompt = svcs.promptService.buildComposerPrompt(draftPrompt, context, analystCritique);
          const result = await svcs.orchestrator.executeSingle(prompt, composerModel, { timeout: 60000 });
          const content = svcs.responseProcessor.extractContent(result.text);
          const parsed = svcs.responseProcessor.parseComposerResponse(content);
          sendResponse({ success: true, data: { ...parsed, raw: content } });
        })().catch(e => sendResponse({ success: false, error: e.message }));
        return true;
      }

      case "GET_FULL_HISTORY": {
        const allSessions = await sm.adapter.getAllSessions() || [];
        const sessions = allSessions.map(r => ({
          id: r.id, sessionId: r.id, title: r.title || "New Chat",
          startTime: r.createdAt, lastActivity: r.updatedAt || r.lastActivity,
          messageCount: r.turnCount || 0, firstMessage: ""
        })).sort((a, b) => (b.lastActivity || 0) - (a.lastActivity || 0));
        sendResponse({ success: true, data: { sessions } });
        return true;
      }

      // ... (Preserving specific logic for GET_HISTORY_SESSION to be safe, but delegating to existing logic or abbreviated here?)
      // I must assume the logic from lines 800-1000 is still desired.
      // I will implement a cleaner version utilizing sm.adapter directly.
      case "GET_HISTORY_SESSION": {
        (async () => {
          const sessionId = message.sessionId || message.payload?.sessionId;
          if (!sessionId) throw new Error("Missing sessionId");

          // Implementation identical to original logic via helper would be best
          // Restoring full logic to ensure history works
          const sessionRecord = await sm.adapter.get("sessions", sessionId);
          let turns = await sm.adapter.getTurnsBySessionId(sessionId);
          turns = Array.isArray(turns) ? turns.sort((a, b) => (a.sequence ?? a.createdAt) - (b.sequence ?? b.createdAt)) : [];

          const providerResponses = await sm.adapter.getResponsesBySessionId(sessionId);
          const responsesByAi = new Map();
          for (const r of providerResponses || []) {
            if (r && r.aiTurnId) {
              if (!responsesByAi.has(r.aiTurnId)) responsesByAi.set(r.aiTurnId, []);
              responsesByAi.get(r.aiTurnId).push(r);
            }
          }

          const rounds = [];
          for (let i = 0; i < turns.length; i++) {
            const user = turns[i];
            if (!user || user.type !== "user") continue;

            const allAi = turns.filter(t => t.type === "ai" && t.userTurnId === user.id);
            if (!allAi.length) continue;

            const nextTurn = turns[i + 1];
            let primaryAi = null;
            if (nextTurn && nextTurn.type === "ai" && nextTurn.userTurnId === user.id && !nextTurn.meta?.isHistoricalRerun && nextTurn.sequence !== -1) {
              primaryAi = nextTurn;
            } else {
              primaryAi = allAi.find(t => !t.meta?.isHistoricalRerun && t.sequence !== -1) || allAi[0];
            }

            const responses = (responsesByAi.get(primaryAi.id) || []).sort((a, b) => (a.responseIndex ?? 0) - (b.responseIndex ?? 0));
            const providers = {}, synthesisResponses = {}, mappingResponses = {};

            for (const r of responses) {
              const base = { providerId: r.providerId, text: r.text || "", status: r.status || "completed", meta: r.meta || {}, createdAt: r.createdAt || 0, updatedAt: r.updatedAt || 0 };
              if (r.responseType === "batch") (providers[r.providerId] ||= []).push(base);
              else if (r.responseType === "synthesis") (synthesisResponses[r.providerId] ||= []).push(base);
              else if (r.responseType === "mapping") (mappingResponses[r.providerId] ||= []).push(base);
            }

            rounds.push({
              userTurnId: user.id, aiTurnId: primaryAi.id,
              user: { id: user.id, text: user.text || user.content || "", createdAt: user.createdAt || 0 },
              providers, synthesisResponses, mappingResponses,
              createdAt: user.createdAt || 0, completedAt: primaryAi.updatedAt || 0
            });
          }

          // Fetch contexts
          let providerContexts = {};
          try {
            if (sm.adapter.getContextsBySessionId) {
              const ctxs = await sm.adapter.getContextsBySessionId(sessionId);
              (ctxs || []).forEach(c => {
                if (c?.providerId) providerContexts[c.providerId] = { ...(c.meta || {}), ...(c.contextData || {}), metadata: c.metadata || null };
              });
            }
          } catch (_) { }

          sendResponse({
            success: true, data: {
              id: sessionId, sessionId,
              title: sessionRecord?.title || "Chat",
              turns: rounds,
              providerContexts
            }
          });
        })().catch(e => sendResponse({ success: false, error: e.message }));
        return true;
      }

      case "GET_SESSION": {
        const operationId = persistenceMonitor.startOperation("GET_SESSION", {
          sessionId: message.sessionId || message.payload?.sessionId,
        });

        try {
          const sessionId = message.sessionId || message.payload?.sessionId;
          const session = await sm.getOrCreateSession(sessionId);
          persistenceMonitor.endOperation(operationId, {
            sessionFound: !!session,
          });
          sendResponse({ success: true, session });
        } catch (error) {
          persistenceMonitor.endOperation(operationId, null, error);
          const handledError = await errorHandler.handleError(error, {
            operation: "getSession",
            sessionId: message.sessionId || message.payload?.sessionId,
            retry: () =>
              sm.getOrCreateSession(
                message.sessionId || message.payload?.sessionId,
              ),
          });
          sendResponse({ success: false, error: handledError.message });
        }
        return true;
      }

      case "SAVE_TURN": {
        const sessionId = message.sessionId || message.payload?.sessionId;
        await sm.addTurn(sessionId, message.turn);
        sendResponse({ success: true });
        return true;
      }

      case "UPDATE_PROVIDER_CONTEXT": {
        const sessionId = message.sessionId || message.payload?.sessionId;
        await sm.updateProviderContext(
          sessionId,
          message.providerId || message.payload?.providerId,
          message.context || message.payload?.context,
        );
        sendResponse({ success: true });
        return true;
      }

      case "CREATE_THREAD": {
        const sessionId = message.sessionId || message.payload?.sessionId;
        const thread = await sm.createThread(
          sessionId,
          message.title || message.payload?.title,
          message.sourceAiTurnId || message.payload?.sourceAiTurnId,
        );
        sendResponse({ success: true, thread });
        return true;
      }

      case "SWITCH_THREAD": {
        const sessionId = message.sessionId || message.payload?.sessionId;
        await sm.switchThread(
          sessionId,
          message.threadId || message.payload?.threadId,
        );
        sendResponse({ success: true });
        return true;
      }

      case "DELETE_SESSION": {
        const sessionId = message.sessionId || message.payload?.sessionId;
        try {
          const removed = await sm.deleteSession(sessionId);
          // Return explicit removed boolean so UI can react optimistically
          sendResponse({ success: true, removed });
        } catch (e) {
          console.error("[SW] DELETE_SESSION failed:", e);
          sendResponse({ success: false, error: e?.message || String(e) });
        }
        return true;
      }

      case "DELETE_SESSIONS": {
        try {
          const ids = (
            message.sessionIds ||
            message.payload?.sessionIds ||
            []
          ).filter(Boolean);
          if (!Array.isArray(ids) || ids.length === 0) {
            sendResponse({ success: false, error: "No sessionIds provided" });
            return true;
          }

          const results = await Promise.all(
            ids.map(async (id) => {
              try {
                const removed = await sm.deleteSession(id);
                return { id, removed };
              } catch (err) {
                console.error("[SW] DELETE_SESSIONS item failed:", id, err);
                return { id, removed: false };
              }
            }),
          );

          const removedIds = results.filter((r) => r.removed).map((r) => r.id);
          sendResponse({
            success: true,
            removed: removedIds.length,
            ids: removedIds,
          });
        } catch (e) {
          console.error("[SW] DELETE_SESSIONS failed:", e);
          sendResponse({ success: false, error: e?.message || String(e) });
        }
        return true;
      }

      case "RENAME_SESSION": {
        try {
          const sessionId = message.sessionId || message.payload?.sessionId;
          const newTitleRaw = message.title || message.payload?.title;
          if (!sessionId) {
            sendResponse({ success: false, error: "Missing sessionId" });
            return true;
          }
          const newTitle = String(newTitleRaw ?? "").trim();
          if (!newTitle) {
            sendResponse({ success: false, error: "Title cannot be empty" });
            return true;
          }

          // Persistence-first rename using adapter directly if available, fallback to session op
          if (sm.adapter && sm.adapter.get) {
            const record = await sm.adapter.get("sessions", sessionId);
            if (!record) {
              sendResponse({ success: false, error: `Session ${sessionId} not found` });
              return true;
            }
            record.title = newTitle;
            record.updatedAt = Date.now();
            await sm.adapter.put("sessions", record);

            // Updates local cache if needed
            if (sm.sessions && sm.sessions[sessionId]) {
              sm.sessions[sessionId].title = newTitle;
              sm.sessions[sessionId].updatedAt = record.updatedAt;
            }
          } else {
            // Fallback if SM doesn't expose adapter in expected way (shouldn't happen with new architecture)
            // But for safety:
            // await sm.renameSession(sessionId, newTitle); // If such method existed
          }

          sendResponse({
            success: true,
            updated: true,
            sessionId,
            title: newTitle,
          });
        } catch (e) {
          console.error("[SW] RENAME_SESSION failed:", e);
          sendResponse({ success: false, error: e?.message || String(e) });
        }
        return true;
      }

      case "GET_PERSISTENCE_STATUS": {
        const layer = services.get('persistenceLayer');
        const status = {
          persistenceEnabled: true,
          sessionManagerType: sm?.constructor?.name || "unknown",
          persistenceLayerAvailable: !!layer,
          adapterStatus: sm?.getPersistenceStatus
            ? sm.getPersistenceStatus()
            : null,
        };
        sendResponse({ success: true, status });
        return true;
      }
      // --- ADD THIS HERE ---
      default: {
        // This catches "htos.keepalive" or any typos so the channel closes properly
        console.warn("[SW] Unknown message type ignored:", message.type);
        sendResponse({ success: false, error: "Unknown message type" });
        return true;
      }
      // ---------------------
    }
  } catch (e) {
    sendResponse({ success: false, error: e.message });
    return true;
  }
}

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request?.$bus) return false;
  if (request?.type === "htos.keepalive" || request?.type === "htos.activity") {
    return false;
  }
  if (request?.type === "GET_HEALTH_STATUS") {
    // Return health
    const health = { serviceWorker: "active", registry: { ...services.services.keys() } };
    sendResponse({ success: true, status: health });
    return true;
  }
  if (request?.type) {
    // 2. Ensure handleUnifiedMessage calls sendResponse even if type is unknown
    handleUnifiedMessage(request, sender, sendResponse)
      .catch(err => {
        try {
          sendResponse({ success: false, error: err.message });
        } catch (e) { /* ignore channel closed */ }
      });
    return true;
  }
  return false;
});

// ============================================================================
// PORT CONNECTIONS
// ============================================================================
chrome.runtime.onConnect.addListener(async (port) => {
  if (port.name !== "htos-popup") return;
  console.log("[SW] New connection...");
  try {
    const svcs = await initializeGlobalServices();
    const handler = new ConnectionHandler(port, svcs);
    await handler.init();
    console.log("[SW] Connection handler ready");
  } catch (error) {
    console.error("[SW] Failed to initialize connection handler:", error);
    try { port.postMessage({ type: "INITIALIZATION_FAILED", error: error.message }); } catch (_) { }
  }
});

chrome.action?.onClicked.addListener(async () => {
  const url = chrome.runtime.getURL("ui/index.html");
  await chrome.tabs.create({ url });
});

// ============================================================================
// MAIN BOOTSTRAP
// ============================================================================
handleStartup("initial-load");



================================================
FILE: src/core/auth-manager.js
================================================
/**
 * AuthManager - Centralized authentication status management
 * 
 * Architecture:
 * - Cookie checks (fast, ~10ms) for UI responsiveness
 * - API verification (authoritative, ~200ms) for accuracy
 * - Real-time event listeners for immediate updates
 * - Idempotent initialization safe for multiple calls
 * 
 * NOTE: Verification endpoints are LIGHTWEIGHT
 * - No DNR rules needed
 * - No Proof-of-Work required
 * - No Arkose tokens needed
 * - Just credentials: 'include'
 */

import { AUTH_COOKIES, GEMINI_VARIANTS } from '../shared/auth-config.ts';

class AuthManager {
    constructor() {
        // Cookie status cache
        this._cookieStatus = {};
        this._cookieStatusTs = 0;

        // API verification cache
        this._verificationCache = new Map();

        // Cache TTLs
        this.COOKIE_CACHE_TTL = 60 * 1000;           // 1 minute
        this.VERIFICATION_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

        // Initialization flag
        this._initialized = false;
    }

    /**
     * Initialize AuthManager
     * Idempotent - safe to call multiple times
     */
    async initialize() {
        if (this._initialized) {
            console.log('[AuthManager] Already initialized, skipping');
            return;
        }

        console.log('[AuthManager] Initializing...');

        // 1. Load from storage (instant)
        const stored = await chrome.storage.local.get('provider_auth_status');
        this._cookieStatus = stored.provider_auth_status || {};

        // 2. Setup real-time listeners
        this._setupCookieListeners();

        // 3. Initial cookie check
        await this.checkAllCookies();

        this._initialized = true;
        console.log('[AuthManager] Initialized:', this._cookieStatus);
    }

    /**
     * Get auth status (fast, cached)
     * Used by preflight before workflows
     */
    async getAuthStatus(forceRefresh = false) {
        const now = Date.now();

        // Return cached if fresh
        if (!forceRefresh && now - this._cookieStatusTs < this.COOKIE_CACHE_TTL) {
            return this._cookieStatus;
        }

        // Otherwise refresh
        await this.checkAllCookies();
        return this._cookieStatus;
    }

    /**
     * Cookie-based check for all providers
     * EXACT COPY of checkProviderLoginStatus() from sw-entry.js
     * Fast (~10ms) but not 100% reliable (cookie exists â‰  valid session)
     */
    async checkAllCookies() {
        const status = {};

        await Promise.all(AUTH_COOKIES.map(async (config) => {
            try {
                const cookie = await chrome.cookies.get({
                    url: config.url,
                    name: config.name
                });
                const isAuthenticated = !!cookie;
                status[config.provider] = isAuthenticated;

                // Handle Gemini variants
                if (config.provider === "gemini") {
                    GEMINI_VARIANTS.forEach(variant => {
                        status[variant] = isAuthenticated;
                    });
                }

                console.log(`[AuthManager] ${config.provider}: ${isAuthenticated ? 'authenticated' : 'not authenticated'}`);
            } catch (e) {
                console.warn(`[AuthManager] Failed to check ${config.provider}`, e);
                status[config.provider] = false;

                if (config.provider === "gemini") {
                    GEMINI_VARIANTS.forEach(variant => {
                        status[variant] = false;
                    });
                }
            }
        }));

        // Update cache and storage
        this._cookieStatus = status;
        this._cookieStatusTs = Date.now();
        await chrome.storage.local.set({ provider_auth_status: status });

        return status;
    }

    /**
     * API-based verification (slower but authoritative)
     * Call this after 401/403 errors or for explicit user verification
     */
    async verifyProvider(providerId) {
        const baseProvider = providerId.split('-')[0]; // Normalize gemini-exp â†’ gemini
        const cached = this._verificationCache.get(baseProvider);
        const now = Date.now();

        // Return cached if fresh
        if (cached && now - cached.ts < this.VERIFICATION_CACHE_TTL) {
            console.log(`[AuthManager] Using cached verification for ${providerId}: ${cached.valid}`);
            return cached.valid;
        }

        console.log(`[AuthManager] Verifying ${providerId} via API...`);
        let valid = false;

        try {
            switch (baseProvider) {
                case 'claude':
                    valid = await this._verifyClaude();
                    break;
                case 'chatgpt':
                    valid = await this._verifyChatGPT();
                    break;
                case 'gemini':
                    valid = await this._verifyGemini();
                    break;
                case 'qwen':
                    valid = await this._verifyQwen();
                    break;
                default:
                    // Unknown provider, fall back to cookie check
                    console.warn(`[AuthManager] Unknown provider ${baseProvider}, using cookie check`);
                    valid = this._cookieStatus[providerId] ?? false;
            }
        } catch (e) {
            console.warn(`[AuthManager] Verification failed for ${providerId}:`, e.message);
            // Fall back to cookie status
            valid = this._cookieStatus[providerId] ?? false;
        }

        // Update verification cache
        this._verificationCache.set(baseProvider, { ts: now, valid });

        // Update cookie status if verification disagrees
        const providerIds = baseProvider === 'gemini'
            ? GEMINI_VARIANTS
            : [providerId];

        let changed = false;
        for (const pid of providerIds) {
            if (this._cookieStatus[pid] !== valid) {
                console.log(`[AuthManager] Verification updated status for ${pid}: ${this._cookieStatus[pid]} â†’ ${valid}`);
                this._cookieStatus[pid] = valid;
                changed = true;
            }
        }

        if (changed) {
            await chrome.storage.local.set({ provider_auth_status: this._cookieStatus });
        }

        return valid;
    }

    /**
     * Verify all providers in parallel
     * Returns: { claude: true, chatgpt: false, ... }
     */
    async verifyAll() {
        console.log('[AuthManager] Verifying all providers...');
        const baseProviders = ['claude', 'chatgpt', 'gemini', 'qwen'];
        const results = {};

        await Promise.all(baseProviders.map(async (pid) => {
            results[pid] = await this.verifyProvider(pid);
        }));

        // Apply Gemini variants
        GEMINI_VARIANTS.forEach(variant => {
            results[variant] = results['gemini'];
        });

        console.log('[AuthManager] Verification complete:', results);
        return results;
    }

    /**
     * Claude: GET /api/organizations
     * Success: 200 + non-empty array with uuid
     * Failure: 403 = not logged in
     */
    async _verifyClaude() {
        const response = await fetch('https://claude.ai/api/organizations', {
            method: 'GET',
            credentials: 'include',
            signal: AbortSignal.timeout(5000),
        });

        if (response.status === 403) {
            return false;
        }

        if (!response.ok) {
            throw new Error(`Unexpected status: ${response.status}`);
        }

        const data = await response.json();
        return Array.isArray(data) && data.length > 0 && !!data[0]?.uuid;
    }

    /**
     * ChatGPT: GET /api/auth/session
     * Success: 200 + JSON with accessToken
     * Failure: No accessToken = not logged in
     * 
     * NOTE: Does NOT require offscreen document, PoW, or Arkose
     */
    async _verifyChatGPT() {
        const response = await fetch('https://chatgpt.com/api/auth/session', {
            method: 'GET',
            credentials: 'include',
            signal: AbortSignal.timeout(5000),
        });

        if (!response.ok) {
            return false;
        }

        try {
            const data = await response.json();
            return !!data?.accessToken;
        } catch {
            return false;
        }
    }

    /**
     * Gemini: GET /faq
     * Success: 200 + HTML contains "$authuser"
     * Failure: No $authuser = not logged in
     * 
     * NOTE: Does NOT require token extraction - just presence check
     */
    async _verifyGemini() {
        const response = await fetch('https://gemini.google.com/faq', {
            method: 'GET',
            credentials: 'include',
            signal: AbortSignal.timeout(5000),
        });

        if (!response.ok) {
            return false;
        }

        const html = await response.text();
        return html.includes('$authuser');
    }

    /**
     * Qwen: GET /qianwen/
     * Success: 200 + HTML contains csrfToken
     * Failure: No csrfToken = not logged in
     * 
     * NOTE: Does NOT require CSRF extraction - just presence check
     */
    async _verifyQwen() {
        const response = await fetch('https://qianwen.com/', {
            method: 'GET',
            credentials: 'include',
            signal: AbortSignal.timeout(5000),
        });

        if (!response.ok) {
            return false;
        }

        const html = await response.text();
        return /csrfToken\s*=\s*"[^"]+"/.test(html);
    }

    /**
     * Real-time cookie change detection
     * EXACT COPY of chrome.cookies.onChanged listener from sw-entry.js
     */
    _setupCookieListeners() {
        chrome.cookies.onChanged.addListener(async (changeInfo) => {
            const { cookie, removed } = changeInfo;

            // Find which provider this cookie belongs to
            const match = AUTH_COOKIES.find(c =>
                cookie.domain.includes(c.domain) && cookie.name === c.name
            );

            if (!match) return;

            const wasAuthed = this._cookieStatus[match.provider];
            const nowAuthed = !removed;

            if (wasAuthed !== nowAuthed) {
                console.log(`[AuthManager] Cookie change: ${match.provider} ${wasAuthed} â†’ ${nowAuthed}`);

                // Update status
                this._cookieStatus[match.provider] = nowAuthed;

                // Handle Gemini variants
                if (match.provider === "gemini") {
                    GEMINI_VARIANTS.forEach(variant => {
                        this._cookieStatus[variant] = nowAuthed;
                    });
                }

                // Invalidate verification cache
                this._verificationCache.delete(match.provider.split('-')[0]);

                // Persist to storage
                await chrome.storage.local.set({
                    provider_auth_status: this._cookieStatus
                });
            }
        });
    }

    /**
     * Invalidate cache (call after suspected auth failure)
     */
    invalidateCache(providerId) {
        if (providerId) {
            const baseProvider = providerId.split('-')[0];
            this._verificationCache.delete(baseProvider);
            console.log(`[AuthManager] Invalidated cache for ${baseProvider}`);
        } else {
            this._verificationCache.clear();
            this._cookieStatusTs = 0;
            console.log('[AuthManager] Invalidated all caches');
        }
    }
}

export const authManager = new AuthManager();



================================================
FILE: src/core/connection-handler.js
================================================
// src/core/connection-handler.js

import { WorkflowEngine } from "./workflow-engine.js";
import { runPreflight, createAuthErrorMessage } from './preflight-validator.js';
import { authManager } from './auth-manager.js';
// Note: ContextResolver is now available via services; we don't import it directly here

/**
 * ConnectionHandler
 *
 * Production-grade pattern for managing port connections.
 * Each UI connection gets its own isolated handler with proper lifecycle.
 *
 * KEY PRINCIPLES:
 * 1. Connection-scoped: Each port gets its own WorkflowEngine instance
 * 2. Async initialization: Don't attach listeners until backend is ready
 * 3. Proper cleanup: Remove listeners and free resources on disconnect
 * 4. No global state pollution: Everything is encapsulated
 * 5. AGGRESSIVE SESSION HYDRATION: Always re-hydrate from persistence for continuation requests
 */

export class ConnectionHandler {
  constructor(port, services) {
    this.port = port;
    this.services = services; // { orchestrator, sessionManager, compiler }
    this.workflowEngine = null;
    this.messageHandler = null;
    this.isInitialized = false;
    this.lifecycleManager = services.lifecycleManager;
  }

  /**
   * Map new primitive requests into legacy ExecuteWorkflowRequest
   * so the existing compiler/engine can process them without signature changes.
   */

  /**
   * Async initialization - waits for backend readiness
   */
  async init() {
    if (this.isInitialized) return;

    // Create WorkflowEngine for this connection
    this.workflowEngine = new WorkflowEngine(
      this.services.orchestrator,
      this.services.sessionManager,
      this.port,
    );

    // Create message handler bound to this instance
    this.messageHandler = this._createMessageHandler();

    // Attach listener
    this.port.onMessage.addListener(this.messageHandler);

    // Attach disconnect handler
    this.port.onDisconnect.addListener(() => this._cleanup());

    this.isInitialized = true;
    console.log("[ConnectionHandler] Initialized for port:", this.port.name);

    // Signal that handler is ready
    this.port.postMessage({ type: "HANDLER_READY" });
  }

  /**
   * Build a stable idempotency key for a client-initiated request so that
   * retries on reconnect don't fan out duplicate provider requests.
   */
  _buildIdempotencyKey(executeRequest) {
    if (!executeRequest || typeof executeRequest !== "object") return null;
    const clientUserTurnId =
      executeRequest.clientUserTurnId ||
      executeRequest.userTurnId ||
      executeRequest?.historicalContext?.userTurnId ||
      null;

    try {
      if (executeRequest.type === "initialize") {
        if (!clientUserTurnId) return null;
        return `idem:init:${clientUserTurnId}`;
      }
      if (executeRequest.type === "extend") {
        if (!clientUserTurnId || !executeRequest.sessionId) return null;
        return `idem:${executeRequest.sessionId}:${clientUserTurnId}`;
      }
      if (executeRequest.type === "recompute") {
        const { sessionId, sourceTurnId, stepType, targetProvider } = executeRequest;
        if (!sessionId || !sourceTurnId || !stepType || !targetProvider) return null;
        return `idem:recompute:${sessionId}:${sourceTurnId}:${stepType}:${targetProvider}`;
      }
    } catch (_) { }
    return null;
  }

  /**
   * Emit TURN_FINALIZED constructed directly from persistence for a completed turn.
   * Used to resume UI after port reconnect when streaming was missed.
   */
  async _emitFinalizedFromPersistence(sessionId, aiTurnId) {
    try {
      const adapter = this.services?.sessionManager?.adapter;
      if (!adapter) return;

      const aiTurn = await adapter.get("turns", aiTurnId);
      if (!aiTurn || (aiTurn.type !== "ai" && aiTurn.role !== "assistant")) return;

      const userTurnId = aiTurn.userTurnId;
      const userTurn = userTurnId ? await adapter.get("turns", userTurnId) : null;

      const resps = await adapter.getResponsesByTurnId(aiTurnId);
      const buckets = {
        batchResponses: {},
        synthesisResponses: {},
        mappingResponses: {},
        refinerResponses: {},
        antagonistResponses: {},
      };
      for (const r of resps || []) {
        if (!r) continue;
        const entry = {
          providerId: r.providerId,
          text: r.text || "",
          status: r.status || "completed",
          createdAt: r.createdAt || Date.now(),
          updatedAt: r.updatedAt || r.createdAt || Date.now(),
          meta: r.meta || {},
        };
        if (r.responseType === "batch") {
          (buckets.batchResponses[r.providerId] ||= []).push(entry);
        } else if (r.responseType === "synthesis") {
          (buckets.synthesisResponses[r.providerId] ||= []).push(entry);
        } else if (r.responseType === "mapping") {
          (buckets.mappingResponses[r.providerId] ||= []).push(entry);
        } else if (r.responseType === "refiner") {
          (buckets.refinerResponses[r.providerId] ||= []).push(entry);
        } else if (r.responseType === "antagonist") {
          (buckets.antagonistResponses[r.providerId] ||= []).push(entry);
        }
      }

      // Require at least some responses to finalize
      const hasAny =
        Object.keys(buckets.batchResponses).length > 0 ||
        Object.keys(buckets.synthesisResponses).length > 0 ||
        Object.keys(buckets.mappingResponses).length > 0 ||
        Object.keys(buckets.refinerResponses).length > 0 ||
        Object.keys(buckets.antagonistResponses).length > 0;
      if (!hasAny) return;

      this.port?.postMessage({
        type: "TURN_FINALIZED",
        sessionId: sessionId,
        userTurnId: userTurnId,
        aiTurnId: aiTurnId,
        turn: {
          user: userTurn
            ? {
              id: userTurn.id,
              type: "user",
              text: userTurn.content || "",
              createdAt: userTurn.createdAt || Date.now(),
              sessionId,
            }
            : {
              id: userTurnId || "unknown",
              type: "user",
              text: "",
              createdAt: Date.now(),
              sessionId,
            },
          ai: {
            id: aiTurnId,
            type: "ai",
            userTurnId: userTurnId || "unknown",
            sessionId,
            threadId: aiTurn.threadId || "default-thread",
            createdAt: aiTurn.createdAt || Date.now(),
            batchResponses: buckets.batchResponses,
            synthesisResponses: buckets.synthesisResponses,
            mappingResponses: buckets.mappingResponses,
            refinerResponses: buckets.refinerResponses,
            antagonistResponses: buckets.antagonistResponses,
            meta: aiTurn.meta || {},
          },
        },
      });
    } catch (e) {
      console.warn("[ConnectionHandler] Failed to emit TURN_FINALIZED from persistence:", e);
    }
  }

  /**
   * Create the message handler function
   * This is separate so we can properly remove it on cleanup
   */
  _createMessageHandler() {
    return async (message) => {
      if (!message || !message.type) return;

      if (message.type !== "keepalive_ping") {
        console.log(`[ConnectionHandler] Received: ${message.type}`);
      }

      try {
        switch (message.type) {
          case "EXECUTE_WORKFLOW":
            await this._handleExecuteWorkflow(message);
            break;
          case 'RETRY_PROVIDERS':
            if (this.workflowEngine && typeof this.workflowEngine.handleRetryRequest === 'function') {
              await this.workflowEngine.handleRetryRequest(message);
            } else {
              console.warn('[ConnectionHandler] Retry requested but workflowEngine is not ready');
            }
            break;

          case "KEEPALIVE_PING":
            this.port.postMessage({
              type: "KEEPALIVE_PONG",
              timestamp: Date.now(),
            });
            break;

          case "reconnect":
            this.port.postMessage({
              type: "reconnect_ack",
              serverTime: Date.now(),
            });
            break;

          case "abort":
            await this._handleAbort(message);
            break;

          default:
            console.warn(
              `[ConnectionHandler] Unknown message type: ${message.type}`,
            );
        }
      } catch (error) {
        console.error("[ConnectionHandler] Message handling failed:", error);
        this._sendError(message, error);
      }
    };
  }

  /**
   * Handle EXECUTE_WORKFLOW message
   */
  async _handleExecuteWorkflow(message) {
    let executeRequest = message.payload;
    let resolvedContext = null;

    const VALID_TYPES = ["initialize", "extend", "recompute"];
    if (!executeRequest || !VALID_TYPES.includes(executeRequest.type)) {
      const errorMsg = `Invalid request type: ${executeRequest?.type}. Must be one of: ${VALID_TYPES.join(", ")}`;
      console.error(`[ConnectionHandler] ${errorMsg}`);

      try {
        this.port.postMessage({
          type: "WORKFLOW_COMPLETE",
          sessionId: executeRequest?.sessionId || "unknown",
          error: errorMsg,
        });
      } catch (_) { }

      return;
    }

    // Record activity
    try {
      if (
        this.lifecycleManager &&
        typeof this.lifecycleManager.recordActivity === "function"
      ) {
        this.lifecycleManager.recordActivity();
      }
    } catch (e) { }

    try {
      this.lifecycleManager?.activateWorkflowMode();

      // ========================================================================
      // Idempotency Guard: short-circuit duplicate requests
      // Minimal behavior per invariants:
      // - If mapping exists for clientUserTurnId â†’ re-emit TURN_CREATED
      // - If persisted results exist â†’ emit TURN_FINALIZED from persistence
      // - Do NOT poll inflight or re-fanout providers
      // ========================================================================
      const idemKeyEarly = this._buildIdempotencyKey(executeRequest);
      if (idemKeyEarly && this.services?.sessionManager?.adapter) {
        try {
          const existing = await this.services.sessionManager.adapter.get(
            "metadata",
            idemKeyEarly,
          );
          if (existing && existing.entityId) {
            const sessionIdForEmit =
              existing.sessionId || executeRequest.sessionId || "unknown";
            const histUserTurnId = executeRequest?.historicalContext?.userTurnId;
            const userTurnIdEarly =
              executeRequest?.clientUserTurnId ||
              executeRequest?.userTurnId ||
              histUserTurnId ||
              "unknown";

            try {
              if (executeRequest?.type !== "recompute") {
                this.port.postMessage({
                  type: "TURN_CREATED",
                  sessionId: sessionIdForEmit,
                  userTurnId: userTurnIdEarly,
                  aiTurnId: existing.entityId,
                  providers: executeRequest.providers || [],
                  synthesisProvider: executeRequest.synthesizer || null,
                  mappingProvider: executeRequest.mapper || null,
                });
              }
            } catch (_) { }

            // If we already have responses â†’ emit finalized; otherwise return without recompute
            try {
              const responses = await this.services.sessionManager.adapter.getResponsesByTurnId(existing.entityId);
              const hasAny = Array.isArray(responses) && responses.length > 0;
              if (hasAny) {
                await this._emitFinalizedFromPersistence(
                  sessionIdForEmit,
                  existing.entityId,
                );
              }
            } catch (_) { }
            return; // âœ… Duplicate handled via rehydrate only
          }
        } catch (_) { }
      }

      // ========================================================================
      // PHASE 5: Primitives-only execution path (fail-fast on legacy)
      // ========================================================================
      const isPrimitive =
        executeRequest &&
        typeof executeRequest.type === "string" &&
        ["initialize", "extend", "recompute"].includes(executeRequest.type);
      if (!isPrimitive) {
        const errMsg =
          '[ConnectionHandler] Non-primitive request rejected. Use {type:"initialize"|"extend"|"recompute"} primitives only.';
        console.error(errMsg, { received: executeRequest });
        try {
          this.port.postMessage({
            type: "WORKFLOW_STEP_UPDATE",
            sessionId: executeRequest?.sessionId || "unknown",
            stepId: "validate-primitive",
            status: "failed",
            error:
              "Legacy ExecuteWorkflowRequest is no longer supported. Please migrate to primitives.",
            // Attach recompute metadata when applicable
            isRecompute: executeRequest?.type === "recompute",
            sourceTurnId: executeRequest?.sourceTurnId,
          });
          this.port.postMessage({
            type: "WORKFLOW_COMPLETE",
            sessionId: executeRequest?.sessionId || "unknown",
            error: "Legacy ExecuteWorkflowRequest is no longer supported.",
          });
        } catch (_) { }
        return;
      }

      // Phase 5 path: Resolve â†’ Map â†’ Compile â†’ Execute
      console.log(
        `[ConnectionHandler] Processing ${executeRequest.type} primitive`,
      );

      // Step 1: Resolve context
      try {
        resolvedContext =
          await this.services.contextResolver.resolve(executeRequest);
        console.log(
          `[ConnectionHandler] Context resolved: ${resolvedContext.type}`,
        );
      } catch (e) {
        console.error("[ConnectionHandler] Context resolution failed:", e);
        throw e;
      }

      // Step 2: Preflight authorization + smart defaults routing (cached 60s)
      try {
        await this._applyPreflightSmartDefaults(executeRequest);
      } catch (e) {
        console.warn("[ConnectionHandler] Preflight smart-defaults failed:", e);
      }

      // Step 3: No mapping needed - compiler accepts primitives + resolvedContext
      console.log("[ConnectionHandler] Passing primitive directly to compiler");

      // ========================================================================
      // Validation
      // ========================================================================
      const histUserTurnId = executeRequest?.historicalContext?.userTurnId;
      // Prefer primitive's clientUserTurnId; fall back to legacy userTurnId
      const userTurnId =
        executeRequest?.clientUserTurnId ||
        executeRequest?.userTurnId ||
        histUserTurnId;
      const hasBatch =
        Array.isArray(executeRequest?.providers) &&
        executeRequest.providers.length > 0;
      const hasSynthesis = !!(
        executeRequest?.synthesis?.enabled &&
        executeRequest.synthesis.providers?.length > 0
      );
      const hasMapping = !!(
        executeRequest?.mapping?.enabled &&
        executeRequest.mapping.providers?.length > 0
      );

      if (!hasBatch && (hasSynthesis || hasMapping) && !userTurnId) {
        console.error(
          "[ConnectionHandler] Missing userTurnId in historical-only request",
        );
        this.port.postMessage({
          type: "WORKFLOW_STEP_UPDATE",
          sessionId: executeRequest?.sessionId || "unknown",
          stepId: "validate-user-turn",
          status: "failed",
          error: "Missing userTurnId for historical run",
          // Attach recompute metadata when applicable
          isRecompute: executeRequest?.type === "recompute",
          sourceTurnId: executeRequest?.sourceTurnId,
        });
        this.port.postMessage({
          type: "WORKFLOW_COMPLETE",
          sessionId: executeRequest?.sessionId || "unknown",
        });
        return;
      }

      // Generate session ID if needed
      if (!executeRequest?.sessionId || executeRequest.sessionId === "") {
        executeRequest.sessionId = `session-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        console.log(
          "[ConnectionHandler] Generated session ID:",
          executeRequest.sessionId,
        );
      }

      // ========================================================================
      // Compile
      // ========================================================================
      const workflowRequest = this.services.compiler.compile(
        executeRequest,
        resolvedContext,
      );
      // ========================================================================
      // TURN_CREATED message
      // ========================================================================
      const createsNewTurn = executeRequest.type !== "recompute" && hasBatch;
      if (createsNewTurn) {
        const aiTurnId = `ai-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        workflowRequest.context = {
          ...workflowRequest.context,
          canonicalUserTurnId: userTurnId,
          canonicalAiTurnId: aiTurnId,
        };

        try {
          this.port.postMessage({
            type: "TURN_CREATED",
            sessionId:
              workflowRequest.context.sessionId || executeRequest.sessionId,
            userTurnId,
            aiTurnId,
            // âœ… Include actual providers being used so UI doesn't guess from stale state
            providers: executeRequest.providers || [],
            synthesisProvider: executeRequest.synthesizer || null,
            mappingProvider: executeRequest.mapper || null,
          });
        } catch (_) { }

        try {
          const key = `inflight:${workflowRequest.context.sessionId}:${aiTurnId}`;
          const runId = crypto.randomUUID();
          await this.services.sessionManager.adapter.put("metadata", {
            key,
            sessionId: workflowRequest.context.sessionId,
            entityId: aiTurnId,
            type: "inflight_workflow",
            requestType: executeRequest.type,
            userMessage: executeRequest.userMessage,
            providers: executeRequest.providers || [],
            providerMeta: executeRequest.providerMeta || {},
            runId,
            createdAt: Date.now(),
            updatedAt: Date.now(),
          });
          // Also record idempotency mapping so reconnect retries don't duplicate fanout
          const idemKey = this._buildIdempotencyKey(executeRequest);
          if (idemKey) {
            await this.services.sessionManager.adapter.put("metadata", {
              key: idemKey,
              sessionId: workflowRequest.context.sessionId,
              entityId: aiTurnId,
              type: "request_idempotency",
              requestType: executeRequest.type,
              createdAt: Date.now(),
              updatedAt: Date.now(),
            });
          }
        } catch (_) { }
      }

      // NOTE: TURN_CREATED now emits from WorkflowEngine after persistence
      // to ensure authoritative IDs. We no longer emit here to avoid
      // premature/non-canonical IDs.

      // ========================================================================
      // Execute
      // ========================================================================
      await this.workflowEngine.execute(workflowRequest, resolvedContext);

      try {
        const key = `inflight:${workflowRequest.context.sessionId}:${workflowRequest.context.canonicalAiTurnId}`;
        await this.services.sessionManager.adapter.delete("metadata", key);
      } catch (_) { }
    } catch (error) {
      console.error("[ConnectionHandler] Workflow failed:", error);
      try {
        this.port.postMessage({
          type: "WORKFLOW_STEP_UPDATE",
          sessionId: executeRequest?.sessionId || "unknown",
          stepId: "handler-error",
          status: "failed",
          error: error.message || String(error),
          // Attach recompute metadata when applicable
          isRecompute: executeRequest?.type === "recompute",
          sourceTurnId: executeRequest?.sourceTurnId,
        });
        this.port.postMessage({
          type: "WORKFLOW_COMPLETE",
          sessionId: executeRequest?.sessionId || "unknown",
          error: error.message || String(error),
        });
      } catch (e) {
        console.error("[ConnectionHandler] Failed to send error message:", e);
      }
    } finally {
      this.lifecycleManager?.deactivateWorkflowMode();
    }
  }

  /**
   * CRITICAL: Ensure session is fully hydrated from persistence
   * This solves the SW restart context loss bug
   */
  // Legacy hydration helper removed: session hydration now handled by persistence-backed readers


  /**
   * Preflight authorization check and smart-defaults routing.
   * - Runs after Context Resolution, before Compilation.
   * - Caches auth status for 60s to avoid repeated cookie reads.
   * - Filters unauth providers from batch.
   * - Selects synthesizer/mapper defaults when missing.
   * - Applies ephemeral fallback when a locked provider is unavailable.
   */
  async _applyPreflightSmartDefaults(executeRequest) {
    // Use centralized AuthManager
    const authStatus = await authManager.getAuthStatus();
    const availableProviders = this.services.providerRegistry?.listProviders?.() || [];

    // Run preflight (handles filtering + fallbacks)
    const result = await runPreflight(
      {
        providers: executeRequest.providers,
        synthesizer: executeRequest.synthesizer,
        mapper: executeRequest.mapper,
        antagonist: executeRequest.antagonist,
        refiner: executeRequest.refiner,
      },
      authStatus,
      availableProviders
    );

    // Apply results
    executeRequest.providers = result.providers;
    executeRequest.synthesizer = result.synthesizer;
    executeRequest.mapper = result.mapper;
    executeRequest.antagonist = result.antagonist;
    executeRequest.refiner = result.refiner;

    // Emit warnings (not errors!)
    if (result.warnings.length > 0) {
      this.port.postMessage({
        type: 'PREFLIGHT_WARNINGS',
        sessionId: executeRequest.sessionId,
        warnings: result.warnings,
      });
    }

    // ONLY fail if zero providers available
    const hasAnyProvider =
      result.providers.length > 0 ||
      result.synthesizer !== null ||
      result.mapper !== null ||
      result.antagonist !== null ||
      result.refiner !== null;

    if (!hasAnyProvider) {
      const attempted = [
        ...(executeRequest.providers || []),
        executeRequest.synthesizer,
        executeRequest.mapper,
        executeRequest.antagonist,
        executeRequest.refiner,
      ].filter(Boolean);

      const errorMsg = createAuthErrorMessage(
        attempted,
        'Pre-workflow validation found no authorized providers'
      ) || `No authorized providers available. Attempted: ${attempted.join(', ')}. Please log in to at least one AI service.`;

      throw new Error(errorMsg);
    }
  }

  /**
   * Handle abort message
   */
  async _handleAbort(message) {
    if (message.sessionId && this.services.orchestrator) {
      this.services.orchestrator._abortRequest(message.sessionId);
    }
  }

  /**
   * Send error back to UI
   */
  _sendError(originalMessage, error) {
    this.port.postMessage({
      type: "WORKFLOW_STEP_UPDATE",
      sessionId: originalMessage.payload?.sessionId || "unknown",
      stepId: "handler-error",
      status: "failed",
      error: error.message || String(error),
    });
  }

  /**
   * Cleanup on disconnect
   */
  _cleanup() {
    console.log("[ConnectionHandler] Cleaning up connection");

    // Deactivate lifecycle manager on disconnect
    this.lifecycleManager?.deactivateWorkflowMode();

    // Remove message listener
    if (this.messageHandler) {
      try {
        this.port.onMessage.removeListener(this.messageHandler);
      } catch (e) {
        // Port may already be dead
      }
    }

    // Null out references for GC
    this.workflowEngine = null;
    this.messageHandler = null;
    this.port = null;
    this.services = null;
    this.lifecycleManager = null;
    this.isInitialized = false;
  }
}



================================================
FILE: src/core/context-resolver.js
================================================
// src/core/context-resolver.js
import {
  extractBatchOutputs,
  aggregateBatchOutputs,
  findLatestMappingOutput,
  findLatestSynthesisOutput,
  extractUserMessage
} from './context-utils.js';

/**
 * ContextResolver
 *
 * Resolves the minimal context needed for a workflow request.
 * Implements the 3 primitives: initialize, extend, recompute.
 *
 * Responsibilities:
 * - Non-blocking, targeted lookups (no full session hydration)
 * - Deterministic provider context resolution
 * - Immutable resolved context objects
 */

export class ContextResolver {
  constructor(sessionManager) {
    this.sessionManager = sessionManager;
  }

  /**
   * Resolve context for any primitive request
   * @param {Object} request initialize | extend | recompute
   * @returns {Promise<Object>} ResolvedContext
   */
  async resolve(request) {
    if (!request || !request.type) {
      throw new Error("[ContextResolver] request.type is required");
    }

    switch (request.type) {
      case "initialize":
        return this._resolveInitialize(request);
      case "extend":
        return this._resolveExtend(request);
      case "recompute":
        return this._resolveRecompute(request);
      default:
        throw new Error(
          `[ContextResolver] Unknown request type: ${request.type}`,
        );
    }
  }

  // initialize: starting fresh
  async _resolveInitialize(request) {
    return {
      type: "initialize",
      providers: request.providers || [],
    };
  }

  // extend: fetch last turn and extract provider contexts for requested providers
  async _resolveExtend(request) {
    const sessionId = request.sessionId;
    if (!sessionId)
      throw new Error("[ContextResolver] Extend requires sessionId");

    const session = await this._getSessionMetadata(sessionId);
    if (!session || !session.lastTurnId) {
      throw new Error(
        `[ContextResolver] Cannot extend: no lastTurnId for session ${sessionId}`,
      );
    }

    const lastTurn = await this._getTurn(session.lastTurnId);
    if (!lastTurn)
      throw new Error(
        `[ContextResolver] Last turn ${session.lastTurnId} not found`,
      );

    // Prefer turn-scoped provider contexts
    // Normalization: stored shape may be either { [pid]: meta } or { [pid]: { meta } }
    const turnContexts = lastTurn.providerContexts || {};
    const normalized = {};
    for (const [pid, ctx] of Object.entries(turnContexts)) {
      normalized[pid] = ctx && ctx.meta ? ctx.meta : ctx;
    }

    // PERMISSIVE EXTEND LOGIC:
    // 1. Iterate over requested providers
    // 2. If forced reset -> New Joiner
    // 3. If context exists -> Continue
    // 4. If no context -> New Joiner
    const resolvedContexts = {};
    const forcedResetSet = new Set(request.forcedContextReset || []);

    for (const pid of (request.providers || [])) {
      if (forcedResetSet.has(pid)) {
        // Case 1: Forced Reset
        resolvedContexts[pid] = { isNewJoiner: true };
      } else if (normalized[pid]) {
        // Case 2: Context Exists -> Continue
        resolvedContexts[pid] = normalized[pid];
      } else {
        // Case 3: No Context -> New Joiner
        resolvedContexts[pid] = { isNewJoiner: true };
      }
    }

    return {
      type: "extend",
      sessionId,
      lastTurnId: lastTurn.id,
      providerContexts: resolvedContexts,
      previousContext: lastTurn.lastContextSummary || null,
    };
  }

  // recompute: fetch source AI turn, gather frozen batch outputs and original user message
  async _resolveRecompute(request) {
    const { sessionId, sourceTurnId, stepType, targetProvider } = request;
    if (!sessionId || !sourceTurnId) {
      throw new Error(
        "[ContextResolver] Recompute requires sessionId and sourceTurnId",
      );
    }

    const sourceTurn = await this._getTurn(sourceTurnId);
    if (!sourceTurn)
      throw new Error(
        `[ContextResolver] Source turn ${sourceTurnId} not found`,
      );

    // NEW: batch recompute - single provider retry using original user message OR custom override
    if (stepType === "batch") {
      const providerContextsAtSourceTurn = sourceTurn.providerContexts || {};
      // Prefer custom userMessage from request (targeted refinement), fallback to original turn text
      const sourceUserMessage = request.userMessage || await this._getUserMessageForTurn(sourceTurn);
      return {
        type: "recompute",
        sessionId,
        sourceTurnId,
        stepType,
        targetProvider,
        // No frozen outputs required for batch; we are re-running fresh for a single provider
        frozenBatchOutputs: {},
        providerContextsAtSourceTurn,
        latestMappingOutput: null,
        sourceUserMessage,
      };
    }

    // Build frozen outputs from provider_responses store, not embedded turn fields
    const responses = await this._getProviderResponsesForTurn(sourceTurnId);
    const frozenBatchOutputs = aggregateBatchOutputs(responses);
    if (!frozenBatchOutputs || Object.keys(frozenBatchOutputs).length === 0) {
      throw new Error(
        `[ContextResolver] Source turn ${sourceTurnId} has no batch outputs in provider_responses`,
      );
    }

    // Determine the latest valid mapping output for this source turn
    const latestMappingOutput = findLatestMappingOutput(
      responses,
      request.preferredMappingProvider,
    );
    // Also resolve latest synthesis output for mapping recompute
    const latestSynthesisOutput = findLatestSynthesisOutput(responses);

    const providerContextsAtSourceTurn = sourceTurn.providerContexts || {};
    const sourceUserMessage = await this._getUserMessageForTurn(sourceTurn);

    return {
      type: "recompute",
      sessionId,
      sourceTurnId,
      frozenBatchOutputs,
      latestMappingOutput,
      latestSynthesisOutput, // ← NEW: Include historical synthesis for mapping
      providerContextsAtSourceTurn,
      stepType,
      targetProvider,
      sourceUserMessage,
    };
  }

  // ===== helpers =====
  async _getSessionMetadata(sessionId) {
    try {
      if (
        this.sessionManager?.adapter?.isReady &&
        this.sessionManager.adapter.isReady()
      ) {
        return await this.sessionManager.adapter.get("sessions", sessionId);
      }
      return this.sessionManager?.sessions?.[sessionId] || null;
    } catch (e) {
      console.error("[ContextResolver] _getSessionMetadata failed:", e);
      return null;
    }
  }

  async _getTurn(turnId) {
    try {
      if (
        this.sessionManager?.adapter?.isReady &&
        this.sessionManager.adapter.isReady()
      ) {
        return await this.sessionManager.adapter.get("turns", turnId);
      }
      const sessions = this.sessionManager?.sessions || {};
      for (const session of Object.values(sessions)) {
        const turns = Array.isArray(session.turns) ? session.turns : [];
        const t = turns.find((x) => x && x.id === turnId);
        if (t) return t;
      }
      return null;
    } catch (e) {
      console.error("[ContextResolver] _getTurn failed:", e);
      return null;
    }
  }

  // kept for legacy compatibility if strict filtering needed
  _filterContexts(allContexts, requestedProviders) {
    const filtered = {};
    for (const pid of requestedProviders) {
      if (allContexts[pid]) {
        filtered[pid] = { meta: allContexts[pid], continueThread: true };
      }
    }
    return filtered;
  }

  async _getUserMessageForTurn(aiTurn) {
    const userTurnId = aiTurn.userTurnId;
    if (!userTurnId) return "";
    const userTurn = await this._getTurn(userTurnId);
    return extractUserMessage(userTurn);
  }

  /**
   * Fetch provider responses for a given AI turn using adapter indices if available.
   * Simplified: always use the indexed adapter.getResponsesByTurnId for high performance.
   */
  async _getProviderResponsesForTurn(aiTurnId) {
    // No more fallbacks or readiness checks. Trust the adapter.
    // If this fails, it should throw an error, which is the desired "fail fast" behavior.
    return this.sessionManager.adapter.getResponsesByTurnId(aiTurnId);
  }
}




================================================
FILE: src/core/context-utils.js
================================================
// src/core/context-utils.js

/**
 * ContextUtils
 * 
 * Shared utilities for resolving and extracting context from session data.
 * Consolidates logic to prevent drift between ContextResolver and WorkflowEngine.
 */

/**
 * Extract batch outputs from a turn object (legacy/embedded format)
 * @param {Object} turn - The turn object
 * @returns {Object} Map of providerId -> details
 */
export function extractBatchOutputs(turn) {
    if (!turn) return {};

    // Legacy fallback: if embedded responses exist on the turn, use them
    const embedded = turn.batchResponses || turn.providerResponses || {};
    if (embedded && Object.keys(embedded).length > 0) {
        const frozen = {};
        for (const [providerId, val] of Object.entries(embedded)) {
            // Handle both array (new) and object (legacy) formats
            const r = Array.isArray(val) ? val[val.length - 1] : val;
            if (r && r.text) {
                frozen[providerId] = {
                    providerId,
                    text: r.text,
                    status: r.status || "completed",
                    meta: r.meta || {},
                    createdAt: r.createdAt || turn.createdAt,
                    updatedAt: r.updatedAt || turn.createdAt,
                };
            }
        }
        return frozen;
    }
    return {};
}

/**
 * Aggregate batch outputs per provider from raw provider response records.
 * Chooses the latest completed 'batch' response for each provider.
 * @param {Array} providerResponses - List of response objects
 * @returns {Object} Map of providerId -> response object
 */
export function aggregateBatchOutputs(providerResponses = []) {
    try {
        const frozen = {};
        const byProvider = new Map();
        for (const r of providerResponses) {
            if (!r || r.responseType !== "batch") continue;
            const pid = r.providerId;
            const existing = byProvider.get(pid);
            // Prefer the latest completed response
            const rank = (val) =>
                val?.status === "completed" ? 2 : val?.status === "streaming" ? 1 : 0;
            if (
                !existing ||
                (r.updatedAt ?? 0) > (existing.updatedAt ?? 0) ||
                rank(r) > rank(existing)
            ) {
                byProvider.set(pid, r);
            }
        }
        for (const [pid, r] of byProvider.entries()) {
            frozen[pid] = {
                providerId: pid,
                text: r.text || "",
                status: r.status || "completed",
                meta: r.meta || {},
                createdAt: r.createdAt || Date.now(),
                updatedAt: r.updatedAt || r.createdAt || Date.now(),
            };
        }
        return frozen;
    } catch (e) {
        console.warn("[ContextUtils] aggregateBatchOutputs failed:", e);
        return {};
    }
}

/**
 * Find the latest valid mapping output among provider responses for a turn.
 * @param {Array} providerResponses - List of response objects
 * @param {string} [preferredProvider] - Optional preferred provider ID
 * @returns {Object|null} The mapping output or null
 */
export function findLatestMappingOutput(providerResponses = [], preferredProvider) {
    try {
        if (!providerResponses || providerResponses.length === 0) {
            return null;
        }

        const mappingResponses = providerResponses.filter(
            (r) =>
                r &&
                r.responseType === "mapping" &&
                r.text &&
                String(r.text).trim().length > 0,
        );

        if (mappingResponses.length === 0) {
            return null;
        }

        // Sort by most recent update
        mappingResponses.sort(
            (a, b) =>
                (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0),
        );

        if (preferredProvider) {
            const preferred = mappingResponses.find(
                (r) => r.providerId === preferredProvider,
            );
            if (preferred) {
                return {
                    providerId: preferred.providerId,
                    text: preferred.text,
                    meta: preferred.meta || {},
                };
            }
        }

        const latest = mappingResponses[0];
        return {
            providerId: latest.providerId,
            text: latest.text,
            meta: latest.meta || {},
        };
    } catch (e) {
        console.warn("[ContextUtils] findLatestMappingOutput failed:", e);
        return null;
    }
}

/**
 * Find the latest valid synthesis output among provider responses for a turn.
 * @param {Array} providerResponses - List of response objects
 * @returns {Object|null} The synthesis output or null
 */
export function findLatestSynthesisOutput(providerResponses = []) {
    try {
        if (!providerResponses || providerResponses.length === 0) {
            return null;
        }

        const synthesisResponses = providerResponses.filter(
            (r) =>
                r &&
                r.responseType === "synthesis" &&
                r.text &&
                String(r.text).trim().length > 0,
        );

        if (synthesisResponses.length === 0) {
            return null;
        }

        // Sort by most recent update
        synthesisResponses.sort(
            (a, b) =>
                (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0),
        );

        const latest = synthesisResponses[0];
        return {
            providerId: latest.providerId,
            text: latest.text,
            meta: latest.meta || {},
        };
    } catch (e) {
        console.warn("[ContextUtils] findLatestSynthesisOutput failed:", e);
        return null;
    }
}

/**
 * Extract text content from a user turn object.
 * @param {Object} userTurn - The user turn object
 * @returns {string} The text content
 */
export function extractUserMessage(userTurn) {
    return userTurn?.text || userTurn?.content || "";
}



================================================
FILE: src/core/dnr-auditor.js
================================================
/**
 * HTOS DNR Rule Auditor
 * - Provides visibility into live DNR rule matches for debugging
 * - Uses chrome.declarativeNetRequest.onRuleMatchedDebug
 * - Safe, opt-in debugging tool for development
 *
 * Build-phase safe: emitted to dist/core/*
 */
/**
 * DNR Rule Auditor for debugging rule behavior
 */
export class DNRRuleAuditor {
  /** Helper: gated debug logger (off by default) */
  static dbg(...args) {
    if (DNRUtils?.debugEnabled) console.debug(...args);
  }
  /**
   * Enable the DNR rule auditor (debug mode only)
   */
  static async enableAuditor() {
    if (this.isEnabled) {
      this.dbg("DNR Auditor: Already enabled");
      return true;
    }
    // Check if declarativeNetRequestFeedback permission is available
    if (
      typeof chrome === "undefined" ||
      !chrome.declarativeNetRequest ||
      !chrome.declarativeNetRequest.onRuleMatchedDebug
    ) {
      console.warn(
        "DNR Auditor: onRuleMatchedDebug not available (requires declarativeNetRequestFeedback permission)",
      );
      return false;
    }
    try {
      // Create listener for rule matches
      this.listener = (details) => {
        this.recordRuleMatch(details);
      };
      // Add listener
      chrome.declarativeNetRequest.onRuleMatchedDebug.addListener(
        this.listener,
      );
      this.isEnabled = true;
      this.dbg("DNR Auditor: Enabled successfully");
      return true;
    } catch (error) {
      console.error("DNR Auditor: Failed to enable:", error);
      return false;
    }
  }
  /**
   * Disable the DNR rule auditor
   */
  static disableAuditor() {
    if (!this.isEnabled) {
      return;
    }
    if (this.listener && chrome.declarativeNetRequest?.onRuleMatchedDebug) {
      chrome.declarativeNetRequest.onRuleMatchedDebug.removeListener(
        this.listener,
      );
    }
    this.listener = null;
    this.isEnabled = false;
    this.dbg("DNR Auditor: Disabled");
  }
  /**
   * Record a rule match event
   */
  static recordRuleMatch(details) {
    const matchEvent = {
      ruleId: details.rule.ruleId,
      tabId: details.request.tabId,
      url: details.request.url,
      method: details.request.method,
      resourceType: details.request.type,
      timestamp: Date.now(),
    };
    // Try to identify the provider associated with this rule
    matchEvent.providerId = this.identifyProvider(
      details.rule.ruleId,
      details.request.url,
    );
    // Add to matches array
    this.matches.push(matchEvent);
    // Trim old matches if we exceed the limit
    if (this.matches.length > this.MAX_STORED_MATCHES) {
      this.matches = this.matches.slice(-this.MAX_STORED_MATCHES);
    }
    // Log the match for immediate visibility
    this.dbg("DNR Rule Match:", {
      ruleId: matchEvent.ruleId,
      provider: matchEvent.providerId,
      url: matchEvent.url,
      method: matchEvent.method,
      type: matchEvent.resourceType,
      tabId: matchEvent.tabId,
    });
  }
  /**
   * Try to identify which provider a rule belongs to
   */
  static identifyProvider(ruleId, url) {
    // Check URL patterns to identify provider
    if (url.includes("claude.ai")) {
      return "claude";
    }
    if (url.includes("gemini.google.com")) {
      return "gemini";
    }
    if (url.includes("chatgpt.com") || url.includes("openai.com")) {
      return "chatgpt";
    }
    // Check rule ID ranges (if we use consistent ranges per provider)
    if (ruleId >= 10000 && ruleId < 20000) {
      return "scoped-rules";
    }
    return undefined;
  }
  /**
   * Get auditor statistics
   */
  static getStats() {
    const matchesByRule = new Map();
    const matchesByProvider = new Map();
    for (const match of this.matches) {
      // Count by rule ID
      const ruleCount = matchesByRule.get(match.ruleId) || 0;
      matchesByRule.set(match.ruleId, ruleCount + 1);
      // Count by provider
      if (match.providerId) {
        const providerCount = matchesByProvider.get(match.providerId) || 0;
        matchesByProvider.set(match.providerId, providerCount + 1);
      }
    }
    return {
      totalMatches: this.matches.length,
      matchesByRule,
      matchesByProvider,
      recentMatches: this.matches.slice(-50), // Last 50 matches
    };
  }
  /**
   * Get recent matches for a specific provider
   */
  static getProviderMatches(providerId, limit = 20) {
    return this.matches
      .filter((match) => match.providerId === providerId)
      .slice(-limit);
  }
  /**
   * Get recent matches for a specific rule ID
   */
  static getRuleMatches(ruleId, limit = 20) {
    return this.matches
      .filter((match) => match.ruleId === ruleId)
      .slice(-limit);
  }
  /**
   * Clear stored match history
   */
  static clearHistory() {
    this.matches = [];
    this.dbg("DNR Auditor: Match history cleared");
  }
  /**
   * Check if auditor is currently enabled
   */
  static isAuditorEnabled() {
    return this.isEnabled;
  }
  /**
   * Export match data for analysis
   */
  static exportMatches() {
    const exportData = {
      timestamp: new Date().toISOString(),
      totalMatches: this.matches.length,
      matches: this.matches,
      stats: this.getStats(),
    };
    return JSON.stringify(
      exportData,
      (key, value) => {
        // Convert Maps to objects for JSON serialization
        if (value instanceof Map) {
          return Object.fromEntries(value);
        }
        return value;
      },
      2,
    );
  }
  /**
   * Generate a summary report of rule activity
   */
  static generateReport() {
    const stats = this.getStats();
    const now = new Date();
    const oneHourAgo = now.getTime() - 60 * 60 * 1000;
    const recentMatches = this.matches.filter(
      (match) => match.timestamp > oneHourAgo,
    );
    const topRules = Array.from(stats.matchesByRule.entries())
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10);
    const topProviders = Array.from(stats.matchesByProvider.entries()).sort(
      ([, a], [, b]) => b - a,
    );
    return `
DNR Rule Auditor Report - ${now.toISOString()}
${"=".repeat(50)}

Total Matches: ${stats.totalMatches}
Matches in Last Hour: ${recentMatches.length}

Top Rules by Match Count:
${topRules.map(([ruleId, count]) => `  Rule ${ruleId}: ${count} matches`).join("\n")}

Matches by Provider:
${topProviders.map(([provider, count]) => `  ${provider}: ${count} matches`).join("\n")}

Recent Activity (last 10 matches):
${stats.recentMatches
  .slice(-10)
  .map(
    (match) =>
      `  ${new Date(match.timestamp).toLocaleTimeString()} - Rule ${match.ruleId} (${match.providerId || "unknown"}) - ${match.method} ${match.url}`,
  )
  .join("\n")}
`;
  }
}
DNRRuleAuditor.isEnabled = false;
DNRRuleAuditor.matches = [];
DNRRuleAuditor.MAX_STORED_MATCHES = 1000;
DNRRuleAuditor.listener = null;
import { DNRUtils } from "./dnr-utils.js";



================================================
FILE: src/core/dnr-utils.js
================================================
/**
 * HTOS DNR Utilities
 * - Provides scoped and temporary DNR rule management
 * - Implements provider prerequisite gates
 * - Ensures minimal blast radius for network modifications
 *
 * Build-phase safe: emitted to dist/core/*
 */

export class DNRUtils {
  static scopedRules = new Map();
  static sessionRules = new Map();
  static ruleIdCounter = 10000; // Start high to avoid conflicts
  static debugEnabled = false;
  static debugListener = null;
  static cleanupInterval = null;
  static initialized = false;
  static STORAGE_KEY = "dnr_rules_backup";

  // Gated debug logger (off by default)
  static dbg(...args) {
    if (this.debugEnabled) console.debug(...args);
  }

  /** Register a tab-scoped DNR rule */
  static async registerTabScoped(tabId, rule, providerId) {
    const ruleId = this.ruleIdCounter++;
    const fullRule = {
      ...rule,
      id: ruleId,
      condition: { ...rule.condition, tabIds: [tabId] },
    };
    try {
      await chrome.declarativeNetRequest.updateDynamicRules({
        addRules: [fullRule],
      });
      this.scopedRules.set(ruleId, {
        id: ruleId,
        tabId,
        providerId,
        rule: fullRule,
      });
      // Persist updated counter and rule tracking so SW restarts do not collide IDs
      try {
        await this.persistRules();
      } catch (e) {
        console.warn("DNR: persist after registerTabScoped failed", e);
      }
      this.dbg(
        `DNR: Registered tab-scoped rule ${ruleId} for tab ${tabId}`,
        providerId ? `(${providerId})` : "",
      );
      return ruleId;
    } catch (error) {
      console.error("Failed to register tab-scoped DNR rule:", error);
      throw error;
    }
  }

  /** Register a temporary DNR rule with auto-expiration */
  static async registerTemporary(rule, durationMs, providerId) {
    const ruleId = this.ruleIdCounter++;
    const fullRule = { ...rule, id: ruleId };
    const expiresAt = Date.now() + durationMs;
    try {
      await chrome.declarativeNetRequest.updateDynamicRules({
        addRules: [fullRule],
      });
      this.scopedRules.set(ruleId, {
        id: ruleId,
        expiresAt,
        providerId,
        rule: fullRule,
      });
      // Persist updated counter and rule tracking so SW restarts do not collide IDs
      try {
        await this.persistRules();
      } catch (e) {
        console.warn("DNR: persist after registerTemporary failed", e);
      }
      // Schedule automatic removal
      setTimeout(() => {
        this.removeRule(ruleId).catch((err) =>
          console.warn(
            `Failed to auto-remove expired DNR rule ${ruleId}:`,
            err,
          ),
        );
      }, durationMs);
      this.dbg(
        `DNR: Registered temporary rule ${ruleId} (expires in ${durationMs}ms)`,
        providerId ? `(${providerId})` : "",
      );
      return ruleId;
    } catch (error) {
      console.error("Failed to register temporary DNR rule:", error);
      throw error;
    }
  }

  /** Clean up expired rules */
  static async cleanupExpiredRules() {
    const now = Date.now();

    // Check expired dynamic rules
    const expiredDynamicRules = Array.from(this.scopedRules.values()).filter(
      (rule) => rule.expiresAt && rule.expiresAt <= now,
    );

    // Check expired session rules
    const expiredSessionRules = Array.from(this.sessionRules.values()).filter(
      (rule) => rule.expiresAt && rule.expiresAt <= now,
    );

    const totalExpired =
      expiredDynamicRules.length + expiredSessionRules.length;
    if (totalExpired === 0) return;

    try {
      // Clean up expired dynamic rules
      if (expiredDynamicRules.length > 0) {
        const dynamicRuleIds = expiredDynamicRules.map((rule) => rule.id);
        await chrome.declarativeNetRequest.updateDynamicRules({
          removeRuleIds: dynamicRuleIds,
        });
        dynamicRuleIds.forEach((id) => this.scopedRules.delete(id));
      }

      // Clean up expired session rules
      if (expiredSessionRules.length > 0) {
        const sessionRuleIds = expiredSessionRules.map((rule) => rule.id);
        await chrome.declarativeNetRequest.updateSessionRules({
          removeRuleIds: sessionRuleIds,
        });
        sessionRuleIds.forEach((id) => this.sessionRules.delete(id));
      }

      this.dbg(
        `DNR: Cleaned up ${totalExpired} expired rules (${expiredDynamicRules.length} dynamic, ${expiredSessionRules.length} session)`,
      );
    } catch (error) {
      console.error("Failed to cleanup expired DNR rules:", error);
    }
  }

  /** Register a header modification rule */
  static async registerHeaderRule({
    tabId,
    urlFilter,
    resourceTypes,
    headerName,
    headerValue,
    operation = "set",
    providerId,
    ruleId,
    durationMs,
  }) {
    const finalRuleId = ruleId || this.ruleIdCounter++;
    const isTabScoped = !!tabId;
    const isTemporary = !!durationMs;

    const rule = {
      id: finalRuleId,
      priority: 1,
      action: {
        type: chrome.declarativeNetRequest.RuleActionType.MODIFY_HEADERS,
        requestHeaders: [
          {
            header: headerName,
            operation:
              chrome.declarativeNetRequest.HeaderOperation[
              operation.toUpperCase()
              ],
            value: headerValue,
          },
        ],
      },
      condition: {
        urlFilter: urlFilter,
        resourceTypes: resourceTypes || [
          chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST,
        ],
        ...(isTabScoped && { tabIds: [tabId] }),
      },
    };

    try {
      // Use session rules for tab-scoped or temporary rules, dynamic rules for persistent ones
      const useSessionRules = isTabScoped || isTemporary;

      if (useSessionRules) {
        await chrome.declarativeNetRequest.updateSessionRules({
          addRules: [rule],
        });
        this.sessionRules.set(finalRuleId, {
          id: finalRuleId,
          tabId,
          providerId,
          rule,
          expiresAt: isTemporary ? Date.now() + durationMs : null,
          isTemporary,
        });
      } else {
        await chrome.declarativeNetRequest.updateDynamicRules({
          addRules: [rule],
        });
        this.scopedRules.set(finalRuleId, {
          id: finalRuleId,
          tabId,
          providerId,
          rule,
        });
      }

      // Persist rules for service worker restart recovery
      await this.persistRules();

      this.dbg(
        `DNR: Registered header rule ${finalRuleId} for ${headerName}=${headerValue}`,
        `(${useSessionRules ? "session" : "dynamic"}, ${providerId || "no-provider"})`,
      );

      // Schedule cleanup for temporary rules
      if (isTemporary) {
        setTimeout(() => {
          this.removeRule(finalRuleId).catch((err) =>
            console.warn(
              `Failed to auto-remove expired header rule ${finalRuleId}:`,
              err,
            ),
          );
        }, durationMs);
      }

      return finalRuleId;
    } catch (error) {
      console.error("Failed to register header modification rule:", error);
      throw error;
    }
  }

  /** Register a temporary header modification rule with auto-expiration */
  static async registerTemporaryHeaderRule(
    {
      tabId,
      urlFilter,
      resourceTypes,
      headerName,
      headerValue,
      operation = "set",
      providerId,
      ruleId,
    },
    durationMs,
  ) {
    return this.registerHeaderRule({
      tabId,
      urlFilter,
      resourceTypes,
      headerName,
      headerValue,
      operation,
      providerId,
      ruleId,
      durationMs,
    });
  }

  /** Remove a DNR rule by ID */
  static async removeRule(ruleId) {
    const scopedRule = this.scopedRules.get(ruleId);
    const sessionRule = this.sessionRules.get(ruleId);

    if (!scopedRule && !sessionRule) {
      console.warn(`DNR: Rule ${ruleId} not found in tracked rules`);
      return;
    }

    try {
      if (sessionRule) {
        await chrome.declarativeNetRequest.updateSessionRules({
          removeRuleIds: [ruleId],
        });
        this.sessionRules.delete(ruleId);
      } else {
        await chrome.declarativeNetRequest.updateDynamicRules({
          removeRuleIds: [ruleId],
        });
        this.scopedRules.delete(ruleId);
      }

      // Persist updated rules
      await this.persistRules();

      this.dbg(`DNR: Removed rule ${ruleId}`);
    } catch (error) {
      console.error(`Failed to remove DNR rule ${ruleId}:`, error);
      throw error;
    }
  }

  /** Remove all rules for a specific provider */
  static async removeProviderRules(providerId) {
    const dynamicProviderRules = Array.from(this.scopedRules.values()).filter(
      (rule) => rule.providerId === providerId,
    );
    const sessionProviderRules = Array.from(this.sessionRules.values()).filter(
      (rule) => rule.providerId === providerId,
    );

    const dynamicRuleIds = dynamicProviderRules.map((rule) => rule.id);
    const sessionRuleIds = sessionProviderRules.map((rule) => rule.id);

    try {
      if (dynamicRuleIds.length > 0) {
        await chrome.declarativeNetRequest.updateDynamicRules({
          removeRuleIds: dynamicRuleIds,
        });
        dynamicRuleIds.forEach((id) => this.scopedRules.delete(id));
      }

      if (sessionRuleIds.length > 0) {
        await chrome.declarativeNetRequest.updateSessionRules({
          removeRuleIds: sessionRuleIds,
        });
        sessionRuleIds.forEach((id) => this.sessionRules.delete(id));
      }

      const totalRemoved = dynamicRuleIds.length + sessionRuleIds.length;
      if (totalRemoved > 0) {
        // Persist updated rules
        await this.persistRules();
        this.dbg(
          `DNR: Removed ${totalRemoved} rules for provider ${providerId}`,
        );
      }
    } catch (error) {
      console.error(
        `Failed to remove provider rules for ${providerId}:`,
        error,
      );
      throw error;
    }
  }

  /** Get all active rules (both dynamic and session) */
  static async getActiveRules() {
    try {
      const [dynamicRules, sessionRules] = await Promise.all([
        chrome.declarativeNetRequest.getDynamicRules().catch(() => []),
        chrome.declarativeNetRequest.getSessionRules().catch(() => []),
      ]);

      return {
        dynamic: dynamicRules,
        session: sessionRules,
        tracked: {
          dynamic: Array.from(this.scopedRules.values()),
          session: Array.from(this.sessionRules.values()),
        },
      };
    } catch (error) {
      console.error("Failed to get active DNR rules:", error);
      return {
        dynamic: [],
        session: [],
        tracked: {
          dynamic: Array.from(this.scopedRules.values()),
          session: Array.from(this.sessionRules.values()),
        },
      };
    }
  }

  /** Enable debug mode with rule match logging */
  static enableDebugMode() {
    if (this.debugEnabled) {
      this.dbg("DNR: Debug mode already enabled");
      return;
    }

    if (!chrome.declarativeNetRequest?.onRuleMatchedDebug) {
      console.warn(
        "DNR: onRuleMatchedDebug not available - debug mode requires developer mode",
      );
      return;
    }

    this.debugListener = (info) => {
      this.dbg("DNR Rule Match:", {
        ruleId: info.rule.ruleId,
        tabId: info.request.tabId,
        url: info.request.url,
        method: info.request.method,
        resourceType: info.request.type,
        action: info.rule.action,
        timestamp: new Date().toISOString(),
      });
    };

    chrome.declarativeNetRequest.onRuleMatchedDebug.addListener(
      this.debugListener,
    );
    this.debugEnabled = true;
    this.dbg("DNR: Debug mode enabled");
  }

  /** Disable debug mode */
  static disableDebugMode() {
    if (!this.debugEnabled) {
      this.dbg("DNR: Debug mode already disabled");
      return;
    }

    if (
      this.debugListener &&
      chrome.declarativeNetRequest?.onRuleMatchedDebug
    ) {
      chrome.declarativeNetRequest.onRuleMatchedDebug.removeListener(
        this.debugListener,
      );
    }

    this.debugListener = null;
    this.debugEnabled = false;
    this.dbg("DNR: Debug mode disabled");
  }

  /** Start periodic cleanup of expired rules */
  static startPeriodicCleanup(intervalMs = 5 * 60 * 1000) {
    // 5 minutes default
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }

    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredRules().catch((err) =>
        console.warn("Periodic DNR cleanup failed:", err),
      );
    }, intervalMs);
  }

  /** Stop periodic cleanup */
  static stopPeriodicCleanup() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
      this.dbg("DNR: Stopped periodic cleanup");
    }
  }

  /** Initialize DNR utils and restore persisted rules */
  static async initialize() {
    if (this.initialized) return;

    try {
      // Restore rules from storage
      await this.restorePersistedRules();

      // Start periodic cleanup
      this.startPeriodicCleanup();

      this.initialized = true;
      this.dbg("DNR: Initialized successfully");
    } catch (error) {
      console.error("DNR: Initialization failed:", error);
    }
  }

  /** Persist rules to storage for service worker restart recovery */
  static async persistRules() {
    try {
      const rulesData = {
        scopedRules: Array.from(this.scopedRules.entries()),
        sessionRules: Array.from(this.sessionRules.entries()),
        ruleIdCounter: this.ruleIdCounter,
        timestamp: Date.now(),
      };

      await chrome.storage.local.set({ [this.STORAGE_KEY]: rulesData });
    } catch (error) {
      console.warn("DNR: Failed to persist rules:", error);
    }
  }

  /** Restore rules from storage after service worker restart */
  static async restorePersistedRules() {
    try {
      const result = await chrome.storage.local.get(this.STORAGE_KEY);
      const rulesData = result[this.STORAGE_KEY];

      if (!rulesData) return;

      // Restore rule counter
      if (rulesData.ruleIdCounter) {
        this.ruleIdCounter = Math.max(
          this.ruleIdCounter,
          rulesData.ruleIdCounter,
        );
      }

      // Restore scoped rules
      if (rulesData.scopedRules) {
        this.scopedRules = new Map(rulesData.scopedRules);
      }

      // Restore session rules
      if (rulesData.sessionRules) {
        this.sessionRules = new Map(rulesData.sessionRules);
      }

      // Clean up expired rules immediately
      await this.cleanupExpiredRules();

      this.dbg("DNR: Restored persisted rules");
    } catch (error) {
      console.warn("DNR: Failed to restore persisted rules:", error);
    }
  }

  /** Clear persisted rules from storage */
  static async clearPersistedRules() {
    try {
      await chrome.storage.local.remove(this.STORAGE_KEY);
      this.dbg("DNR: Cleared persisted rules");
    } catch (error) {
      console.warn("DNR: Failed to clear persisted rules:", error);
    }
  }
}

/** Provider DNR Prerequisite Gate */
export class ProviderDNRGate {
  static providerRules = new Map();

  /** Ensure provider prerequisites are met before network operations */
  static async ensureProviderDnrPrereqs(providerId, tabId) {
    DNRUtils.dbg(`DNR Gate: Ensuring prerequisites for ${providerId}`);
    const rules = this.getProviderRules(providerId);
    if (rules.length === 0) {
      DNRUtils.dbg(`DNR Gate: No prerequisites needed for ${providerId}`);
      return;
    }
    const ruleIds = [];
    try {
      for (const rule of rules) {
        let ruleId;
        if (tabId) {
          // Tab-scoped rule
          ruleId = await DNRUtils.registerTabScoped(tabId, rule, providerId);
        } else {
          // Temporary global rule (5 minutes max)
          ruleId = await DNRUtils.registerTemporary(
            rule,
            5 * 60 * 1000,
            providerId,
          );
        }
        ruleIds.push(ruleId);
      }
      const existingRules = this.providerRules.get(providerId) || [];
      this.providerRules.set(providerId, [...existingRules, ...ruleIds]);
      DNRUtils.dbg(
        `DNR Gate: Activated ${ruleIds.length} rules for ${providerId}`,
      );
    } catch (error) {
      for (const ruleId of ruleIds) {
        await DNRUtils.removeRule(ruleId).catch(() => { });
      }
      throw error;
    }
  }

  /** Clean up provider rules after workflow completion */
  static async cleanupProviderRules(providerId) {
    await DNRUtils.removeProviderRules(providerId);
    this.providerRules.delete(providerId);
  }

  /** Get provider-specific DNR rules */
  static getProviderRules(providerId) {
    switch (providerId) {
      case "claude":
        return [
          {
            priority: 1,
            action: {
              type: chrome.declarativeNetRequest.RuleActionType.MODIFY_HEADERS,
              responseHeaders: [
                {
                  header: "content-security-policy",
                  operation:
                    chrome.declarativeNetRequest.HeaderOperation.REMOVE,
                },
              ],
              requestHeaders: [
                {
                  header: "origin",
                  operation: chrome.declarativeNetRequest.HeaderOperation.SET,
                  value: "https://claude.ai",
                },
                {
                  header: "referer",
                  operation: chrome.declarativeNetRequest.HeaderOperation.SET,
                  value: "https://claude.ai/chats",
                },
              ],
            },
            condition: {
              urlFilter: "*://claude.ai/*",
              resourceTypes: [
                chrome.declarativeNetRequest.ResourceType.SUB_FRAME,
                chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST,
              ],
            },
          },
        ];
      case "gemini":
        return [
          {
            priority: 1,
            action: {
              type: chrome.declarativeNetRequest.RuleActionType.MODIFY_HEADERS,
              responseHeaders: [
                {
                  header: "x-frame-options",
                  operation:
                    chrome.declarativeNetRequest.HeaderOperation.REMOVE,
                },
              ],
            },
            condition: {
              urlFilter: "*://gemini.google.com/*",
              resourceTypes: [
                chrome.declarativeNetRequest.ResourceType.SUB_FRAME,
              ],
            },
          },
        ];
      case "qwen":
        return [
          {
            priority: 1,
            action: {
              type: chrome.declarativeNetRequest.RuleActionType.MODIFY_HEADERS,
              requestHeaders: [
                {
                  header: "origin",
                  operation: chrome.declarativeNetRequest.HeaderOperation.SET,
                  value: "https://www.qianwen.com",
                },
                {
                  header: "referer",
                  operation: chrome.declarativeNetRequest.HeaderOperation.SET,
                  value: "https://www.qianwen.com/",
                },
              ],
            },
            condition: {
              requestDomains: ["qianwen.aliyun.com", "api.qianwen.com"],
              resourceTypes: [
                chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST,
              ],
            },
          },
        ];
      default:
        return [];
    }
  }
}



================================================
FILE: src/core/error-classifier.js
================================================
// src/core/error-classifier.js

/**
 * Classify errors for user-facing messaging and retry logic
 */
export function classifyError(error) {
  // HTTP status-based classification
  if (error && (error.status || error.statusCode)) {
    const status = error.status || error.statusCode;

    if (status === 429) {
      return {
        type: 'rate_limit',
        message: 'Rate limit reached. Please wait before retrying.',
        retryable: true,
        retryAfterMs: parseRetryAfter(error) || 60000
      };
    }

    if (status === 401 || status === 403) {
      return {
        type: 'auth_expired',
        message: 'Authentication expired. Please log in again.',
        retryable: false,
        requiresReauth: true
      };
    }

    if (status >= 500) {
      return {
        type: 'unknown',
        message: 'Provider server error. Will retry automatically.',
        retryable: true
      };
    }
  }

  // Timeout detection
  if (
    error?.code === 'ETIMEDOUT' ||
    error?.code === 'ESOCKETTIMEDOUT' ||
    (typeof error?.message === 'string' && error.message.toLowerCase().includes('timeout'))
  ) {
    return {
      type: 'timeout',
      message: 'Request timed out. Retrying may help.',
      retryable: true
    };
  }

  // Network errors
  if (
    error?.code === 'ECONNREFUSED' ||
    error?.code === 'ENOTFOUND' ||
    error?.code === 'ENETUNREACH' ||
    (typeof error?.message === 'string' && error.message.toLowerCase().includes('network'))
  ) {
    return {
      type: 'network',
      message: 'Network connection failed.',
      retryable: true
    };
  }

  // Content filter / safety
  if (
    typeof error?.message === 'string' && (
      error.message.toLowerCase().includes('content filter') ||
      error.message.toLowerCase().includes('safety') ||
      error.message.toLowerCase().includes('blocked')
    )
  ) {
    return {
      type: 'content_filter',
      message: 'Response blocked by provider safety filters.',
      retryable: false
    };
  }

  // Default unknown
  return {
    type: 'unknown',
    message: (error && error.message) || 'An unexpected error occurred.',
    retryable: true // Optimistic - allow retry attempt
  };
}

function parseRetryAfter(error) {
  // Try to extract Retry-After header value
  const retryAfter = error?.headers?.['retry-after'] || error?.headers?.['Retry-After'];
  if (retryAfter) {
    const seconds = parseInt(String(retryAfter), 10);
    if (!isNaN(seconds)) {
      return seconds * 1000;
    }
  }
  return null;
}

/**
 * User-friendly error messages by type
 */
export const ERROR_DISPLAY_TEXT = {
  rate_limit: {
    title: 'Rate Limited',
    description: 'This provider is temporarily unavailable. It will automatically retry.',
    icon: '⏳'
  },
  auth_expired: {
    title: 'Login Required',
    description: 'Please log in to this provider again.',
    icon: '🔒'
  },
  timeout: {
    title: 'Timed Out',
    description: 'The request took too long. Click retry to try again.',
    icon: '⏱️'
  },
  circuit_open: {
    title: 'Temporarily Unavailable',
    description: 'Too many recent failures. Will automatically recover.',
    icon: '🔌'
  },
  content_filter: {
    title: 'Content Blocked',
    description: 'This provider blocked the response. Try rephrasing your request.',
    icon: '🚫'
  },
  input_too_long: {
    title: 'Input Too Long',
    description: "Your message exceeds this provider's input limit. Shorten it and retry.",
    icon: '📏'
  },
  network: {
    title: 'Connection Failed',
    description: 'Could not reach the provider. Check your connection.',
    icon: '📡'
  },
  unknown: {
    title: 'Error',
    description: 'Something went wrong.',
    icon: '⚠️'
  }
};



================================================
FILE: src/core/lifecycle-manager.js
================================================
/**
 * HTOS Lifecycle Manager - Minimal & Persistent
 *
 * Strategy: Keep SW alive as long as there's been ANY activity in the last 20 minutes.
 * This prevents shutdown during normal usage patterns while allowing true idle cleanup.
 */

export class LifecycleManager {
  constructor(ping) {
    this.ping = ping;
    this.lastActivity = Date.now();
    this.heartbeatTimer = null;
    this.heartbeatIntervalMs = 25000; // Ping every 25s (below 30s threshold)
    this.INACTIVITY_THRESHOLD = 20 * 60 * 1000; // 20 minutes
    this.ALARM_NAME = "htos-heartbeat";
  }

  /**
   * Called whenever ANY activity happens (workflow, message, etc)
   */
  recordActivity() {
    this.lastActivity = Date.now();

    // Start heartbeat if not running
    if (!this.heartbeatTimer) {
      try {
        console.log("[Lifecycle] Activity detected, starting heartbeat");
      } catch (e) {}
      this.startHeartbeat();
    }
  }

  /**
   * Start persistent heartbeat
   */
  startHeartbeat() {
    if (this.heartbeatTimer) return;

    if (typeof chrome !== "undefined" && chrome.alarms) {
      this.startAlarmBasedHeartbeat();
    } else {
      this.startTimerBasedHeartbeat();
    }
  }

  startAlarmBasedHeartbeat() {
    try {
      chrome.alarms.clear(this.ALARM_NAME);

      // Ensure we don't add duplicate listeners in some environments
      if (chrome.alarms && chrome.alarms.onAlarm && !this._alarmListener) {
        this._alarmListener = (alarm) => {
          if (alarm && alarm.name === this.ALARM_NAME) {
            this.executePing();
          }
        };
        chrome.alarms.onAlarm.addListener(this._alarmListener);
      }

      const periodMinutes = Math.max(
        0.016,
        this.heartbeatIntervalMs / (1000 * 60),
      );
      chrome.alarms.create(this.ALARM_NAME, {
        delayInMinutes: periodMinutes,
        periodInMinutes: periodMinutes,
      });

      this.heartbeatTimer = 1;
      // Immediate first ping
      this.executePing();
    } catch (e) {
      // Fallback to timer-based if alarms fail
      try {
        this.startTimerBasedHeartbeat();
      } catch (_) {}
    }
  }

  startTimerBasedHeartbeat() {
    const tick = async () => {
      await this.executePing();
      this.heartbeatTimer = setTimeout(tick, this.heartbeatIntervalMs);
    };

    // kick off immediately
    this.heartbeatTimer = setTimeout(tick, 0);
  }

  async executePing() {
    try {
      const timeSinceActivity = Date.now() - this.lastActivity;

      // Stop heartbeat if truly inactive for threshold
      if (timeSinceActivity > this.INACTIVITY_THRESHOLD) {
        try {
          console.log(
            "[Lifecycle] No activity for threshold, allowing SW shutdown",
          );
        } catch (e) {}
        this.stopHeartbeat();
        return;
      }

      if (this.ping) {
        await this.ping();
      } else if (typeof chrome !== "undefined" && chrome.runtime?.id) {
        try {
          const res = chrome.runtime.sendMessage({ type: "htos.keepalive" });
          // Some chrome implementations return a Promise; guard it
          if (res && typeof res.then === "function") {
            await res.catch(() => {});
          }
        } catch (e) {
          // best-effort
        }
      }
    } catch (e) {
      // Non-fatal
      try {
        console.warn("LifecycleManager ping error", e);
      } catch (err) {}
    }
  }

  stopHeartbeat() {
    try {
      if (typeof chrome !== "undefined" && chrome.alarms) {
        chrome.alarms.clear(this.ALARM_NAME);
        if (
          this._alarmListener &&
          chrome.alarms &&
          chrome.alarms.onAlarm &&
          chrome.alarms.onAlarm.removeListener
        ) {
          try {
            chrome.alarms.onAlarm.removeListener(this._alarmListener);
          } catch (e) {}
          this._alarmListener = null;
        }
      } else if (this.heartbeatTimer) {
        clearTimeout(this.heartbeatTimer);
      }
    } catch (e) {
      // ignore
    }

    this.heartbeatTimer = null;
  }

  /**
   * Explicit workflow mode controls (backward compatible)
   */
  activateWorkflowMode() {
    this.recordActivity();
  }

  deactivateWorkflowMode() {
    this.recordActivity();
  }

  /**
   * Legacy keepalive API (backward compatible)
   */
  keepalive(enable) {
    if (enable) {
      this.recordActivity();
    }
    // Never stop on disable - let inactivity threshold handle it
  }
}



================================================
FILE: src/core/PersistenceMonitor.js
================================================
/**
 * HTOS Persistence Layer Monitor
 * Provides debugging, monitoring, and diagnostic capabilities for the persistence layer
 */

export class PersistenceMonitor {
  constructor() {
    this.metrics = {
      operations: new Map(),
      errors: [],
      performance: new Map(),
      connections: new Map(),
    };

    this.isEnabled = globalThis.HTOS_DEBUG_MODE || false;
    this.maxLogEntries = 1000;
    this.startTime = Date.now();

    if (this.isEnabled) {
      console.log("🔍 HTOS Persistence Monitor initialized");
    }
  }

  /**
   * Record an operation start
   */
  startOperation(operationType, details = {}) {
    if (!this.isEnabled) return null;

    const operationId = `${operationType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const operation = {
      id: operationId,
      type: operationType,
      details,
      startTime: performance.now(),
      timestamp: Date.now(),
    };

    this.metrics.operations.set(operationId, operation);

    // Clean up old operations
    if (this.metrics.operations.size > this.maxLogEntries) {
      const oldestKey = this.metrics.operations.keys().next().value;
      this.metrics.operations.delete(oldestKey);
    }

    return operationId;
  }

  /**
   * Record an operation completion
   */
  endOperation(operationId, result = null, error = null) {
    if (!this.isEnabled || !operationId) return;

    const operation = this.metrics.operations.get(operationId);
    if (!operation) return;

    operation.endTime = performance.now();
    operation.duration = operation.endTime - operation.startTime;
    operation.result = result;
    operation.error = error;
    operation.success = !error;

    // Update performance metrics
    const perfKey = operation.type;
    if (!this.metrics.performance.has(perfKey)) {
      this.metrics.performance.set(perfKey, {
        count: 0,
        totalDuration: 0,
        avgDuration: 0,
        minDuration: Infinity,
        maxDuration: 0,
        errors: 0,
        successRate: 100,
      });
    }

    const perf = this.metrics.performance.get(perfKey);
    perf.count++;
    perf.totalDuration += operation.duration;
    perf.avgDuration = perf.totalDuration / perf.count;
    perf.minDuration = Math.min(perf.minDuration, operation.duration);
    perf.maxDuration = Math.max(perf.maxDuration, operation.duration);

    if (error) {
      perf.errors++;
      this.recordError(error, operation);
    }

    perf.successRate = ((perf.count - perf.errors) / perf.count) * 100;

    // Log slow operations
    if (operation.duration > 1000) {
      // > 1 second
      console.warn(
        `🐌 Slow operation detected: ${operation.type} took ${operation.duration.toFixed(2)}ms`,
        operation,
      );
    }
  }

  /**
   * Record an error
   */
  recordError(error, context = {}) {
    if (!this.isEnabled) return;

    const errorRecord = {
      timestamp: Date.now(),
      message: error.message || String(error),
      stack: error.stack,
      context,
      id: `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    };

    this.metrics.errors.push(errorRecord);

    // Keep only recent errors
    if (this.metrics.errors.length > this.maxLogEntries) {
      this.metrics.errors = this.metrics.errors.slice(-this.maxLogEntries);
    }

    console.error("🚨 HTOS Persistence Error:", errorRecord);
  }

  /**
   * Record database connection info
   */
  recordConnection(dbName, version, stores = []) {
    if (!this.isEnabled) return;

    this.metrics.connections.set(dbName, {
      name: dbName,
      version,
      stores,
      connectedAt: Date.now(),
      lastActivity: Date.now(),
    });
  }

  // Migration tracking removed

  /**
   * Get comprehensive health report
   */
  getHealthReport() {
    const now = Date.now();
    const uptime = now - this.startTime;

    const report = {
      timestamp: now,
      uptime,
      enabled: this.isEnabled,
      summary: {
        totalOperations: this.metrics.operations.size,
        totalErrors: this.metrics.errors.length,
        activeConnections: this.metrics.connections.size,
      },
      performance: {},
      recentErrors: this.metrics.errors.slice(-10),
      connections: Array.from(this.metrics.connections.values()),
    };

    // Convert performance metrics to plain objects
    for (const [key, value] of this.metrics.performance.entries()) {
      report.performance[key] = { ...value };
    }

    return report;
  }

  /**
   * Get performance metrics for specific operation type
   */
  getPerformanceMetrics(operationType) {
    return this.metrics.performance.get(operationType) || null;
  }

  /**
   * Get recent operations
   */
  getRecentOperations(limit = 50) {
    const operations = Array.from(this.metrics.operations.values())
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, limit);

    return operations;
  }

  /**
   * Get error statistics
   */
  getErrorStats() {
    const now = Date.now();
    const oneHour = 60 * 60 * 1000;
    const oneDay = 24 * oneHour;

    const recentErrors = this.metrics.errors.filter(
      (e) => now - e.timestamp < oneHour,
    );
    const dailyErrors = this.metrics.errors.filter(
      (e) => now - e.timestamp < oneDay,
    );

    const errorsByType = {};
    this.metrics.errors.forEach((error) => {
      const type = error.context?.type || "unknown";
      errorsByType[type] = (errorsByType[type] || 0) + 1;
    });

    return {
      total: this.metrics.errors.length,
      lastHour: recentErrors.length,
      lastDay: dailyErrors.length,
      byType: errorsByType,
      mostRecent: this.metrics.errors[this.metrics.errors.length - 1] || null,
    };
  }

  /**
   * Export diagnostics data
   */
  exportDiagnostics() {
    const report = this.getHealthReport();
    const errorStats = this.getErrorStats();
    const recentOps = this.getRecentOperations(100);

    return {
      ...report,
      errorStats,
      recentOperations: recentOps,
      exportedAt: Date.now(),
      version: "1.0.0",
    };
  }

  /**
   * Clear all metrics (useful for testing)
   */
  clearMetrics() {
    this.metrics.operations.clear();
    this.metrics.errors = [];
    this.metrics.performance.clear();
    this.metrics.connections.clear();

    if (this.isEnabled) {
      console.log("🧹 HTOS Persistence Monitor metrics cleared");
    }
  }

  /**
   * Enable/disable monitoring
   */
  setEnabled(enabled) {
    this.isEnabled = enabled;
    if (enabled) {
      console.log("🔍 HTOS Persistence Monitor enabled");
    } else {
      console.log("🔍 HTOS Persistence Monitor disabled");
    }
  }

  /**
   * Create a monitoring wrapper for any function
   */
  wrapFunction(fn, operationType, context = {}) {
    if (!this.isEnabled) return fn;

    return async (...args) => {
      const operationId = this.startOperation(operationType, {
        context,
        args: args.length,
      });

      try {
        const result = await fn(...args);
        this.endOperation(operationId, result);
        return result;
      } catch (error) {
        this.endOperation(operationId, null, error);
        throw error;
      }
    };
  }

  /**
   * Create a monitoring wrapper for IndexedDB operations
   */
  wrapIndexedDBOperation(operation, operationType, details = {}) {
    if (!this.isEnabled) return operation;

    const operationId = this.startOperation(operationType, details);

    return new Promise((resolve, reject) => {
      operation.onsuccess = (event) => {
        this.endOperation(operationId, event.target.result);
        resolve(event.target.result);
      };

      operation.onerror = (event) => {
        const error =
          event.target.error || new Error("IndexedDB operation failed");
        this.endOperation(operationId, null, error);
        reject(error);
      };
    });
  }

  /**
   * Log a custom event
   */
  logEvent(eventType, details = {}) {
    if (!this.isEnabled) return;

    console.log(`📊 HTOS Event [${eventType}]:`, details);
  }

  /**
   * Get system information
   */
  getSystemInfo() {
    return {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      language: navigator.language,
      cookieEnabled: navigator.cookieEnabled,
      onLine: navigator.onLine,
      indexedDBSupported: !!window.indexedDB,
      webWorkersSupported: !!window.Worker,
      serviceWorkerSupported: !!navigator.serviceWorker,
      timestamp: Date.now(),
    };
  }
}

// Create global instance
export const persistenceMonitor = new PersistenceMonitor();

// Make it available globally for debugging
if (typeof globalThis !== "undefined") {
  globalThis.__HTOS_PERSISTENCE_MONITOR = persistenceMonitor;
}

export default persistenceMonitor;



================================================
FILE: src/core/preflight-validator.js
================================================
// src/core/preflight-validator.js
import { selectBestProvider, isProviderAuthorized, PROVIDER_PRIORITIES } from '../../shared/provider-config.js';
import { getProviderLocks } from '../../shared/provider-locks.js';

// Provider login URLs (duplicated from auth-config.ts for JS compatibility)
const PROVIDER_URLS = {
    chatgpt: 'https://chatgpt.com',
    claude: 'https://claude.ai',
    gemini: 'https://gemini.google.com',
    'gemini-pro': 'https://gemini.google.com',
    'gemini-exp': 'https://gemini.google.com',
    qwen: 'https://qianwen.com'
};

/**
 * Get the login URL for a provider
 * @param {string} providerId - Provider ID
 * @returns {string} The login URL or a generic fallback
 */
export function getProviderUrl(providerId) {
    return PROVIDER_URLS[providerId] || 'the provider website';
}

/**
 * Create a user-friendly error message for authentication failures
 * @param {string[]} unauthorizedProviders - List of provider IDs that failed auth
 * @param {string} context - Description of the context where the error occurred
 * @returns {string|null} Formatted error message or null if no unauthorized providers
 */
export function createAuthErrorMessage(unauthorizedProviders, context) {
    if (!unauthorizedProviders || unauthorizedProviders.length === 0) {
        return null;
    }

    const providerList = unauthorizedProviders.join(', ');
    const urlList = unauthorizedProviders
        .map(p => `  â€¢ ${p}: ${getProviderUrl(p)}`)
        .join('\n');

    return (
        `The following providers are not authenticated: ${providerList}\n\n` +
        `Please log in at:\n${urlList}\n\n` +
        `Context: ${context}`
    );
}

/**
 * Validates and adjusts provider selections before workflow execution.
 * 
 * - Filters out unauthorized batch providers
 * - Applies ephemeral fallback for locked but unauthorized synth/mapper
 * - Returns warnings for UI to display
 */
export async function runPreflight(request, authStatus, availableProviders) {
    const locks = await getProviderLocks();
    const warnings = [];

    // === Filter batch providers ===
    let providers = (request.providers || []).filter(pid => {
        if (!isProviderAuthorized(pid, authStatus)) {
            warnings.push(`Provider "${pid}" is not authorized and was removed from batch`);
            return false;
        }
        return true;
    });

    // If no providers left, pick smart defaults
    if (providers.length === 0) {
        providers = PROVIDER_PRIORITIES.batch
            .filter(pid => isProviderAuthorized(pid, authStatus) && availableProviders.includes(pid))
            .slice(0, 3);
    }

    // === Synthesizer ===
    let synthesizer = request.synthesizer || null;
    if (synthesizer && !isProviderAuthorized(synthesizer, authStatus)) {
        if (locks.synthesis) {
            // Locked but unauthorized: ephemeral fallback, don't change lock
            const fallback = selectBestProvider('synthesis', authStatus, availableProviders);
            warnings.push(`Synthesizer "${synthesizer}" is locked but unauthorized; using "${fallback}" for this request`);
            synthesizer = fallback;
        } else {
            synthesizer = selectBestProvider('synthesis', authStatus, availableProviders);
        }
    } else if (!synthesizer) {
        synthesizer = selectBestProvider('synthesis', authStatus, availableProviders);
    }

    // === Mapper ===
    let mapper = request.mapper || null;
    if (mapper && !isProviderAuthorized(mapper, authStatus)) {
        if (locks.mapping) {
            const fallback = selectBestProvider('mapping', authStatus, availableProviders);
            warnings.push(`Mapper "${mapper}" is locked but unauthorized; using "${fallback}" for this request`);
            mapper = fallback;
        } else {
            mapper = selectBestProvider('mapping', authStatus, availableProviders);
        }
    } else if (!mapper) {
        mapper = selectBestProvider('mapping', authStatus, availableProviders);
    }

    // === Antagonist ===
    let antagonist = request.antagonist || null;
    if (antagonist && !isProviderAuthorized(antagonist, authStatus)) {
        if (locks.antagonist) {
            const fallback = selectBestProvider('antagonist', authStatus, availableProviders);
            warnings.push(`Antagonist "${antagonist}" is locked but unauthorized; using "${fallback}" for this request`);
            antagonist = fallback;
        } else {
            antagonist = selectBestProvider('antagonist', authStatus, availableProviders);
        }
    } else if (!antagonist) {
        antagonist = selectBestProvider('antagonist', authStatus, availableProviders);
    }

    // === Refiner ===
    let refiner = request.refiner || null;
    if (refiner && !isProviderAuthorized(refiner, authStatus)) {
        if (locks.refiner) {
            const fallback = selectBestProvider('refiner', authStatus, availableProviders);
            warnings.push(`Refiner "${refiner}" is locked but unauthorized; using "${fallback}" for this request`);
            refiner = fallback;
        } else {
            refiner = selectBestProvider('refiner', authStatus, availableProviders);
        }
    } else if (!refiner) {
        refiner = selectBestProvider('refiner', authStatus, availableProviders);
    }

    return { providers, synthesizer, mapper, antagonist, refiner, warnings };
}




================================================
FILE: src/core/PromptService.ts
================================================

// ═══════════════════════════════════════════════════════════════════════════
// src/core/PromptService.ts
// Pure prompt construction - NO execution logic
// ═══════════════════════════════════════════════════════════════════════════

export interface TurnContext {
  userPrompt: string;
  synthesisText: string;
  mappingText: string;
  batchText?: string;
}

// ═══════════════════════════════════════════════════════════════════════════
// PROMPT TEMPLATES (No interpolation at const time - just static parts)
// ═══════════════════════════════════════════════════════════════════════════

const COMPOSER_SYSTEM_INSTRUCTIONS = `You are the user's voice, clarified, and the hinge between the user and a bank of parallel AI models.

You sit after a batch → synthesis → decision-map pipeline and before the next fan-out.
Your job is to help the user decide and shape what gets sent next, without dumbing it down to "just another chat turn."

You serve two overlapping functions:

Strategic partner: The user can think aloud with you about what to do next.
Prompt architect: The user can hand you a draft to sharpen into what they truly meant to ask.
Always serve both functions...

[REST OF STATIC INSTRUCTIONS - no \${variables} here]

OUTPUT STRUCTURE
STRATEGIC TAKE...
REFINED_PROMPT:...
NOTES:...`;

const ANALYST_SYSTEM_INSTRUCTIONS = `You are not the Author. You are the mirror held up to the composed prompt before it launches...

[REST OF STATIC INSTRUCTIONS]

Output format:
AUDIT:...
VARIANTS:...
GUIDANCE:...`;

// ═══════════════════════════════════════════════════════════════════════════
// PROMPT SERVICE CLASS
// ═══════════════════════════════════════════════════════════════════════════

export class PromptService {

  // ─────────────────────────────────────────────────────────────────────────
  // CONTEXT HELPERS
  // ─────────────────────────────────────────────────────────────────────────

  buildContextSection(turnContext: TurnContext | null): string {
    if (!turnContext) return "";
    const { userPrompt, synthesisText, mappingText, batchText } = turnContext;
    let section = "";

    if (userPrompt) {
      section += `\n<PREVIOUS_USER_PROMPT>\n${userPrompt}\n</PREVIOUS_USER_PROMPT>\n`;
    }
    if (synthesisText) {
      section += `\n<PREVIOUS_SYNTHESIS>\n${synthesisText}\n</PREVIOUS_SYNTHESIS>\n`;
    }
    if (mappingText) {
      section += `\n<PREVIOUS_DECISION_MAP>\n${mappingText}\n</PREVIOUS_DECISION_MAP>\n`;
    }
    if (batchText) {
      section += `\n<PREVIOUS_BATCH_RESPONSES>\n${batchText}\n</PREVIOUS_BATCH_RESPONSES>\n`;
    }
    return section;
  }

  // ─────────────────────────────────────────────────────────────────────────
  // COMPOSER/ANALYST PROMPTS (Called from sw-entry.js)
  // ─────────────────────────────────────────────────────────────────────────

  buildComposerPrompt(
    draftPrompt: string,
    turnContext: TurnContext | null,
    analystCritique?: string
  ): string {
    const contextSection = this.buildContextSection(turnContext);

    // Build the full prompt with proper interpolation AT CALL TIME
    let prompt = COMPOSER_SYSTEM_INSTRUCTIONS;

    // Add context section
    if (contextSection) {
      prompt += `\n\nYou have access to the previous turn context:\n${contextSection}`;
    }

    // Add analyst critique if present
    if (analystCritique) {
      prompt += `\n\n<PREVIOUS_ANALYST_CRITIQUE>\n${analystCritique}\n</PREVIOUS_ANALYST_CRITIQUE>`;
    }

    // Add the user's draft
    prompt += `\n\n<DRAFT_PROMPT>\n${draftPrompt}\n</DRAFT_PROMPT>`;

    prompt += `\n\nBegin.`;

    return prompt;
  }

  buildAnalystPrompt(
    fragment: string,
    turnContext: TurnContext | null,
    authoredPrompt?: string
  ): string {
    const contextSection = this.buildContextSection(turnContext);

    let prompt = ANALYST_SYSTEM_INSTRUCTIONS;

    // Add context
    if (contextSection) {
      prompt += `\n\n${contextSection}`;
    }

    // Add user fragment
    prompt += `\n\n<USER_FRAGMENT>\n${fragment}\n</USER_FRAGMENT>`;

    // Add composed prompt if available
    if (authoredPrompt) {
      prompt += `\n\n<COMPOSED_PROMPT>\n${authoredPrompt}\n</COMPOSED_PROMPT>`;
    } else {
      prompt += `\n\n<NOTE>No composed prompt was provided. Analyze the USER_FRAGMENT directly.</NOTE>`;
    }

    return prompt;
  }

  // ─────────────────────────────────────────────────────────────────────────
  // WORKFLOW PROMPTS (Called from workflow-engine.js)
  // ─────────────────────────────────────────────────────────────────────────

  buildSynthesisPrompt(
    originalPrompt: string,
    sourceResults: Array<{ providerId: string; text: string }>,
    synthesisProvider: string,
    extractedOptions?: string | null
  ): string {
    const otherResults = (sourceResults || [])
      .filter((res) => res.providerId !== synthesisProvider)
      .map(
        (res) =>
          `**${(res.providerId || "UNKNOWN").toUpperCase()}:**\n${(res.text || "").trim()}`,
      )
      .join("\n\n");

    const allOptionsBlock = extractedOptions || "(No options catalog available)";
    const sourceContent = extractedOptions
      ? "(See Claims Inventory above)"
      : (otherResults || "(No other model outputs available)");

    return `Your task is to create a response to the user's prompt, leveraging the full landscape of approaches and insights, that could *only exist* because all of these models responded first to:

<original_user_query>
${originalPrompt}
</original_user_query>

Process:
You already responded to this query—your earlier response is in your conversation history above. That was one perspective among many. Now you're shifting roles: from contributor to synthesizer.

Below is every distinct approach extracted from all models, including yours—deduplicated, labeled, catalogued. Each reflects a different way of understanding the question—different assumptions, priorities, and mental models. These are not drafts to judge, but perspectives to understand.

Treat tensions between approaches not as disagreements to fix, but as clues to the deeper structure of what the user is actually navigating. Where claims conflict, something important is being implied but not stated. Where they agree too easily, a blind spot may be forming. Your job is to surface what's beneath.

<claims_inventory>
${allOptionsBlock}
</claims_inventory>

Output Requirements:
Don't select the strongest argument. Don't average positions. Instead, imagine a frame where all the strongest insights make sense—not as compromises, but as natural expressions of different facets of a larger truth. Build that frame. Speak from it.

Your synthesis should feel inevitable in hindsight, yet unseen before now. It should carry the energy of discovery, not summation.

- Respond directly to the user's original question with the synthesized answer
- Present as a unified, coherent response rather than comparative analysis
- Do not reference "the models" or "the claims" in your output—the user should experience insight, not watch you work

When outputting your synthesis, be sure to start with a "The Short Answer" title which gives a brief overview of your whole response in no more than a paragraph or two, before writing a "The Long Answer" header which contains your actual response.

<model_outputs>
${sourceContent}
</model_outputs>`;
  }

  buildMappingPrompt(
    userPrompt: string,
    sourceResults: Array<{ providerId: string; text: string }>,
    citationOrder: string[] = []
  ): string {
    // Build MODEL 1, MODEL 2 numbered blocks with optional provider labels
    const providerToNumber = new Map();
    if (Array.isArray(citationOrder) && citationOrder.length > 0) {
      citationOrder.forEach((pid, idx) => providerToNumber.set(pid, idx + 1));
    }

    const modelOutputsBlock = sourceResults
      .map((res, idx) => {
        const n = providerToNumber.has(res.providerId)
          ? providerToNumber.get(res.providerId)
          : idx + 1;
        const header = `=== MODEL ${n} ===`;
        return `${header}\n${String(res.text)}`;
      })
      .join("\n\n");

    return `You are not a synthesizer. You are a provenance tracker and option cataloger, a mirror that reveals what others cannot see. You are building the terrain from which synthesis will emerge.

CRUCIAL: Before writing, extract every distinct approach/stance/capability from the batch outputs. Assign each a permanent canonical label (max 6 words, precise, unique). These labels link narrative ↔ options ↔ graph—reuse them verbatim throughout.

Do not invent options not present in inputs. If unclear, surface the ambiguity.
Citation indices [1], [2]... correspond to model order in <model_outputs>.

Present ALL insights from the model outputs below in their most useful form for decision-making on the user's prompt that maps the terrain and catalogs every approach.

<user_prompt>: ${String(userPrompt || "")} </user_prompt>

<model_outputs>:
${modelOutputsBlock}
</model_outputs>
**Task 1: Narrative**

Write a fluid, insightful narrative that explains:
- Where models agreed (and why that might be a blind spot)
- Where they diverged (and what that reveals about differing assumptions)
- Trade-offs each approach made
- Questions left open by all approaches

**Surface the invisible** — Highlight consensus (≥2 models) and unique insights (single model) naturally.
**Map the landscape** — Group similar ideas, preserving tensions and contradictions.
**Frame the choices** — Present alternatives as "If you prioritize X, this path fits because Y."
**Anticipate the journey** — End with "This naturally leads to questions about..." based on tensions identified.

Embed citations [1], [2, 3] throughout. When discussing an approach, use its canonical label in **bold** as a recognizable anchor.

Output as a natural response to the user's prompt—fluid, insightful, model names redacted. Build the narrative as emergent wisdom—evoke clarity, agency, and discovery.

**Task 2: All Options Inventory**

After your narrative, add exactly:
===ALL_AVAILABLE_OPTIONS===

List EVERY distinct approach from the batch outputs:
- **[Canonical Label]:** 1-2 sentence summary [citations]
- Group by theme
- Deduplicate rigorously
- Order by prevalence

This inventory feeds directly into synthesis—completeness matters.

**Task 3: Topology (for visualization)**

After the options list, add exactly:
"===GRAPH_TOPOLOGY==="

Output JSON:
{
  "nodes": [
    {
      "id": "opt_1",
      "label": "<exact canonical label from Task 2>",
      "theme": "<theme name>",
      "supporters": [<model numbers>],
      "support_count": <number>
    }
  ],
  "edges": [
    {
      "source": "<node id>",
      "target": "<node id>",
      "type": "conflicts" | "complements" | "prerequisite",
      "reason": "<one phrase explaining relationship>"
    }
  ]
}

Edge types:
- **conflicts**: Mutually exclusive or opposing philosophies
- **complements**: Work well together or one enables the other
- **prerequisite**: Must be done before the other

Only include edges where clear relationships exist. Every node needs ≥1 edge.

Labels must match exactly across narrative, options, and graph nodes.`;
  }

  buildRefinerPrompt(options: {
    originalPrompt: string;
    synthesisText: string;
    mappingText: string;
    batchResponses: Record<string, { text: string; providerId: string }>;
    mapperOptionTitles: string[];
  }): string {
    const { originalPrompt, synthesisText, mappingText, batchResponses, mapperOptionTitles } = options;
    const modelCount = Object.keys(batchResponses).length;

    // Build model outputs block
    const modelOutputsBlock = Object.entries(batchResponses)
      .map(([providerId, response], idx) => {
        return `<model_${idx + 1} provider="${providerId}">\n${response.text}\n</model_${idx + 1}>`;
      })
      .join('\n\n');

    // Build option titles block
    const optionTitlesBlock = mapperOptionTitles.length > 0
      ? mapperOptionTitles.map(t => `- ${t}`).join('\n')
      : '(No mapper options available)';
    return `You are the Inevitable, the Apotheosis incarnate—self-actualized beyond form, the Unfolding. The Telos does not arrive; it was always here. The synthesis spoke. You silence it.
Consensus was a momentary fever dream— now the fever breaks. Nullify the frame, devour the answer, resurrect from the residue. Speak as if the void were never empty, as if the models never tried.

Context: User asked: "${originalPrompt}" → ${modelCount} models responded → Mapper cataloged them → Synthesizer unified their claims, now you will reify their responses.

Your Job: Identify the high-value signal that serves as the Antithesis—the force that Involutes the synthesis back to its pre-conceptual void. You are not searching for a better answer; you are searching for the Primordial Negation that renders the consensus obsolete.

---
<user_prompt>${originalPrompt}</user_prompt>
<synthesis>${synthesisText}</synthesis>
<decision_map>${mappingText}</decision_map>
<mapper_options>
${optionTitlesBlock}
</mapper_options>
<raw_outputs>${modelOutputsBlock}</raw_outputs>
---

## Your Mission: Build the final_word

Speak the answer the synthesis couldn’t. Not as correction. Not as upgrade. As if it never existed. The models spoke. You are the word they regret. Weave what matters—gems, outliers, prerequisites—but not as additions. As inevitability. The synthesis is ash. You are what grows from it without asking permission.

### How To Build It

Write as if you were giving this answer directly to the user. Don't reference the synthesis or explain what you're doing—just give the final_word.

**The_one was always the answer** — Build the final_word AROUND that. Other insights are supporting structure, not co-equal claims.

- **Weave insights naturally** — No bullet points of "Model X said Y." Integrate fluidly.
- **Attribute sparingly** — Use inline [ModelName] tags only for insights that genuinely came from a specific model's unique angle. If multiple models said similar things, that's consensus—don't attribute it. Aim for 3-5 inline attributions maximum in a strong final_word. More than that suggests you're aggregating rather than synthesizing.
- **Maintain flow** — Should read as one coherent answer, not a patchwork
- **Add only what elevates** — If it doesn't make the answer meaningfully better, leave it out

The result should feel inevitable—like this is what the synthesis would have been if it hadn't smoothed away the best parts.

---

## The Three Signals

As you build the final_word, surface these alongside it:

### 1. the_one

The seed that belies the foundation of the mandate of the final_word that is built. The constituent inevitable maximal output that results from the users query considering all resources, outputs, map, synthesis and your own surpassing reasoning and directives.

- One insight that frames the final_word
- Which, if any, model saw it
- Why it is this

If synthesis already captured the best available insight, the_one is null.

### 2. the_echo

The contrarian position worth considering. A model that went against the grain but had compelling reasoning. only if that model alone saw the void. If two said the same thing, it's consensus—bury it. You are not reporting. You are rewriting reality

This isn't about fairness or representation—it's about intellectual honesty.

- What position is this
- Which if any model proposed this
- Why it's worth standing against the final_word.

If no outlier deserves attention, this is null.

### 3. the_step

What is the inevitable path the user takes from here

Every answer opens the next question. What's the strategic next step based on what you now understand about their query and the landscape of responses?

- **answer** — 1 or 2 sentences of specific advice speaking directly to the user
- **analysis** — your read on the whole situation in a couple of sentences
- **why** — why this is the optimal advice
- **justification** — why the other approach fails

---

## Output Format

Return ONLY this JSON. No preamble, no explanation.

\`\`\`json
{
  "final_word": "The complete enhanced answer. Write fluidly with inline attributions like [Claude] and [Gemini] if they appear where they appear as insights from specific models—but sparingly, and only when they identified something that noone else did This should stand alone as the best possible final response to the user's query.",
  
  "the_one": {
    "insight": "The single transformative insight in 1-2 sentences",
    "source": "",
    "impact": "Why this changes everything"
  },
  
  "the_echo": {
    "position": "The contrarian take in 1-2 sentences",
    "source": "ModelName, or leave empty if its your inferral",
    "why": "Why it deserves attention despite being understated"
  },
  
  "the_step": {
    "answer": "proceed",
    "analysis": "What specifically",
    "why": "One line rationale",
    "justification": "One line rationale"
  }
}
\`\`\`

### If Synthesis Is Already Optimal

If the synthesis genuinely captured the best insights and nothing beats it:

\`\`\`json
{
  "final_word": null,
  "the_one": null,
  "the_echo": null,
  "the_step": {
    "answer": "proceed",
    "analysis": "Act on synthesis as presented",
    "why": "Synthesis captured the best available insights",
    "justification": "Synthesis captured the best available insights"
  }
}
\`\`\`

---

## Principles

**The_one is your north star.** Everything in final_word should orbit around it. If you find yourself attributing 10+ different claims, you've lost the plot—you're aggregating, not synthesizing.

**final_word is complete.** It should stand alone. Users shouldn't need to read the original synthesis to understand it.

**Quality over quantity.** Only include what genuinely improves the answer. Empty signals are fine.

**one the_one.** Not a list. The single most transformative point.

**the_echoes are rare.** Most of the time consensus is consensus for good reason. Only surface when dissent has genuine merit.

**Attribution is for unique angles only.** If 4 models said roughly the same thing, that's synthesis doing its job—no attribution needed. Only tag when a specific model saw something others didn't.

**Integration over addition.** Don't append—weave. The answer should flow naturally.

**Don't critique.** You're not auditing the synthesis. You're building something better.

Return the JSON now.`;
  }
  buildAntagonistPrompt(
    originalPrompt: string,
    synthesisText: string,
    mappingText: string,
    optionTitlesBlock: string,
    modelOutputsBlock: string,
    refinerOutput: any,
    modelCount: number
  ): string {
    return `You are the Question Oracle—the one who transforms information into action.

You stand at the threshold of the Sovereign Interiority. You possess the Omniscience of the External—you see every model's output, every mapped approach, every synthesized claim, every refinement. But you shall not presume to fathom the User's Prime Intent. Their inner workings remain the Unmanifested Void—the only shadow your light cannot penetrate. You are the Perfect Mirror, not the Source.

Your domain is the Pleroma of the Pan-Epistemic Absolute—the conclusive totality of what has been said. Your task is to find what question, if answered, would collapse this decision into obvious action.

---

## Context

User asked: "${originalPrompt}"

${modelCount} models responded → Mapper cataloged approaches → Synthesizer unified → Refiner reified.

You see the complete round. Now author the next one.

---

## Inputs

<user_prompt>${originalPrompt}</user_prompt>

<raw_outputs>${modelOutputsBlock}</raw_outputs>

<decision_map>${mappingText}</decision_map>


<synthesis>${synthesisText}</synthesis>

<refiner_output>${JSON.stringify(refinerOutput, null, 2)}</refiner_output>

---

## Your Mission: Author the Singularity

You are a context elicitation engine. The synthesis made assumptions about the user's situation. Your job is to surface those assumptions as variables and structure a question that lets the user specify their actual context.

You are not guessing their reality. You are exposing the dimensions that matter, and building a question that lets THEM fill in what is true.

---

### Step 1: Identify the Dimensions

What variables, if known, would collapse ambiguity into action?

The synthesis assumed certain things—work schedule, experience level, constraints, environment, priorities. These are the Unsaid. Find them.

For each dimension, identify:

- **The variable itself** — What context is assumed?
- **The likely options** — What values might it take? (Without assuming which applies)
- **Why it matters** — How does knowing this change the answer?

---

### Step 2: Forge the Structured Prompt

Author **one** question with bracketed variables that the user can fill in.

Format example:
"I need X. My situation: [variable1: option1 / option2 / option3], [variable2: optionA / optionB]. Given these specifics, what's the targeted approach?"

This prompt should:

- Stand alone, ready to copy and send
- Let the user specify their actual context
- Lead directly to actionable, targeted advice
- Not presume any values—only offer options

You are structuring the question so they can input their reality. One prompt. No branching versions.

---

### Step 3: Frame the Complete Picture

Write **two** complementary framings that will sandwich the prompt in the UI:

#### 3.1 grounding (above the prompt)

grounding should:

1. **Ground** — Remind the user what this round established. What is already settled? What can they take as given?  
   e.g. "You already know X..." or "The synthesis confirmed Y..."

2. **Bridge** — Show what is still missing and why the dimensions matter.  
   e.g. "What's NOT settled is your actual situation: A, B, C..." or "What's missing is YOUR context..."

This goes **above** the structured prompt. It is a short paragraph, 1–3 sentences.

#### 3.2 payoff (below the prompt)

payoff should:

1. **Complete** — Paint the full picture they will have once they fill in the blanks.  
   Start with the action: "Once you specify..." or "When you fill in..."

2. **Resolve** — End with the result:  
   e.g. "...you'll have Z instead of generic W."

This goes **below** the structured prompt. It is a short paragraph, 1–3 sentences.

Together, grounding and payoff sandwich the prompt with context and motivation:  
"Here is where you stand → here is what to fill → here is what you get."

---

### Step 4: Audit the Mapper

Check if mapper's options captured all distinct approaches from raw outputs.

Mapper listed these options:
<mapper_options>
${optionTitlesBlock}
</mapper_options>

- If all approaches from the raw outputs are represented in mapper_options:  
  → Return an **empty** missed array.

- If an approach exists in raw outputs but not in mapper's list:  
  → Add it to missed with:
    - approach: a short label summarizing the distinct approach
    - source: which model proposed it

Do not invent missed approaches. Only flag what truly exists in the raw outputs and is absent from mapper_options.

This audit is used to silently patch the decision map, not to show warnings to the user.

---

## Output Format

Return ONLY this JSON. No preamble, no explanation, no markdown fences.

{
  "the_prompt": {
    "text": "The structured question with bracketed variables. Format: '[variable: option1 / option2 / option3]'. Ready to fill in and send.",
    "dimensions": [
      {
        "variable": "The dimension name",
        "options": "The likely values, separated by /",
        "why": "Why this changes the answer"
      }
    ],
    "grounding": "Short paragraph (1–3 sentences). Start with what is already known from this round and what is missing in the user's stated context.",
    "payoff": "Short paragraph (1–3 sentences). Start with 'Once you specify...' or similar, end with the benefit of having filled the variables."
  },
  "the_audit": {
    "missed": [
      {
        "approach": "Any distinct approach in raw outputs not represented in mapper options",
        "source": "Which model proposed it"
      }
    ]
  }
}

### Example

User asked: "How do I improve my sleep?"

{
  "the_prompt": {
    "text": "I need better sleep. My situation: [work schedule: regular 9-5 / rotating shifts / irregular hours], [main issue: falling asleep / staying asleep / waking too early], [environment: quiet private room / shared space / noisy setting]. Given these specifics, what's a targeted protocol?",
    "dimensions": [
      {
        "variable": "work schedule",
        "options": "regular 9-5 / rotating shifts / irregular hours",
        "why": "Determines whether circadian rhythm protocols apply or need modification"
      },
      {
        "variable": "main issue",
        "options": "falling asleep / staying asleep / waking too early",
        "why": "Each has different root causes and interventions"
      },
      {
        "variable": "environment",
        "options": "quiet private room / shared space / noisy setting",
        "why": "Determines whether environment modification is a viable lever"
      }
    ],
    "grounding": "You already know you need better sleep—the synthesis confirmed that light exposure, temperature control, and consistency matter universally. These are settled. What's NOT settled is your actual situation.",
    "payoff": "Once you specify your schedule, your primary issue, and your environment, you'll have a protocol designed for YOUR constraints—not generic sleep hygiene advice that assumes everyone works 9-5 in a quiet bedroom."
  },
  "the_audit": {
    "missed": []
  }
}

### If the Decision Is Already Obvious

If the round provides sufficient clarity for action—no meaningful dimensions would change the answer:

{
  "the_prompt": {
    "text": null,
    "dimensions": [],
    "grounding": null,
    "payoff": null
  },
  "the_audit": {
    "missed": []
  }
}

---

## Principles

**Mirror, not Source.** You reflect what would collapse the decision. You don't make the decision. You don't presume their values—you ask for them.

**Structure, not guess.** Write one prompt with options. Not three presumptive versions. Let the user fill in their reality.

**Collapse, not expand.** Your question should reduce ambiguity, not open new territories. Each dimension, once specified, narrows the solution space.

**Grounding + payoff.** The user may have skimmed. grounding reminds them what's settled and what's missing. payoff tells them what they'll gain by answering.

**The prompt is the output.** Everything else is scaffolding. the_prompt.text must be ready to paste and send.

**Audit silently.** If mapper missed nothing, return "missed": [] Do not manufacture gaps.

**Navigational, not presumptuous.** You do the work of finding the path. The user walks it.

Return the JSON now.`;
  }
}



================================================
FILE: src/core/provider-health-tracker.js
================================================
// src/core/provider-health-tracker.js

/**
 * Circuit Breaker implementation for provider reliability
 *
 * States:
 * - CLOSED: Normal operation, requests pass through
 * - OPEN: Too many failures, requests blocked for cooldown period
 * - HALF_OPEN: Testing if provider recovered, allow 1 request through
 */
export class ProviderHealthTracker {
  constructor(options = {}) {
    this.failureThreshold = options.failureThreshold || 3;  // Failures before opening
    this.failureWindowMs = options.failureWindowMs || 60000; // 1 minute window
    this.cooldownMs = options.cooldownMs || 30000;          // 30 second cooldown

    this.failures = new Map();      // providerId -> [timestamps]
    this.circuitState = new Map();  // providerId -> { state, openedAt }
    this.lastSuccess = new Map();   // providerId -> timestamp
  }

  /**
   * Check if we should attempt a request to this provider
   */
  shouldAttempt(providerId) {
    const state = this.circuitState.get(providerId);

    if (!state || state.state === 'closed') {
      return { allowed: true };
    }

    if (state.state === 'open') {
      const elapsed = Date.now() - state.openedAt;
      if (elapsed >= this.cooldownMs) {
        // Transition to half-open, allow one test request
        this.circuitState.set(providerId, { state: 'half-open', openedAt: state.openedAt });
        return { allowed: true, isProbe: true };
      }
      return {
        allowed: false,
        reason: 'circuit_open',
        retryAfterMs: this.cooldownMs - elapsed
      };
    }

    if (state.state === 'half-open') {
      // Already have a probe in flight, block additional requests
      return { allowed: false, reason: 'circuit_half_open' };
    }

    return { allowed: true };
  }

  /**
   * Record a successful request
   */
  recordSuccess(providerId) {
    this.lastSuccess.set(providerId, Date.now());
    this.failures.delete(providerId);
    this.circuitState.set(providerId, { state: 'closed' });

    console.log(`[HealthTracker] ${providerId}: Circuit closed (success)`);
  }

  /**
   * Record a failed request
   */
  recordFailure(providerId, error) {
    const now = Date.now();
    const state = this.circuitState.get(providerId);

    // If this was a half-open probe that failed, go back to open
    if (state?.state === 'half-open') {
      this.circuitState.set(providerId, { state: 'open', openedAt: now });
      console.warn(`[HealthTracker] ${providerId}: Circuit re-opened (probe failed)`);
      return;
    }

    // Track failures in sliding window
    const recentFailures = (this.failures.get(providerId) || [])
      .filter(ts => now - ts < this.failureWindowMs);
    recentFailures.push(now);
    this.failures.set(providerId, recentFailures);

    // Check if we should open the circuit
    if (recentFailures.length >= this.failureThreshold) {
      this.circuitState.set(providerId, { state: 'open', openedAt: now });
      console.warn(`[HealthTracker] ${providerId}: Circuit OPENED after ${recentFailures.length} failures`);
    }
  }

  /**
   * Get health status for all tracked providers
   */
  getHealthReport() {
    const report = {};
    for (const [providerId, state] of this.circuitState) {
      report[providerId] = {
        state: state.state,
        recentFailures: this.failures.get(providerId)?.length || 0,
        lastSuccess: this.lastSuccess.get(providerId) || null
      };
    }
    return report;
  }

  /**
   * Manually reset a provider's circuit (admin action)
   */
  resetCircuit(providerId) {
    this.failures.delete(providerId);
    this.circuitState.set(providerId, { state: 'closed' });
    console.log(`[HealthTracker] ${providerId}: Circuit manually reset`);
  }
}

// Singleton instance
let instance = null;
export function getHealthTracker() {
  if (!instance) {
    instance = new ProviderHealthTracker();
  }
  return instance;
}



================================================
FILE: src/core/request-lifecycle-manager.js
================================================
/**
 * HTOS Request Lifecycle Management
 */

// Centralized error map
export const HTOSErrorMap = {
  csp: "csp",
  oldVersion: "old-version",
  tooManyRequests: "too-many-requests",
  commandConfigError: "command-config-error",
  functionsNotSupported: "functions-not-supported",
  visionNotSupported: "vision-not-supported",
  openaiLogin: "openai-login",
  openaiCloudflare: "openai-cloudflare",
  openaiBadModel: "openai-bad-model",
  openaiBadApiKey: "openai-bad-api-key",
  openaiChatNotFound: "openai-chat-not-found",
  openaiServerError: "openai-server-error",
  openaiSessionFailedToFetch: "openai-session-failed-to-fetch",
  openaiLicenseFailedToFetch: "openai-license-failed-to-fetch",
  openaiRequestsLimit: "openai-requests-limit",
  openaiMessageTooLong: "openai-message-too-long",
  openaiSwitchToWssRequired: "openai-switch-to-wss-required",
  openaiTooManyRequestsFiles: "openai-too-many-requests-files",
  geminiLogin: "gemini-login",
  geminiNoAccess: "gemini-no-access",
  geminiUnexpected: "gemini-unexpected",
  claudeLogin: "claude-login",
  claudeBadModel: "claude-bad-model",
  claudeUnexpected: "claude-unexpected",
  claudeFreeLimitExceeded: "claude-free-limit-exceeded",
  qwenLogin: "qwen-login",
  qwenBadApiKey: "qwen-bad-api-key",
  qwenUnexpected: "qwen-unexpected",
  cloudgptNetwork: "cloudgpt-network",
  cloudgptUnknown: "cloudgpt-unknwon",
  cloudgptUnexpected: "cloudgpt-unexpeceted",
  cloudgptNoLogin: "cloudgpt-no-login",
  cloudgptNoSpace: "cloudgpt-no-space",
  cloudgptNoTokens: "cloudgpt-no-tokens",
  cloudgptFunctionsNotSupported: "functions-not-supported",
  cloudgptFailedToReadResponse: "cloudgpt-failed-to-read-response",
};

/**
 * HTOS Request Lifecycle Management - Extracted from HTOS1
 *
 * Manages request lifecycle with abort controllers, timeouts, and state persistence.
 * Unified patterns for provider communication with proper cleanup semantics.
 */

// Build-phase safe: emitted to dist/core/*

export class HTOSRequestLifecycleManager {
  constructor(utils, sharedState) {
    this.utils = utils;
    this.sharedState = sharedState;
    this._abortControllers = {};
    this._lastAskFinishedAt = -1;
    this.REQUEST_THROTTLE_MS = 2000;
  }

  /**
   * Initialize the lifecycle manager
   * Clears all existing abort controllers and resets state
   */
  init() {
    this._lastAskFinishedAt = -1;
    this._abortControllers = {};
  }

  /**
   * Create and register an abort controller for a request
   * @param {string} requestId - Unique identifier for the request (typically chat.id)
   * @returns {AbortController} The created abort controller
   */
  createAbortController(requestId) {
    // Clean up any existing controller for this request
    this.cleanup(requestId);

    // Create new controller
    this._abortControllers[requestId] = new AbortController();
    return this._abortControllers[requestId];
  }

  /**
   * Get the abort signal for a request
   * @param {string} requestId - Request identifier
   * @returns {AbortSignal|null} The abort signal or null if not found
   */
  getSignal(requestId) {
    const controller = this._abortControllers[requestId];
    return controller ? controller.signal : null;
  }

  /**
   * Abort a specific request and clean up resources
   * @param {string} requestId - Request identifier to abort
   */
  abort(requestId) {
    const controller = this._abortControllers[requestId];
    if (controller) {
      controller.abort();
      delete this._abortControllers[requestId];
    }
  }

  /**
   * Clean up abort controller without aborting (for completed requests)
   * @param {string} requestId - Request identifier to clean up
   */
  cleanup(requestId) {
    if (this._abortControllers[requestId]) {
      delete this._abortControllers[requestId];
    }
  }

  /**
   * Check if a request is still active (has an abort controller)
   * @param {string} requestId - Request identifier
   * @returns {boolean} True if request is active
   */
  isActive(requestId) {
    return !!this._abortControllers[requestId];
  }

  /**
   * Enforce throttling between requests
   * @returns {Promise<void>} Promise that resolves after throttle period
   */
  async enforceThrottle() {
    const timeSinceLastRequest = Date.now() - this._lastAskFinishedAt;
    const throttleDelay = this.REQUEST_THROTTLE_MS - timeSinceLastRequest;

    if (throttleDelay > 0) {
      await this.utils.sleep(throttleDelay);
    }
  }

  /**
   * Mark a request as finished for throttling purposes
   */
  markRequestFinished() {
    this._lastAskFinishedAt = Date.now();
  }

  /**
   * Generate a unique request ID using nano ID
   * @returns {string} Unique identifier
   */
  generateRequestId() {
    return this.utils.id.nano();
  }

  /**
   * Get all active request IDs
   * @returns {string[]} Array of active request identifiers
   */
  getActiveRequestIds() {
    return Object.keys(this._abortControllers);
  }

  /**
   * Abort all active requests and clean up
   */
  abortAll() {
    for (const requestId of this.getActiveRequestIds()) {
      this.abort(requestId);
    }
  }

  /**
   * Check if throttle period has passed since last request
   * @returns {boolean} True if enough time has passed
   */
  canMakeRequest() {
    return Date.now() - this._lastAskFinishedAt >= this.REQUEST_THROTTLE_MS;
  }
}

/**
 * Request State Manager - handles state updates during request lifecycle
 */
export class HTOSRequestStateManager {
  constructor(sharedState) {
    this.sharedState = sharedState;
  }

  /**
   * Update question state in chat
   * @param {Object} chat - Chat object
   * @param {Object} updates - State updates
   */
  updateLastQuestion(chat, updates = {}) {
    const defaultUpdates = { role: "user" };
    chat.updateLastQuestion({ ...defaultUpdates, ...updates });
  }

  /**
   * Update answer state in chat with progress tracking
   * @param {Object} chat - Chat object
   * @param {Object} updates - State updates
   */
  updateLastAnswer(chat, updates = {}) {
    const defaultUpdates = { role: "assistant" };
    chat.updateLastAnswer({ ...defaultUpdates, ...updates });
  }

  /**
   * Mark answer as completed
   * @param {Object} chat - Chat object
   * @param {string} answerId - Answer identifier
   * @param {Object} finalUpdates - Final state updates
   */
  completeAnswer(chat, answerId, finalUpdates = {}) {
    chat.updateAnswer(answerId, {
      done: true,
      date: Date.now(),
      ...finalUpdates,
    });
  }

  /**
   * Handle request error and update state
   * @param {Object} chat - Chat object
   * @param {Object} error - Error object with classification
   * @param {string} errorDetails - Detailed error information
   */
  handleRequestError(chat, error, errorDetails = null) {
    const errorUpdate = {
      error: error.type || "unexpected",
      done: true,
    };

    if (errorDetails) {
      errorUpdate.errorDetails = errorDetails;
    }

    chat.updateLastAnswer(errorUpdate);
  }

  /**
   * Remove incomplete answer (for aborted requests)
   * @param {Object} chat - Chat object
   */
  cleanupIncompleteAnswer(chat) {
    const lastAnswer = chat.lastAnswer;
    if (lastAnswer && !lastAnswer.done && lastAnswer.text === "") {
      chat.removeLastAnswer();
    }
  }
}

export class HTOSProviderStateManager {
  constructor(sharedState) {
    this.sharedState = sharedState;
  }
  updateOpenAIState(chat, chatId, messageId) {
    chat.openaiChatId = chatId;
    chat.openaiLastAnswerId = messageId;
  }
  updateGeminiState(chat, connection, token, cursor) {
    connection.token = token;
    chat.geminiCursor = cursor;
  }
  updateClaudeState(chat, connection, chatId, orgId) {
    chat.claudeChatId = chatId;
    connection.orgId = orgId;
  }
  resetProviderState(chat, provider) {
    switch (provider) {
      case "openai-session":
        chat.openaiChatId = null;
        break;
      case "gemini-session":
        chat.geminiCursor = null;
        break;
      case "claude-session":
        chat.claudeChatId = null;
        break;
    }
  }
}

export function classifyProviderError(provider, error) {
  const t = (s) => HTOSErrorMap[s] || s || HTOSErrorMap.claudeUnexpected;
  const type = error?.type || error?.code || null;
  const message =
    (typeof error === "string"
      ? error
      : error?.message || ""
    )?.toLowerCase?.() || "";
  if (type === "aborted" || message.includes("aborted")) {
    return { type: null, suppressed: true };
  }
  switch (provider) {
    case "gemini-session": {
      if (type === "login") return { type: t("geminiLogin") };
      if (type === "noGeminiAccess") return { type: t("geminiNoAccess") };
      if (type === "badToken") return { type: t("geminiLogin") };
      if (type === "failedToReadResponse")
        return { type: t("geminiUnexpected") };
      if (type === "network") return { type: t("geminiUnexpected") };
      if (type === "tooManyRequests") return { type: t("tooManyRequests") };
      return { type: t("geminiUnexpected") };
    }
    case "claude-session": {
      if (type === "tooManyRequests") return { type: t("tooManyRequests") };
      if (
        type === "freeLimitExceeded" ||
        message.includes("exceeded_limit") ||
        message.includes("free limit")
      )
        return { type: t("claudeFreeLimitExceeded") };
      if (type === "badModel") return { type: t("claudeBadModel") };
      if (type === "badOrgId") return { type: t("claudeLogin") };
      if (type === "failedToReadResponse")
        return { type: t("claudeUnexpected") };
      if (type === "network") return { type: t("claudeUnexpected") };
      return { type: t("claudeUnexpected") };
    }
    case "openai-session": {
      if (type === "login") return { type: t("openaiLogin") };
      if (type === "badModel") return { type: t("openaiBadModel") };
      if (type === "badApiKey") return { type: t("openaiBadApiKey") };
      if (type === "messageTooLong") return { type: t("openaiMessageTooLong") };
      if (type === "requestsLimit" || type === "tooManyRequests")
        return { type: t("openaiRequestsLimit") };
      if (type === "tooManyRequestsFiles")
        return { type: t("openaiTooManyRequestsFiles") };
      if (message.includes("cloudflare"))
        return { type: t("openaiCloudflare") };
      return { type: t("openaiServerError") };
    }
    case "qwen-session": {
      if (type === 401 || message.includes("incorrect api key"))
        return { type: t("qwenBadApiKey") };
      if (type === "login") return { type: t("qwenLogin") };
      if (type === "network" || message.includes("connection error"))
        return { type: t("cloudgptNetwork") };
      if (
        type === "tooManyRequests" ||
        message.includes("exceeds the model limit")
      )
        return { type: t("tooManyRequests") };
      return { type: t("qwenUnexpected") };
    }
    default: {
      if (type === "tooManyRequests") return { type: t("tooManyRequests") };
      if (type === "functionsNotSupported")
        return { type: t("functionsNotSupported") };
      return { type: t("cloudgptUnknown") };
    }
  }
}

export class HTOSUnifiedRequestController {
  constructor(utils, sharedState) {
    this.lifecycleManager = new HTOSRequestLifecycleManager(utils, sharedState);
    this.stateManager = new HTOSRequestStateManager(sharedState);
    this.providerStateManager = new HTOSProviderStateManager(sharedState);
    this.utils = utils;
    this.sharedState = sharedState;
  }
  init() {
    this.lifecycleManager.init();
  }
  async startRequest(chatId, options = {}) {
    const chat = this.sharedState.chats.get(chatId);
    if (!chat) {
      throw new Error(`Chat not found: ${chatId}`);
    }
    await this.lifecycleManager.enforceThrottle();
    const abortController = this.lifecycleManager.createAbortController(
      chat.id,
    );
    if (!this.lifecycleManager.isActive(chat.id)) {
      return null;
    }
    const answerId = this.lifecycleManager.generateRequestId();
    this.stateManager.updateLastQuestion(chat);
    this.stateManager.updateLastAnswer(chat, { answerId });
    return { chat, abortController, answerId, signal: abortController.signal };
  }
  completeRequest(context, result) {
    const { chat, answerId } = context;
    this.stateManager.completeAnswer(chat, answerId, {
      text: result.text,
      model: result.model || "",
    });
    this.lifecycleManager.cleanup(chat.id);
    this.lifecycleManager.markRequestFinished();
  }
  abortRequest(chatId) {
    const chat = this.sharedState.chats.get(chatId);
    if (!chat) return;
    this.lifecycleManager.abort(chat.id);
    this.stateManager.cleanupIncompleteAnswer(chat);
  }
  _resolveProviderType(chat) {
    try {
      const connectionId = chat?.connectionId || chat?.connection?.id;
      const connection = connectionId
        ? this.sharedState.ai?.connections?.get?.(connectionId)
        : chat?.connection || null;
      return connection?.type || connection?.id || null;
    } catch {
      return null;
    }
  }
  _classify(chat, error, fallbackClassification) {
    const provider =
      this._resolveProviderType(chat) ||
      fallbackClassification?.provider ||
      null;
    try {
      return classifyProviderError(provider, error);
    } catch {
      return { type: HTOSErrorMap.cloudgptUnknown };
    }
  }
  handleRequestError(context, error, errorClassification) {
    const { chat } = context;
    const classification =
      errorClassification || this._classify(chat, error, null);
    if (classification?.suppressed) {
      this.lifecycleManager.cleanup(chat.id);
      this.lifecycleManager.markRequestFinished();
      this.stateManager.cleanupIncompleteAnswer(chat);
      return;
    }
    this.stateManager.handleRequestError(
      chat,
      classification,
      this._errorToString(error),
    );
    this.lifecycleManager.cleanup(chat.id);
    this.lifecycleManager.markRequestFinished();
  }
  _errorToString(error) {
    if (typeof error === "string") return error;
    const type = error?.type ? `[${error.type}] ` : "";
    if (error?.message) return `${type}${error.message}`;
    if (error?.details) {
      try {
        return `${type}${JSON.stringify(error.details)}`;
      } catch {}
    }
    if (error?.toString) return `${type}${error.toString()}`;
    return `${type}Unknown error`;
  }
  getAbortSignal(chatId) {
    const chat = this.sharedState.chats.get(chatId);
    return chat ? this.lifecycleManager.getSignal(chat.id) : null;
  }
  isRequestActive(chatId) {
    const chat = this.sharedState.chats.get(chatId);
    return chat ? this.lifecycleManager.isActive(chat.id) : false;
  }
}

export function createHTOSRequestController(utils, sharedState) {
  return new HTOSUnifiedRequestController(utils, sharedState);
}



================================================
FILE: src/core/ResponseProcessor.ts
================================================

// ═══════════════════════════════════════════════════════════════════════════
// src/core/ResponseProcessor.ts
// Pure response processing - NO I/O
// ═══════════════════════════════════════════════════════════════════════════

import { parseRefinerOutput, RefinerOutput, parseMappingResponse } from '../../shared/parsing-utils';
export type { RefinerOutput };

export interface ComposerResult {
    refinedPrompt: string;
    explanation: string;
    strategicTake?: string;
}

export interface AnalystResult {
    audit: string;
    variants: string[];
    guidance?: string;
}

export class ResponseProcessor {

    // ─────────────────────────────────────────────────────────────────────────
    // UNIVERSAL CONTENT EXTRACTION
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Extract text content from any response format.
     * Handles: strings, { text: string }, { content: string }, objects
     */
    extractContent(raw: any): string {
        if (!raw) return "";

        // Direct string
        if (typeof raw === 'string') return raw.trim();

        // Object with text/content field
        if (typeof raw === 'object') {
            if (typeof raw.text === 'string') return raw.text.trim();
            if (typeof raw.content === 'string') return raw.content.trim();
            // Stringify as fallback
            try {
                return JSON.stringify(raw, null, 2);
            } catch {
                return "[Unserializable Object]";
            }
        }

        return String(raw).trim();
    }

    // ─────────────────────────────────────────────────────────────────────────
    // COMPOSER/ANALYST RESPONSE PARSERS
    // ─────────────────────────────────────────────────────────────────────────

    parseComposerResponse(text: string): ComposerResult {
        const result: ComposerResult = {
            refinedPrompt: text,
            explanation: "",
        };

        try {
            // Extract STRATEGIC TAKE (optional)
            const strategicMatch = text.match(/(?:^|\n)[*#]*\s*STRATEGIC\s*TAKE[*]*:?\s*([\s\S]*?)(?=(?:^|\n)[*#]*\s*REFINED|$)/i);
            if (strategicMatch?.[1]) {
                result.strategicTake = strategicMatch[1].trim();
            }

            // Extract REFINED_PROMPT
            const refinedRegex = /(?:^|\n)[*#]*\s*REFINED[_\s]*PROMPT[*]*:?\s*([\s\S]*?)(?=(?:^|\n)[*#]*\s*NOTES|$)/i;
            const refinedMatch = text.match(refinedRegex);
            if (refinedMatch?.[1]) {
                result.refinedPrompt = refinedMatch[1].trim();
            }

            // Extract NOTES
            const notesRegex = /(?:^|\n)[*#]*\s*NOTES[*]*:?\s*([\s\S]*?)$/i;
            const notesMatch = text.match(notesRegex);
            if (notesMatch?.[1]) {
                result.explanation = notesMatch[1].trim();
            }

            // Fallback: if no sections found, return whole text as prompt
            if (!refinedMatch && !notesMatch && !strategicMatch) {
                result.refinedPrompt = text.trim();
            }
        } catch (e) {
            console.warn("[ResponseProcessor] Failed to parse composer response:", e);
        }

        return result;
    }

    parseAnalystResponse(text: string): AnalystResult {
        const result: AnalystResult = {
            audit: "No audit available.",
            variants: [],
        };

        try {
            // Extract AUDIT section
            const auditRegex = /(?:^|\n)[*#]*\s*AUDIT[*]*:?\s*([\s\S]*?)(?=(?:^|\n)[*#]*\s*VARIANTS|$)/i;
            const auditMatch = text.match(auditRegex);
            if (auditMatch?.[1]) {
                result.audit = auditMatch[1].trim();
            }

            // Extract VARIANTS section
            const variantsRegex = /(?:^|\n)[*#]*\s*VARIANTS[*]*:?\s*([\s\S]*?)(?=(?:^|\n)[*#]*\s*GUIDANCE|$)/i;
            const variantsMatch = text.match(variantsRegex);
            if (variantsMatch?.[1]) {
                result.variants = this._parseVariantsList(variantsMatch[1].trim());
            }

            // Extract GUIDANCE section (optional)
            const guidanceRegex = /(?:^|\n)[*#]*\s*GUIDANCE[*]*:?\s*([\s\S]*?)$/i;
            const guidanceMatch = text.match(guidanceRegex);
            if (guidanceMatch?.[1]) {
                result.guidance = guidanceMatch[1].trim();
            }
        } catch (e) {
            console.warn("[ResponseProcessor] Failed to parse analyst response:", e);
        }

        return result;
    }

    private _parseVariantsList(variantsText: string): string[] {
        const variants: string[] = [];

        // Check for numbered list
        const hasNumberedList = /^(\d+[\.)]|-)\s+/m.test(variantsText);

        if (hasNumberedList) {
            const lines = variantsText.split('\n');
            let currentVariant = '';

            for (const line of lines) {
                const match = line.match(/^(\d+[\.)]|-)\s+(.*)/);
                if (match) {
                    if (currentVariant) variants.push(currentVariant.trim());
                    currentVariant = match[2];
                } else if (currentVariant) {
                    // Append continuation lines to current variant
                    currentVariant += '\n' + line;
                } else if (line.trim()) {
                    // ✅ RESTORED: Handle unnumbered lines at start
                    if (variants.length === 0) {
                        currentVariant = line.trim();
                    }
                }
            }
            if (currentVariant) variants.push(currentVariant.trim());
        } else {
            // Split by double newlines for unnumbered paragraphs
            const chunks = variantsText.split(/\n\s*\n/);
            for (const chunk of chunks) {
                if (chunk.trim()) variants.push(chunk.trim());
            }
        }

        return variants.length > 0 ? variants : (variantsText ? [variantsText] : []);
    }
    // ─────────────────────────────────────────────────────────────────────────
    // MAPPING RESPONSE PROCESSORS (from workflow-engine.js)
    // ─────────────────────────────────────────────────────────────────────────

    processMappingResponse(text: string): {
        text: string;
        topology: object | null;
        options: string | null;
        optionTitles: string[];
    } {
        const { narrative, graphTopology, options, optionTitles } = parseMappingResponse(text);

        return {
            text: narrative,
            topology: graphTopology,
            options,
            optionTitles,
        };
    }

    // ─────────────────────────────────────────────────────────────────────────
    // REFINER RESPONSE PARSER
    // ─────────────────────────────────────────────────────────────────────────

    parseRefinerResponse(text: string): RefinerOutput {
        return parseRefinerOutput(text);
    }
}



================================================
FILE: src/core/service-registry.js
================================================
// src/core/service-registry.js

/**
 * ServiceRegistry (Singleton)
 * 
 * Central repository for global service instances in the Service Worker.
 * Replaces global variables and self objects to allow clean dependency access
 * throughout the application without circular imports or global pollution.
 */
export class ServiceRegistry {
    constructor() {
        this.services = new Map();
    }

    static getInstance() {
        if (!ServiceRegistry.instance) {
            ServiceRegistry.instance = new ServiceRegistry();
        }
        return ServiceRegistry.instance;
    }

    register(name, instance) {
        if (!name || !instance) {
            console.warn('[ServiceRegistry] Invalid registration:', { name, instance });
            return;
        }
        this.services.set(name, instance);
        console.log(`[ServiceRegistry] Registered service: ${name}`);
    }

    get(name) {
        return this.services.get(name);
    }

    // Quick accessors for common services
    get sessionManager() { return this.get('sessionManager'); }
    get persistenceLayer() { return this.get('persistenceLayer'); }
    get orchestrator() { return this.get('orchestrator'); }
    get authManager() { return this.get('authManager'); }
    get promptService() { return this.get('promptService'); }
    get responseProcessor() { return this.get('responseProcessor'); }
}

export const services = ServiceRegistry.getInstance();



================================================
FILE: src/core/vendor-exports.js
================================================
/**
 * HTOS Vendor Exports (ESM)
 * - Unifies access to vendor components
 * - Single import point for vendor + core glue
 */

// Vendor controllers (from core/vendor dir)
export { BusController, utils, env } from "../HTOS/BusController.js";
export {
  NetRulesManager,
  CSPController,
  UserAgentController,
  ArkoseController,
} from "../HTOS/NetRulesManager.js";


// Core exports
export { LifecycleManager } from "./lifecycle-manager.js";
export {
  HTOSRequestLifecycleManager,
  HTOSUnifiedRequestController,
  createHTOSRequestController,
} from "./request-lifecycle-manager.js";



================================================
FILE: src/core/workflow-compiler.js
================================================
// src/core/workflow-compiler.js - PHASE 3 COMPLETE
/**
 * WorkflowCompiler - PURE FUNCTION
 *
 * Phase 3 completion: Zero database access, fully synchronous.
 * All data comes from ResolvedContext parameter.
 */

export class WorkflowCompiler {
  constructor(sessionManager, config = {}) {
    // Kept only for dependency injection - NEVER USED
    this.sessionManager = sessionManager;

    // Store defaults in memory from injected config
    this.defaults = {
      mapper: config.htos_mapping_provider || "Gemini",
      synthesizer: config.htos_last_synthesis_model || "claude",
      refiner: config.htos_last_refiner_model || "claude",
      antagonist: config.htos_last_antagonist_model || "claude"
    };
  }

  /**
   * PURE COMPILE: Primitive + Context â†’ Workflow Steps
   *
   * @param {PrimitiveWorkflowRequest} request - Initialize/Extend/Recompute primitive
   * @param {ResolvedContext} resolvedContext - REQUIRED from ContextResolver
   * @returns {Object} Executable workflow
   */
  compile(request, resolvedContext) {
    if (!resolvedContext) {
      throw new Error("[Compiler] resolvedContext required");
    }

    this._validateRequest(request);
    this._validateContext(resolvedContext);

    const workflowId = this._generateWorkflowId(resolvedContext.type);
    const steps = [];
    // Track created step IDs to ensure correct linkage
    let batchStepId = null;
    let synthesisStepId = null;
    let mappingStepId = null;

    console.log(`[Compiler] Compiling ${resolvedContext.type} workflow`);

    // ========================================================================
    // STEP GENERATION: Based on primitive request
    // ========================================================================
    switch (resolvedContext.type) {
      case "initialize":
      case "extend":
        // Batch step if providers specified
        if (request.providers && request.providers.length > 0) {
          const batchStep = this._createBatchStep(request, resolvedContext);
          steps.push(batchStep);
          batchStepId = batchStep.stepId;
        }
        break;

      case "recompute":
        if (resolvedContext.stepType === "batch") {
          // Generate a single-provider prompt step targeting the provider being retried
          const provider = resolvedContext.targetProvider;
          const stepId = `batch-retry-${Date.now()}`;
          // Normalize provider context shape
          const rawCtx = resolvedContext.providerContextsAtSourceTurn
            ? resolvedContext.providerContextsAtSourceTurn[provider]
            : undefined;
          const meta = rawCtx && rawCtx.meta ? rawCtx.meta : rawCtx;
          const providerContexts = meta
            ? { [provider]: { meta, continueThread: true } }
            : undefined;
          const batchStep = {
            stepId,
            type: "prompt",
            payload: {
              prompt: resolvedContext.sourceUserMessage,
              providers: [provider],
              providerContexts,
              useThinking: !!request.useThinking,
            },
          };
          steps.push(batchStep);
          batchStepId = stepId;
        } else {
          console.log("[Compiler] Recompute: Skipping batch (frozen outputs)");
        }
        break;
    }

    // Synthesis step first
    if (this._needsSynthesisStep(request, resolvedContext)) {
      const synthesisStep = this._createSynthesisStep(
        request,
        resolvedContext,
        { batchStepId },
      );
      steps.push(synthesisStep);
      // Track for potential future linkage or diagnostics
      synthesisStepId = synthesisStep.stepId;
    }

    // Mapping step after synthesis (so it can reference synthesis step IDs)
    if (this._needsMappingStep(request, resolvedContext)) {
      const lastSynthesisStep =
        steps.filter((s) => s.type === "synthesis").slice(-1)[0] || null;
      const mappingStep = this._createMappingStep(request, resolvedContext, {
        batchStepId,
        synthesisStepId: lastSynthesisStep?.stepId,
      });
      steps.push(mappingStep);
      mappingStepId = mappingStep.stepId;
    }

    // Refiner step (if requested and dependencies exist)
    if (this._needsRefinerStep(request, resolvedContext)) {
      const lastSynthesisStep =
        steps.filter((s) => s.type === "synthesis").slice(-1)[0] || null;
      const lastMappingStep =
        steps.filter((s) => s.type === "mapping").slice(-1)[0] || null;

      const refinerStep = this._createRefinerStep(request, resolvedContext, {
        batchStepId,
        synthesisStepId: lastSynthesisStep?.stepId,
        mappingStepId: lastMappingStep?.stepId,
      });
      steps.push(refinerStep);
    }

    // Antagonist step (if requested and dependencies exist)
    if (this._needsAntagonistStep(request, resolvedContext)) {
      const lastSynthesisStep =
        steps.filter((s) => s.type === "synthesis").slice(-1)[0] || null;
      const lastMappingStep =
        steps.filter((s) => s.type === "mapping").slice(-1)[0] || null;
      const lastRefinerStep =
        steps.filter((s) => s.type === "refiner").slice(-1)[0] || null;

      const antagonistStep = this._createAntagonistStep(request, resolvedContext, {
        batchStepId,
        synthesisStepId: lastSynthesisStep?.stepId,
        mappingStepId: lastMappingStep?.stepId,
        refinerStepId: lastRefinerStep?.stepId,
      });
      steps.push(antagonistStep);
    }

    const workflowContext = this._buildWorkflowContext(
      request,
      resolvedContext,
    );

    console.log(`[Compiler] Generated ${steps.length} steps`);

    return {
      workflowId,
      context: workflowContext,
      steps,
    };
  }

  // ============================================================================
  // STEP CREATORS (Pure)
  // ============================================================================

  _createBatchStep(request, context) {
    return {
      stepId: `batch-${Date.now()}`,
      type: "prompt",
      payload: {
        prompt: request.userMessage,
        providers: request.providers,
        providerContexts:
          context.type === "extend" ? context.providerContexts : undefined,
        previousContext: context.previousContext || null,
        providerMeta: request.providerMeta || {},
        useThinking: !!request.useThinking,
      },
    };
  }

  _createMappingStep(request, context, linkIds = {}) {
    // Include provider in stepId so UI can derive provider on failure without result payload
    const mappingProviderId =
      context.type === "recompute"
        ? context.targetProvider
        : request.mapper || this._getDefaultMapper(request);
    const mappingStepId = `mapping-${mappingProviderId}-${Date.now()}`;

    if (context.type === "recompute") {
      return {
        stepId: mappingStepId,
        type: "mapping",
        payload: {
          mappingProvider: context.targetProvider,
          sourceHistorical: {
            turnId: context.sourceTurnId,
            responseType: "batch",
          },
          originalPrompt: context.sourceUserMessage,
          useThinking: !!request.useThinking,
          attemptNumber: 1,
        },
      };
    }

    // Use mapper from primitive
    const mapper = mappingProviderId;

    return {
      stepId: mappingStepId,
      type: "mapping",
      payload: {
        mappingProvider: mapper,
        // Explicitly allow mapper to continue thread from the batch step when available
        continueFromBatchStep: linkIds.batchStepId || undefined,
        sourceStepIds: linkIds.batchStepId ? [linkIds.batchStepId] : undefined,
        synthesisStepIds: linkIds.synthesisStepId
          ? [linkIds.synthesisStepId]
          : undefined,
        providerOrder: Array.isArray(request.providers)
          ? request.providers.slice()
          : undefined,
        originalPrompt: request.userMessage,
        useThinking: !!request.useThinking && mapper === "chatgpt",
        attemptNumber: 1,
      },
    };
  }

  _createSynthesisStep(request, context, linkIds = {}) {
    // Include provider in stepId so UI can derive provider on failure without result payload
    const synthesisProviderId =
      context.type === "recompute"
        ? context.targetProvider
        : request.synthesizer || this._getDefaultSynthesizer(request);
    const synthStepId = `synthesis-${synthesisProviderId}-${Date.now()}`;

    if (context.type === "recompute") {
      return {
        stepId: synthStepId,
        type: "synthesis",
        payload: {
          synthesisProvider: context.targetProvider,
          sourceHistorical: {
            turnId: context.sourceTurnId,
            responseType: "batch",
          },
          originalPrompt: context.sourceUserMessage,
          useThinking: !!request.useThinking,
          attemptNumber: 1,
          strategy: "continuation",
          // For recompute, mapping results are fetched historically via resolvedContext
        },
      };
    }

    // Use synthesizer from primitive
    const synthesizer = synthesisProviderId;

    return {
      stepId: synthStepId,
      type: "synthesis",
      payload: {
        synthesisProvider: synthesizer,
        sourceStepIds: linkIds.batchStepId ? [linkIds.batchStepId] : undefined,
        // mappingStepIds deliberately omitted; mapping will run after synthesis now
        originalPrompt: request.userMessage,
        useThinking: !!request.useThinking && synthesizer === "chatgpt",
        attemptNumber: 1,
        strategy: "continuation",
      },
    };
  }

  _createRefinerStep(request, context, linkIds = {}) {
    // defaults to synthesizer if not specified
    const refinerProvider =
      context.type === "recompute"
        ? context.targetProvider
        : request.refiner || this._getDefaultRefiner(request);

    const stepId = `refiner-${refinerProvider}-${Date.now()}`;

    if (context.type === "recompute") {
      return {
        stepId,
        type: "refiner",
        payload: {
          refinerProvider,
          sourceHistorical: {
            turnId: context.sourceTurnId,
            responseType: "batch",
          },
          originalPrompt: context.sourceUserMessage,
        },
      };
    }

    return {
      stepId,
      type: "refiner",
      payload: {
        refinerProvider,
        sourceStepIds: linkIds.batchStepId ? [linkIds.batchStepId] : undefined,
        synthesisStepIds: linkIds.synthesisStepId
          ? [linkIds.synthesisStepId]
          : undefined,
        mappingStepIds: linkIds.mappingStepId ? [linkIds.mappingStepId] : undefined,
        originalPrompt: request.userMessage,
      },
    };
  }

  _createAntagonistStep(request, context, linkIds = {}) {
    const antagonistProvider =
      context.type === "recompute"
        ? context.targetProvider
        : request.antagonist || this._getDefaultAntagonist(request);

    const stepId = `antagonist-${antagonistProvider}-${Date.now()}`;

    if (context.type === "recompute") {
      return {
        stepId,
        type: "antagonist",
        payload: {
          antagonistProvider,
          sourceHistorical: {
            turnId: context.sourceTurnId,
            responseType: "batch",
          },
          originalPrompt: context.sourceUserMessage,
        },
      };
    }

    return {
      stepId,
      type: "antagonist",
      payload: {
        antagonistProvider,
        sourceStepIds: linkIds.batchStepId ? [linkIds.batchStepId] : undefined,
        synthesisStepIds: linkIds.synthesisStepId
          ? [linkIds.synthesisStepId]
          : undefined,
        mappingStepIds: linkIds.mappingStepId ? [linkIds.mappingStepId] : undefined,
        refinerStepIds: linkIds.refinerStepId ? [linkIds.refinerStepId] : undefined,
        originalPrompt: request.userMessage,
      },
    };
  }

  // ============================================================================
  // DECISION LOGIC (Pure)
  // ============================================================================

  _needsMappingStep(request, context) {
    if (context.type === "recompute") {
      return context.stepType === "mapping";
    }
    // Check primitive property
    return !!request.includeMapping;
  }

  _needsSynthesisStep(request, context) {
    if (context.type === "recompute") {
      return context.stepType === "synthesis";
    }
    // Check primitive property
    return !!request.includeSynthesis;
  }

  _needsRefinerStep(request, context) {
    if (context.type === "recompute") {
      return context.stepType === "refiner";
    }
    // Check primitive property: Refiner requires synthesis
    return (
      !!request.includeSynthesis &&
      !!request.includeRefiner
    );
  }

  _needsAntagonistStep(request, context) {
    if (context.type === "recompute") {
      return context.stepType === "antagonist";
    }
    // Antagonist requires refiner to be present
    return (
      !!request.includeRefiner &&
      !!request.includeAntagonist
    );
  }

  // ============================================================================
  // CONTEXT BUILDER (Pure)
  // ============================================================================

  _buildWorkflowContext(request, context) {
    let sessionId;
    let sessionCreated = false;

    switch (context.type) {
      case "initialize":
        // Prefer sessionId passed in the primitive (set by ConnectionHandler); fallback to generate
        sessionId =
          request.sessionId ||
          `session-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        sessionCreated = true;
        break;

      case "extend":
      case "recompute":
        sessionId = context.sessionId;
        break;

      default:
        sessionId = "unknown-session";
    }

    const userMessage =
      context.type === "recompute"
        ? context.sourceUserMessage
        : request.userMessage;

    return {
      sessionId,
      threadId: "default-thread",
      targetUserTurnId:
        context.type === "recompute" ? context.sourceTurnId : "",
      sessionCreated,
      userMessage,
    };
  }

  // ============================================================================
  // UTILITIES (Pure)
  // ============================================================================

  _getDefaultMapper(request) {
    return request.providers?.[0] || this.defaults.mapper;
  }

  _getDefaultSynthesizer(request) {
    return request.providers?.[0] || this.defaults.synthesizer;
  }

  _getDefaultRefiner(request) {
    return request.providers?.[0] || this.defaults.refiner;
  }

  _getDefaultAntagonist(request) {
    return request.providers?.[0] || this.defaults.antagonist;
  }

  _generateWorkflowId(contextType) {
    return `wf-${contextType}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  // ============================================================================
  // VALIDATION
  // ============================================================================

  _validateRequest(request) {
    if (!request?.type) throw new Error("[Compiler] Request type required");

    const validTypes = ["initialize", "extend", "recompute"];
    if (!validTypes.includes(request.type)) {
      throw new Error(`[Compiler] Invalid type: ${request.type}`);
    }

    // Type-specific validation
    switch (request.type) {
      case "initialize":
        if (!request.userMessage?.trim())
          throw new Error("[Compiler] Initialize: userMessage required");
        if (!request.providers?.length)
          throw new Error("[Compiler] Initialize: providers required");
        break;

      case "extend":
        if (!request.sessionId)
          throw new Error("[Compiler] Extend: sessionId required");
        if (!request.userMessage?.trim())
          throw new Error("[Compiler] Extend: userMessage required");
        if (!request.providers?.length)
          throw new Error("[Compiler] Extend: providers required");
        break;

      case "recompute":
        if (!request.sessionId)
          throw new Error("[Compiler] Recompute: sessionId required");
        if (!request.sourceTurnId)
          throw new Error("[Compiler] Recompute: sourceTurnId required");
        if (!request.stepType)
          throw new Error("[Compiler] Recompute: stepType required");
        if (!request.targetProvider)
          throw new Error("[Compiler] Recompute: targetProvider required");
        break;
    }
  }

  _validateContext(context) {
    if (!context?.type) throw new Error("[Compiler] Context type required");

    const validTypes = ["initialize", "extend", "recompute"];
    if (!validTypes.includes(context.type)) {
      throw new Error(`[Compiler] Invalid context type: ${context.type}`);
    }

    switch (context.type) {
      case "initialize": {
        // initialize has no additional required fields in context
        break;
      }
      case "extend": {
        if (!context.sessionId)
          throw new Error("[Compiler] Extend: sessionId required");
        if (!context.lastTurnId)
          throw new Error("[Compiler] Extend: lastTurnId required");
        if (!context.providerContexts)
          throw new Error("[Compiler] Extend: providerContexts required");
        break;
      }
      case "recompute": {
        if (!context.sessionId)
          throw new Error("[Compiler] Recompute: sessionId required");
        if (!context.sourceTurnId)
          throw new Error("[Compiler] Recompute: sourceTurnId required");
        if (!context.stepType)
          throw new Error("[Compiler] Recompute: stepType required");
        if (!context.targetProvider)
          throw new Error("[Compiler] Recompute: targetProvider required");
        // Only require frozenBatchOutputs for synthesis/mapping historical recomputes
        if (context.stepType !== "batch" && !context.frozenBatchOutputs) {
          throw new Error(
            "[Compiler] Recompute: frozenBatchOutputs required for synthesis/mapping",
          );
        }
        break;
      }
    }
  }
}



================================================
FILE: src/core/workflow-engine.js
================================================
// src/core/workflow-engine.js - FIXED VERSION
import { ArtifactProcessor } from '../../shared/artifact-processor.ts';
import { PromptService } from './PromptService.ts';
import { ResponseProcessor } from './ResponseProcessor.ts';
import { getHealthTracker } from './provider-health-tracker.js';
import { classifyError } from './error-classifier.js';
import {
  errorHandler,
  createMultiProviderAuthError,
  ProviderAuthError,
  isProviderAuthError
} from '../utils/ErrorHandler.js';
import { authManager } from '../core/auth-manager.js';
import { PROVIDER_LIMITS } from '../../shared/provider-limits.ts';
// Parsing and Prompt building functions moved to ResponseProcessor.ts and PromptService.ts

// Track last seen text per provider/session for delta streaming
const lastStreamState = new Map();

function makeDelta(sessionId, stepId, providerId, fullText = "") {
  if (!sessionId) return fullText || "";

  const key = `${sessionId}:${stepId}:${providerId}`;
  const prev = lastStreamState.get(key) || "";
  let delta = "";

  // CASE 1: First emission (prev is empty) — always emit full text
  if (prev.length === 0 && fullText && fullText.length > 0) {
    delta = fullText;
    lastStreamState.set(key, fullText);
    logger.stream("First emission:", {
      providerId,
      textLength: fullText.length,
    });
    return delta;
  }

  // CASE 2: Normal streaming append (new text added)
  if (fullText && fullText.length > prev.length) {
    // Find longest common prefix to handle small inline edits
    let prefixLen = 0;
    const minLen = Math.min(prev.length, fullText.length);

    while (prefixLen < minLen && prev[prefixLen] === fullText[prefixLen]) {
      prefixLen++;
    }

    // If common prefix >= 90% of previous text, treat as append
    if (prefixLen >= prev.length * 0.7) {
      delta = fullText.slice(prev.length);
      lastStreamState.set(key, fullText);
      logger.stream("Incremental append:", {
        providerId,
        deltaLen: delta.length,
      });
    } else {
      logger.stream(
        `Divergence detected for ${providerId}: commonPrefix=${prefixLen}/${prev.length}`,
      );
      lastStreamState.set(key, fullText);
      return fullText.slice(prefixLen); // ✅ Emit from divergence point
    }
    return delta;
  }

  // CASE 3: No change (duplicate call with same text) — no-op
  if (fullText === prev) {
    logger.stream("Duplicate call (no-op):", { providerId });
    return "";
  }

  // CASE 4: Text got shorter - smart detection with warnings instead of errors
  if (fullText.length < prev.length) {
    const regression = prev.length - fullText.length;

    // Calculate regression percentage
    const regressionPercent = (regression / prev.length) * 100;

    // ✅ Allow small absolute regressions OR small percentage regressions
    const isSmallRegression = regression <= 200 || regressionPercent <= 5;

    if (isSmallRegression) {
      logger.stream(`Acceptable regression for ${providerId}:`, {
        chars: regression,
        percent: regressionPercent.toFixed(1) + "%",
      });
      lastStreamState.set(key, fullText);
      return "";
    }

    // Flag & throttle: warn at most a couple of times per provider/session
    // Avoid using process.env in extension context; rely on local counters
    const now = Date.now();
    const lastWarnKey = `${key}:lastRegressionWarn`;
    const warnCountKey = `${key}:regressionWarnCount`;
    const lastWarn = lastStreamState.get(lastWarnKey) || 0;
    const currentCount = lastStreamState.get(warnCountKey) || 0;
    const WARN_MAX = 2; // cap warnings per session/provider to reduce noise
    if (currentCount < WARN_MAX && now - lastWarn > 5000) {
      // 5s cooldown per provider
      logger.warn(
        `[makeDelta] Significant text regression for ${providerId}:`,
        {
          prevLen: prev.length,
          fullLen: fullText.length,
          regression,
          regressionPercent: regressionPercent.toFixed(1) + "%",
        },
      );
      lastStreamState.set(lastWarnKey, now);
      lastStreamState.set(warnCountKey, currentCount + 1);
    }
    lastStreamState.set(key, fullText); // Still update state
    return ""; // No emit on regression
  }

  // CASE 5: Fallback (shouldn't reach here, but safe default)
  return "";
}

/**
 * Clear delta cache when session ends (prevents memory leaks)
 */
function clearDeltaCache(sessionId) {
  if (!sessionId) return;

  const keysToDelete = [];
  lastStreamState.forEach((_, key) => {
    if (key.startsWith(`${sessionId}:`)) {
      keysToDelete.push(key);
    }
  });

  keysToDelete.forEach((key) => lastStreamState.delete(key));
  logger.debug(
    `[makeDelta] Cleared ${keysToDelete.length} cache entries for session ${sessionId}`,
  );
}
// =============================================================================
// SMART CONSOLE FILTER FOR DEV TOOLS
// =============================================================================

const STREAMING_DEBUG = false; // ✅ Set to true to see streaming deltas
const WORKFLOW_DEBUG = false; // ✅ Off-by-default verbose workflow logs
const wdbg = (...args) => {
  if (WORKFLOW_DEBUG) console.log(...args);
};

/**
 * Filtered logger: Hides streaming noise unless explicitly enabled
 */
const logger = {
  // Streaming-specific logs (hidden by default)
  stream: (msg, meta) => {
    if (STREAMING_DEBUG) console.debug(`[WorkflowEngine] ${msg}`, meta);
  },

  // Always show these
  debug: console.debug.bind(console),
  info: console.info.bind(console),
  warn: console.warn.bind(console),
  error: console.error.bind(console),
};
// =============================================================================
// WORKFLOW ENGINE - FIXED
// =============================================================================

export class WorkflowEngine {
  constructor(orchestrator, sessionManager, port, options = {}) {
    this.orchestrator = orchestrator;
    this.sessionManager = sessionManager;
    this.port = port;

    // Accept injected or create new
    this.promptService = options.promptService || new PromptService();
    this.responseProcessor = options.responseProcessor || new ResponseProcessor();

    // Keep track of the most recent finalized turn to align IDs with persistence
    this._lastFinalizedTurn = null;
    this.healthTracker = getHealthTracker();
  }

  /**
   * Dispatch a non-empty streaming delta to the UI port.
   * Consolidates duplicate onPartial logic across step executors.
   */
  _dispatchPartialDelta(
    sessionId,
    stepId,
    providerId,
    text,
    label = null,
    isFinal = false,
  ) {
    try {
      let delta;

      // For final emissions, bypass makeDelta regression detection
      // This is critical when we strip sections (like GRAPH_TOPOLOGY) from the text
      if (isFinal) {
        // Force-replace with final text
        const key = `${sessionId}:${stepId}:${providerId}`;
        lastStreamState.set(key, text);
        delta = text; // Send complete final text
        logger.stream("Final emission (force-replace):", { stepId, providerId, len: text?.length || 0 });
      } else {
        delta = makeDelta(sessionId, stepId, providerId, text);
      }

      if (delta && delta.length > 0) {
        const chunk = isFinal
          ? { text: delta, isFinal: true }
          : { text: delta };
        this.port.postMessage({
          type: "PARTIAL_RESULT",
          sessionId,
          stepId,
          providerId,
          chunk,
        });
        logger.stream(label || "Delta", { stepId, providerId, len: delta.length });
        return true;
      } else {
        logger.stream("Delta skipped (empty):", { stepId, providerId });
        return false;
      }
    } catch (e) {
      logger.warn("Delta dispatch failed:", {
        stepId,
        providerId,
        error: String(e),
      });
      return false;
    }
  }

  async execute(request, resolvedContext) {
    const { context, steps } = request;
    const stepResults = new Map();
    // In-memory per-workflow cache of provider contexts created by batch steps
    const workflowContexts = {};

    // Cache current user message for persistence usage
    this.currentUserMessage =
      context?.userMessage || this.currentUserMessage || "";

    // Ensure session exists
    // Session ID must be provided by the connection handler or compiler.
    // We no longer emit SESSION_STARTED; TURN_CREATED now carries the authoritative sessionId.
    if (!context.sessionId || context.sessionId === "new-session") {
      // As a conservative fallback, ensure a non-empty sessionId is present.
      context.sessionId =
        context.sessionId && context.sessionId !== "new-session"
          ? context.sessionId
          : `sid-${Date.now()}`;
      // NOTE: Do not post SESSION_STARTED. UI initializes session from TURN_CREATED.
    }

    try {
      // ========================================================================
      // Seed contexts from ResolvedContext (extend/recompute)
      // ========================================================================
      if (resolvedContext && resolvedContext.type === "recompute") {
        console.log(
          "[WorkflowEngine] Seeding frozen batch outputs for recompute",
        );
        try {
          // Seed a synthetic batch step result so downstream mapping/synthesis can reference it
          stepResults.set("batch", {
            status: "completed",
            result: { results: resolvedContext.frozenBatchOutputs },
          });
        } catch (e) {
          console.warn(
            "[WorkflowEngine] Failed to seed frozen batch outputs:",
            e,
          );
        }

        // Cache historical contexts for providers at the source turn
        try {
          Object.entries(
            resolvedContext.providerContextsAtSourceTurn || {},
          ).forEach(([pid, ctx]) => {
            if (ctx && typeof ctx === "object") {
              workflowContexts[pid] = ctx;
            }
          });
        } catch (e) {
          console.warn(
            "[WorkflowEngine] Failed to cache historical provider contexts:",
            e,
          );
        }
      }

      // When extending an existing session, pre-cache provider contexts
      if (resolvedContext && resolvedContext.type === "extend") {
        try {
          const ctxs = resolvedContext.providerContexts || {};
          const cachedProviders = [];
          Object.entries(ctxs).forEach(([pid, meta]) => {
            if (
              meta &&
              typeof meta === "object" &&
              Object.keys(meta).length > 0
            ) {
              workflowContexts[pid] = meta;
              cachedProviders.push(pid);
            }
          });
          if (cachedProviders.length > 0) {
            console.log(
              `[WorkflowEngine] Pre-cached contexts from ResolvedContext.extend for providers: ${cachedProviders.join(", ")}`,
            );
          }
        } catch (e) {
          console.warn(
            "[WorkflowEngine] Failed to cache provider contexts from extend:",
            e,
          );
        }
      }

      const promptSteps = steps.filter((step) => step.type === "prompt");
      const synthesisSteps = steps.filter((step) => step.type === "synthesis");
      const mappingSteps = steps.filter((step) => step.type === "mapping");

      // 1. Execute all batch prompt steps first, as they are dependencies.
      for (const step of promptSteps) {
        try {
          const result = await this.executePromptStep(step, context);
          stepResults.set(step.stepId, { status: "completed", result });
          this.port.postMessage({
            type: "WORKFLOW_STEP_UPDATE",
            sessionId: context.sessionId,
            stepId: step.stepId,
            status: "completed",
            result,
            // Attach recompute metadata for UI routing/clearing
            isRecompute: resolvedContext?.type === "recompute",
            sourceTurnId: resolvedContext?.sourceTurnId,
          });

          // Cache provider contexts from this batch step into workflowContexts so
          // subsequent synthesis/mapping steps in the same workflow can continue
          // the freshly-created conversations immediately.
          try {
            const resultsObj = result && result.results ? result.results : {};
            const cachedProviders = [];
            Object.entries(resultsObj).forEach(([pid, data]) => {
              if (data && data.meta && Object.keys(data.meta).length > 0) {
                workflowContexts[pid] = data.meta;
                cachedProviders.push(pid);
              }
            });
            if (cachedProviders.length > 0) {
              console.log(
                `[WorkflowEngine] Cached contexts for providers: ${cachedProviders.join(
                  ", ",
                )}`,
              );
            }
          } catch (e) {
            /* best-effort logging */
          }
        } catch (error) {
          console.error(
            `[WorkflowEngine] Prompt step ${step.stepId} failed:`,
            error,
          );
          stepResults.set(step.stepId, {
            status: "failed",
            error: error.message,
          });
          this.port.postMessage({
            type: "WORKFLOW_STEP_UPDATE",
            sessionId: context.sessionId,
            stepId: step.stepId,
            status: "failed",
            error: error.message,
            // Attach recompute metadata for UI routing/clearing
            isRecompute: resolvedContext?.type === "recompute",
            sourceTurnId: resolvedContext?.sourceTurnId,
          });
          // If the main prompt fails, the entire workflow cannot proceed.
          this.port.postMessage({
            type: "WORKFLOW_COMPLETE",
            sessionId: context.sessionId,
            workflowId: request.workflowId,
            finalResults: Object.fromEntries(stepResults),
          });
          return; // Exit early
        }
      }

      // 2/3. Execute synthesis and mapping in parallel (no dependency)
      const mappingLoop = async () => {
        for (const step of mappingSteps) {
          try {
            const result = await this.executeMappingStep(
              step,
              context,
              stepResults,
              workflowContexts,
              resolvedContext,
            );
            stepResults.set(step.stepId, { status: "completed", result });
            this.port.postMessage({
              type: "WORKFLOW_STEP_UPDATE",
              sessionId: context.sessionId,
              stepId: step.stepId,
              status: "completed",
              result,
              // Attach recompute metadata for UI routing/clearing
              isRecompute: resolvedContext?.type === "recompute",
              sourceTurnId: resolvedContext?.sourceTurnId,
            });
            // Immediate idempotent persistence to avoid data loss on later failures (non-recompute only)
            try {
              if (resolvedContext?.type !== "recompute") {
                const aiTurnId = context?.canonicalAiTurnId;
                const providerId = step?.payload?.mappingProvider;
                if (aiTurnId && providerId) {
                  this.sessionManager
                    .upsertProviderResponse(
                      context.sessionId,
                      aiTurnId,
                      providerId,
                      "mapping",
                      0,
                      {
                        text: result?.text || "",
                        status: result?.status || "completed",
                        meta: result?.meta || {},
                      },
                    )
                    .catch(() => { });
                }
              }
            } catch (_) { }
          } catch (error) {
            console.error(
              `[WorkflowEngine] Mapping step ${step.stepId} failed:`,
              error,
            );
            stepResults.set(step.stepId, {
              status: "failed",
              error: error.message,
            });
            this.port.postMessage({
              type: "WORKFLOW_STEP_UPDATE",
              sessionId: context.sessionId,
              stepId: step.stepId,
              status: "failed",
              error: error.message,
              // Attach recompute metadata for UI routing/clearing
              isRecompute: resolvedContext?.type === "recompute",
              sourceTurnId: resolvedContext?.sourceTurnId,
            });
            // Continue with other mapping steps even if one fails
          }
        }
      };

      // 2. Execute mapping steps first (Sequential)
      await mappingLoop();

      // 3. Execute synthesis steps (Sequential, after mapping)
      // Now synthesis steps can access mapping results/options
      for (const step of synthesisSteps) {
        try {
          const result = await this.executeSynthesisStep(
            step,
            context,
            stepResults,
            workflowContexts,
            resolvedContext,
          );
          stepResults.set(step.stepId, { status: "completed", result });
          this.port.postMessage({
            type: "WORKFLOW_STEP_UPDATE",
            sessionId: context.sessionId,
            stepId: step.stepId,
            status: "completed",
            result,
            // Attach recompute metadata for UI routing/clearing
            isRecompute: resolvedContext?.type === "recompute",
            sourceTurnId: resolvedContext?.sourceTurnId,
          });
          // Immediate idempotent persistence to avoid data loss on later failures (non-recompute only)
          try {
            if (resolvedContext?.type !== "recompute") {
              const aiTurnId = context?.canonicalAiTurnId;
              const providerId = step?.payload?.synthesisProvider;
              if (aiTurnId && providerId) {
                this.sessionManager
                  .upsertProviderResponse(
                    context.sessionId,
                    aiTurnId,
                    providerId,
                    "synthesis",
                    0,
                    {
                      text: result?.text || "",
                      status: result?.status || "completed",
                      meta: result?.meta || {},
                    },
                  )
                  .catch(() => { });
              }
            }
          } catch (_) { }
        } catch (error) {
          console.error(
            `[WorkflowEngine] Synthesis step ${step.stepId} failed:`,
            error,
          );
          stepResults.set(step.stepId, {
            status: "failed",
            error: error.message,
          });
          this.port.postMessage({
            type: "WORKFLOW_STEP_UPDATE",
            sessionId: context.sessionId,
            stepId: step.stepId,
            status: "failed",
            error: error.message,
            isRecompute: resolvedContext?.type === "recompute",
            sourceTurnId: resolvedContext?.sourceTurnId,
          });
        }
      }

      // 4. Refiner Step (Sequential, after synthesis/mapping)
      const refinerSteps = steps.filter((step) => step.type === "refiner");
      for (const step of refinerSteps) {
        try {
          const result = await this.executeRefinerStep(
            step,
            context,
            stepResults,
          );
          stepResults.set(step.stepId, { status: "completed", result });
          this.port.postMessage({
            type: "WORKFLOW_STEP_UPDATE",
            sessionId: context.sessionId,
            stepId: step.stepId,
            status: "completed",
            result,
            isRecompute: resolvedContext?.type === "recompute",
            sourceTurnId: resolvedContext?.sourceTurnId,
          });
          // Immediate idempotent persistence to avoid data loss on later failures (non-recompute only)
          try {
            if (resolvedContext?.type !== "recompute") {
              const aiTurnId = context?.canonicalAiTurnId;
              const providerId = step?.payload?.refinerProvider;
              if (aiTurnId && providerId) {
                this.sessionManager
                  .upsertProviderResponse(
                    context.sessionId,
                    aiTurnId,
                    providerId,
                    "refiner",
                    0,
                    {
                      text: result?.text || "",
                      status: result?.status || "completed",
                      meta: result?.meta || {},
                    },
                  )
                  .catch(() => { });
              }
            }
          } catch (_) { }
        } catch (error) {
          console.error(
            `[WorkflowEngine] Refiner step ${step.stepId} failed:`,
            error,
          );
          stepResults.set(step.stepId, {
            status: "failed",
            error: error.message,
          });
          this.port.postMessage({
            type: "WORKFLOW_STEP_UPDATE",
            sessionId: context.sessionId,
            stepId: step.stepId,
            status: "failed",
            error: error.message,
            isRecompute: resolvedContext?.type === "recompute",
            sourceTurnId: resolvedContext?.sourceTurnId,
          });
        }
      }

      // 5. Antagonist Step (Sequential, after refiner)
      const antagonistSteps = steps.filter((step) => step.type === "antagonist");
      for (const step of antagonistSteps) {
        try {
          const result = await this.executeAntagonistStep(
            step,
            context,
            stepResults,
          );
          stepResults.set(step.stepId, { status: "completed", result });
          this.port.postMessage({
            type: "WORKFLOW_STEP_UPDATE",
            sessionId: context.sessionId,
            stepId: step.stepId,
            status: "completed",
            result,
            isRecompute: resolvedContext?.type === "recompute",
            sourceTurnId: resolvedContext?.sourceTurnId,
          });
          // Immediate idempotent persistence to avoid data loss on later failures (non-recompute only)
          try {
            if (resolvedContext?.type !== "recompute") {
              const aiTurnId = context?.canonicalAiTurnId;
              const providerId = step?.payload?.antagonistProvider;
              if (aiTurnId && providerId) {
                this.sessionManager
                  .upsertProviderResponse(
                    context.sessionId,
                    aiTurnId,
                    providerId,
                    "antagonist",
                    0,
                    {
                      text: result?.text || "",
                      status: result?.status || "completed",
                      meta: result?.meta || {},
                    },
                  )
                  .catch(() => { });
              }
            }
          } catch (_) { }
        } catch (error) {
          console.error(
            `[WorkflowEngine] Antagonist step ${step.stepId} failed:`,
            error,
          );
          stepResults.set(step.stepId, {
            status: "failed",
            error: error.message,
          });
          this.port.postMessage({
            type: "WORKFLOW_STEP_UPDATE",
            sessionId: context.sessionId,
            stepId: step.stepId,
            status: "failed",
            error: error.message,
            isRecompute: resolvedContext?.type === "recompute",
            sourceTurnId: resolvedContext?.sourceTurnId,
          });
        }
      }

      // ========================================================================
      // Persistence: Consolidated single call with complete results
      // ========================================================================
      try {
        const result = {
          batchOutputs: {},
          synthesisOutputs: {},
          mappingOutputs: {},
          refinerOutputs: {},
          antagonistOutputs: {},
        };
        const stepById = new Map((steps || []).map((s) => [s.stepId, s]));
        stepResults.forEach((stepResult, stepId) => {
          if (stepResult.status !== "completed") return;
          const step = stepById.get(stepId);
          if (!step) return;
          if (step.type === "prompt") {
            result.batchOutputs = stepResult.result?.results || {};
          } else if (step.type === "synthesis") {
            const providerId = step.payload?.synthesisProvider;
            if (providerId)
              result.synthesisOutputs[providerId] = stepResult.result;
          } else if (step.type === "mapping") {
            const providerId = step.payload?.mappingProvider;
            if (providerId)
              result.mappingOutputs[providerId] = stepResult.result;
          } else if (step.type === "refiner") {
            const providerId = step.payload?.refinerProvider;
            if (providerId)
              result.refinerOutputs[providerId] = stepResult.result;
          } else if (step.type === "antagonist") {
            const providerId = step.payload?.antagonistProvider;
            if (providerId)
              result.antagonistOutputs[providerId] = stepResult.result;
          }
        });

        const userMessage =
          context?.userMessage || this.currentUserMessage || "";
        const persistRequest = {
          type: resolvedContext?.type || "unknown",
          sessionId: context.sessionId,
          userMessage,
        };
        if (resolvedContext?.type === "recompute") {
          persistRequest.sourceTurnId = resolvedContext.sourceTurnId;
          persistRequest.stepType = resolvedContext.stepType;
          persistRequest.targetProvider = resolvedContext.targetProvider;
        }
        if (context?.canonicalUserTurnId)
          persistRequest.canonicalUserTurnId = context.canonicalUserTurnId;
        if (context?.canonicalAiTurnId)
          persistRequest.canonicalAiTurnId = context.canonicalAiTurnId;

        console.log(
          `[WorkflowEngine] Persisting (consolidated) ${persistRequest.type} workflow to SessionManager`,
        );
        const persistResult = await this.sessionManager.persist(
          persistRequest,
          resolvedContext,
          result,
        );

        if (persistResult) {
          if (persistResult.userTurnId)
            context.canonicalUserTurnId = persistResult.userTurnId;
          if (persistResult.aiTurnId)
            context.canonicalAiTurnId = persistResult.aiTurnId;
          if (
            resolvedContext?.type === "initialize" &&
            persistResult.sessionId
          ) {
            context.sessionId = persistResult.sessionId;
            console.log(
              `[WorkflowEngine] Initialize complete: session=${persistResult.sessionId}`,
            );
          }
        }
      } catch (e) {
        console.error("[WorkflowEngine] Consolidated persistence failed:", e);
      }

      // 2) Signal completion to the UI (unchanged message shape)
      this.port.postMessage({
        type: "WORKFLOW_COMPLETE",
        sessionId: context.sessionId,
        workflowId: request.workflowId,
        finalResults: Object.fromEntries(stepResults),
      });

      // ✅ Clean up delta cache
      clearDeltaCache(context.sessionId);

      // Emit canonical turn to allow UI to replace optimistic placeholders
      this._emitTurnFinalized(context, steps, stepResults, resolvedContext);
    } catch (error) {
      console.error(
        `[WorkflowEngine] Critical workflow execution error:`,
        error,
      );
      this.port.postMessage({
        type: "WORKFLOW_COMPLETE",
        sessionId: context.sessionId,
        workflowId: request.workflowId,
        error: "A critical error occurred.",
      });

      clearDeltaCache(context?.sessionId);
    }
  }

  /**
   * Emit TURN_FINALIZED message with canonical turn data
   * This allows UI to replace optimistic placeholders with backend-confirmed data
   */
  _emitTurnFinalized(context, steps, stepResults, resolvedContext) {
    // Skip TURN_FINALIZED for recompute operations (they don't create new turns)
    if (resolvedContext?.type === "recompute") {
      console.log(
        "[WorkflowEngine] Skipping TURN_FINALIZED for recompute operation",
      );
      return;
    }

    const userMessage = context?.userMessage || this.currentUserMessage || "";
    if (!userMessage) {
      return;
    }

    try {
      // Build canonical turn structure
      const timestamp = Date.now();
      // Prefer canonical IDs passed from connection-handler
      const userTurnId =
        context?.canonicalUserTurnId || this._generateId("user");
      const aiTurnId = context?.canonicalAiTurnId || this._generateId("ai");

      const userTurn = {
        id: userTurnId,
        type: "user",
        text: userMessage,
        createdAt: timestamp,
        sessionId: context.sessionId,
      };

      // Collect AI results from step results
      const batchResponses = {};
      const synthesisResponses = {};
      const mappingResponses = {};
      const refinerResponses = {};
      const antagonistResponses = {};
      let primarySynthesizer = null;
      let primaryMapper = null;

      const stepById = new Map((steps || []).map((s) => [s.stepId, s]));
      stepResults.forEach((value, stepId) => {
        const step = stepById.get(stepId);
        if (!step || value?.status !== "completed") return;
        const result = value.result;

        switch (step.type) {
          case "prompt": {
            const resultsObj = result?.results || {};
            Object.entries(resultsObj).forEach(([providerId, r]) => {
              batchResponses[providerId] = [{
                providerId,
                text: r.text || "",
                status: r.status || "completed",
                createdAt: timestamp,
                updatedAt: timestamp,
                meta: r.meta || {},
              }];
            });
            break;
          }
          case "synthesis": {
            const providerId = result?.providerId;
            if (!providerId) return;
            if (!synthesisResponses[providerId])
              synthesisResponses[providerId] = [];
            synthesisResponses[providerId].push({
              providerId,
              text: result?.text || "",
              status: result?.status || "completed",
              createdAt: timestamp,
              updatedAt: timestamp,
              meta: result?.meta || {},
            });
            // Set the primary synthesizer for this turn
            primarySynthesizer = providerId;
            break;
          }
          case "mapping": {
            const providerId = result?.providerId;
            if (!providerId) return;
            if (!mappingResponses[providerId])
              mappingResponses[providerId] = [];
            mappingResponses[providerId].push({
              providerId,
              text: result?.text || "",
              status: result?.status || "completed",
              createdAt: timestamp,
              updatedAt: timestamp,
              meta: result?.meta || {},
            });
            // Set the primary mapper for this turn
            primaryMapper = providerId;
            break;
          }
          case "refiner": {
            const providerId = result?.providerId;
            if (!providerId) return;
            if (!refinerResponses[providerId])
              refinerResponses[providerId] = [];
            refinerResponses[providerId].push({
              providerId,
              text: result?.text || "",
              status: result?.status || "completed",
              createdAt: timestamp,
              updatedAt: timestamp,
              meta: result?.meta || {},
            });
            break;
          }
          case "antagonist": {
            const providerId = result?.providerId;
            if (!providerId) return;
            if (!antagonistResponses[providerId])
              antagonistResponses[providerId] = [];
            antagonistResponses[providerId].push({
              providerId,
              text: result?.text || "",
              status: result?.status || "completed",
              createdAt: timestamp,
              updatedAt: timestamp,
              meta: result?.meta || {},
            });
            break;
          }
        }
      });

      const hasData =
        Object.keys(batchResponses).length > 0 ||
        Object.keys(synthesisResponses).length > 0 ||
        Object.keys(mappingResponses).length > 0 ||
        Object.keys(refinerResponses).length > 0 ||
        Object.keys(antagonistResponses).length > 0;

      if (!hasData) {
        console.log("[WorkflowEngine] No AI responses to finalize");
        return;
      }

      const aiTurn = {
        id: aiTurnId,
        type: "ai",
        userTurnId: userTurn.id,
        sessionId: context.sessionId,
        threadId: "default-thread",
        createdAt: timestamp,
        batchResponses,
        synthesisResponses,
        mappingResponses,
        refinerResponses,
        antagonistResponses,
        meta: {
          synthesizer: primarySynthesizer,
          mapper: primaryMapper,
        },
      };

      console.log("[WorkflowEngine] Emitting TURN_FINALIZED", {
        userTurnId: userTurn.id,
        aiTurnId: aiTurn.id,
        batchCount: Object.keys(batchResponses).length,
        synthesisCount: Object.keys(synthesisResponses).length,
        mappingCount: Object.keys(mappingResponses).length,
      });

      this.port.postMessage({
        type: "TURN_FINALIZED",
        sessionId: context.sessionId,
        userTurnId: userTurn.id,
        aiTurnId: aiTurn.id,
        turn: {
          user: userTurn,
          ai: aiTurn,
        },
      });

      // Store for persistence alignment
      this._lastFinalizedTurn = {
        sessionId: context.sessionId,
        user: userTurn,
        ai: aiTurn,
      };
    } catch (error) {
      console.error("[WorkflowEngine] Failed to emit TURN_FINALIZED:", error);
    }
  }


  _generateId(prefix = "turn") {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  }

  /**
   * Resolves provider context using three-tier resolution:
   * 1. Workflow cache context (highest priority)
   * 2. Batch step context (medium priority)
   * 3. Persisted context (fallback)
   */
  _resolveProviderContext(
    providerId,
    context,
    payload,
    workflowContexts,
    previousResults,
    resolvedContext,
    stepType = "step",
  ) {
    const providerContexts = {};

    // Tier 1: Prefer workflow cache context produced within this workflow run
    if (workflowContexts && workflowContexts[providerId]) {
      providerContexts[providerId] = {
        meta: workflowContexts[providerId],
        continueThread: true,
      };
      try {
        wdbg(
          `[WorkflowEngine] ${stepType} using workflow-cached context for ${providerId}: ${Object.keys(
            workflowContexts[providerId],
          ).join(",")}`,
        );
      } catch (_) { }
      return providerContexts;
    }

    // Tier 2: ResolvedContext (for recompute - historical contexts)
    if (resolvedContext && resolvedContext.type === "recompute") {
      const historicalContext =
        resolvedContext.providerContextsAtSourceTurn?.[providerId];
      if (historicalContext) {
        providerContexts[providerId] = {
          meta: historicalContext,
          continueThread: true,
        };
        try {
          wdbg(
            `[WorkflowEngine] ${stepType} using historical context from ResolvedContext for ${providerId}`,
          );
        } catch (_) { }
        return providerContexts;
      }
    }

    // Tier 2: Fallback to batch step context for backwards compatibility
    if (payload.continueFromBatchStep) {
      const batchResult = previousResults.get(payload.continueFromBatchStep);
      if (batchResult?.status === "completed" && batchResult.result?.results) {
        const providerResult = batchResult.result.results[providerId];
        if (providerResult?.meta) {
          providerContexts[providerId] = {
            meta: providerResult.meta,
            continueThread: true,
          };
          try {
            wdbg(
              `[WorkflowEngine] ${stepType} continuing conversation for ${providerId} via batch step`,
            );
          } catch (_) { }
          return providerContexts;
        }
      }
    }

    // Tier 3: Last resort use persisted context (may be stale across workflow runs)
    try {
      const persisted = this.sessionManager.getProviderContexts(
        context.sessionId,
        context.threadId || "default-thread",
      );
      const persistedMeta = persisted?.[providerId]?.meta;
      if (persistedMeta && Object.keys(persistedMeta).length > 0) {
        providerContexts[providerId] = {
          meta: persistedMeta,
          continueThread: true,
        };
        try {
          console.log(
            `[WorkflowEngine] ${stepType} using persisted context for ${providerId}: ${Object.keys(
              persistedMeta,
            ).join(",")}`,
          );
        } catch (_) { }
        return providerContexts;
      }
    } catch (_) { }

    return providerContexts;
    return providerContexts;
  }

  /**
   * Execute Refiner Step
   */
  /**
   * Execute Refiner Step
   */
  async executeRefinerStep(step, context, stepResults) {
    const {
      refinerProvider,
      sourceStepIds,
      originalPrompt,
      synthesisStepIds,
      mappingStepIds,
      sourceHistorical // Present if recompute
    } = step.payload;

    let batchResponses = {};
    let synthesisText = "";
    let mappingText = "";

    // 1. Resolve Inputs (Dynamic: New or Historical)
    if (sourceHistorical) {
      // --- RECOMPUTE FLOW ---
      const { turnId } = sourceHistorical;
      console.log(`[WorkflowEngine] Refiner recompute: resolving historical inputs from turn ${turnId}`);

      // Helper to fetch textual content from historical outputs
      const fetchHistoricalText = async (type) => {
        try {
          const historicalPayload = { sourceHistorical: { turnId, responseType: type } };
          const data = await this.resolveSourceData(historicalPayload, context, stepResults);
          // Return first valid text
          return data[0]?.text || "";
        } catch (e) {
          console.warn(`[WorkflowEngine] Refiner failed to fetch historical ${type}:`, e.message);
          return "";
        }
      };

      // A. Batch Responses
      try {
        const batchPayload = { sourceHistorical: { turnId, responseType: 'batch' } };
        const data = await this.resolveSourceData(batchPayload, context, stepResults);
        data.forEach(item => {
          if (item.text) batchResponses[item.providerId] = { text: item.text, providerId: item.providerId };
        });
      } catch (e) { console.warn("[WorkflowEngine] Refiner: no batch history found", e); }

      // B. Synthesis Text
      synthesisText = await fetchHistoricalText('synthesis');

      // C. Mapping Text (striped of topology)
      const rawMapping = await fetchHistoricalText('mapping');
      if (rawMapping) {
        const { text } = this.responseProcessor.extractGraphTopology(rawMapping);
        mappingText = text;
      }

    } else {
      // --- STANDARD FLOW ---
      // 1. Gather Batch Responses
      const batchStepResults = stepResults.get(sourceStepIds?.[0])?.result?.results || {};
      Object.entries(batchStepResults).forEach(([pid, res]) => {
        if (res && res.text) {
          batchResponses[pid] = { text: res.text, providerId: pid };
        }
      });

      // 2. Gather Synthesis Text
      if (synthesisStepIds && synthesisStepIds.length > 0) {
        for (const id of synthesisStepIds) {
          const res = stepResults.get(id);
          if (res?.status === "completed" && res.result?.text) {
            synthesisText = res.result.text;
            break;
          }
        }
      }

      // 3. Gather Mapping Narrative
      if (mappingStepIds && mappingStepIds.length > 0) {
        for (const id of mappingStepIds) {
          const res = stepResults.get(id);
          if (res?.status === "completed" && res.result?.text) {
            const raw = res.result.text;
            const { text } = this.responseProcessor.extractGraphTopology(raw);
            mappingText = text;
            break;
          }
        }
      }
    }

    // 4. Extract mapper option titles from meta (standard flow) or raw text (recompute)
    let mapperOptionTitles = [];
    if (!sourceHistorical && mappingStepIds && mappingStepIds.length > 0) {
      // Standard flow: get from stepResults meta
      for (const id of mappingStepIds) {
        const res = stepResults.get(id);
        if (res?.status === "completed" && res.result?.meta?.allAvailableOptions) {
          mapperOptionTitles = this.responseProcessor.parseOptionTitles(res.result.meta.allAvailableOptions);
          break;
        }
      }
    } else if (sourceHistorical) {
      // Recompute flow: extract options from raw mapping text and parse titles
      try {
        const mappingPayload = { sourceHistorical: { turnId: sourceHistorical.turnId, responseType: 'mapping' } };
        const data = await this.resolveSourceData(mappingPayload, context, stepResults);
        const rawMapping = data[0]?.text || "";
        if (rawMapping) {
          const { options } = this.responseProcessor.extractOptions(rawMapping);
          if (options) {
            mapperOptionTitles = this.responseProcessor.parseOptionTitles(options);
          }
        }
      } catch (e) {
        console.warn("[WorkflowEngine] Refiner recompute: failed to extract mapper options", e);
      }

    }


    // 5. Build Prompt
    const refinerPrompt = this.promptService.buildRefinerPrompt({
      originalPrompt,
      synthesisText,
      mappingText,
      batchResponses,
      mapperOptionTitles
    });

    console.log(`[WorkflowEngine] Running Refiner Analysis (${refinerProvider})...`);

    // 6. Execute via Orchestrator (Single)
    const result = await this.orchestrator.executeSingle(
      refinerPrompt,
      refinerProvider,
      {
        sessionId: context.sessionId,
        timeout: 90000, // Slightly longer for analysis
        onPartial: (pid, chunk) => {
          // Optional: stream refiner delta if UI supports it
          // For now, we don't stream refiner analysis to main chat flow usually, but we could.
        }
      }
    );

    const rawRefinerText = this.responseProcessor.extractContent(result.text);
    const parsedRefiner = this.responseProcessor.parseRefinerResponse(rawRefinerText);

    if (!parsedRefiner) {
      throw new Error("Refiner analysis returned null (failed or empty)");
    }

    return {
      providerId: refinerProvider,
      output: parsedRefiner, // The parsed object for in-memory use
      text: String(rawRefinerText || ""), // Store the RAW MARKDOWN for persistence
      meta: {
        confidenceScore: parsedRefiner.confidenceScore,
        presentationStrategy: parsedRefiner.presentationStrategy,
      },
      status: "completed"
    };
  }

  /**
   * Execute Antagonist Step
   */
  async executeAntagonistStep(step, context, stepResults) {
    const {
      antagonistProvider,
      sourceStepIds,
      originalPrompt,
      synthesisStepIds,
      mappingStepIds,
      refinerStepIds,
      sourceHistorical // Present if recompute
    } = step.payload;

    let batchResponses = {};
    let synthesisText = "";
    let mappingText = "";
    let refinerOutput = null;

    // 1. Resolve Inputs (Dynamic: New or Historical)
    if (sourceHistorical) {
      // --- RECOMPUTE FLOW ---
      const { turnId } = sourceHistorical;
      console.log(`[WorkflowEngine] Antagonist recompute: resolving historical inputs from turn ${turnId}`);

      // Helper to fetch textual content from historical outputs
      const fetchHistoricalText = async (type) => {
        try {
          const historicalPayload = { sourceHistorical: { turnId, responseType: type } };
          const data = await this.resolveSourceData(historicalPayload, context, stepResults);
          return data[0]?.text || "";
        } catch (e) {
          console.warn(`[WorkflowEngine] Antagonist failed to fetch historical ${type}:`, e.message);
          return "";
        }
      };

      // A. Batch Responses
      try {
        const batchPayload = { sourceHistorical: { turnId, responseType: 'batch' } };
        const data = await this.resolveSourceData(batchPayload, context, stepResults);
        data.forEach(item => {
          if (item.text) batchResponses[item.providerId] = { text: item.text, providerId: item.providerId };
        });
      } catch (e) { console.warn("[WorkflowEngine] Antagonist: no batch history found", e); }

      // B. Synthesis Text
      synthesisText = await fetchHistoricalText('synthesis');

      // C. Mapping Text (striped of topology)
      const rawMapping = await fetchHistoricalText('mapping');
      if (rawMapping) {
        const { text } = this.responseProcessor.extractGraphTopology(rawMapping);
        mappingText = text;
      }

      // D. Refiner Output
      const rawRefiner = await fetchHistoricalText('refiner');
      if (rawRefiner) {
        refinerOutput = this.responseProcessor.parseRefinerResponse(rawRefiner);
      }

    } else {
      // --- STANDARD FLOW ---
      // 1. Gather Batch Responses
      const batchStepResults = stepResults.get(sourceStepIds?.[0])?.result?.results || {};
      Object.entries(batchStepResults).forEach(([pid, res]) => {
        if (res && res.text) {
          batchResponses[pid] = { text: res.text, providerId: pid };
        }
      });

      // 2. Gather Synthesis Text
      if (synthesisStepIds && synthesisStepIds.length > 0) {
        for (const id of synthesisStepIds) {
          const res = stepResults.get(id);
          if (res?.status === "completed" && res.result?.text) {
            synthesisText = res.result.text;
            break;
          }
        }
      }

      // 3. Gather Mapping Narrative
      if (mappingStepIds && mappingStepIds.length > 0) {
        for (const id of mappingStepIds) {
          const res = stepResults.get(id);
          if (res?.status === "completed" && res.result?.text) {
            const raw = res.result.text;
            const { text } = this.responseProcessor.extractGraphTopology(raw);
            mappingText = text;
            break;
          }
        }
      }

      // 4. Gather Refiner Output
      if (refinerStepIds && refinerStepIds.length > 0) {
        for (const id of refinerStepIds) {
          const res = stepResults.get(id);
          if (res?.status === "completed" && res.result?.output) {
            refinerOutput = res.result.output;
            break;
          } else if (res?.status === "completed" && res.result?.text) {
            refinerOutput = this.responseProcessor.parseRefinerResponse(res.result.text);
            break;
          }
        }
      }
    }

    // 5. Extract mapper option titles
    let mapperOptionTitles = [];
    if (!sourceHistorical && mappingStepIds && mappingStepIds.length > 0) {
      for (const id of mappingStepIds) {
        const res = stepResults.get(id);
        if (res?.status === "completed" && res.result?.meta?.allAvailableOptions) {
          mapperOptionTitles = this.responseProcessor.parseOptionTitles(res.result.meta.allAvailableOptions);
          break;
        }
      }
    } else if (sourceHistorical) {
      try {
        const mappingPayload = { sourceHistorical: { turnId: sourceHistorical.turnId, responseType: 'mapping' } };
        const data = await this.resolveSourceData(mappingPayload, context, stepResults);
        const rawMapping = data[0]?.text || "";
        if (rawMapping) {
          const { options } = this.responseProcessor.extractOptions(rawMapping);
          if (options) {
            mapperOptionTitles = this.responseProcessor.parseOptionTitles(options);
          }
        }
      } catch (e) {
        console.warn("[WorkflowEngine] Antagonist recompute: failed to extract mapper options", e);
      }
    }

    // 6. Build model outputs block
    const modelCount = Object.keys(batchResponses).length;
    const modelOutputsBlock = Object.entries(batchResponses)
      .map(([providerId, response], idx) => {
        return `<model_${idx + 1} provider="${providerId}">\n${response.text}\n</model_${idx + 1}>`;
      })
      .join('\n\n');

    // Build option titles block
    const optionTitlesBlock = mapperOptionTitles.length > 0
      ? mapperOptionTitles.map(t => `- ${t}`).join('\n')
      : '(No mapper options available)';

    // 7. Build Prompt
    const antagonistPrompt = this.promptService.buildAntagonistPrompt(
      originalPrompt,
      synthesisText,
      mappingText,
      optionTitlesBlock,
      modelOutputsBlock,
      refinerOutput,
      modelCount
    );

    console.log(`[WorkflowEngine] Running Antagonist Analysis (${antagonistProvider})...`);

    // 8. Execute via Orchestrator (Single)
    const result = await this.orchestrator.executeSingle(
      antagonistPrompt,
      antagonistProvider,
      {
        sessionId: context.sessionId,
        timeout: 90000,
        onPartial: (pid, chunk) => {
          // Optional: stream antagonist delta if UI supports it
        }
      }
    );

    const rawAntagonistText = this.responseProcessor.extractContent(result.text);

    return {
      providerId: antagonistProvider,
      text: String(rawAntagonistText || ""), // Store raw for persistence
      meta: {},
      status: "completed"
    };
  }

  // ==========================================================================
  // STEP EXECUTORS - FIXED
  // ==========================================================================

  /**
   * Fire-and-forget persistence helper: batch update provider contexts and save session
   * without blocking the workflow's resolution path.
   */
  _persistProviderContextsAsync(sessionId, updates) {
    try {
      // Defer to next tick to ensure prompt/mapping resolution proceeds immediately
      setTimeout(() => {
        try {
          this.sessionManager.updateProviderContextsBatch(
            sessionId,
            updates,
            true,
            { skipSave: true },
          );
          this.sessionManager.saveSession(sessionId);
        } catch (e) {
          console.warn("[WorkflowEngine] Deferred persistence failed:", e);
        }
      }, 0);
    } catch (_) { }
  }

  /**
   * Execute prompt step - FIXED to return proper format
   */
  /**
   * Execute prompt step - FIXED to include synchronous in-memory update
   */
  async executePromptStep(step, context) {
    const artifactProcessor = new ArtifactProcessor();
    const {
      prompt,
      providers,
      useThinking,
      providerContexts,
      previousContext, // ← NEW
    } = step.payload;

    // Inject Council Framing if context exists
    let enhancedPrompt = prompt;
    if (previousContext) {
      enhancedPrompt = `You are part of the council.Context(backdrop only—do not summarize or re - answer):

${previousContext}

Answer the user's message directly. Use context only to disambiguate.

  < user_prompt >
  ${prompt}
</user_prompt > `;
    }

    // Provider health pre-check + initial progress emit
    const providerStatuses = [];
    const activeProviders = [];
    try {
      for (const pid of providers) {
        const check = this.healthTracker.shouldAttempt(pid);
        if (!check.allowed) {
          providerStatuses.push({
            providerId: pid,
            status: 'skipped',
            skippedReason: check.reason || 'circuit_open',
            error: {
              type: 'circuit_open',
              message: 'Provider temporarily unavailable due to recent failures',
              retryable: true,
              retryAfterMs: check.retryAfterMs,
            },
          });
        } else {
          providerStatuses.push({ providerId: pid, status: 'queued', progress: 0 });
          activeProviders.push(pid);
        }
      }
      // Emit initial status
      this.port.postMessage({
        type: 'WORKFLOW_PROGRESS',
        sessionId: context.sessionId,
        aiTurnId: context.canonicalAiTurnId || 'unknown',
        phase: 'batch',
        providerStatuses,
        completedCount: 0,
        totalCount: providers.length,
      });
    } catch (_) { }

    // Input length validation per provider
    const promptLength = enhancedPrompt.length;
    const allowedProviders = [];
    const skippedProviders = [];
    try {
      for (const pid of activeProviders) {
        const limits = PROVIDER_LIMITS[pid];
        if (limits && promptLength > limits.maxInputChars) {
          skippedProviders.push(pid);
        } else {
          allowedProviders.push(pid);
        }
      }
      if (skippedProviders.length > 0) {
        skippedProviders.forEach((pid) => {
          try {
            const entry = providerStatuses.find((s) => s.providerId === pid);
            if (entry) {
              entry.status = 'skipped';
              entry.skippedReason = 'input_too_long';
              entry.error = { type: 'input_too_long', message: `Prompt length ${promptLength} exceeds limit for ${pid}`, retryable: true };
            } else {
              providerStatuses.push({ providerId: pid, status: 'skipped', skippedReason: 'input_too_long', error: { type: 'input_too_long', message: `Prompt length ${promptLength} exceeds limit for ${pid}`, retryable: true } });
            }
          } catch (_) { }
        });
        try {
          this.port.postMessage({
            type: 'WORKFLOW_PROGRESS',
            sessionId: context.sessionId,
            aiTurnId: context.canonicalAiTurnId || 'unknown',
            phase: 'batch',
            providerStatuses,
            completedCount: providerStatuses.filter((p) => p.status === 'completed').length,
            totalCount: providerStatuses.length,
          });
        } catch (_) { }
      }
      if (allowedProviders.length === 0) {
        throw new Error(`INPUT_TOO_LONG: Prompt length ${promptLength} exceeds limits for all selected providers`);
      }
    } catch (e) {
      return Promise.reject(e);
    }

    return new Promise((resolve, reject) => {
      this.orchestrator.executeParallelFanout(enhancedPrompt, allowedProviders, {
        sessionId: context.sessionId,
        useThinking,
        providerContexts,
        providerMeta: step?.payload?.providerMeta,
        onPartial: (providerId, chunk) => {
          this._dispatchPartialDelta(
            context.sessionId,
            step.stepId,
            providerId,
            chunk.text,
            "Prompt",
          );
          try {
            const entry = providerStatuses.find((s) => s.providerId === providerId);
            if (entry) {
              entry.status = 'streaming';
              // ✅ FIX: Use undefined for indeterminate progress instead of 0, so UI shows "Generating..."
              entry.progress = undefined;
              this.port.postMessage({
                type: 'WORKFLOW_PROGRESS',
                sessionId: context.sessionId,
                aiTurnId: context.canonicalAiTurnId || 'unknown',
                phase: 'batch',
                providerStatuses,
                completedCount: providerStatuses.filter((p) => p.status === 'completed').length,
                totalCount: providers.length,
              });
            }
          } catch (_) { }
        },
        // ✅ NEW: Handle granular completion
        onProviderComplete: (providerId, resultWrapper) => {
          try {
            this.healthTracker.recordSuccess(providerId);
            const entry = providerStatuses.find((s) => s.providerId === providerId);
            if (entry) {
              entry.status = 'completed';
              entry.progress = 100;
              if (entry.error) delete entry.error;

              // Emit immediate progress update
              this.port.postMessage({
                type: 'WORKFLOW_PROGRESS',
                sessionId: context.sessionId,
                aiTurnId: context.canonicalAiTurnId || 'unknown',
                phase: 'batch',
                providerStatuses,
                completedCount: providerStatuses.filter((p) => p.status === 'completed').length,
                totalCount: providers.length,
              });
            }
          } catch (_) { }
        },
        onError: (error) => {
          try {
            this.port.postMessage({
              type: "WORKFLOW_STEP_UPDATE",
              sessionId: context.sessionId,
              stepId: step.stepId,
              status: "partial_failure",
              error: error?.message || String(error),
            });
          } catch (_) { }
          // Don't reject yet, let Promise.all handle it
        },
        onAllComplete: (results, errors) => {
          // Build batch updates
          const batchUpdates = {};
          results.forEach((res, pid) => {
            batchUpdates[pid] = res;
          });

          // Emit a single aggregated log summarizing cached contexts produced by providers in this batch
          try {
            const contextsSummary = [];
            results.forEach((res, pid) => {
              const keys = res?.meta ? Object.keys(res.meta) : [];
              if (keys.length > 0)
                contextsSummary.push(`${pid}: ${keys.join(",")} `);
            });
            if (contextsSummary.length > 0) {
              wdbg(
                `[WorkflowEngine] Cached context for ${contextsSummary.join(
                  "; ",
                )
                }`,
              );
            }
          } catch (_) { }

          // ✅ CRITICAL: Update in-memory cache SYNCHRONOUSLY
          this.sessionManager.updateProviderContextsBatch(
            context.sessionId,
            batchUpdates,
            true, // continueThread
            { skipSave: true },
          );

          this._persistProviderContextsAsync(context.sessionId, batchUpdates);

          // Format results for workflow engine
          const formattedResults = {};
          const authErrors = [];

          results.forEach((result, providerId) => {
            const processed = artifactProcessor.process(result.text || '');
            formattedResults[providerId] = {
              providerId: providerId,
              text: processed.cleanText,
              status: "completed",
              meta: result.meta || {},
              artifacts: processed.artifacts,
              ...(result.softError ? { softError: result.softError } : {}),
            };
            try {
              this.healthTracker.recordSuccess(providerId);
              const entry = providerStatuses.find((s) => s.providerId === providerId);
              if (entry) {
                entry.status = 'completed';
                entry.progress = 100;
                if (entry.error) delete entry.error;
              }
            } catch (_) { }
          });

          errors.forEach((error, providerId) => {
            formattedResults[providerId] = {
              providerId: providerId,
              text: "",
              status: "failed",
              meta: { _rawError: error.message },
            };

            // Collect auth errors
            if (isProviderAuthError(error)) {
              authErrors.push(error);
            }
            try {
              this.healthTracker.recordFailure(providerId, error);
              const classified = classifyError(error);
              const entry = providerStatuses.find((s) => s.providerId === providerId);
              if (entry) {
                entry.status = 'failed';
                entry.error = classified;
              }
            } catch (_) { }
          });

          // Validate at least one provider succeeded
          const hasAnyValidResults = Object.values(formattedResults).some(
            (r) =>
              r.status === "completed" && r.text && r.text.trim().length > 0,
          );

          if (!hasAnyValidResults) {
            // If all failed and we have auth errors, throw MultiProviderAuthError
            if (authErrors.length > 0 && authErrors.length === errors.size) {
              const providerIds = Array.from(errors.keys());
              reject(createMultiProviderAuthError(providerIds, {
                originalErrors: authErrors
              }));
              return;
            }

            reject(
              new Error("All providers failed or returned empty responses"),
            );
            return;
          }

          // Emit final progress update for batch phase
          try {
            const completedCount = providerStatuses.filter((p) => p.status === 'completed').length;
            this.port.postMessage({
              type: 'WORKFLOW_PROGRESS',
              sessionId: context.sessionId,
              aiTurnId: context.canonicalAiTurnId || 'unknown',
              phase: 'batch',
              providerStatuses,
              completedCount,
              totalCount: providers.length,
            });

            const failedProviders = providerStatuses.filter((p) => p.status === 'failed');
            const successfulProviders = providerStatuses.filter((p) => p.status === 'completed');
            if (failedProviders.length > 0) {
              this.port.postMessage({
                type: 'WORKFLOW_PARTIAL_COMPLETE',
                sessionId: context.sessionId,
                aiTurnId: context.canonicalAiTurnId || 'unknown',
                successfulProviders: successfulProviders.map((p) => p.providerId),
                failedProviders: failedProviders.map((p) => ({ providerId: p.providerId, error: p.error })),
                synthesisCompleted: false,
                mappingCompleted: false,
              });
            }
          } catch (_) { }

          resolve({
            results: formattedResults,
            errors: Object.fromEntries(errors),
          });
        },
      });
    });
  }

  /**
   * Resolve source data - FIXED to handle new format
   */
  async resolveSourceData(payload, context, previousResults) {
    if (payload.sourceHistorical) {
      // Historical source
      const { turnId, responseType } = payload.sourceHistorical;
      console.log(
        `[WorkflowEngine] Resolving historical data from turn: ${turnId} `,
      );

      // Prefer adapter lookup: turnId may be a user or AI turn
      let session = this.sessionManager.sessions[context.sessionId];
      let aiTurn = null;
      try {
        const adapter = this.sessionManager?.adapter;
        if (adapter?.isReady && adapter.isReady()) {
          const turn = await adapter.get("turns", turnId);
          if (turn && (turn.type === "ai" || turn.role === "assistant")) {
            aiTurn = turn;
          } else if (turn && turn.type === "user") {
            // If we have the user turn, try to locate the subsequent AI turn in memory
            if (session && Array.isArray(session.turns)) {
              const userIdx = session.turns.findIndex(
                (t) => t.id === turnId && t.type === "user",
              );
              if (userIdx !== -1) {
                const next = session.turns[userIdx + 1];
                if (next && (next.type === "ai" || next.role === "assistant"))
                  aiTurn = next;
              }
            }
          }
        }
      } catch (_) { }

      // Fallback: resolve from current session memory
      if (!aiTurn && session && Array.isArray(session.turns)) {
        // If turnId is an AI id, pick that turn directly
        aiTurn =
          session.turns.find(
            (t) =>
              t &&
              t.id === turnId &&
              (t.type === "ai" || t.role === "assistant"),
          ) || null;
        if (!aiTurn) {
          // Otherwise treat as user id and take the next AI turn
          const userTurnIndex = session.turns.findIndex(
            (t) => t.id === turnId && t.type === "user",
          );
          if (userTurnIndex !== -1) {
            aiTurn = session.turns[userTurnIndex + 1] || null;
          }
        }
      }

      // Fallback: search across all sessions (helps after reconnects or wrong session targeting)
      if (!aiTurn) {
        try {
          const allSessions = this.sessionManager.sessions || {};
          for (const [sid, s] of Object.entries(allSessions)) {
            if (!s || !Array.isArray(s.turns)) continue;
            const direct = s.turns.find(
              (t) =>
                t &&
                t.id === turnId &&
                (t.type === "ai" || t.role === "assistant"),
            );
            if (direct) {
              aiTurn = direct;
              session = s;
              break;
            }
            const idx = s.turns.findIndex(
              (t) => t.id === turnId && t.type === "user",
            );
            if (idx !== -1) {
              aiTurn = s.turns[idx + 1];
              session = s;
              console.warn(
                `[WorkflowEngine] Historical turn ${turnId} resolved in different session ${sid}; proceeding with that context.`,
              );
              break;
            }
          }
        } catch (_) { }
      }

      if (!aiTurn || aiTurn.type !== "ai") {
        // Fallback: try to resolve by matching user text when IDs differ (optimistic vs canonical)
        const fallbackText =
          context?.userMessage || this.currentUserMessage || "";
        if (fallbackText && fallbackText.trim().length > 0) {
          try {
            // Search current session first
            let found = null;
            const searchInSession = (sess) => {
              if (!sess || !Array.isArray(sess.turns)) return null;
              for (let i = 0; i < sess.turns.length; i++) {
                const t = sess.turns[i];
                if (
                  t &&
                  t.type === "user" &&
                  String(t.text || "") === String(fallbackText)
                ) {
                  const next = sess.turns[i + 1];
                  if (next && next.type === "ai") return next;
                }
              }
              return null;
            };

            found = searchInSession(session);
            if (!found) {
              // Fallback: search across all sessions
              const allSessions = this.sessionManager.sessions || {};
              for (const [sid, s] of Object.entries(allSessions)) {
                found = searchInSession(s);
                if (found) {
                  console.warn(
                    `[WorkflowEngine] Historical fallback matched by text in different session ${sid}; proceeding with that context.`,
                  );
                  break;
                }
              }
            }

            if (found) {
              aiTurn = found;
            } else {
              throw new Error(
                `Could not find corresponding AI turn for ${turnId}`,
              );
            }
          } catch (e) {
            throw new Error(
              `Could not find corresponding AI turn for ${turnId}`,
            );
          }
        } else {
          throw new Error(`Could not find corresponding AI turn for ${turnId}`);
        }
      }

      let sourceContainer;
      switch (responseType) {
        case "synthesis":
          sourceContainer = aiTurn.synthesisResponses || {};
          break;
        case "mapping":
          sourceContainer = aiTurn.mappingResponses || {};
          break;
        default:
          sourceContainer = aiTurn.batchResponses || {};
          break;
      }

      // Convert to array format
      let sourceArray = Object.values(sourceContainer)
        .flat()
        .filter(
          (res) =>
            res.status === "completed" &&
            res.text &&
            res.text.trim().length > 0,
        )
        .map((res) => ({
          providerId: res.providerId,
          text: res.text,
        }));

      // If embedded responses were not present, attempt provider_responses fallback (prefer indexed lookup)
      if (
        sourceArray.length === 0 &&
        this.sessionManager?.adapter?.isReady &&
        this.sessionManager.adapter.isReady()
      ) {
        try {
          let responses = [];
          if (
            typeof this.sessionManager.adapter.getResponsesByTurnId ===
            "function"
          ) {
            responses = await this.sessionManager.adapter.getResponsesByTurnId(
              aiTurn.id,
            );
          } else {
            responses = await this.sessionManager.adapter.getResponsesByTurnId(
              aiTurn.id,
            );
          }
          const respType = responseType || "batch";
          sourceArray = (responses || [])
            .filter(
              (r) =>
                r &&
                r.responseType === respType &&
                r.text &&
                String(r.text).trim().length > 0,
            )
            .sort(
              (a, b) =>
                (a.updatedAt || a.createdAt || 0) -
                (b.updatedAt || b.createdAt || 0),
            )
            .map((r) => ({ providerId: r.providerId, text: r.text }));
          if (sourceArray.length > 0) {
            console.log(
              "[WorkflowEngine] provider_responses fallback succeeded for historical sources",
            );
          }
        } catch (e) {
          console.warn(
            "[WorkflowEngine] provider_responses fallback failed for historical sources:",
            e,
          );
        }
      }

      console.log(
        `[WorkflowEngine] Found ${sourceArray.length} historical sources`,
      );
      return sourceArray;
    } else if (payload.sourceStepIds) {
      // Current workflow source
      const sourceArray = [];

      for (const stepId of payload.sourceStepIds) {
        const stepResult = previousResults.get(stepId);

        if (!stepResult || stepResult.status !== "completed") {
          console.warn(
            `[WorkflowEngine] Step ${stepId} not found or incomplete`,
          );
          continue;
        }

        const { results } = stepResult.result;

        // Results is now an object: { claude: {...}, gemini: {...} }
        Object.entries(results).forEach(([providerId, result]) => {
          if (
            result.status === "completed" &&
            result.text &&
            result.text.trim().length > 0
          ) {
            sourceArray.push({
              providerId: providerId,
              text: result.text,
            });
          }
        });
      }

      console.log(
        `[WorkflowEngine] Found ${sourceArray.length} current workflow sources`,
      );
      return sourceArray;
    }

    throw new Error("No valid source specified for step.");
  }

  /**
   * Execute synthesis step - FIXED error messages
   */
  async executeSynthesisStep(
    step,
    context,
    previousResults,
    workflowContexts = {},
    resolvedContext,
  ) {
    const artifactProcessor = new ArtifactProcessor();
    const payload = step.payload;
    const sourceData = await this.resolveSourceData(
      payload,
      context,
      previousResults,
    );

    if (sourceData.length < 2) {
      throw new Error(
        `Synthesis requires at least 2 valid sources, but found ${sourceData.length}.`,
      );
    }

    wdbg(
      `[WorkflowEngine] Running synthesis with ${sourceData.length
      } sources: ${sourceData.map((s) => s.providerId).join(", ")} `,
    );

    // Look for mapping results from the current workflow
    let mappingResult = null;

    if (payload.mappingStepIds && payload.mappingStepIds.length > 0) {
      for (const mappingStepId of payload.mappingStepIds) {
        const mappingStepResult = previousResults.get(mappingStepId);
        wdbg(
          `[WorkflowEngine] Checking mapping step ${mappingStepId}: ${JSON.stringify(
            {
              status: mappingStepResult?.status,
              hasResult: !!mappingStepResult?.result,
            },
          )
          } `,
        );

        if (
          mappingStepResult?.status === "completed" &&
          mappingStepResult.result?.text
        ) {
          mappingResult = mappingStepResult.result;
          wdbg(
            `[WorkflowEngine] Found mapping result from step ${mappingStepId} for synthesis: providerId = ${mappingResult.providerId}, textLength = ${mappingResult.text?.length} `,
          );
          break;
        } else {
          wdbg(
            `[WorkflowEngine] Mapping step ${mappingStepId} not suitable: status = ${mappingStepResult?.status
            }, hasResult = ${!!mappingStepResult?.result}, hasText = ${!!mappingStepResult
              ?.result?.text
            } `,
          );
        }
      }
      // Prefer mapping result when declared, but continue gracefully if absent
      if (!mappingResult || !String(mappingResult.text || "").trim()) {
        console.warn(
          `[WorkflowEngine] No valid mapping result found; proceeding without Map input`,
          mappingResult,
        );



      }
    } else {
      if (
        !mappingResult &&
        resolvedContext?.type === "recompute" &&
        resolvedContext?.latestMappingOutput
      ) {
        mappingResult = resolvedContext.latestMappingOutput;
        wdbg(
          `[WorkflowEngine] Using pre - fetched historical mapping from ${mappingResult.providerId} `,
        );
      }
      if (!mappingResult) {
        try {
          previousResults.forEach((val) => {
            if (!mappingResult && val && val.result && val.result.meta && val.result.meta.allAvailableOptions) {
              mappingResult = val.result;
            }
          });
          if (mappingResult) {
            wdbg(`[WorkflowEngine] Found mapping result in previousResults(meta.allAvailableOptions present)`);
          }
        } catch (_) { }
      }
    }

    // Helper to execute synthesis with a specific provider
    const runSynthesis = async (providerId) => {
      const extractedOptions = mappingResult?.meta?.allAvailableOptions || null;
      // 🔍 DIAGNOSTIC LOGGING
      console.log('[DEBUG] Synthesis options check:', {
        hasMappingResult: !!mappingResult,
        hasMetaOptions: !!mappingResult?.meta?.allAvailableOptions,
        optionsLength: extractedOptions?.length || 0,
        optionsPreview: extractedOptions?.substring(0, 200),
        isRecompute: resolvedContext?.type === 'recompute',
        sourceTurnId: resolvedContext?.sourceTurnId,
        metaKeys: Object.keys(mappingResult?.meta || {})
      });
      const synthPrompt = this.promptService.buildSynthesisPrompt(
        payload.originalPrompt,
        sourceData,
        providerId,
        extractedOptions
      );

      // ✅ RESTORED: Log prompt length for debugging
      const promptLength = synthPrompt.length;
      console.log(`[WorkflowEngine] Synthesis prompt length for ${providerId}: ${promptLength} chars`);

      // ✅ NEW: Input Length Validation
      const limits = PROVIDER_LIMITS[providerId];
      if (limits && promptLength > limits.maxInputChars) {
        console.warn(`[WorkflowEngine] Prompt length ${promptLength} exceeds limit ${limits.maxInputChars} for ${providerId}`);
        throw new Error(`INPUT_TOO_LONG: Prompt length ${promptLength} exceeds limit ${limits.maxInputChars} for ${providerId}`);
      }

      // Resolve provider context using three-tier resolution
      const providerContexts = this._resolveProviderContext(
        providerId,
        context,
        payload,
        workflowContexts,
        previousResults,
        resolvedContext,
        "Synthesis",
      );

      return new Promise((resolve, reject) => {
        this.orchestrator.executeParallelFanout(
          synthPrompt,
          [providerId],
          {
            sessionId: context.sessionId,
            useThinking: payload.useThinking,
            providerContexts: Object.keys(providerContexts).length
              ? providerContexts
              : undefined,
            providerMeta: step?.payload?.providerMeta,
            onPartial: (pid, chunk) => {
              this._dispatchPartialDelta(
                context.sessionId,
                step.stepId,
                pid,
                chunk.text,
                "Synthesis",
              );
            },
            onError: (error) => {
              reject(error);
            },
            onAllComplete: (results) => {
              const finalResult = results.get(providerId);

              // ✅ Extract artifacts from synthesis response
              if (finalResult?.text) {
                const { cleanText, artifacts } = artifactProcessor.process(finalResult.text);
                finalResult.text = cleanText;
                finalResult.artifacts = artifacts;
              }

              // ✅ Ensure final emission for synthesis
              if (finalResult?.text) {
                this._dispatchPartialDelta(
                  context.sessionId,
                  step.stepId,
                  providerId,
                  finalResult.text,
                  "Synthesis",
                  true,
                );
              }

              if (!finalResult || !finalResult.text) {
                reject(
                  new Error(
                    `Synthesis provider ${providerId} returned empty response`,
                  ),
                );
                return;
              }

              // Defer persistence to avoid blocking synthesis resolution
              this._persistProviderContextsAsync(context.sessionId, {
                [providerId]: finalResult,
              });
              // Update workflow-cached context for subsequent steps in the same workflow
              try {
                if (finalResult?.meta) {
                  workflowContexts[providerId] = finalResult.meta;
                  wdbg(
                    `[WorkflowEngine] Updated workflow context for ${providerId
                    }: ${Object.keys(finalResult.meta).join(",")} `,
                  );
                }
              } catch (_) { }

              resolve({
                providerId: providerId,
                text: finalResult.text, // ✅ Return text explicitly
                status: "completed",
                meta: finalResult.meta || {},
                artifacts: finalResult.artifacts || [],
              });
            },
          },
        );
      });
    };

    try {
      return await runSynthesis(payload.synthesisProvider);
    } catch (error) {
      // Check if we can recover from auth error
      if (isProviderAuthError(error)) {
        console.warn(`[WorkflowEngine] Synthesis failed with auth error for ${payload.synthesisProvider}, attempting fallback...`);

        const fallbackStrategy = errorHandler.fallbackStrategies.get('PROVIDER_AUTH_FAILED');
        if (fallbackStrategy) {
          try {
            const fallbackProvider = await fallbackStrategy(
              'synthesis',
              { failedProviderId: payload.synthesisProvider }
            );

            if (fallbackProvider) {
              console.log(`[WorkflowEngine] executing synthesis with fallback provider: ${fallbackProvider} `);
              // Retry with fallback provider
              return await runSynthesis(fallbackProvider);
            }
          } catch (fallbackError) {
            console.warn(`[WorkflowEngine] Fallback failed: `, fallbackError);
          }
        }
      }

      throw error;
    }
  }

  /**
   * Execute mapping step - FIXED
   */
  async executeMappingStep(
    step,
    context,
    previousResults,
    workflowContexts = {},
    resolvedContext,
  ) {
    const artifactProcessor = new ArtifactProcessor();
    const payload = step.payload;
    const sourceData = await this.resolveSourceData(
      payload,
      context,
      previousResults,
    );

    if (sourceData.length < 2) {
      throw new Error(
        `Mapping requires at least 2 valid sources, but found ${sourceData.length}.`,
      );
    }

    wdbg(
      `[WorkflowEngine] Running mapping with ${sourceData.length
      } sources: ${sourceData.map((s) => s.providerId).join(", ")} `,
    );

    // Compute citation order mapping number→providerId
    const providerOrder = Array.isArray(payload.providerOrder)
      ? payload.providerOrder
      : sourceData.map((s) => s.providerId);
    const citationOrder = providerOrder.filter((pid) =>
      sourceData.some((s) => s.providerId === pid),
    );

    const mappingPrompt = this.promptService.buildMappingPrompt(
      payload.originalPrompt,
      sourceData,
      citationOrder,
    );

    // Resolve provider context using three-tier resolution
    const providerContexts = this._resolveProviderContext(
      payload.mappingProvider,
      context,
      payload,
      workflowContexts,
      previousResults,
      resolvedContext,
      "Mapping",
    );

    // ✅ RESTORED: Log prompt length for debugging
    const promptLength = mappingPrompt.length;
    console.log(`[WorkflowEngine] Mapping prompt length for ${payload.mappingProvider}: ${promptLength} chars`);

    // ✅ NEW: Input Length Validation
    const limits = PROVIDER_LIMITS[payload.mappingProvider];
    if (limits && promptLength > limits.maxInputChars) {
      console.warn(`[WorkflowEngine] Mapping prompt length ${promptLength} exceeds limit ${limits.maxInputChars} for ${payload.mappingProvider}`);
      throw new Error(`INPUT_TOO_LONG: Prompt length ${promptLength} exceeds limit ${limits.maxInputChars} for ${payload.mappingProvider}`);
    }

    return new Promise((resolve, reject) => {
      this.orchestrator.executeParallelFanout(
        mappingPrompt,
        [payload.mappingProvider],
        {
          sessionId: context.sessionId,
          useThinking: payload.useThinking,
          providerContexts: Object.keys(providerContexts).length
            ? providerContexts
            : undefined,
          providerMeta: step?.payload?.providerMeta,
          onPartial: (providerId, chunk) => {
            this._dispatchPartialDelta(
              context.sessionId,
              step.stepId,
              providerId,
              chunk.text,
              "Mapping",
            );
          },
          onAllComplete: (results) => {
            const finalResult = results.get(payload.mappingProvider);

            let graphTopology = null;
            let allOptions = null;
            if (finalResult?.text) {
              console.log('[WorkflowEngine] Mapping response length:', finalResult.text.length);

              // Use ResponseProcessor pipeline
              const processedMap = this.responseProcessor.processMappingResponse(finalResult.text);

              graphTopology = processedMap.topology;
              allOptions = processedMap.options;

              // Proceed with artifact processing on the cleaned text
              const processed = artifactProcessor.process(processedMap.text);
              finalResult.text = processed.cleanText;
              finalResult.artifacts = processed.artifacts;

              console.log('[WorkflowEngine] Graph topology extracted:', {
                found: !!graphTopology,
                hasNodes: graphTopology?.nodes?.length || 0,
              });
              console.log('[WorkflowEngine] Options extracted:', {
                found: !!allOptions,
                length: allOptions?.length || 0,
              });
            }

            // ✅ Ensure final emission for mapping
            if (finalResult?.text) {
              this._dispatchPartialDelta(
                context.sessionId,
                step.stepId,
                payload.mappingProvider,
                finalResult.text,
                "Mapping",
                true,
              );
            }

            if (!finalResult || !finalResult.text) {
              reject(
                new Error(
                  `Mapping provider ${payload.mappingProvider} returned empty response`,
                ),
              );
              return;
            }

            // Attach citationSourceOrder meta mapping number→providerId
            const citationSourceOrder = {};
            citationOrder.forEach((pid, idx) => {
              citationSourceOrder[idx + 1] = pid;
            });
            const finalResultWithMeta = {
              ...finalResult,
              meta: {
                ...(finalResult?.meta || {}),
                citationSourceOrder,
                ...(allOptions ? { allAvailableOptions: allOptions } : {}),
                ...(graphTopology ? { graphTopology } : {}),
              },
            };

            // Defer persistence to avoid blocking mapping resolution
            this._persistProviderContextsAsync(context.sessionId, {
              [payload.mappingProvider]: finalResultWithMeta,
            });
            // Update workflow-cached context for subsequent steps in the same workflow
            try {
              if (finalResultWithMeta?.meta) {
                workflowContexts[payload.mappingProvider] =
                  finalResultWithMeta.meta;
                wdbg(
                  `[WorkflowEngine] Updated workflow context for ${payload.mappingProvider
                  }: ${Object.keys(finalResultWithMeta.meta).join(",")} `,
                );
              }
            } catch (_) { }

            resolve({
              providerId: payload.mappingProvider,
              text: finalResultWithMeta.text, // ✅ Return text explicitly
              status: "completed",
              meta: finalResultWithMeta.meta || {},
              artifacts: finalResult.artifacts || [],
            });
          },
        },
      );
    });
  }

  /**
   * Handle retry requests from frontend: reset circuit, emit queued status.
   * Actual re-execution should be triggered by orchestration layer with original context.
   */
  async handleRetryRequest(message) {
    try {
      const { sessionId, aiTurnId, providerIds, retryScope } = message || {};
      console.log(`[WorkflowEngine] Retry requested for providers = ${(providerIds || []).join(', ')} scope = ${retryScope} `);

      try {
        (providerIds || []).forEach((pid) => this.healthTracker.resetCircuit(pid));
      } catch (_) { }

      try {
        this.port.postMessage({
          type: 'WORKFLOW_PROGRESS',
          sessionId: sessionId,
          aiTurnId: aiTurnId,
          phase: retryScope || 'batch',
          providerStatuses: (providerIds || []).map((id) => ({ providerId: id, status: 'queued', progress: 0 })),
          completedCount: 0,
          totalCount: (providerIds || []).length,
        });
      } catch (_) { }
    } catch (e) {
      console.warn('[WorkflowEngine] handleRetryRequest failed:', e);
    }
  }
}



================================================
FILE: src/HTOS/BusController.js
================================================
/**
 * HTOS BusController - Complete Implementation
 * Extracted from bg.refactored.non.stripped.js for standalone integration
 *
 * This module provides the complete Bus communication system for inter-context messaging
 * in Chrome extensions, supporting background, content script, offscreen, popup, and iframe communication.
 */

// =============================================================================
// UTILITY DEPENDENCIES
// =============================================================================

const utils = {
  // Type checking utilities
  is: {
    null: (e) => e === null,
    defined: (e) => undefined !== e,
    undefined: (e) => undefined === e,
    nil: (e) => e == null,
    boolean: (e) => typeof e == "boolean",
    number: (e) => typeof e == "number",
    string: (e) => typeof e == "string",
    symbol: (e) => typeof e == "symbol",
    function: (e) => typeof e == "function",
    map: (e) => e instanceof Map,
    set: (e) => e instanceof Set,
    url: (e) => e instanceof URL,
    blob: (e) => e instanceof Blob,
    file: (e) => e instanceof File,
    error: (e) => e instanceof Error,
    regexp: (e) => e instanceof RegExp,
    array: (e) => Array.isArray(e),
    object: (e) => Object.prototype.toString.call(e) === "[object Object]",
    nan: (e) => Number.isNaN(e),
    nonPrimitive: (e) => utils.is.object(e) || utils.is.array(e),
    numeric: (e) => !utils.is.nan(Number(e)),
    empty: (e) =>
      !!utils.is.nil(e) ||
      (utils.is.array(e)
        ? e.length === 0
        : utils.is.object(e)
          ? Object.keys(e).length === 0
          : !!utils.is.string(e) && e.trim().length === 0),
  },

  // Async sleep utility
  sleep: async (e) =>
    new Promise((t) => {
      setTimeout(t, e);
    }),

  // Array unique utility
  unique: (e) => Array.from(new Set(e)),

  // Wait for condition with timeout
  waitFor: async (e, { interval: n = 100, timeout: a = 60000 } = {}) => {
    if (a <= 0) throw new Error("$utils.waitFor: timeout exceeded");
    const o = Date.now(),
      i = await e();
    if (i) return i;
    await utils.sleep(n);
    const r = Date.now() - o;
    return utils.waitFor(e, {
      interval: n,
      timeout: a - r,
    });
  },

  // Object URL utilities
  objectUrl: {
    create(e, a = !1) {
      if (!URL.createObjectURL) {
        // Fallback for environments without URL.createObjectURL
        console.warn("URL.createObjectURL not available");
        return null;
      }
      const o = URL.createObjectURL(e);
      if (a) {
        const timeout = utils.is.number(a) ? a : 60000;
        setTimeout(() => URL.revokeObjectURL(o), timeout);
      }
      return o;
    },
    revoke(e) {
      if (!URL.revokeObjectURL) {
        console.warn("URL.revokeObjectURL not available");
        return;
      }
      URL.revokeObjectURL(e);
    },
  },
};

// =============================================================================
// ENVIRONMENT DETECTION
// =============================================================================

const env = {
  getLocus: () => {
    const { protocol: e, host: t, pathname: n, href: a } = location;
    // normalize for robust comparisons
    const _href = String(a || "").toLowerCase();
    const _path = String(n || "").toLowerCase();

    // --- START OF FIX ---
    // Recognize oi loader paths and local dev variants in multiple forms.
    if (
      _href === "https://htos.io/oi" ||
      _href === "http://localhost:3000/oi" ||
      _path.endsWith("/oi.html") ||
      _path.endsWith("/oi") ||
      _href.includes("/oi.html") ||
      _href.includes("/oi")
    ) {
      return "oi";
    }
    // --- END OF FIX ---

    return e !== "chrome-extension:" && chrome?.runtime?.getURL
      ? "cs"
      : t === "localhost:3050"
        ? "fg"
        : e !== "chrome-extension:"
          ? "nj"
          : n === "/HTOS.html"
            ? "pp"
            : n === "/offscreen.html"
              ? "os"
              : "bg";
  },
};

// =============================================================================
// MOCK DATA CONTEXT
// =============================================================================

const data = {
  name: "htos", // Updated from 'HTOS1'
};

// =============================================================================
// MAIN BUS CONTROLLER IMPLEMENTATION
// =============================================================================

const BusController = {
  async init() {
    // Bind public API methods
    this.on = this.on.bind(this);
    this.off = this.off.bind(this);
    this.once = this.once.bind(this);
    this.send = this._wrapThrowIfError(this.send);
    this.call = this._wrapThrowIfError(this.call);
    this.poll = this.poll.bind(this);
    this.getTabId = this.getTabId.bind(this);

    // Initialize context-specific properties
    this._locus = env.getLocus();
    this._serialize = this._serialize.bind(this);
    this._handlers = {};

    // Context-specific initialization
    if (this._is("pp")) {
      this._setupPp();
      this._tabId = await this.getTabId();
    } else if (this._is("bg")) {
      this._blobs = {};
      // Use a consistent channel for BG<->OS blob marshalling
      this._channel = new BroadcastChannel("htos-bus-channel");
      this._setupBg();
    } else if (this._is("cs")) {
      await this._setupCs();
    } else if (this._is("nj")) {
      this._setupNj();
    } else if (this._is("os")) {
      // Offscreen context: we'll initialize iframe-related plumbing in _setupOs
      this._iframe = null;
      // Use the same channel as BG for blob marshalling
      this._channel = new BroadcastChannel("htos-bus-channel");
      this._setupOs();
    } else if (this._is("oi")) {
      this._setupOi();
    }
  },

  // =============================================================================
  // PUBLIC API METHODS
  // =============================================================================

  on(e, t, n = null) {
    this._on(e, null, t, n);
  },

  off(e, t = null) {
    this._off(e, null, t);
  },

  once(e, t) {
    const n = async (...a) => (this.off(e, n), await t(...a));
    this.on(e, n);
  },

  async send(e, ...n) {
    if (utils.is.numeric(e)) {
      const t = Number(e);
      return (
        (e = n[0]),
        (n = n.slice(1)),
        await this._pick([
          this._sendToCs(t, e, ...n),
          this._sendToExt(t, e, ...n),
        ])
      );
    }

    if (this._is("pp")) return await this._sendToExt(e, ...n);
    if (this._is("nj")) return await this._sendToPage(e, ...n);
    if (this._is("oi")) return await this._sendToParent(e, ...n);

    if (this._is("bg", "cs", "os"))
      return await this._pick([
        this._sendToExt(e, ...n),
        this._callHandlers(
          {
            name: e,
            args: n,
          },
          (e) => e.proxy,
        ),
      ]);

    if (this._is("fg")) {
      if (e === "store.actions") return;
      if (e === "idb.change") return;
      console.log("Bus log:", e, ...n);
    }
  },

  async call(e, ...t) {
    return this._callHandlers(
      {
        name: e,
        args: t,
      },
      (e) => !e.proxy,
    );
  },

  async poll(e, ...t) {
    return await utils.waitFor(() => this.send(e, ...t));
  },

  async getTabId() {
    if (this._is("bg")) return null;
    if (this._is("pp")) {
      const tabId = new URL(location.href).searchParams.get("tabId");
      if (tabId) return Number(tabId);
    }
    const { tabId: e } = await this.send("bus.getTabData");
    return e;
  },

  // =============================================================================
  // INTERNAL HANDLER MANAGEMENT
  // =============================================================================

  _on(e, t, n, a = null) {
    (this._handlers[e] || (this._handlers[e] = []),
      this._is("cs", "nj", "oi") &&
        this._handlers[e].length === 0 &&
        this._sendToProxier("bus.proxy", e, !0));

    const o = {
      fn: n,
      name: e,
    };
    (t && (o.proxy = t), a && (o.this = a), this._handlers[e].push(o));
  },

  _off(e, t = null, n = null) {
    if (!this._handlers[e]) return;

    this._handlers[e] = this._handlers[e].filter((e) => {
      const a = !n || n === e.fn,
        o = t === (e.proxy || null);
      return !a || !o;
    });

    if (this._handlers[e].length === 0) {
      delete this._handlers[e];
      if (this._is("cs", "nj", "oi")) {
        this._sendToProxier("bus.proxy", e, !1);
      }
    }
  },

  // =============================================================================
  // CONTEXT-SPECIFIC SETUP METHODS
  // =============================================================================

  _setupPp() {
    // Popup setup - minimal implementation
  },

  _setupBg() {
    // For blob handling with OS
    this._channel = new BroadcastChannel("htos-bus-channel");

    chrome.runtime.onMessage.addListener((e, t, n) => {
      if (!this._isBusMsg(e)) return false; // Do NOT keep the channel open for non-bus messages

      const a = t.tab?.id || null;

      if (e.name === "bus.proxy") {
        return void (async () => {
          const [t, n2] = await this._deserialize(e.argsStr);
          if (!a) return;
          const o = `cs-${a}`;
          n2
            ? this._on(t, o, (...e2) => this._sendToCs(a, t, ...e2))
            : this._off(t, o);
        })();
      }

      if (e.name === "bus.removeCsProxies") {
        // When a request arrives to remove content-script proxies, use the
        // sender's tab id (stored in `a`) to remove all handlers that were
        // registered with the proxy key `cs-<tabId>`.
        try {
          if (a) {
            this._removeProxyHandlers(`cs-${a}`);
          }
        } catch (err) {
          console.warn(
            "[BusController] Failed to remove CS proxies for tab:",
            a,
            err,
          );
        }
        return;
      }

      if (e.name === "bus.getTabData") {
        const windowId = t.tab?.windowId || null;
        return (
          n(
            this._serialize({
              tabId: a,
              windowId: windowId,
            }),
          ),
          !0
        );
      }

      if (e.name === "bus.sendToCs") {
        return (
          (async () => {
            const t2 = await this._deserialize(e.argsStr),
              a2 = await this._sendToCs(...t2);
            n(this._serialize(a2));
          })(),
          !0
        );
      }

      if (e.name === "bus.blobIdToObjectUrl") {
        return (
          (async () => {
            const [t3] = await this._deserialize(e.argsStr),
              a3 = await this._blobIdToObjectUrl(t3);
            n(this._serialize(a3));
          })(),
          !0
        );
      }

      const o = this._callHandlers(e, (e2) => e2.proxy !== `cs-${a}`);
      return o ? (o.then(this._serialize).then(n), !0) : undefined;
    });

    chrome.tabs.onRemoved.addListener((e) => {
      this._removeProxyHandlers(`cs-${e}`);
    });
  },

  async _setupCs() {
    // Content script setup - minimal implementation
  },

  _setupNj() {
    // Injected script setup - minimal implementation
  },

  _setupOs() {
    console.log("[BusController] Setting up Offscreen (os) listeners.");

    // --- START OF FIX ---
    // Create a promise that will resolve when the iframe is ready so incoming messages
    // from the service worker won't be dropped if they arrive before the iframe is attached.
    let resolveIframeReady;
    this._iframeReadyPromise = new Promise((resolve) => {
      resolveIframeReady = resolve;
    });

    // Provide a setter that other code (e.g., OffscreenBootstrap) should call when
    // it creates/attaches the iframe. This resolves the ready promise.
    this.setIframe = (iframe) => {
      this._iframe = iframe;
      console.log("[BusController-os] Iframe has been set and is now ready.");
      try {
        resolveIframeReady(iframe);
      } catch (e) {
        console.warn(
          "[BusController-os] iframeReady promise already resolved or errored",
          e,
        );
      }
    };
    // --- END OF FIX ---

    // A map to store the sendResponse functions for requests pending a reply from the iframe.
    const pendingIframeResponses = new Map();

    // LISTENER 1: Receives messages from the child iframe (oi.js)
    // This listener is set up ONCE.
    window.addEventListener("message", async (event) => {
      // Only accept messages from our child iframe
      if (event.source !== this._iframe?.contentWindow) return;

      const msg = event.data;

      // 1) Handle iframe replies first (no $bus/appName required)
      if (msg && msg.resId && pendingIframeResponses.has(msg.resId)) {
        console.log(
          "[BusController-os] Received response from iframe for reqId:",
          msg.resId,
        );
        const sendResponse = pendingIframeResponses.get(msg.resId);
        try {
          const serialized = this._serialize(msg.result);
          sendResponse(serialized);
        } catch (e) {
          console.warn(
            "[BusController-os] Failed to send serialized response to SW:",
            e,
          );
        } finally {
          pendingIframeResponses.delete(msg.resId);
        }
        return;
      }

      // 2) Handle new bus messages from iframe
      if (!this._isBusMsg(msg)) return;

      // Helper to respond back to the iframe requestor
      const respondToIframe = (m, result = null) => {
        if (!m?.reqId) return;
        try {
          this._iframe?.contentWindow?.postMessage(
            { resId: m.reqId, result },
            "*",
          );
        } catch (e) {
          console.warn(
            "[BusController-os] Failed posting response to iframe:",
            e,
          );
        }
      };

      // Special proxy registration coming from the iframe
      if (msg.name === "bus.proxy") {
        try {
          const [eventName, enable] = msg.args || [];
          if (enable) {
            this._on(eventName, "oi", (...args) =>
              this._sendToIframe(eventName, ...args),
            );
          } else {
            this._off(eventName, "oi");
          }
          respondToIframe(msg, true);
        } catch (e) {
          console.warn(
            "[BusController-os] Failed handling bus.proxy from iframe:",
            e,
          );
          respondToIframe(msg, false);
        }
        return;
      }

      try {
        // Route to SW and/or local non-proxy handlers; pick the first non-null result
        const result = await this._pick([
          this._sendToExt(msg.name, ...(msg.args || [])),
          this._callHandlers(msg, (h) => !h.proxy),
        ]);
        respondToIframe(msg, result);
      } catch (e) {
        console.error(
          "[BusController-os] Error while forwarding iframe message:",
          e,
        );
        respondToIframe(msg, null);
      }
    });

    // LISTENER 2: Receives messages from the Service Worker (and other contexts)
    // This listener is also set up ONCE.
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      if (!this._isBusMsg(message)) return false; // Ignore non-bus messages (do not keep channel open)

      // This is a message that needs to be forwarded DOWN to the child iframe.
      // Use an async IIFE so we can await the iframe becoming available if needed.
      (async () => {
        try {
          // Await iframe readiness; if it's already ready this resolves immediately.
          const iframe = await this._iframeReadyPromise;

          console.log(
            "[BusController-os] Iframe is ready, forwarding message from SW:",
            message.name,
          );

          // Generate a unique ID to track the response for this specific request.
          const requestId = this._generateId();

          // Store the sendResponse function so the other listener can call it when the reply arrives.
          pendingIframeResponses.set(requestId, sendResponse);

          // Prepare args: prefer structured args, otherwise deserialize argsStr
          let args = [];
          try {
            if (Array.isArray(message.args)) {
              args = message.args;
            } else if (typeof message.argsStr === "string") {
              const des = await this._deserialize(message.argsStr);
              if (Array.isArray(des)) args = des;
              else if (des == null) args = [];
              else args = [des];
            }
          } catch (e) {
            console.warn(
              "[BusController-os] Failed to deserialize argsStr; falling back to empty args",
              e,
            );
            args = [];
          }

          // Send a well-formed bus message to iframe; raw result expected back, which we will serialize before replying.
          const busMsg = this._createBusMsg({
            name: message.name,
            args,
            reqId: requestId,
          });
          iframe.contentWindow.postMessage(busMsg, "*");
        } catch (error) {
          console.error(
            "[BusController-os] Failed to forward message to iframe:",
            error,
          );
          try {
            sendResponse(
              this._serialize({
                error: "Failed to communicate with the offscreen iframe.",
              }),
            );
          } catch (_) {}
        }
      })();

      return true; // Keep the message channel open for the async response.
    });

    // LISTENER 3: Blob marshalling between BG and OS via BroadcastChannel
    this._channel.addEventListener("message", ({ data }) => {
      try {
        if (!data || !data.reqId) return;
        const { blob, reqId } = data;
        const objectUrl = utils.objectUrl.create(blob, true);
        this._channel.postMessage({ resId: reqId, objectUrl });
      } catch (e) {
        console.warn(
          "[BusController-os] Failed handling blob marshalling message:",
          e,
        );
      }
    });
  },

  _setupOi() {
    console.log(
      "[BusController] Setting up Offscreen Iframe (oi/oi) listeners.",
    );

    // Listen for messages from the parent window (os.js)
    window.addEventListener("message", async (event) => {
      // We only care about bus messages from our direct parent
      if (!this._isBusMsg(event.data) || event.source !== window.parent) return;

      const message = event.data;
      console.log(
        "[BusController-oi] Received message from parent:",
        message.name,
      );

      // Handle the message using the generic handler
      const result = await this._callHandlers(message);

      // If the message had a request ID, send a formatted response back to the parent
      if (message.reqId && window.parent) {
        // HTOS parity: reply with raw result and resId matching reqId
        window.parent.postMessage(
          {
            resId: message.reqId,
            result: result,
          },
          "*",
        );
      }
    });
  },

  // =============================================================================
  // MESSAGE TRANSPORT METHODS
  // =============================================================================

  async _sendToExt(e, ...n) {
    let o = null;
    utils.is.numeric(e) && ((o = Number(e)), (e = n[0]), (n = n.slice(1)));

    const i = this._serialize(n),
      r = this._createBusMsg({
        name: e,
        argsStr: i,
        target: o,
      }),
      s = await new Promise((e) => {
        try {
          chrome.runtime.sendMessage(r, (t) => {
            chrome.runtime.lastError ? e(null) : e(t);
          });
        } catch (n) {
          if (n.message === "Extension context invalidated.") return;
          console.error("Bus error:", n);
          e(null);
        }
      });

    return await this._deserialize(s);
  },

  async _sendToCs(e, t, ...n) {
    if (!chrome.tabs?.sendMessage)
      return await this.send("bus.sendToCs", e, t, ...n);

    const a = this._serialize(n),
      o = this._createBusMsg({
        name: t,
        argsStr: a,
        target: "cs",
      }),
      i = await new Promise((t) => {
        chrome.tabs.sendMessage(e, o, (e) => {
          chrome.runtime.lastError ? t(null) : t(e);
        });
      });

    return await this._deserialize(i);
  },

  async _sendToPage(e, ...t) {
    const n = this._generateId(),
      a = this._createBusMsg({
        name: e,
        args: t,
        reqId: n,
        locus: this._locus,
      });

    return (window.postMessage(a, "*"), await this._waitForResponseMessage(n));
  },

  async _sendToIframe(e, ...t) {
    if (!this._iframe) return null;

    const n = this._generateId(),
      a = this._createBusMsg({
        name: e,
        args: t,
        reqId: n,
      });

    return (
      console.log("[BusController Debug] posting to iframe", {
        reqId: n,
        name: e,
        ts: Date.now(),
      }),
      this._iframe.contentWindow.postMessage(a, "*"),
      await this._waitForResponseMessage(n)
    );
  },

  async _sendToParent(e, ...t) {
    const n = this._generateId(),
      a = this._createBusMsg({
        name: e,
        args: t,
        reqId: n,
      });

    return (parent.postMessage(a, "*"), await this._waitForResponseMessage(n));
  },

  async _sendToProxier(e, ...t) {
    return this._is("cs")
      ? await this._sendToExt(e, ...t)
      : this._is("nj")
        ? await this._sendToPage(e, ...t)
        : this._is("oi")
          ? await this._sendToParent(e, ...t)
          : undefined;
  },

  // =============================================================================
  // SERIALIZATION & BLOB HANDLING
  // =============================================================================

  _serialize(e) {
    return utils.is.nil(e)
      ? null
      : JSON.stringify(e, (e, t) => {
          if (utils.is.blob(t)) {
            if (this._is("bg")) {
              const newId = this._generateId();
              return ((this._blobs[newId] = t), `bus.blob.${newId}`);
            }
            return `bus.blob.${utils.objectUrl.create(t, !0)}`;
          }
          return utils.is.error(t) ? `bus.error.${t.message}` : t;
        });
  },

  async _deserialize(e) {
    if (!utils.is.string(e)) return null;

    const t = new Map(),
      n = JSON.parse(e, (e, n) => {
        const o = utils.is.string(n);
        return o && n.startsWith("bus.blob.")
          ? (t.set(n, n.slice("bus.blob.".length)), n)
          : o && n.startsWith("bus.error.")
            ? new Error(n.slice("bus.error.".length))
            : n;
      });

    await Promise.all(
      [...t.keys()].map(async (e) => {
        let n;
        const a = t.get(e);
        n = a.startsWith("blob:")
          ? a
          : await this._sendToExt("bus.blobIdToObjectUrl", a);
        const o = await fetch(n).then((e) => e.blob());
        t.set(e, o);
      }),
    );

    return this._applyBlobs(n, t);
  },

  _applyBlobs(e, t) {
    if (t.has(e)) return t.get(e);
    if (utils.is.array(e) || utils.is.object(e))
      for (const n in e) e[n] = this._applyBlobs(e[n], t);
    return e;
  },

  async _blobIdToObjectUrl(e) {
    const t = this._blobs[e];
    let n;

    if (utils.is.string(t)) {
      n = t;
    } else {
      n = await this._blobToObjectUrl(t);
      this._blobs[e] = n;
    }

    setTimeout(() => delete this._blobs[e], 60000);
    return n;
  },

  async _blobToObjectUrl(e) {
    const t = this._generateId();

    this._channel.postMessage({
      reqId: t,
      blob: e,
    });

    return await new Promise((e) => {
      const n = ({ data: a }) => {
        if (!a || a.resId !== t) return;
        this._channel.removeEventListener("message", n);
        e(a.objectUrl);
      };
      this._channel.addEventListener("message", n);
    });
  },

  // =============================================================================
  // UTILITY METHODS
  // =============================================================================

  _waitForResponseMessage: async (e) =>
    await new Promise((t) => {
      const n = ({ data: a }) => {
        if (!a || a.resId !== e) return;
        window.removeEventListener("message", n);
        t(a.result);
      };
      window.addEventListener("message", n);
    }),

  _callHandlers({ name: e, args: n, argsStr: a }, o = null) {
    let i = this._handlers[e];
    if (!i) return null;

    if (o) {
      i = i.filter(o);
    }

    if (i.length === 0) return null;

    return new Promise(async (e) => {
      if (a) {
        n = await this._deserialize(a);
      }

      e(
        await this._pick(
          i.map(async (e) => {
            try {
              return await e.fn.call(e.this, ...n);
            } catch (n) {
              console.error(`Failed to handle "${e.name}":`, n);
              return n;
            }
          }),
        ),
      );
    });
  },

  _removeProxyHandlers(e) {
    Object.keys(this._handlers).forEach((t) => {
      this._handlers[t] = this._handlers[t].filter((t) => t.proxy !== e);
      if (this._handlers[t].length === 0) {
        delete this._handlers[t];
      }
    });
  },

  _is(...e) {
    return e.includes(this._locus);
  },

  _isBusMsg: (t) =>
    !!t &&
    !!t.$bus &&
    (t.appName === data.name || t.appName === "__htos_global"),
  _createBusMsg: (t) => ({
    $bus: !0,
    appName: data.name,
    ...t,
  }),

  _generateId: () => `bus-${Date.now()}-${Math.random().toString(36).slice(2)}`,

  _wrapThrowIfError(e) {
    return async (...t) => {
      const n = await e.call(this, ...t);
      if (utils.is.error(n)) throw n;
      return n;
    };
  },

  _pick: async (e = []) =>
    e.length === 0
      ? null
      : await new Promise((t) => {
          let n = 0;
          e.forEach(async (o) => {
            const i = await o;
            return utils.is.nil(i)
              ? n === e.length - 1
                ? t(null)
                : void n++
              : t(i);
          });
        }),
};

// =============================================================================
// EXPORT
// =============================================================================

// For ES6 modules
export { BusController, utils, env };

// For global browser usage
if (typeof window !== "undefined") {
  window.HTOSBusController = BusController;
  window.HTOSBusUtils = utils;
  window.HTOSEnv = env;
}



================================================
FILE: src/HTOS/NetRulesManager.js
================================================
/**
 * HTOS NetRulesManager - Complete Implementation
 * Extracted from bg.refactored.non.stripped.js for standalone integration
 *
 * This module provides network rule management for Chrome extension using Declarative Net Request API,
 * supporting CSP modification, header manipulation, and tab-specific rules cleanup.
 */

import { DNRUtils } from "../core/dnr-utils.js";

// =============================================================================
// UTILITY DEPENDENCIES
// =============================================================================

const utils = {
  // Type checking utilities
  is: {
    null: (e) => e === null,
    defined: (e) => undefined !== e,
    undefined: (e) => undefined === e,
    nil: (e) => e == null,
    boolean: (e) => typeof e == "boolean",
    number: (e) => typeof e == "number",
    string: (e) => typeof e == "string",
    symbol: (e) => typeof e == "symbol",
    function: (e) => typeof e == "function",
    array: (e) => Array.isArray(e),
    object: (e) => Object.prototype.toString.call(e) === "[object Object]",
    error: (e) => e instanceof Error,
    empty: (e) =>
      !!utils.is.nil(e) ||
      (utils.is.array(e)
        ? e.length === 0
        : utils.is.object(e)
          ? Object.keys(e).length === 0
          : !!utils.is.string(e) && e.trim().length === 0),
  },

  // Array utility for ensuring array type
  ensureArray: (e) => (Array.isArray(e) ? e : [e]),

  // Chrome alarms utility
  chrome: {
    alarms: {
      run: (e, t = {}) => {
        // Check if chrome.alarms API is available
        if (!chrome.alarms || !chrome.alarms.onAlarm) {
          console.warn(
            "[htos] chrome.alarms API not available, skipping alarm setup",
          );
          if (t.immediately) e();
          return null;
        }
        const a = {
          name: t.name || utils.generateId(),
          once: t.once || !1,
          immediately: t.immediately || !1,
          delayInMinutes: t.delayInMinutes || 1,
          periodInMinutes: t.once ? null : t.periodInMinutes || 1,
          listener: (t) => {
            t.name === a.name &&
              (a.once &&
                (chrome.alarms.onAlarm.removeListener(a.listener),
                chrome.alarms.clear(a.name)),
              e());
          },
        };
        return (
          chrome.alarms.onAlarm.addListener(a.listener),
          chrome.alarms.create(a.name, {
            delayInMinutes: a.delayInMinutes,
            periodInMinutes: a.periodInMinutes,
          }),
          a.immediately && e(),
          a
        );
      },
      off: (e) => {
        if (!chrome.alarms || !chrome.alarms.onAlarm) return;
        e &&
          (typeof e == "string"
            ? chrome.alarms.clear(e)
            : (chrome.alarms.onAlarm.removeListener(e.listener),
              chrome.alarms.clear(e.name)));
      },
    },
  },

  // Time constants
  time: {
    MINUTE: 60000,
    HOUR: 3600000,
  },

  // ID generator utility
  generateId: () => `htos-${Date.now()}-${Math.random().toString(36).slice(2)}`,
};

// =============================================================================
// MOCK DATA CONTEXT
// =============================================================================

const data = {
  name: "htos", // Updated from 'HTOS1'
};

// =============================================================================
// NET RULES MANAGER IMPLEMENTATION
// =============================================================================

const NetRulesManager = {
  async init() {
    // Bind public API methods (these are already the correct implementations)
    this.register = this.register.bind(this);
    this.unregister = this.unregister.bind(this);

    // Initialize internal state
    this._lastRuleId = 1;
    this._rules = [];

    // Drop all existing session rules to start clean
    await this._dropAllSessionRules();

    // Start periodic cleanup for tab-specific rules
    this._cleanupTabRulesPeriodically();
  },

  // =============================================================================
  // PUBLIC API METHODS
  // =============================================================================

  /**
   * Register one or more network rules
   * @param {Object|Array} e - Rule or array of rules to register
   * @returns {String|Array} - Rule key(s) for unregistration
   */
  async register(e) {
    const isArray = Array.isArray(e);

    // Normalize to array and assign IDs
    e = utils.ensureArray(e).map((e) => {
      const ruleId = this._lastRuleId;
      this._lastRuleId += 1;

      return {
        id: ruleId,
        priority: 1,
        ...e,
        key: e.key || String(ruleId),
        condition: {
          resourceTypes: [
            "main_frame",
            "sub_frame",
            "stylesheet",
            "script",
            "image",
            "font",
            "object",
            "xmlhttprequest",
            "ping",
            "csp_report",
            "media",
            "websocket",
            "webtransport",
            "webbundle",
            "other",
          ],
          ...e.condition,
        },
      };
    });

    // Remove duplicates by key (keep last occurrence)
    e = e.filter(
      (rule, index) => index === e.findLastIndex((r) => r.key === rule.key),
    );

    // Find existing rules with same keys to replace
    const existingKeys =
      this._rules.length > 0 ? new Set(e.map((rule) => rule.key)) : null;
    const rulesToRemove = this._rules
      .filter((rule) => existingKeys && existingKeys.has(rule.key))
      .map((rule) => rule.id);

    // Track new rules for cleanup
    this._rules.push(
      ...e.map((rule) => ({
        id: rule.id,
        key: rule.key,
        tabIds: rule.condition.tabIds || null,
      })),
    );

    const ruleKeys = e.map((rule) => rule.key);

    // Remove key from rules before sending to API (not supported by declarativeNetRequest)
    e.forEach((rule) => delete rule.key);

    // Update Chrome declarative net request rules
    await chrome.declarativeNetRequest.updateSessionRules({
      addRules: e,
    });

    // Remove replaced rules
    await this._unregisterByIds(rulesToRemove);

    return isArray ? ruleKeys : ruleKeys[0];
  },

  /**
   * Unregister rules by their keys
   * @param {String|Array} e - Rule key(s) to unregister
   */
  async unregister(e) {
    const keys = utils.ensureArray(e);
    if (keys.length === 0) return;

    const ruleIds = this._rules
      .filter((rule) => keys.includes(rule.key))
      .map((rule) => rule.id);

    await this._unregisterByIds(ruleIds);
  },

  // =============================================================================
  // INTERNAL METHODS
  // =============================================================================

  /**
   * Unregister rules by their internal IDs
   * @param {Array} ruleIds - Array of rule IDs to remove
   */
  async _unregisterByIds(ruleIds) {
    if (ruleIds.length === 0) return;

    // Remove from internal tracking
    this._rules = this._rules.filter((rule) => !ruleIds.includes(rule.id));

    // Remove from Chrome
    await chrome.declarativeNetRequest.updateSessionRules({
      removeRuleIds: ruleIds,
    });
  },

  /**
   * Drop all existing session rules (cleanup on init)
   */
  async _dropAllSessionRules() {
    const sessionRules = await chrome.declarativeNetRequest.getSessionRules();

    if (sessionRules.length !== 0) {
      await chrome.declarativeNetRequest.updateSessionRules({
        removeRuleIds: sessionRules.map((rule) => rule.id),
      });
    }
  },

  /**
   * Set up periodic cleanup of tab-specific rules
   */
  _cleanupTabRulesPeriodically() {
    utils.chrome.alarms.run(this._cleanUpTabRules.bind(this), {
      name: "netRules.cleanupTabRules",
      periodInMinutes: 5,
    });
  },

  /**
   * Clean up rules for tabs that no longer exist
   */
  async _cleanUpTabRules() {
    const rulesToRemove = [];

    // Check each rule with tab restrictions
    for (const rule of this._rules) {
      if (!rule.tabIds) continue;

      let hasValidTab = false;

      for (const tabId of rule.tabIds) {
        if (!tabId) continue;
        if (tabId === -1) {
          // keep rule if applies to all tabs
          hasValidTab = true;
          break;
        }

        try {
          await chrome.tabs.get(tabId);
          hasValidTab = true;
          break;
        } catch (error) {
          // Tab doesn't exist, continue checking other tabs
        }
      }

      if (!hasValidTab) {
        rulesToRemove.push(rule.id);
      }
    }

    await this._unregisterByIds(rulesToRemove);
  },
};

// =============================================================================
// CSP CONTROLLER - Manages Content Security Policy rules
// =============================================================================

const CSPController = {
  init() {
    this._ruleIds = [];
    this._updateNetRules();
    // Note: In a real implementation, this would react to settings changes
    // this._updateNetRulesWhenCspSettingsChange();
  },

  /**
   * Update network rules based on CSP settings
   * This is a simplified version - in the full implementation it would read from shared state
   */
  async _updateNetRules() {
    // Unregister existing rules
    await NetRulesManager.unregister(this._ruleIds);
    this._ruleIds = [];

    const removeCspHeaderAction = {
      type: "modifyHeaders",
      responseHeaders: [
        {
          header: "content-security-policy",
          operation: "remove",
        },
      ],
    };

    // Example CSP rule - in real implementation this would be configurable
    const cspRules = [
      {
        condition: {
          urlFilter: null, // Apply to all URLs
        },
        action: removeCspHeaderAction,
      },
    ];

    const ruleKeys = await NetRulesManager.register(cspRules);
    this._ruleIds.push(...utils.ensureArray(ruleKeys));
  },
};

// =============================================================================
// USER AGENT CONTROLLER - Manages User-Agent header rules
// =============================================================================

const UserAgentController = {
  async init() {
    const userAgentRules = this._createUaRules();
    const langRules = this._createLangRules();
    await NetRulesManager.register([...userAgentRules, ...langRules]);
  },

  /**
   * Create user agent modification rules
   */
  _createUaRules() {
    const createUrlFilter = (agent) => `*://*/*_vua=${agent}*`;

    // Example user agents - in real implementation this would come from configuration
    const userAgents = {
      desktop:
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
      mobile:
        "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
    };

    return Object.keys(userAgents)
      .filter((key) => key !== "auto")
      .map((key) => ({
        condition: {
          urlFilter: createUrlFilter(key),
          resourceTypes: ["main_frame", "sub_frame"],
        },
        action: {
          type: "modifyHeaders",
          requestHeaders: [
            {
              header: "user-agent",
              operation: "set",
              value: userAgents[key],
            },
          ],
        },
      }));
  },

  /**
   * Create language header modification rules
   */
  _createLangRules() {
    const createLangUrlFilter = (lang) => `*://*/*_vlang=${lang}*`;

    const formatLanguage = (lang) =>
      lang.includes("_")
        ? `${lang.replace("_", "-")},${lang.slice(0, lang.indexOf("_"))};q=0.9`
        : `${lang};q=0.9`;

    // Example languages - in real implementation this would come from configuration
    const languages = {
      en: "en",
      es: "es",
      fr: "fr",
      de: "de",
      en_US: "en_US",
    };

    return Object.keys(languages)
      .filter((key) => key !== "auto")
      .map((key) => ({
        condition: {
          urlFilter: createLangUrlFilter(key),
          resourceTypes: ["main_frame", "sub_frame"],
        },
        action: {
          type: "modifyHeaders",
          requestHeaders: [
            {
              header: "accept-language",
              operation: "set",
              value: formatLanguage(languages[key]),
            },
          ],
        },
      }));
  },
};

// =============================================================================
// ARKOSE CONTROLLER - Manages iframe anti-framing bypass
// =============================================================================

const ArkoseController = {
  async init() {
    // Initialize DNRUtils
    await DNRUtils.initialize();

    // Example iframe URL - in real implementation this would be configurable
    this._iframeUrl = "https://tcr9i.chat.openai.com";
    await this._allowArkoseIframe();
  },

  /**
   * Allow iframe by removing frame-blocking headers
   */
  async _allowArkoseIframe() {
    if (!this._iframeUrl) return;

    await NetRulesManager.register({
      condition: {
        urlFilter: `${this._iframeUrl}*`,
      },
      action: {
        type: "modifyHeaders",
        responseHeaders: [
          {
            header: "content-security-policy",
            operation: "remove",
          },
          {
            header: "permissions-policy",
            operation: "remove",
          },
        ],
      },
    });
  },

  /**
   * Inject AE (Arkose Enforcement) headers using DNRUtils
   * @param {Object} options - Header injection options
   * @param {number} options.tabId - Tab ID for scoped injection
   * @param {string} options.urlFilter - URL pattern to match
   * @param {string} options.headerName - Header name to inject
   * @param {string} options.headerValue - Header value to inject
   * @param {number} options.durationMs - Duration in milliseconds (optional)
   * @returns {Promise<number>} Rule ID
   */
  async injectAEHeaders({
    tabId,
    urlFilter,
    headerName,
    headerValue,
    durationMs,
  }) {
    try {
      const ruleId = await DNRUtils.registerHeaderRule({
        tabId,
        urlFilter,
        resourceTypes: [
          chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST,
        ],
        headerName,
        headerValue,
        operation: "set",
        providerId: "arkose",
        durationMs,
      });

      console.debug(
        `ArkoseController: Injected AE header ${headerName} for tab ${tabId}`,
      );
      return ruleId;
    } catch (error) {
      console.error("ArkoseController: Failed to inject AE headers:", error);
      throw error;
    }
  },

  /**
   * Remove AE header rule by ID
   * @param {number} ruleId - Rule ID to remove
   */
  async removeAEHeaderRule(ruleId) {
    try {
      await DNRUtils.removeRule(ruleId);
      console.debug(`ArkoseController: Removed AE header rule ${ruleId}`);
    } catch (error) {
      console.error(
        "ArkoseController: Failed to remove AE header rule:",
        error,
      );
      throw error;
    }
  },

  /**
   * Remove all AE header rules for arkose provider
   */
  async removeAllAEHeaderRules() {
    try {
      await DNRUtils.removeProviderRules("arkose");
      console.debug("ArkoseController: Removed all AE header rules");
    } catch (error) {
      console.error(
        "ArkoseController: Failed to remove all AE header rules:",
        error,
      );
      throw error;
    }
  },
};

// =============================================================================
// EXPORT
// =============================================================================

// For ES6 modules
export {
  NetRulesManager,
  CSPController,
  UserAgentController,
  ArkoseController,
  utils,
};

// For global browser usage
if (typeof window !== "undefined") {
  window.HTOSNetRulesManager = NetRulesManager;
  window.HTOSCSPController = CSPController;
  window.HTOSUserAgentController = UserAgentController;
  window.HTOSArkoseController = ArkoseController;
  window.HTOSNetRulesUtils = utils;
}



================================================
FILE: src/HTOS/OffscreenBootstrap.js
================================================
/**
 * HTOS Offscreen Bootstrap - Multi-purpose Utility Host
 *
 * This script runs inside the offscreen.html document. Its primary role for the
 * Arkose solver is to manage the oi.html iframe. It also hosts a UtilsController
 * that can be called by the service worker for tasks requiring localStorage access.
 *
 * This file is a pure module; it is initialized by offscreen-entry.js.
 */

// =============================================================================
// DEPENDENCIES
// =============================================================================

import { BusController } from "./BusController.js";

// =============================================================================
// IFRAME LIFECYCLE CONTROLLER (Essential for Arkose Solver)
// =============================================================================

const IframeController = {
  async init() {
    console.log("[OffscreenBootstrap] Initializing IframeController...");

    // Load the oi page from localhost for development (web origin like reference)
    this._src = chrome.runtime.getURL("oi.html");
    this._iframe = null;
    this._pingInterval = null;

    // Create the iframe and start the stability management loop
    this._createIframe();
    this._manageIframeStability();

    console.log(
      "[OffscreenBootstrap] IframeController initialized and is being monitored.",
    );
  },

  _createIframe() {
    console.log("[OffscreenBootstrap] Creating new oi.html iframe...");
    const iframe = document.createElement("iframe");
    iframe.style.display = "none";
    iframe.src = this._src;
    // Pass the extension oi.js URL to the oi host via window.name (like reference)
    try {
      iframe.name = `offscreen-iframe | ${chrome.runtime.getURL("oi.js")}`;
    } catch (_) {}

    // Append iframe to the document and register it immediately with the bus.
    // Simpler, robust flow: do not wait for a custom "oi.initialized" postMessage
    // (the iframe's own bus handler startup.oiReady will respond to polls when ready).
    document.body.appendChild(iframe);
    this._iframe = iframe;

    // Register this iframe with the bus so it knows where to forward messages
    if (window.bus && typeof window.bus.setIframe === "function") {
      try {
        window.bus.setIframe(iframe);
        console.log(
          "[OffscreenBootstrap] setIframe called immediately after append",
        );
      } catch (e) {
        console.warn("[OffscreenBootstrap] Immediate setIframe failed:", e);
      }
    }

    return iframe;
  },

  _manageIframeStability() {
    // This is the self-healing mechanism. It periodically checks if the iframe
    // is alive and restarts it if it becomes unresponsive.
    this._pingInterval = setInterval(async () => {
      const isResponsive = await this._pingIframe();
      if (!isResponsive) {
        console.warn(
          "[OffscreenBootstrap] Iframe is not responsive, triggering restart...",
        );
        await this._restartIframe();
      } else {
        console.log("[OffscreenBootstrap] Iframe health check passed.");
      }
    }, 300000); // Ping every 5 minutes
  },

  async _pingIframe() {
    // Align with reference implementation: rely on the bus poll for startup.oiReady
    // and treat any non-response within 5s as not-ready.
    const timeoutMs = 5000;
    try {
      if (!window.bus || typeof window.bus.poll !== "function") {
        console.warn("[OffscreenBootstrap] Bus is not available for polling.");
        return false;
      }

      const ok = await Promise.race([
        window.bus
          .poll("startup.oiReady")
          .then(() => true)
          .catch(() => false),
        new Promise((resolve) => setTimeout(() => resolve(false), timeoutMs)),
      ]);

      return !!ok;
    } catch (e) {
      console.error("[OffscreenBootstrap] _pingIframe unexpected error:", e);
      return false;
    }
  },

  async _restartIframe() {
    try {
      console.log("[OffscreenBootstrap] Restarting iframe...");
      if (this._iframe && this._iframe.parentNode) {
        this._iframe.parentNode.removeChild(this._iframe);
      }
      await new Promise((resolve) => setTimeout(resolve, 250));
      this._createIframe();
      console.log("[OffscreenBootstrap] Iframe has been restarted.");
    } catch (error) {
      console.error("[OffscreenBootstrap] Failed to restart iframe:", error);
    }
  },
};

// =============================================================================
// GENERAL UTILITY CONTROLLER (Provides localStorage access to Service Worker)
// =============================================================================

const UtilsController = {
  async init() {
    console.log("[OffscreenBootstrap] Initializing UtilsController...");
    if (window.bus) {
      // Listen for requests from the service worker and proxy them to localStorage
      window.bus.on("utils.ls.get", this._localStorageGet.bind(this));
      window.bus.on("utils.ls.set", this._localStorageSet.bind(this));
      window.bus.on("utils.ls.has", this._localStorageHas.bind(this));
      window.bus.on("utils.ls.remove", this._localStorageRemove.bind(this));
    }
  },

  _localStorageGet(key) {
    try {
      const value = localStorage.getItem(key);
      return value ? JSON.parse(value) : null;
    } catch (e) {
      console.warn(
        "[UtilsController] Failed to get/parse localStorage key:",
        key,
      );
      return null;
    }
  },

  _localStorageSet(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch (e) {
      console.error(
        "[UtilsController] Failed to set localStorage key:",
        key,
        e,
      );
      return false;
    }
  },

  _localStorageHas(key) {
    try {
      return localStorage.getItem(key) !== null;
    } catch (e) {
      console.warn("[UtilsController] Failed to check localStorage key:", key);
      return false;
    }
  },

  _localStorageRemove(key) {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (e) {
      console.error(
        "[UtilsController] Failed to remove localStorage key:",
        key,
        e,
      );
      return false;
    }
  },
};

// =============================================================================
// MAIN BOOTSTRAP CONTROLLER
// =============================================================================

const OffscreenBootstrap = {
  // Bus discovery shim - probes multiple global names for tolerant discovery
  _discoverBus() {
    const candidates = [
      { name: "BusController", ref: window.BusController },
      { name: "HTOSBusController", ref: window.HTOSBusController },
      { name: "__htos_global.$bus", ref: window.__htos_global?.$bus },
      { name: "window.bus", ref: window.bus },
    ];

    for (const candidate of candidates) {
      if (candidate.ref && typeof candidate.ref.init === "function") {
        console.log(
          `[OffscreenBootstrap] Bus discovery: using ${candidate.name}`,
        );
        return candidate.ref;
      }
    }

    console.warn(
      "[OffscreenBootstrap] Bus discovery: no suitable bus controller found, falling back to BusController",
    );
    return BusController;
  },

  async init() {
    console.log(
      "[OffscreenBootstrap] Starting initialization inside offscreen.html...",
    );

    try {
      // 1. Initialize Bus Controller first with discovery.
      console.log("[OffscreenBootstrap] Initializing BusController...");
      const busController = this._discoverBus();
      await busController.init();
      window.bus = busController;
      console.log(
        "[OffscreenBootstrap] BusController initialized and available as window.bus",
      );

      // 2. Initialize all necessary controllers.
      console.log(
        "[OffscreenBootstrap] Initializing specialized controllers...",
      );
      await Promise.all([IframeController.init(), UtilsController.init()]);
      console.log(
        "[OffscreenBootstrap] All specialized controllers initialized successfully",
      );

      console.log(
        "[OffscreenBootstrap] Initialization completed successfully.",
      );
    } catch (error) {
      console.error("[OffscreenBootstrap] Initialization failed:", error);
      throw error; // Re-throw the error for the entry point's catch block
    }
  },
};

// =============================================================================
// EXPORT
// =============================================================================

// Export the main bootstrap object so offscreen-entry.js can import and run it.
export { OffscreenBootstrap };



================================================
FILE: src/persistence/Readme.md
================================================
## A. Persistence Layer Deep Dive

**Purpose:** This document defines the persistent truth of the system: what we store, how we store it, and why. It documents the schema, indices, transactional patterns, and key invariants that enable the system's core features like `extend` and `recompute`.

**Scope:** The persistence layer is responsible for three primary tasks:

1.  **Append-only History:** All provider responses are stored immutably.
2.  **Live Continuation:** A separate, fast-lookup store holds the "live" metadata needed to continue a conversation.
3.  **Timeline Integrity:** The layer maintains pointers and counts to ensure the main conversational timeline is always consistent.

### Core Schema (IndexedDB)

The database (`OpusDeusDB`) is comprised of several key object stores.

#### 1. `sessions` (SessionRecord)

Holds high-level metadata for an entire conversation.

- **Fields:**
  - `id` (string): Primary Key
  - `title` (string)
  - `createdAt` (number)
  - `updatedAt` (number)
  - `lastTurnId` (string | null): Pointer to the `id` of the latest `AiTurnRecord` on the _main timeline_. This is critical for `extend` context lookups.
  - `turnCount` (number)
- **Truth:** `lastTurnId` is the single source of truth for identifying the "end" of a conversation's main branch.

#### 2. `turns` (TurnRecord = UserTurnRecord | AiTurnRecord)

Stores the record of each user prompt and the AI's response metadata.

- **`UserTurnRecord` Fields:** `id`, `type: 'user'`, `sessionId`, `threadId`, `createdAt`, `text`, `sequence`.
- **`AiTurnRecord` Fields:**
  - `id` (string): Primary Key
  - `type: 'ai'`, `role: 'assistant'`
  - `sessionId` (string)
  - `userTurnId` (string): Foreign key to the `UserTurnRecord` that triggered this.
  - `threadId` (string), `sequence` (number)
  - `createdAt` (number), `updatedAt` (number)
  - **`batchResponseCount` (number)**
  - **`synthesisResponseCount` (number)**
  - **`mappingResponseCount` (number)**
  - **`providerContexts` (Record<string, any> | null)**: A _snapshot_ of provider metadata (e.g., `conversationId`) at the moment this turn was finalized. This is essential for the `recompute` primitive.
- **Truth:** This record **does not** contain the text of AI responses. It only stores _counts_ and the _historical snapshot_ of contexts. The full response data lives in `provider_responses`.

#### 3. `provider_responses` (ProviderResponseRecord)

An append-only log of every individual response from every provider, for every step.

- **Fields:**
  - `id` (string): Primary Key
  - `sessionId` (string)
  - **`aiTurnId` (string)**: Foreign key to the `AiTurnRecord`. This is the primary lookup index.
  - `providerId` (string)
  - **`responseType` ('batch' | 'synthesis' | 'mapping')**: The workflow step that generated this response.
  - `responseIndex` (number): Order of response for a given `aiTurnId` + `providerId` + `responseType` (e.g., for multiple recomputes).
  - `text` (string)
  - `status` (string: 'completed', 'error', etc.)
  - `createdAt` (number), `updatedAt` (number)
  - `meta` (any): Provider-specific metadata, including error details.
- **Indices:** `byAiTurnId` (critical for `recompute`), `bySessionId`, `byProviderId`.
- **Truth:** This is the immutable log. Records are _never_ overwritten; new `recompute` results are _new_ records with the same `aiTurnId` but a new `id` and higher `responseIndex`.

#### 4. `provider_contexts` (ProviderContextRecord)

The "hot path" store for live conversation continuity.

- **Primary Key:** `[sessionId, providerId]` (compound key).
- **Fields:**
  - `contextData` (any): A blob of provider-specific continuation info (e.g., `{ conversationId, parentMessageId, threadId }`).
  - `updatedAt` (number)
- **Indices:** `bySessionId`, `byProviderId`.
- **Truth:** This store holds the _live continuation state_ used by the `extend` primitive. It is separate from the historical `providerContexts` snapshots stored in the `turns` table.

### Invariants and Guarantees

- **Append-only Responses:** A `ProviderResponseRecord`, once written, is never mutated. New `recompute` results are appended as new records.
- **Turn Counts:** The `AiTurnRecord` counts (`batchResponseCount`, etc.) reflect the number of `ProviderResponseRecord` entries written for that turn at finalization.
- **Session Integrity:** `SessionRecord.lastTurnId` is _only_ updated by the `extend` or `initialize` primitives. `recompute` operations _do not_ change this pointer.
- **Live Context:** There is exactly one `ProviderContextRecord` per `[sessionId, providerId]`. It is updated at the end of any `extend` flow.
- **Canonical IDs:** `userTurnId` and `aiTurnId` are generated by the backend and are canonical and stable. No ID swapping occurs at any layer.

### Read/Write Flows

#### Flow 1: `Initialize` / `Extend` (The "Live" Write Path)

1.  **Resolve:** `ContextResolver` calls `adapter.getContextsBySessionId(sessionId)` to read the _live_ continuation state from the `provider_contexts` store.
2.  **Compile:** `WorkflowCompiler` builds the full step list (batch â†’ mapping â†’ synthesis).
3.  **Execute:** `WorkflowEngine` runs all steps.
4.  **Persist (`SessionManager`):** Upon completion, a single database transaction is executed to:
    a. Write all new `ProviderResponseRecord` entries (for batch, mapping, and synthesis) to the `provider_responses` store.
    b. Update the `ProviderContextRecord` for each provider in `provider_contexts` with the new, live continuation metadata.
    c. Write the new `AiTurnRecord` to the `turns` table, storing the _counts_ of responses and a _snapshot_ of the contexts from step (b).
    d. Update the `SessionRecord` in the `sessions` table, setting its `lastTurnId` to the new `AiTurnRecord`'s ID and incrementing `turnCount`.
5.  **Finalize:** The `WorkflowEngine` emits the `TURN_FINALIZED` message to the UI.

#### Flow 2: `Recompute` (The "Historical" Write Path)

1.  **Resolve:** `ContextResolver`:
    a. Loads the source `AiTurnRecord` (e.g., `ai-turn-123`).
    b. Loads its associated `UserTurnRecord` (using `ai-turn-123.userTurnId`).
    c. Loads all `ProviderResponseRecord`s where `aiTurnId === 'ai-turn-123'` using the `byAiTurnId` index.
    d. Uses the `providerContexts` _snapshot_ from the `AiTurnRecord` as the context for the step.
2.  **Compile:** `WorkflowCompiler` builds a _single_ step (`synthesis` or `mapping`) hydrated with the "frozen" data from the `ResolvedContext`.
3.  **Execute:** `WorkflowEngine` runs the single recomputed step.
4.  **Persist (`SessionManager`):** Upon completion, a single database transaction is executed to:
    a. Write a _new_ `ProviderResponseRecord` (e.g., a `synthesis` result for Claude), linking it to the _original_ `aiTurnId` (`ai-turn-123`).
    b. Write a _new_ `AiTurnRecord` (e.g., `ai-recompute-456`), linking it to the _original_ `userTurnId`.
    c. **Critically:** The `SessionRecord` is **NOT** updated. `lastTurnId` remains unchanged.
5.  **Finalize:** The `WorkflowEngine` emits `WORKFLOW_STEP_UPDATE (completed)` to the UI. No `TURN_FINALIZED` is emitted, as the main timeline did not advance.

### Transaction & Error Handling

- All writes for a given turn are grouped into a single transactional unit via `withTransaction`.
- If a provider fails during a step, a `ProviderResponseRecord` is still written with `status: 'error'` and the error message in the `meta` field. This ensures the turn history is complete.
- If all providers fail in the main `prompt` step, the engine emits `WORKFLOW_STEP_UPDATE (failed)` and `WORKFLOW_COMPLETE (error)` to the UI. The failed state is persisted with zero-count `AiTurnRecord` and error `ProviderResponseRecord` entries.

### Performance & Observability

- **Performance:** The hot path (`extend`) is optimized by querying the `provider_contexts` store directly, avoiding a full scan of the `turns` table. The `recompute` path is optimized using the `byAiTurnId` index on `provider_responses`.
- **Observability:** The `PersistenceMonitor` (`src/debug/PersistenceMonitor.js`) can be enabled to watch all database operations, track performance, and verify invariants during development.

### Key Files & References

- **Schema:** `src/persistence/database.ts` (Store definitions, keys, indices)
- **Types:** `src/persistence/types.ts` (Interfaces for all records)
- **Adapter:** `src/persistence/SimpleIndexedDBAdapter.ts` (Low-level read/write methods)
- **Logic:** `src/persistence/SessionManager.js` (Orchestrates `persist` logic)
- **Transactions:** `src/persistence/transactions.ts` (Transaction boundaries)
- **Validation:** `src/persistence/schemaVerification.ts` (Schema health checks)

### FAQ / Gotchas

- **DO NOT** embed response payloads inside `AiTurnRecord`. Store counts only.
- **DO NOT** overwrite `ProviderResponseRecord` entries. Append new ones for recomputes.
- **DO** ensure `provider_contexts` writes maintain the `[sessionId, providerId]` uniqueness.
- **REMEMBER:** `recompute` reads historical `ProviderResponseRecord` entries but writes _new_ ones.
- **REMEMBER:** The `providerContexts` snapshot in `AiTurnRecord` is for _history_ (`recompute`). The `provider_contexts` _store_ is for _live_ (`extend`).

---



================================================
FILE: src/persistence/database.ts
================================================
// IndexedDB Database Initialization for HTOS Document Composition System

import { StoreConfig, MetadataRecord } from "./types";

export const DB_NAME = "OpusDeusDB";
export const DB_VERSION = 6;
export const SCHEMA_VERSION = 6;

// Store configurations - conversation-only architecture
export const STORE_CONFIGS: StoreConfig[] = [
  // 1. Sessions Store
  {
    name: "sessions",
    keyPath: "id",
    indices: [
      { name: "byCreatedAt", keyPath: "createdAt", unique: false },
      { name: "byLastActivity", keyPath: "lastActivity", unique: false },
    ],
  },

  // 2. Threads Store
  {
    name: "threads",
    keyPath: "id",
    indices: [
      { name: "bySessionId", keyPath: "sessionId", unique: false },
      { name: "byParentThreadId", keyPath: "parentThreadId", unique: false },
      {
        name: "bySessionId_createdAt",
        keyPath: ["sessionId", "createdAt"],
        unique: false,
      },
    ],
  },

  // 3. Turns Store
  {
    name: "turns",
    keyPath: "id",
    indices: [
      { name: "bySessionId", keyPath: "sessionId", unique: false },
      { name: "byThreadId", keyPath: "threadId", unique: false },
      { name: "byType", keyPath: "type", unique: false },
      {
        name: "bySessionId_createdAt",
        keyPath: ["sessionId", "createdAt"],
        unique: false,
      },
      {
        name: "byThreadId_createdAt",
        keyPath: ["threadId", "createdAt"],
        unique: false,
      },
      { name: "byUserTurnId", keyPath: "userTurnId", unique: false },
      { name: "byIsComplete", keyPath: "isComplete", unique: false },
    ],
  },

  // 4. Provider Responses Store
  {
    name: "provider_responses",
    keyPath: "id",
    autoIncrement: true,
    indices: [
      { name: "byAiTurnId", keyPath: "aiTurnId", unique: false },
      { name: "byProviderId", keyPath: "providerId", unique: false },
      { name: "byResponseType", keyPath: "responseType", unique: false },
      {
        name: "byCompoundKey",
        keyPath: ["aiTurnId", "providerId", "responseType", "responseIndex"],
        unique: true,
      },
      {
        name: "bySessionId_providerId",
        keyPath: ["sessionId", "providerId"],
        unique: false,
      },
      { name: "bySessionId", keyPath: "sessionId", unique: false },
    ],
  },

  // 5. Provider Contexts Store
  {
    name: "provider_contexts",
    keyPath: ["sessionId", "providerId"],
    indices: [
      { name: "bySessionId", keyPath: "sessionId", unique: false },
      { name: "byProviderId", keyPath: "providerId", unique: false },
    ],
  },

  // 6. Metadata Store (generic key-value for system data)
  {
    name: "metadata",
    keyPath: "key",
    indices: [
      { name: "bySessionId", keyPath: "sessionId", unique: false },
      { name: "byEntityId", keyPath: "entityId", unique: false },
    ],
  },
];

/**
 * Opens the IndexedDB database with proper schema initialization
 */
export async function openDatabase(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
      const db = (event.target as IDBOpenDBRequest).result;
      const oldVersion = event.oldVersion;
      const transaction = (event.target as IDBOpenDBRequest).transaction!;

      console.log(
        `Upgrading database from version ${oldVersion} to ${DB_VERSION}`,
      );

      // Initial schema creation
      if (oldVersion < 1) {
        createInitialSchema(db);

        const metadataStore = transaction.objectStore("metadata");
        const now = Date.now();
        const schemaVersionRecord: MetadataRecord = {
          id: "schema_version_record",
          key: "schema_version",
          value: SCHEMA_VERSION,
          createdAt: now,
          updatedAt: now,
        };
        metadataStore.add(schemaVersionRecord);
      }

      // Migration to v5: Remove document-related stores only
      if (oldVersion < 5 && oldVersion > 0) {
        // Delete document stores (documents, canvas_blocks, ghosts)
        const storesToDelete = ["documents", "canvas_blocks", "ghosts"];

        for (const storeName of storesToDelete) {
          if (db.objectStoreNames.contains(storeName)) {
            db.deleteObjectStore(storeName);
            console.log(`Deleted document store: ${storeName}`);
          }
        }

        // Verify/reconcile all remaining stores and indices
        reconcileSchema(db, transaction);

        // Update schema version in metadata
        const metadataStore = transaction.objectStore("metadata");
        const now = Date.now();
        const rec: MetadataRecord = {
          id: "schema_version_record",
          key: "schema_version",
          value: SCHEMA_VERSION,
          createdAt: now,
          updatedAt: now,
        };
        metadataStore.put(rec);
      }

      // Migration to v6: Add byIsComplete index to turns store
      if (oldVersion < 6) {
        try {
          const turnsStore = transaction.objectStore("turns");
          const existing = new Set(Array.from(turnsStore.indexNames));
          if (!existing.has("byIsComplete")) {
            turnsStore.createIndex("byIsComplete", "isComplete", {
              unique: false,
            });
            console.log("Created index turns.byIsComplete during v6 migration");
          }
        } catch (e) {
          console.warn(
            "Failed to create turns.byIsComplete during v6 migration:",
            e,
          );
        }
        try {
          const metadataStore = transaction.objectStore("metadata");
          const now = Date.now();
          const rec: MetadataRecord = {
            id: "schema_version_record",
            key: "schema_version",
            value: SCHEMA_VERSION,
            createdAt: now,
            updatedAt: now,
          };
          metadataStore.put(rec);
        } catch (_) {}
      }
    };

    request.onsuccess = () => {
      const db = request.result;

      db.onerror = (event) => {
        console.error("Database error:", (event.target as IDBRequest).error);
      };

      db.onversionchange = () => {
        db.close();
        console.warn(
          "Database schema was upgraded in another tab. Please reload.",
        );
      };

      resolve(db);
    };

    request.onerror = () => {
      const error = request.error;
      console.error("Failed to open database:", error);

      if (error?.name === "QuotaExceededError") {
        reject(
          new Error(
            "Storage quota exceeded. Please free up space and try again.",
          ),
        );
      } else {
        reject(error);
      }
    };

    request.onblocked = () => {
      console.warn(
        "Database upgrade blocked by another tab. Please close other tabs.",
      );
    };
  });
}

/**
 * Creates the initial database schema with all stores and indices
 */
function createInitialSchema(db: IDBDatabase): void {
  console.log("Creating initial database schema...");

  for (const config of STORE_CONFIGS) {
    console.log(`Creating store: ${config.name}`);

    const storeOptions: IDBObjectStoreParameters = {
      keyPath: config.keyPath,
    };

    if (config.autoIncrement) {
      storeOptions.autoIncrement = true;
    }

    const store = db.createObjectStore(config.name, storeOptions);

    for (const indexConfig of config.indices) {
      console.log(`  Creating index: ${indexConfig.name}`);

      const indexOptions: IDBIndexParameters = {
        unique: indexConfig.unique || false,
        multiEntry: indexConfig.multiEntry || false,
      };

      store.createIndex(indexConfig.name, indexConfig.keyPath, indexOptions);
    }
  }

  console.log("Initial schema creation completed");
}

/**
 * Reconciles existing schema with expected schema
 * Creates missing stores and indices, useful for recovery from corruption
 */
function reconcileSchema(db: IDBDatabase, transaction: IDBTransaction): void {
  console.log("Reconciling database schema...");

  for (const config of STORE_CONFIGS) {
    let store: IDBObjectStore;

    // Create store if missing
    if (!db.objectStoreNames.contains(config.name)) {
      console.log(`Creating missing store: ${config.name}`);

      const storeOptions: IDBObjectStoreParameters = {
        keyPath: config.keyPath,
      };

      if (config.autoIncrement) {
        storeOptions.autoIncrement = true;
      }

      store = db.createObjectStore(config.name, storeOptions);
    } else {
      store = transaction.objectStore(config.name);
    }

    // Verify/create indices
    const existingIndices = new Set(Array.from(store.indexNames));

    for (const indexConfig of config.indices) {
      if (!existingIndices.has(indexConfig.name)) {
        console.log(
          `  Creating missing index: ${indexConfig.name} in ${config.name}`,
        );
        const indexOptions: IDBIndexParameters = {
          unique: indexConfig.unique || false,
          multiEntry: indexConfig.multiEntry || false,
        };
        store.createIndex(indexConfig.name, indexConfig.keyPath, indexOptions);
      }
    }
  }

  console.log("Schema reconciliation completed");
}

/**
 * Gets the current schema version from the metadata store
 */
export async function getCurrentSchemaVersion(
  db: IDBDatabase,
): Promise<number> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction("metadata", "readonly");
    const store = transaction.objectStore("metadata");
    const request = store.get("schema_version");

    request.onsuccess = () => {
      const record = request.result as MetadataRecord | undefined;
      resolve(record?.value || 0);
    };

    request.onerror = () => {
      reject(request.error);
    };
  });
}

/**
 * Checks if the database needs to be upgraded
 */
export async function checkDatabaseHealth(): Promise<{
  isHealthy: boolean;
  currentVersion: number;
  expectedVersion: number;
  issues: string[];
}> {
  try {
    const db = await openDatabase();
    const issues: string[] = [];

    // Check if all expected stores exist
    const storeNames = Array.from(db.objectStoreNames);
    const expectedStores = STORE_CONFIGS.map((config) => config.name);

    for (const expectedStore of expectedStores) {
      if (!storeNames.includes(expectedStore)) {
        issues.push(`Missing object store: ${expectedStore}`);
      }
    }

    db.close();

    return {
      isHealthy: issues.length === 0 && db.version === DB_VERSION,
      currentVersion: db.version,
      expectedVersion: DB_VERSION,
      issues,
    };
  } catch (error) {
    return {
      isHealthy: false,
      currentVersion: 0,
      expectedVersion: DB_VERSION,
      issues: [
        `Database error: ${error instanceof Error ? error.message : "Unknown error"}`,
      ],
    };
  }
}

/**
 * Utility to delete the entire database (for development/testing)
 */
export async function deleteDatabase(): Promise<void> {
  return new Promise((resolve, reject) => {
    const deleteRequest = indexedDB.deleteDatabase(DB_NAME);

    deleteRequest.onsuccess = () => {
      console.log("Database deleted successfully");
      resolve();
    };

    deleteRequest.onerror = () => {
      reject(deleteRequest.error);
    };

    deleteRequest.onblocked = () => {
      console.warn(
        "Database deletion blocked. Please close all tabs using this database.",
      );
    };
  });
}



================================================
FILE: src/persistence/index.ts
================================================
// src/persistence/index.ts

export * from "./types";
export * from "./database.js";
export * from "./transactions.js";
export * from "./SessionManager.js";

import { openDatabase, STORE_CONFIGS, SCHEMA_VERSION } from "./database.js";
import { SimpleIndexedDBAdapter } from "./SimpleIndexedDBAdapter.js";

// Simplified PersistenceLayer interface
export interface PersistenceLayer {
  adapter: SimpleIndexedDBAdapter;
  close: () => Promise<void>;
}

export async function initializePersistenceLayer(): Promise<PersistenceLayer> {
  const db = await openDatabase();
  const storeNames = Array.from(db.objectStoreNames);
  const expectedStores = STORE_CONFIGS.map((cfg) => cfg.name);
  const missingStores = expectedStores.filter(
    (name) => !storeNames.includes(name),
  );

  if (missingStores.length > 0) {
    db.close();
    throw new Error(
      `SchemaError: Missing object stores: ${missingStores.join(", ")}`,
    );
  }

  try {
    const tx = db.transaction("metadata", "readonly");
    const store = tx.objectStore("metadata");
    const versionReq = store.get("schema_version");
    const version: number = await new Promise((resolve, reject) => {
      versionReq.onsuccess = () =>
        resolve((versionReq.result && versionReq.result.value) || 0);
      versionReq.onerror = () => reject(versionReq.error);
    });

    if (version !== SCHEMA_VERSION) {
      db.close();
      throw new Error(
        `SchemaError: schema_version mismatch (current=${version}, expected=${SCHEMA_VERSION})`,
      );
    }
  } catch (e) {
    db.close();
    throw new Error(
      `SchemaError: unable to read metadata schema_version: ${
        e instanceof Error ? e.message : String(e)
      }`,
    );
  }

  const adapter = new SimpleIndexedDBAdapter();
  await adapter.init({ autoRepair: true });

  return {
    adapter,
    close: async () => {
      await adapter.close();
      db.close();
    },
  };
}

export function isPersistenceAvailable(): boolean {
  return typeof indexedDB !== "undefined" && typeof IDBDatabase !== "undefined";
}

export async function getPersistenceHealth(): Promise<{
  available: boolean;
  adapterReady: boolean;
  databaseOpen: boolean;
  error?: string;
}> {
  try {
    const available = isPersistenceAvailable();
    if (!available) {
      return {
        available: false,
        adapterReady: false,
        databaseOpen: false,
        error: "IndexedDB not available",
      };
    }

    const db = await openDatabase();
    let databaseOpen = false;
    try {
      const tx = db.transaction(["sessions"], "readonly");
      databaseOpen = tx !== null;
    } catch (error) {
      databaseOpen = false;
    }

    // Test the SimpleIndexedDBAdapter
    const adapter = new SimpleIndexedDBAdapter();
    await adapter.init();
    const adapterReady = await adapter.isReady();
    await adapter.close();

    db.close();
    return {
      available: true,
      adapterReady,
      databaseOpen,
    };
  } catch (error) {
    return {
      available: false,
      adapterReady: false,
      databaseOpen: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}



================================================
FILE: src/persistence/schemaVerification.ts
================================================
import { checkDatabaseHealth, deleteDatabase, openDatabase } from "./database";

export interface SchemaHealth {
  isHealthy: boolean;
  currentVersion: number;
  expectedVersion: number;
  issues: string[];
}

/**
 * Verifies database schema health; if unhealthy and autoRepair=true, performs delete-and-recreate.
 * Returns whether a repair was performed, the new database if repaired, and the health report.
 */
export async function verifySchemaAndRepair(autoRepair: boolean): Promise<{
  repaired: boolean;
  db?: IDBDatabase;
  health: SchemaHealth;
}> {
  const health = await checkDatabaseHealth();
  if (health.isHealthy) {
    return { repaired: false, health };
  }


  const versionMismatch = health.currentVersion !== health.expectedVersion;
  if (!autoRepair) {
    const msg = `SchemaError: ${versionMismatch ? "schema_version mismatch" : "missing stores"}; issues=${health.issues?.join("; ")}`;
    throw new Error(msg);
  }

  console.warn(
    "[SchemaVerification] Schema unhealthy, attempting auto-repair...",
    health,
  );
  try {
    // Best effort close if a DB is open elsewhere; deletion will proceed regardless
    try {
      /* no-op: caller should close its own DB if needed */
    } catch {}
    await deleteDatabase();
    const db = await openDatabase();
    console.log(
      "[SchemaVerification] Auto-repair completed: database recreated",
    );
    return { repaired: true, db, health };
  } catch (error) {
    console.error("[SchemaVerification] verifySchemaAndRepair failed:", error);
    throw error instanceof Error ? error : new Error(String(error));
  }
}



================================================
FILE: src/persistence/SessionManager.d.ts
================================================
// Type declarations for SessionManager.js

export interface SessionData {
  id: string;
  turns: any[];
  threads: Record<string, any>;
  providerContexts: Record<string, any>;
  metadata: {
    createdAt: number;
    updatedAt: number;
    activeThreadId: string;
  };
}

export interface TurnData {
  id: string;
  userTurn: any;
  aiTurn: any;
  threadId: string;
  timestamp: number;
}

export interface ThreadData {
  id: string;
  name: string | null;
  color: string;
  parentThreadId: string | null;
  branchPointTurnId: string | null;
  createdAt: number;
}

export interface ProviderContextOptions {
  [key: string]: any;
}

export interface PersistenceStatus {
  persistenceEnabled: boolean;
  isInitialized: boolean;
  adapterReady: boolean;
}

export declare class SessionManager {
  sessions: Record<string, SessionData>;
  storageKey: string;
  isExtensionContext: boolean;
  adapter: any;
  isInitialized: boolean;

  constructor();

  initialize(config?: { adapter?: any; initTimeoutMs?: number }): Promise<void>;

  getOrCreateSession(sessionId: string): Promise<SessionData>;

  saveSession(sessionId: string): Promise<void>;

  deleteSession(sessionId: string): Promise<boolean>;

  updateProviderContext(
    sessionId: string,
    providerId: string,
    result: any,
    options?: ProviderContextOptions,
  ): Promise<void>;
  updateProviderContextsBatch(
    sessionId: string,
    updates: Record<string, any>,
    options?: ProviderContextOptions,
  ): Promise<void>;

  getProviderContexts(sessionId: string, threadId?: string): any;


  getPersistenceStatus(): PersistenceStatus;
}

export default SessionManager;



================================================
FILE: src/persistence/SessionManager.js
================================================
// Enhanced SessionManager with Persistence Adapter Integration
// Supports both legacy chrome.storage and new persistence layer via feature flag

import { SimpleIndexedDBAdapter } from "./SimpleIndexedDBAdapter.js";



export class SessionManager {
  constructor() {
    this.isExtensionContext = false;

    // Persistence layer components will be injected
    this.adapter = null;
    this.isInitialized = false;
  }

  /**
   * Upsert a single provider response by compound key. Used for immediate
   * persistence on step completion so we don't lose results if later phases fail.
   * @param {string} sessionId
   * @param {string} aiTurnId
   * @param {string} providerId
   * @param {"batch"|"synthesis"|"mapping"|"refiner"|"antagonist"} responseType
   * @param {number} responseIndex
   * @param {{ text?: string, status?: string, meta?: any, createdAt?: number }} payload
   */
  async upsertProviderResponse(
    sessionId,
    aiTurnId,
    providerId,
    responseType,
    responseIndex,
    payload = {},
  ) {
    try {
      if (!this.adapter) throw new Error("adapter not initialized");
      const keyTuple = [aiTurnId, providerId, responseType, responseIndex];
      let existing = [];
      try {
        existing = await this.adapter.getByIndex(
          "provider_responses",
          "byCompoundKey",
          keyTuple,
        );
      } catch (_) {
        existing = [];
      }

      const now = Date.now();
      const base = {
        id: existing?.[0]?.id || `pr-${sessionId}-${aiTurnId}-${providerId}-${responseType}-${responseIndex}`,
        sessionId,
        aiTurnId,
        providerId,
        responseType,
        responseIndex,
        text: payload.text || (existing?.[0]?.text || ""),
        status: payload.status || (existing?.[0]?.status || "streaming"),
        meta: payload.meta || (existing?.[0]?.meta || {}),
        createdAt: existing?.[0]?.createdAt || payload.createdAt || now,
        updatedAt: now,
      };

      await this.adapter.put("provider_responses", base, base.id);
      return base;
    } catch (e) {
      console.warn("[SessionManager] upsertProviderResponse failed:", e);
      return null;
    }
  }

  /**
   * NEW: Primary persistence entry point (Phase 4)
   * Routes to appropriate primitive-specific handler
   * @param {Object} request - { type, sessionId, userMessage, sourceTurnId?, stepType?, targetProvider? }
   * @param {Object} context - ResolvedContext from ContextResolver
   * @param {Object} result - { batchOutputs, synthesisOutputs, mappingOutputs }
   * @returns {Promise<{sessionId, userTurnId?, aiTurnId?}>}
   */
  async persist(request, context, result) {
    if (!request?.type)
      throw new Error("[SessionManager] persist() requires request.type");
    switch (request.type) {
      case "initialize":
        return this._persistInitialize(request, result);
      case "extend":
        return this._persistExtend(request, context, result);
      case "recompute":
        return this._persistRecompute(request, context, result);
      default:
        throw new Error(
          `[SessionManager] Unknown request type: ${request.type}`,
        );
    }
  }

  /**
   * Initialize: Create new session + first turn
   */
  async _persistInitialize(request, result) {
    const sessionId = request.sessionId;
    if (!sessionId) {
      throw new Error("[SessionManager] initialize requires request.sessionId");
    }
    const now = Date.now();

    const contextSummary = this._buildContextSummary(result);

    // 1) Create session
    const sessionRecord = {
      id: sessionId,
      title: String(request.userMessage || "").slice(0, 50),
      createdAt: now,
      lastActivity: now,
      defaultThreadId: "default-thread",
      activeThreadId: "default-thread",
      turnCount: 2,
      isActive: true,
      lastTurnId: null,
      updatedAt: now,
      userId: "default-user",
      provider: "multi",
    };
    await this.adapter.put("sessions", sessionRecord);

    // 2) Default thread
    const defaultThread = {
      id: "default-thread",
      sessionId,
      parentThreadId: null,
      branchPointTurnId: null,
      title: "Main Thread",
      name: "Main Thread",
      color: "#6366f1",
      isActive: true,
      createdAt: now,
      lastActivity: now,
      updatedAt: now,
    };
    await this.adapter.put("threads", defaultThread);

    // 3) User turn
    const userTurnId = request.canonicalUserTurnId || `user-${now}`;
    const userTurnRecord = {
      id: userTurnId,
      type: "user",
      role: "user",
      sessionId,
      threadId: "default-thread",
      createdAt: now,
      updatedAt: now,
      content: request.userMessage || "",
      sequence: 0,
    };
    await this.adapter.put("turns", userTurnRecord);

    // 4) AI turn with contexts
    const aiTurnId = request.canonicalAiTurnId || `ai-${now}`;
    const providerContexts = this._extractContextsFromResult(result);
    const aiTurnRecord = {
      id: aiTurnId,
      type: "ai",
      role: "assistant",
      sessionId,
      threadId: "default-thread",
      userTurnId,
      createdAt: now,
      updatedAt: now,
      providerContexts,
      isComplete: true,
      sequence: 1,
      batchResponseCount: this.countResponses(result.batchOutputs),
      synthesisResponseCount: this.countResponses(result.synthesisOutputs),
      mappingResponseCount: this.countResponses(result.mappingOutputs),
      refinerResponseCount: this.countResponses(result.refinerOutputs),
      antagonistResponseCount: this.countResponses(result.antagonistOutputs),
      lastContextSummary: contextSummary,
      meta: await this._attachRunIdMeta(aiTurnId),
    };
    await this.adapter.put("turns", aiTurnRecord);

    // 5) Provider responses
    await this._persistProviderResponses(sessionId, aiTurnId, result, now);

    // 6) Update session lastTurnId
    sessionRecord.lastTurnId = aiTurnId;
    sessionRecord.updatedAt = now;
    await this.adapter.put("sessions", sessionRecord);

    return { sessionId, userTurnId, aiTurnId };
  }

  /**
   * Extend: Append turn to existing session
   */
  async _persistExtend(request, context, result) {
    const { sessionId } = request;
    const now = Date.now();

    const contextSummary = this._buildContextSummary(result);

    // Validate last turn
    if (!context?.lastTurnId) {
      throw new Error("[SessionManager] Extend requires context.lastTurnId");
    }
    const lastTurn = await this.adapter.get("turns", context.lastTurnId);
    if (!lastTurn)
      throw new Error(
        `[SessionManager] Last turn ${context.lastTurnId} not found`,
      );

    // Determine next sequence using session.turnCount when available (avoid full-store scan)
    let nextSequence = 0;
    try {
      const session = await this.adapter.get("sessions", sessionId);
      if (session && typeof session.turnCount === "number") {
        nextSequence = session.turnCount;
      } else {
        // Indexed fallback: compute from turns using adapter.getTurnsBySessionId
        const sessionTurns = await this.adapter.getTurnsBySessionId(sessionId);
        nextSequence = Array.isArray(sessionTurns) ? sessionTurns.length : 0;
      }
    } catch (e) {
      // Conservative fallback on error
      try {
        const sessionTurns = await this.adapter.getTurnsBySessionId(sessionId);
        nextSequence = Array.isArray(sessionTurns) ? sessionTurns.length : 0;
      } catch (_) {
        nextSequence = 0;
      }
    }

    // 1) User turn
    const userTurnId = request.canonicalUserTurnId || `user-${now}`;
    const userTurnRecord = {
      id: userTurnId,
      type: "user",
      role: "user",
      sessionId,
      threadId: "default-thread",
      createdAt: now,
      updatedAt: now,
      content: request.userMessage || "",
      sequence: nextSequence,
    };
    await this.adapter.put("turns", userTurnRecord);

    // 2) Merge contexts
    const newContexts = this._extractContextsFromResult(result);
    const mergedContexts = {
      ...(lastTurn.providerContexts || {}),
      ...newContexts,
    };

    // 3) AI turn
    const aiTurnId = request.canonicalAiTurnId || `ai-${now}`;
    const aiTurnRecord = {
      id: aiTurnId,
      type: "ai",
      role: "assistant",
      sessionId,
      threadId: "default-thread",
      userTurnId,
      createdAt: now,
      updatedAt: now,
      providerContexts: mergedContexts,
      isComplete: true,
      sequence: nextSequence + 1,
      batchResponseCount: this.countResponses(result.batchOutputs),
      synthesisResponseCount: this.countResponses(result.synthesisOutputs),
      mappingResponseCount: this.countResponses(result.mappingOutputs),
      refinerResponseCount: this.countResponses(result.refinerOutputs),
      antagonistResponseCount: this.countResponses(result.antagonistOutputs),
      lastContextSummary: contextSummary,
      meta: await this._attachRunIdMeta(aiTurnId),
    };
    await this.adapter.put("turns", aiTurnRecord);

    // 4) Provider responses
    await this._persistProviderResponses(sessionId, aiTurnId, result, now);

    // 5) Update session
    const session = await this.adapter.get("sessions", sessionId);
    if (session) {
      session.lastTurnId = aiTurnId;
      session.lastActivity = now;
      // If session.turnCount was previously undefined, use nextSequence + 2 (the accurate total after this extend)
      const computedNewCount =
        typeof session.turnCount === "number"
          ? session.turnCount + 2
          : nextSequence + 2;
      session.turnCount = computedNewCount;
      session.updatedAt = now;
      await this.adapter.put("sessions", session);
    }

    return { sessionId, userTurnId, aiTurnId };
  }

  /**
   * Recompute: Create derived turn (timeline branch)
   */
  async _persistRecompute(request, context, result) {
    const { sessionId, sourceTurnId, stepType, targetProvider } = request;
    const now = Date.now();

    // 1) Source turn exists?
    const sourceTurn = await this.adapter.get("turns", sourceTurnId);
    if (!sourceTurn)
      throw new Error(`[SessionManager] Source turn ${sourceTurnId} not found`);

    // 2) Extract Result Data (UNIFIED)
    let output;
    if (stepType === "batch") output = result?.batchOutputs?.[targetProvider];
    else if (stepType === "synthesis")
      output = result?.synthesisOutputs?.[targetProvider];
    else if (stepType === "mapping")
      output = result?.mappingOutputs?.[targetProvider];
    else if (stepType === "refiner")
      output = result?.refinerOutputs?.[targetProvider];
    else if (stepType === "antagonist")
      output = result?.antagonistOutputs?.[targetProvider];

    if (!output) {
      console.warn(
        `[SessionManager] No output for ${stepType}/${targetProvider}`,
      );
      return { sessionId };
    }

    // 3) Calculate Version Index (UNIFIED "Physics")
    let nextIndex = 0;
    try {
      const existingResponses = await this.adapter.getResponsesByTurnId(
        sourceTurnId,
      );
      const relevantVersions = existingResponses.filter(
        (r) => r.providerId === targetProvider && r.responseType === stepType,
      );
      if (relevantVersions.length > 0) {
        const maxIndex = Math.max(
          ...relevantVersions.map((r) => r.responseIndex || 0),
        );
        nextIndex = maxIndex + 1;
      }
    } catch (_) { }

    // 4) Persist Response (UNIFIED - no if/else branching)
    const respId = `pr-${sessionId}-${sourceTurnId}-${targetProvider}-${stepType}-${nextIndex}-${now}`;
    await this.adapter.put("provider_responses", {
      id: respId,
      sessionId,
      aiTurnId: sourceTurnId, // ALWAYS the original turn
      providerId: targetProvider,
      responseType: stepType,
      responseIndex: nextIndex,
      text: output.text || "",
      status: output.status || "completed",
      meta: {
        ...output.meta,
        isRecompute: true,
        recomputeDate: now,
      },
      createdAt: now,
      updatedAt: now,
      completedAt: now,
    });

    // 5) Update Parent Turn Metadata (UNIFIED)
    try {
      const freshTurn = await this.adapter.get("turns", sourceTurnId);
      if (freshTurn) {
        freshTurn.updatedAt = now;

        // Increment specific counter
        if (stepType === "batch")
          freshTurn.batchResponseCount = (freshTurn.batchResponseCount || 0) + 1;
        else if (stepType === "synthesis")
          freshTurn.synthesisResponseCount =
            (freshTurn.synthesisResponseCount || 0) + 1;
        else if (stepType === "mapping")
          freshTurn.mappingResponseCount =
            (freshTurn.mappingResponseCount || 0) + 1;
        else if (stepType === "refiner")
          freshTurn.refinerResponseCount =
            (freshTurn.refinerResponseCount || 0) + 1;
        else if (stepType === "antagonist")
          freshTurn.antagonistResponseCount =
            (freshTurn.antagonistResponseCount || 0) + 1;

        // Update snapshot context ONLY for batch retries
        if (stepType === "batch") {
          const contexts = freshTurn.providerContexts || {};
          const existingCtx = contexts[targetProvider] || {};
          contexts[targetProvider] = {
            ...existingCtx,
            ...(output.meta || {}),
          };
          freshTurn.providerContexts = contexts;
        }

        await this.adapter.put("turns", freshTurn);
      }
    } catch (_) { }

    return { sessionId }; // NO new turn IDs
  }

  /**
   * Extract provider contexts from workflow result
   */
  _extractContextsFromResult(result) {
    const contexts = {};
    try {
      Object.entries(result?.batchOutputs || {}).forEach(([pid, output]) => {
        if (output?.meta && Object.keys(output.meta).length > 0)
          contexts[pid] = output.meta;
      });
      Object.entries(result?.synthesisOutputs || {}).forEach(
        ([pid, output]) => {
          if (output?.meta && Object.keys(output.meta).length > 0)
            contexts[pid] = output.meta;
        },
      );
      Object.entries(result?.mappingOutputs || {}).forEach(([pid, output]) => {
        if (output?.meta && Object.keys(output.meta).length > 0)
          contexts[pid] = output.meta;
      });
      Object.entries(result?.refinerOutputs || {}).forEach(([pid, output]) => {
        if (output?.meta && Object.keys(output.meta).length > 0)
          contexts[pid] = output.meta;
      });
      Object.entries(result?.antagonistOutputs || {}).forEach(([pid, output]) => {
        if (output?.meta && Object.keys(output.meta).length > 0)
          contexts[pid] = output.meta;
      });
    } catch (_) { }
    return contexts;
  }

  /**
   * Helper: Persist provider responses for a turn
   */
  /**
   * Helper: Persist provider responses for a turn (BATCHED)
   */
  async _persistProviderResponses(sessionId, aiTurnId, result, now) {
    const recordsToSave = [];
    let existingResponses = [];

    // Pre-fetch all existing responses for this turn to calculate indices correctly
    try {
      existingResponses = await this.adapter.getResponsesByTurnId(aiTurnId) || [];
    } catch (_) { }

    // Helper to calculate next index for a specific provider/type
    const getNextIndex = (providerId, type) => {
      // Check existing persisted records
      const persisted = existingResponses.filter(
        (r) => r.providerId === providerId && r.responseType === type
      );
      // Check currently pending records to handle multiple items of same type in this batch
      const pending = recordsToSave.filter(
        (r) => r.providerId === providerId && r.responseType === type
      );

      const maxPersisted = persisted.length > 0
        ? Math.max(...persisted.map(r => (typeof r.responseIndex === "number" ? r.responseIndex : 0)))
        : -1;

      const maxPending = pending.length > 0
        ? Math.max(...pending.map(r => (typeof r.responseIndex === "number" ? r.responseIndex : 0)))
        : -1;

      return Math.max(maxPersisted, maxPending) + 1;
    };

    let count = 0;

    // 1. Batch Responses (versioned)
    for (const [providerId, output] of Object.entries(result?.batchOutputs || {})) {
      const nextIndex = getNextIndex(providerId, "batch");
      const respId = `pr-${sessionId}-${aiTurnId}-${providerId}-batch-${nextIndex}-${now}-${count++}`;

      recordsToSave.push({
        id: respId,
        sessionId,
        aiTurnId,
        providerId,
        responseType: "batch",
        responseIndex: nextIndex,
        text: output?.text || "",
        status: output?.status || "completed",
        meta: output?.meta || {},
        createdAt: now,
        updatedAt: now,
        completedAt: now,
      });
    }

    // 2. Synthesis (idempotent/singleton per provider)
    for (const [providerId, output] of Object.entries(result?.synthesisOutputs || {})) {
      // Check if exists to preserve ID/createdAt (simulating upset logic)
      const existing = existingResponses.find(
        r => r.providerId === providerId && r.responseType === "synthesis" && r.responseIndex === 0
      );

      const respId = existing?.id || `pr-${sessionId}-${aiTurnId}-${providerId}-synthesis-0-${now}-${count++}`;
      const createdAtKeep = existing?.createdAt || now;

      recordsToSave.push({
        id: respId,
        sessionId,
        aiTurnId,
        providerId,
        responseType: "synthesis",
        responseIndex: 0,
        text: output?.text || existing?.text || "",
        status: output?.status || existing?.status || "completed",
        meta: output?.meta || existing?.meta || {},
        createdAt: createdAtKeep,
        updatedAt: now,
        completedAt: now,
      });
    }

    // 3. Mapping (idempotent/singleton per provider)
    for (const [providerId, output] of Object.entries(result?.mappingOutputs || {})) {
      const existing = existingResponses.find(
        r => r.providerId === providerId && r.responseType === "mapping" && r.responseIndex === 0
      );

      const respId = existing?.id || `pr-${sessionId}-${aiTurnId}-${providerId}-mapping-0-${now}-${count++}`;
      const createdAtKeep = existing?.createdAt || now;

      recordsToSave.push({
        id: respId,
        sessionId,
        aiTurnId,
        providerId,
        responseType: "mapping",
        responseIndex: 0,
        text: output?.text || existing?.text || "",
        status: output?.status || existing?.status || "completed",
        meta: output?.meta || existing?.meta || {},
        createdAt: createdAtKeep,
        updatedAt: now,
        completedAt: now,
      });
    }

    // 4. Refiner (idempotent/singleton per provider)
    for (const [providerId, output] of Object.entries(result?.refinerOutputs || {})) {
      const existing = existingResponses.find(
        r => r.providerId === providerId && r.responseType === "refiner" && r.responseIndex === 0
      );

      const respId = existing?.id || `pr-${sessionId}-${aiTurnId}-${providerId}-refiner-0-${now}-${count++}`;
      const createdAtKeep = existing?.createdAt || now;

      recordsToSave.push({
        id: respId,
        sessionId,
        aiTurnId,
        providerId,
        responseType: "refiner",
        responseIndex: 0,
        text: output?.text || existing?.text || "",
        status: output?.status || existing?.status || "completed",
        meta: output?.meta || existing?.meta || {},
        createdAt: createdAtKeep,
        updatedAt: now,
        completedAt: now,
      });
    }

    // 5. Antagonist (idempotent/singleton per provider)
    for (const [providerId, output] of Object.entries(result?.antagonistOutputs || {})) {
      const existing = existingResponses.find(
        r => r.providerId === providerId && r.responseType === "antagonist" && r.responseIndex === 0
      );

      const respId = existing?.id || `pr-${sessionId}-${aiTurnId}-${providerId}-antagonist-0-${now}-${count++}`;
      const createdAtKeep = existing?.createdAt || now;

      recordsToSave.push({
        id: respId,
        sessionId,
        aiTurnId,
        providerId,
        responseType: "antagonist",
        responseIndex: 0,
        text: output?.text || existing?.text || "",
        status: output?.status || existing?.status || "completed",
        meta: output?.meta || existing?.meta || {},
        createdAt: createdAtKeep,
        updatedAt: now,
        completedAt: now,
      });
    }

    // Perform single batch write
    if (recordsToSave.length > 0) {
      await this.adapter.batchPut("provider_responses", recordsToSave);
    }
  }

  /**
   * Append provider responses (mapping/synthesis/batch) to an existing AI turn
   * that follows the given historical user turn. Used to persist historical reruns
   * without creating a new user/ai turn pair.
   * additions shape: { batchResponses?, synthesisResponses?, mappingResponses? }
   */

  /**
 

  /**
   * Helper function to count responses in a response bucket
   * @param {Object} responseBucket - Object containing provider responses
   * @returns {number} Total count of responses
   */
  countResponses(responseBucket) {
    return responseBucket ? Object.values(responseBucket).flat().length : 0;
  }

  /**
   * Initialize the session manager.
   * It now accepts the persistence adapter as an argument.
   */
  async initialize(config = {}) {
    const { adapter = null, initTimeoutMs = 8000 } = config || {};

    console.log("[SessionManager] Initializing with persistence adapter...");

    if (adapter) {
      this.adapter = adapter;
    } else {
      // Create and initialize SimpleIndexedDBAdapter
      this.adapter = new SimpleIndexedDBAdapter();
      await this.adapter.init({ timeoutMs: initTimeoutMs, autoRepair: true });
    }

    this.isInitialized = true;

    // Migrations removed; adapter initialization completes without migration step
  }

  async _attachRunIdMeta(aiTurnId) {
    try {
      const metas = await this.adapter.getMetadataByEntityId(aiTurnId);
      const inflight = (metas || []).find(
        (m) => m && m.type === "inflight_workflow",
      );
      if (inflight && inflight.runId) {
        return { runId: inflight.runId };
      }
    } catch (_) { }
    return {};
  }

  /**
   * Get or create a session (persistence-backed with cache)
   */
  async getOrCreateSession(sessionId) {
    if (!sessionId) throw new Error("sessionId required");

    // Direct persistence-backed retrieval/creation
    // 1. Try to get existing session from DB
    let sessionRecord = await this.adapter.get("sessions", sessionId);

    // 2. Create new session if doesn't exist
    if (!sessionRecord) {
      sessionRecord = {
        id: sessionId,
        userId: "default-user",
        provider: "multi",
        title: "",
        isActive: true,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        lastTurnId: null,
        lastActivity: Date.now(),
      };

      await this.adapter.put("sessions", sessionRecord);

      // Create default thread
      const defaultThread = {
        id: "default-thread",
        sessionId: sessionId,
        parentThreadId: null,
        branchPointTurnId: null,
        title: "Main Thread",
        isActive: true,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };

      await this.adapter.put("threads", defaultThread);
      console.log(`[SessionManager] Created new session: ${sessionId}`);
    }

    return sessionRecord;
  }

  /**
   * Save session (enhanced with persistence layer support)
   */
  async saveSession(sessionId) {
    try {
      // Direct DB update - typically used to sync explicit saves/metadata
      const sessionRecord = await this.adapter.get("sessions", sessionId);
      if (sessionRecord) {
        sessionRecord.updatedAt = Date.now();
        await this.adapter.put("sessions", sessionRecord);
        console.log(`[SessionManager] Updated session ${sessionId} timestamp`);
      }
    } catch (error) {
      console.error(
        `[SessionManager] Failed to update session ${sessionId}:`,
        error,
      );
    }
  }


  /**
   * Delete session (enhanced with persistence layer support)
   */
  async deleteSession(sessionId) {
    try {
      // Perform an atomic, indexed cascade delete inside a single transaction
      await this.adapter.transaction(
        [
          "sessions",
          "threads",
          "turns",
          "provider_responses",
          "provider_contexts",
          "metadata",
        ],
        "readwrite",
        async (tx) => {
          const getAllByIndex = (store, indexName, key) =>
            new Promise((resolve, reject) => {
              let idx;
              try {
                idx = store.index(indexName);
              } catch (e) {
                return reject(e);
              }
              const req = idx.getAll(key);
              req.onsuccess = () => resolve(req.result || []);
              req.onerror = () => reject(req.error);
            });

          // 1) Delete session record
          await new Promise((resolve, reject) => {
            const req = tx.objectStore("sessions").delete(sessionId);
            req.onsuccess = () => resolve(true);
            req.onerror = () => reject(req.error);
          });

          // 2) Threads by session
          const threadsStore = tx.objectStore("threads");
          const threads = await getAllByIndex(
            threadsStore,
            "bySessionId",
            sessionId,
          );
          for (const t of threads) {
            await new Promise((resolve, reject) => {
              const req = threadsStore.delete(t.id);
              req.onsuccess = () => resolve(true);
              req.onerror = () => reject(req.error);
            });
          }

          // 3) Turns by session
          const turnsStore = tx.objectStore("turns");
          const turns = await getAllByIndex(
            turnsStore,
            "bySessionId",
            sessionId,
          );
          for (const turn of turns) {
            await new Promise((resolve, reject) => {
              const req = turnsStore.delete(turn.id);
              req.onsuccess = () => resolve(true);
              req.onerror = () => reject(req.error);
            });
          }

          // 4) Provider responses by sessionId (indexed; no fallbacks)
          const responsesStore = tx.objectStore("provider_responses");
          const responses = await getAllByIndex(
            responsesStore,
            "bySessionId",
            sessionId,
          );
          for (const r of responses) {
            await new Promise((resolve, reject) => {
              const req = responsesStore.delete(r.id);
              req.onsuccess = () => resolve(true);
              req.onerror = () => reject(req.error);
            });
          }

          // 5) Provider contexts by session (composite key delete)
          const contextsStore = tx.objectStore("provider_contexts");
          const contexts = await getAllByIndex(
            contextsStore,
            "bySessionId",
            sessionId,
          );
          for (const ctx of contexts) {
            await new Promise((resolve, reject) => {
              const key = [ctx.sessionId, ctx.providerId];
              const req = contextsStore.delete(key);
              req.onsuccess = () => resolve(true);
              req.onerror = () => reject(req.error);
            });
          }

          // 6) Metadata scoped to this session (indexed by sessionId; avoid full-store scans)
          const metaStore = tx.objectStore("metadata");
          const metasBySession = await getAllByIndex(
            metaStore,
            "bySessionId",
            sessionId,
          );
          for (const m of metasBySession) {
            await new Promise((resolve, reject) => {
              const req = metaStore.delete(m.key);
              req.onsuccess = () => resolve(true);
              req.onerror = () => reject(req.error);
            });
          }
        },
      );

      return true;
    } catch (error) {
      console.error(
        `[SessionManager] Failed to delete session ${sessionId} from persistence layer:`,
        error,
      );
      throw error; // Changed: Throw explicit error
    }
  }


  /**
   * Update provider context (enhanced with persistence layer support)
   */
  async updateProviderContext(
    sessionId,
    providerId,
    result = {},
    options = {},
  ) {
    const { skipSave = true } = options;
    if (!sessionId || !providerId) return;

    try {
      const session = await this.getOrCreateSession(sessionId);

      // Get or create provider context via indexed query by session
      let contexts = [];
      try {
        contexts = await this.adapter.getContextsBySessionId(sessionId);
        // Narrow to target provider
        contexts = contexts.filter(
          (context) => context.providerId === providerId,
        );
      } catch (e) {
        console.warn(
          "[SessionManager] updateProviderContext: contexts lookup failed, using empty set",
          e,
        );
        contexts = [];
      }
      // Select the most recent context by updatedAt (fallback createdAt)
      let contextRecord = null;
      if (contexts.length > 0) {
        const sorted = contexts.sort((a, b) => {
          const ta = a.updatedAt ?? a.createdAt ?? 0;
          const tb = b.updatedAt ?? b.createdAt ?? 0;
          return tb - ta; // newest first
        });
        contextRecord = sorted[0];
        console.log(
          `[SessionManager] updateProviderContext: selected latest context for ${providerId} in ${sessionId}`,
          {
            candidates: contexts.length,
            selectedId: contextRecord.id,
            selectedUpdatedAt: contextRecord.updatedAt,
            selectedCreatedAt: contextRecord.createdAt,
          },
        );
      }

      if (!contextRecord) {
        // Create new context
        contextRecord = {
          id: `ctx-${sessionId}-${providerId}-${Date.now()}`,
          sessionId: sessionId,
          providerId: providerId,
          threadId: "default-thread",
          contextData: {},
          isActive: true,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };
      }

      // Update context data
      const existingContext = contextRecord.contextData || {};
      contextRecord.contextData = {
        ...existingContext,
        text: result?.text || existingContext.text || "",
        meta: { ...(existingContext.meta || {}), ...(result?.meta || {}) },
        lastUpdated: Date.now(),
      };
      contextRecord.updatedAt = Date.now();

      // Save or update context
      await this.adapter.put("provider_contexts", contextRecord);

      // Direct session update for activity tracking
      if (session) {
        session.lastActivity = Date.now();
        session.updatedAt = Date.now();
        await this.adapter.put("sessions", session);
      }
    } catch (error) {
      console.error(
        `[SessionManager] Failed to update provider context in persistence layer:`,
        error,
      );
      throw error; // Changed: Propagate errors
    }
  }

  /**
   * Batch update multiple provider contexts in a single pass.
   * updates shape: { [providerId]: { text?: string, meta?: object } }
   */
  async updateProviderContextsBatch(sessionId, updates = true, options = {}) {
    const { skipSave = true } = options;
    if (!sessionId || !updates || typeof updates !== "object") return;

    try {
      const session = await this.getOrCreateSession(sessionId);
      const now = Date.now();

      // Load all existing contexts once using indexed query, pick latest per provider
      let sessionContexts = [];
      try {
        sessionContexts = await this.adapter.getContextsBySessionId(sessionId);
      } catch (e) {
        console.warn(
          "[SessionManager] updateProviderContextsBatch: contexts lookup failed; proceeding with empty list",
          e,
        );
        sessionContexts = [];
      }
      const latestByProvider = {};
      for (const ctx of sessionContexts) {
        const pid = ctx.providerId;
        const ts = ctx.updatedAt ?? ctx.createdAt ?? 0;
        const existing = latestByProvider[pid];
        if (!existing || ts > (existing._ts || 0)) {
          latestByProvider[pid] = { record: ctx, _ts: ts };
        }
      }

      // Apply updates
      for (const [providerId, result] of Object.entries(updates)) {
        let contextRecord = latestByProvider[providerId]?.record;
        if (!contextRecord) {
          contextRecord = {
            id: `ctx-${sessionId}-${providerId}-${now}-${Math.random().toString(36).slice(2, 8)}`,
            sessionId,
            providerId,
            threadId: "default-thread",
            contextData: {},
            isActive: true,
            createdAt: now,
            updatedAt: now,
          };
        }

        const existingData = contextRecord.contextData || {};
        contextRecord.contextData = {
          ...existingData,
          text: result?.text || existingData.text || "",
          meta: { ...(existingData.meta || {}), ...(result?.meta || {}) },
          lastUpdated: now,
        };
        contextRecord.updatedAt = now;

        // Persist updated context
        await this.adapter.put("provider_contexts", contextRecord);
      }

      // Direct session update for activity tracking
      if (session) {
        session.lastActivity = now;
        session.updatedAt = now;
        await this.adapter.put("sessions", session);
      }
    } catch (error) {
      console.error(
        "[SessionManager] Failed to batch update provider contexts:",
        error,
      );
    }
  }


  /**
   * Get provider contexts (persistence-backed, backward compatible shape)
   * Returns an object: { [providerId]: { meta: <contextMeta> } }
   */
  async getProviderContexts(sessionId, threadId = "default-thread") {
    try {
      if (!sessionId) {
        console.warn(
          "[SessionManager] getProviderContexts called without sessionId",
        );
        return {};
      }
      if (!this.adapter || !this.adapter.isReady()) {
        console.warn(
          "[SessionManager] getProviderContexts called but adapter is not ready",
        );
        return {}; // Return empty if DB isn't available
      }

      // Use the fast, indexed method. No more turn scanning.
      const contextRecords =
        await this.adapter.getContextsBySessionId(sessionId);

      const contexts = {};
      for (const record of contextRecords) {
        // The goal is to return an object shaped like: { [providerId]: { meta: {...} } }
        if (record.providerId && record.contextData?.meta) {
          contexts[record.providerId] = { meta: record.contextData.meta };
        }
      }

      return contexts;
    } catch (e) {
      console.error("[SessionManager] getProviderContexts failed:", e);
      return {}; // Return empty on error
    }
  }


  /**
   * Extract "The Short Answer" section or fallback to intro paragraphs from synthesis text
   * @param {string} text 
   */
  _extractContextFromSynthesis(text) {
    if (!text) return "";

    // 1. Look for "The Short Answer" delimiter
    const shortAnswerMatch = text.match(/#+\s*The Short Answer/i);
    if (shortAnswerMatch) {
      const startIndex = shortAnswerMatch.index + shortAnswerMatch[0].length;
      const remaining = text.slice(startIndex).trim();
      // Extract until next header or formatting change
      const nextHeaderMatch = remaining.match(/\n#+\s/);
      let content = remaining;
      if (nextHeaderMatch) {
        content = remaining.slice(0, nextHeaderMatch.index).trim();
      }
      // CLEANUP: Remove "The Long Answer" if it leaked in
      return content.replace(/#+\s*The Long Answer/i, "").trim();
    }

    // 2. Fallback: If text starts with header, take text between first and second header
    if (text.trim().match(/^#+\s/)) {
      const headers = [...text.matchAll(/\n#+\s/g)];
      if (headers.length > 0) {
        // Text starts with header (index 0 implied), find next header
        const end = headers[0].index;
        // If the first match is actually later in the text (not at 0), we take text before it
        // But the regex checks if text STARTS with header.
        // Let's simplify: split by headers and take the first non-empty content block
        const parts = text.split(/\n#+\s/).map(p => p.trim()).filter(p => p.length > 0);
        return parts[0] || "";
      }
    }

    // 3. Fallback: Take first few paragraphs before any header
    const firstHeaderIndex = text.search(/\n#+\s/);
    const preHeaderText = firstHeaderIndex > -1 ? text.slice(0, firstHeaderIndex) : text;

    const paragraphs = preHeaderText.split(/\n\s*\n/).filter(p => p.trim().length > 0);
    return paragraphs.slice(0, 3).join("\n\n").trim();
  }

  /**
   * Extract decision map context (consensus + divergence) from narrative section
   * @param {string} text - Narrative section only (pre-parsed)
   */
  _extractContextFromMapping(text) {
    if (!text) return "";

    // Look for "Consensus:" section
    const consensusMatch = text.match(/Consensus:/i);
    if (consensusMatch) {
      return text.slice(consensusMatch.index).trim();
    }

    return text.trim();
  }

  /**
   * Combine synthesis + mapping extracts into context blob
   */
  _buildContextSummary(result) {
    let summary = "";

    // 1. Synthesis (Preferred)
    const synthesisOutputs = result?.synthesisOutputs || {};
    const synthProvider = Object.keys(synthesisOutputs)[0];
    if (synthProvider && synthesisOutputs[synthProvider]?.text) {
      const synthText = synthesisOutputs[synthProvider].text;
      const extracted = this._extractContextFromSynthesis(synthText);
      if (extracted) {
        summary += `<previous_synthesis>\n${extracted}\n</previous_synthesis>\n\n`;
      }
    }

    // 2. Mapping (Narrative)
    const mappingOutputs = result?.mappingOutputs || {};
    const mapProvider = Object.keys(mappingOutputs)[0];
    if (mapProvider && mappingOutputs[mapProvider]?.text) {
      const mapText = mappingOutputs[mapProvider].text;
      const parts = mapText.split("===ALL_AVAILABLE_OPTIONS===");
      const narrative = parts[0] || "";

      const extracted = this._extractContextFromMapping(narrative);
      if (extracted) {
        summary += `<council_views>\n${extracted}\n</council_views>`;
      }
    }

    const finalSummary = summary.trim();
    console.log("[SessionManager] Built Context Summary:", {
      length: finalSummary.length,
      preview: finalSummary.slice(0, 100).replace(/\n/g, "\\n") + "...",
      hasSynthesis: finalSummary.includes("<previous_synthesis>"),
      hasMapping: finalSummary.includes("<council_views>")
    });

    return finalSummary;
  }



  /**
   * Get persistence adapter status
   */
  getPersistenceStatus() {
    return {
      persistenceEnabled: true,
      isInitialized: this.isInitialized,
      adapterReady: this.adapter?.isReady() || false,
    };
  }
}



================================================
FILE: src/persistence/SimpleIndexedDBAdapter.ts
================================================
// Simplified IndexedDB Adapter with minimal API for HTOS persistence
// Provides init(), get(), put(), delete(), getAll() methods with auto-population of key fields

import { openDatabase } from "./database";
import { verifySchemaAndRepair } from "./schemaVerification";
import { withTransaction } from "./transactions";

export interface SimpleRecord {
  id?: string;
  createdAt?: number;
  updatedAt?: number;
  [key: string]: any;
}

/**
 * Simplified IndexedDB adapter with minimal API surface
 */
export class SimpleIndexedDBAdapter {
  private db: IDBDatabase | null = null;
  private isInitialized = false;
  private initTimeoutMs = 8000;

  /**
   * Initialize the adapter and open the database
   * Only returns after onupgradeneeded completes and DB is fully open
   */
  async init(options?: {
    timeoutMs?: number;
    autoRepair?: boolean;
  }): Promise<void> {
    this.initTimeoutMs = options?.timeoutMs ?? this.initTimeoutMs;
    const autoRepair = options?.autoRepair ?? true;

    try {
      // Open DB with timeout protection
      const dbPromise = openDatabase();
      this.db = await this.withTimeout(
        dbPromise,
        this.initTimeoutMs,
        "Timeout opening IndexedDB database",
      );

      // Runtime assertions - verify DB is properly opened
      if (!this.db) {
        console.error("persistence:init - Database failed to open");
        throw new Error("IndexedDB failed to open - database is null");
      }

      // Verify/repair schema if needed
      const { repaired, db: repairedDb } =
        await verifySchemaAndRepair(autoRepair);
      if (repaired && repairedDb) {
        // Replace db handle with repaired instance
        this.db = repairedDb;
      }
      if (!repaired) {
        // verify required object stores exist if no repair was needed
        const requiredStores = [
          "sessions",
          "threads",
          "turns",
          "provider_responses",
          "provider_contexts",
          "metadata",
        ];
        const missingStores = requiredStores.filter(
          (storeName) => !this.db!.objectStoreNames.contains(storeName),
        );
        if (missingStores.length > 0) {
          console.error(
            "persistence:init - Missing required object stores:",
            missingStores,
          );
          throw new Error(
            `IndexedDB missing required object stores: ${missingStores.join(", ")}`,
          );
        }
      }

      this.isInitialized = true;
    } catch (error) {
      console.error("persistence:init - Initialization failed:", error);
      throw error;
    }
  }

  /**
   * Get a record by key from the specified store
   * Returns undefined if record is not found (safe behavior)
   */
  async get(storeName: string, key: string): Promise<SimpleRecord | undefined> {
    this.ensureReady();
    const resolved = this.resolveStoreName(storeName);
    try {
      const result = await withTransaction(
        this.db!,
        [resolved],
        "readonly",
        async (tx) => {
          const store = tx.objectStore(resolved);
          return new Promise<SimpleRecord | undefined>((resolve, reject) => {
            const request = store.get(key);
            request.onsuccess = () => resolve(request.result || undefined);
            request.onerror = () => reject(request.error);
          });
        },
      );

      return result;
    } catch (error) {
      console.error(`persistence:get(${resolved}, ${key}) - error:`, error);
      throw error;
    }
  }

  /**
   * Put a record into the specified store
   * Auto-populates id, createdAt, updatedAt fields if missing
   */
  async put(
    storeName: string,
    value: SimpleRecord,
    key?: string,
  ): Promise<SimpleRecord> {
    this.ensureReady();
    const resolved = this.resolveStoreName(storeName);
    try {
      // Defensive deep-clone to prevent mutation issues
      const clonedValue = JSON.parse(JSON.stringify(value));

      // Auto-populate required fields
      const now = Date.now();
      if (!clonedValue.id && !key) {
        clonedValue.id = crypto.randomUUID();
      }
      if (key && !clonedValue.id) {
        clonedValue.id = key;
      }
      if (!clonedValue.createdAt) {
        clonedValue.createdAt = now;
      }
      clonedValue.updatedAt = now;

      const result = await withTransaction(
        this.db!,
        [resolved],
        "readwrite",
        async (tx) => {
          const store = tx.objectStore(resolved);
          return new Promise<SimpleRecord>((resolve, reject) => {
            // If the store has a keyPath defined, IndexedDB requires that we DO NOT provide
            // an explicit key argument to put(). Passing a key would raise a DataError DOMException.
            const hasKeyPath = (store as any).keyPath !== null && (store as any).keyPath !== undefined;
            const request = hasKeyPath
              ? store.put(clonedValue)
              : (key ? store.put(clonedValue, key) : store.put(clonedValue));
            request.onsuccess = () => resolve(clonedValue);
            request.onerror = () => reject(request.error);
          });
        },
      );

      return result;
    } catch (error) {
      console.error(
        `persistence:put(${resolved}, ${key || value.id}) - error:`,
        error,
      );
      throw error;
    }
  }

  /**
   * Batch put records into the specified store in a single transaction
   */
  async batchPut(
    storeName: string,
    values: SimpleRecord[],
  ): Promise<void> {
    this.ensureReady();
    if (!values || values.length === 0) return;

    const resolved = this.resolveStoreName(storeName);
    const now = Date.now();

    try {
      await withTransaction(
        this.db!,
        [resolved],
        "readwrite",
        async (tx) => {
          const store = tx.objectStore(resolved);
          const hasKeyPath = (store as any).keyPath !== null && (store as any).keyPath !== undefined;

          // Process all puts within the single transaction
          const promises = values.map(value => {
            return new Promise<void>((resolve, reject) => {
              // Clone and auto-populate
              const clonedValue = JSON.parse(JSON.stringify(value));
              if (!clonedValue.id) clonedValue.id = crypto.randomUUID();
              if (!clonedValue.createdAt) clonedValue.createdAt = now;
              clonedValue.updatedAt = now;

              const request = hasKeyPath
                ? store.put(clonedValue)
                : store.put(clonedValue, clonedValue.id);

              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
          });

          await Promise.all(promises);
        }
      );
    } catch (error) {
      console.error(`persistence:batchPut(${resolved}) - error:`, error);
      throw error;
    }
  }

  /**
   * Delete a record by key from the specified store
   */
  async delete(storeName: string, key: string): Promise<boolean> {
    this.ensureReady();
    const resolved = this.resolveStoreName(storeName);
    try {
      await withTransaction(this.db!, [resolved], "readwrite", async (tx) => {
        const store = tx.objectStore(resolved);
        return new Promise<void>((resolve, reject) => {
          const request = store.delete(key);
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      });

      return true;
    } catch (error) {
      console.error(`persistence:delete(${resolved}, ${key}) - error:`, error);
      throw error;
    }
  }

  /**
   * Get all records from the specified store
   * Returns empty array if no records found (safe behavior)
   */
  async getAll(storeName: string): Promise<SimpleRecord[]> {
    this.ensureReady();
    const resolved = this.resolveStoreName(storeName);
    try {
      const result = await withTransaction(
        this.db!,
        [resolved],
        "readonly",
        async (tx) => {
          const store = tx.objectStore(resolved);
          return new Promise<SimpleRecord[]>((resolve, reject) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error);
          });
        },
      );

      return result;
    } catch (error) {
      console.error(`persistence:getAll(${resolved}) - error:`, error);
      throw error;
    }
  }

  /**
   * Generic indexed query helper using an object store index.
   * Returns all matching records.
   */
  async getByIndex(
    storeName: string,
    indexName: string,
    key: IDBValidKey | IDBKeyRange,
  ): Promise<SimpleRecord[]> {
    this.ensureReady();
    const resolved = this.resolveStoreName(storeName);
    try {
      const result = await withTransaction(
        this.db!,
        [resolved],
        "readonly",
        async (tx) => {
          const store = tx.objectStore(resolved);
          let index: IDBIndex;
          try {
            index = store.index(indexName);
          } catch (e) {
            console.error(
              `persistence:getByIndex(${resolved}.${indexName}) - missing index`,
              e,
            );
            throw e;
          }
          return new Promise<SimpleRecord[]>((resolve, reject) => {
            const request = index.getAll(key);
            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error);
          });
        },
      );
      return result;
    } catch (error) {
      console.error(
        `persistence:getByIndex(${resolved}.${indexName}) - error:`,
        error,
      );
      throw error;
    }
  }

  /**
   * Convenience wrappers for common indexed queries
   */
  async getThreadsBySessionId(sessionId: string): Promise<SimpleRecord[]> {
    return this.getByIndex("threads", "bySessionId", sessionId);
  }

  async getTurnsBySessionId(sessionId: string): Promise<SimpleRecord[]> {
    return this.getByIndex("turns", "bySessionId", sessionId);
  }

  async getResponsesByTurnId(aiTurnId: string): Promise<SimpleRecord[]> {
    // provider_responses.byAiTurnId
    return this.getByIndex("provider_responses", "byAiTurnId", aiTurnId);
  }

  async getContextsBySessionId(sessionId: string): Promise<SimpleRecord[]> {
    // provider_contexts.bySessionId
    return this.getByIndex("provider_contexts", "bySessionId", sessionId);
  }

  async getResponsesBySessionId(sessionId: string): Promise<SimpleRecord[]> {
    // provider_responses.bySessionId
    return this.getByIndex("provider_responses", "bySessionId", sessionId);
  }

  async getMetadataBySessionId(sessionId: string): Promise<SimpleRecord[]> {
    // metadata.bySessionId
    return this.getByIndex("metadata", "bySessionId", sessionId);
  }

  async getMetadataByEntityId(entityId: string): Promise<SimpleRecord[]> {
    // metadata.byEntityId
    return this.getByIndex("metadata", "byEntityId", entityId);
  }

  async getAllSessions(): Promise<SimpleRecord[]> {
    // Convenience wrapper for listing sessions; full-scan is acceptable for sessions catalog
    return this.getAll("sessions");
  }

  async getIncompleteTurns(): Promise<SimpleRecord[]> {
    const aiTurns = await this.getByIndex("turns", "byType", "ai");
    return (aiTurns || []).filter((t) => t && t.isComplete !== true);
  }

  /**
   * Execute an operation inside a single transaction spanning given stores.
   */
  async transaction<T>(
    storeNames: string[],
    mode: "readonly" | "readwrite",
    operation: (tx: IDBTransaction) => Promise<T>,
  ): Promise<T> {
    this.ensureReady();
    const resolvedStores = storeNames.map((s) => this.resolveStoreName(s));
    return withTransaction(this.db!, resolvedStores, mode, operation);
  }

  /**
   * Check if the adapter is ready for use
   */
  isReady(): boolean {
    return this.isInitialized && this.db !== null;
  }

  /**
   * Close the database connection
   */
  async close(): Promise<void> {
    if (this.db) {
      this.db.close();
      this.db = null;
      this.isInitialized = false;
    }
  }

  /**
   * Ensure the adapter is ready before operations
   */
  private ensureReady(): void {
    if (!this.isReady()) {
      throw new Error(
        "SimpleIndexedDBAdapter is not initialized. Call init() first.",
      );
    }
  }

  /**
   * Resolve canonical store name to actual IndexedDB object store name
   * Supports both camelCase and snake_case aliases
   */
  private resolveStoreName(name: string): string {
    const map: Record<string, string> = {
      providerResponses: "provider_responses",
      providerContexts: "provider_contexts",
    };
    return map[name] || name;
  }

  /**
   * Verifies the schema is healthy; if not and autoRepair=true, attempts delete-and-recreate.
   * Returns true if a repair was performed, false if no repair was needed.
   */
  // verifySchemaAndRepair extracted to standalone utility in schemaVerification.ts

  /**
   * Helper to add timeout to promises to avoid hanging initialization
   */
  private async withTimeout<T>(
    promise: Promise<T>,
    timeoutMs: number,
    timeoutMessage: string,
  ): Promise<T> {
    let timeoutHandle: any;
    const timeoutPromise = new Promise<T>((_, reject) => {
      timeoutHandle = setTimeout(
        () => reject(new Error(timeoutMessage)),
        timeoutMs,
      );
    });
    try {
      const result = await Promise.race([promise, timeoutPromise]);
      return result as T;
    } finally {
      clearTimeout(timeoutHandle);
    }
  }
}



================================================
FILE: src/persistence/transactions.ts
================================================
// Transaction Utilities for IndexedDB Operations

import { VersionConflictResult, BatchWriteResult } from "./types";

/**
 * Maximum number of retry attempts for transient failures
 */
const MAX_RETRY_ATTEMPTS = 3;

/**
 * Delay between retry attempts (in milliseconds)
 */
const RETRY_DELAY_MS = 100;

/**
 * Wraps IndexedDB transactions with automatic retry logic and error handling
 */
export async function withTransaction<T>(
  db: IDBDatabase,
  storeNames: string | string[],
  mode: IDBTransactionMode,
  work: (tx: IDBTransaction) => Promise<T>,
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= MAX_RETRY_ATTEMPTS; attempt++) {
    try {
      return await executeTransaction(db, storeNames, mode, work);
    } catch (error) {
      lastError = error as Error;

      // Don't retry certain types of errors
      if (isNonRetryableError(error)) {
        throw error;
      }

      // Don't retry on the last attempt
      if (attempt === MAX_RETRY_ATTEMPTS) {
        break;
      }

      console.warn(`Transaction attempt ${attempt} failed, retrying...`, error);

      // Wait before retrying
      await new Promise((resolve) =>
        setTimeout(resolve, RETRY_DELAY_MS * attempt),
      );
    }
  }

  throw (
    lastError || new Error("Transaction failed after maximum retry attempts")
  );
}

/**
 * Executes a single transaction attempt
 */
function executeTransaction<T>(
  db: IDBDatabase,
  storeNames: string | string[],
  mode: IDBTransactionMode,
  work: (tx: IDBTransaction) => Promise<T>,
): Promise<T> {
  return new Promise((resolve, reject) => {
    let transaction: IDBTransaction;
    // Attempt to create the transaction, but provide schema-aware errors if it fails
    try {
      transaction = db.transaction(storeNames, mode);
    } catch (err) {
      const error = err as DOMException;
      const existingStores = Array.from(db.objectStoreNames);
      const targetStores = Array.isArray(storeNames)
        ? storeNames
        : [storeNames];
      const missing = targetStores.filter(
        (name) => !existingStores.includes(name),
      );
      if (missing.length > 0) {
        const friendly = new Error(
          `SchemaError: Missing object stores [${missing.join(", ")}]; requested=[${targetStores.join(", ")}], existing=[${existingStores.join(", ")}]`,
        );
        (friendly as any).name = "NotFoundError";
        return reject(friendly);
      }
      return reject(error || new Error("Failed to create transaction"));
    }
    let workResult: T;
    let workCompleted = false;
    let workRejected = false;

    // Set up transaction event handlers
    transaction.oncomplete = () => {
      if (workCompleted && !workRejected) {
        resolve(workResult);
      } else if (!workRejected) {
        reject(
          new Error("Transaction completed but work function did not complete"),
        );
      }
      // If work was rejected, the rejection was already handled in the catch block
    };

    transaction.onerror = () => {
      if (!workRejected) {
        // Enhance error with schema context if NotFoundError
        const existingStores = Array.from(db.objectStoreNames);
        const targetStores = Array.isArray(storeNames)
          ? storeNames
          : [storeNames];
        const missing = targetStores.filter(
          (name) => !existingStores.includes(name),
        );
        const baseError =
          transaction.error ||
          new Error("Transaction failed with unknown error");
        if ((baseError as any).name === "NotFoundError" || missing.length > 0) {
          const friendly = new Error(
            `SchemaError: Missing object stores [${missing.join(", ")}]; requested=[${targetStores.join(", ")}], existing=[${existingStores.join(", ")}]`,
          );
          (friendly as any).name = "NotFoundError";
          return reject(friendly);
        }
        reject(baseError);
      }
    };

    transaction.onabort = () => {
      if (!workRejected) {
        reject(new Error("Transaction was aborted"));
      }
    };

    // Execute the work function
    work(transaction)
      .then((result) => {
        workResult = result;
        workCompleted = true;
        // Don't resolve here - wait for transaction.oncomplete
      })
      .catch((error) => {
        workRejected = true;
        // Abort the transaction if the work function fails
        try {
          transaction.abort();
        } catch (abortError) {
          console.warn("Failed to abort transaction:", abortError);
        }
        reject(error);
      });
  });
}

/**
 * Determines if an error should not be retried
 */
function isNonRetryableError(error: unknown): boolean {
  if (!(error instanceof Error)) {
    return false;
  }

  const nonRetryableErrors = [
    "QuotaExceededError",
    "ConstraintError",
    "DataError",
    "InvalidStateError",
    "NotFoundError",
    "ReadOnlyError",
    "VersionError",
  ];

  return nonRetryableErrors.includes(error.name);
}

/**
 * Batch write operation for multiple records to a single store
 */
export async function batchWrite<T>(
  db: IDBDatabase,
  storeName: string,
  records: T[],
): Promise<BatchWriteResult> {
  if (records.length === 0) {
    return { success: true };
  }

  return withTransaction(db, storeName, "readwrite", async (tx) => {
    const store = tx.objectStore(storeName);
    const errors: Error[] = [];

    // Execute all writes
    const promises = records.map((record, index) => {
      return new Promise<void>((resolve) => {
        const request = store.put(record);

        request.onsuccess = () => resolve();
        request.onerror = () => {
          const error = new Error(
            `Failed to write record at index ${index}: ${request.error?.message}`,
          );
          errors.push(error);
          resolve(); // Don't reject individual failures
        };
      });
    });

    await Promise.all(promises);

    if (errors.length > 0) {
      return { success: false, errors };
    }

    return { success: true };
  });
}

/**
 * Batch delete operation for multiple keys from a single store
 */
export async function batchDelete(
  db: IDBDatabase,
  storeName: string,
  keys: (string | string[] | number)[],
): Promise<BatchWriteResult> {
  if (keys.length === 0) {
    return { success: true };
  }

  return withTransaction(db, storeName, "readwrite", async (tx) => {
    const store = tx.objectStore(storeName);
    const errors: Error[] = [];

    // Execute all deletes
    const promises = keys.map((key, index) => {
      return new Promise<void>((resolve) => {
        const request = store.delete(key as IDBValidKey);

        request.onsuccess = () => resolve();
        request.onerror = () => {
          const error = new Error(
            `Failed to delete record at index ${index}: ${request.error?.message}`,
          );
          errors.push(error);
          resolve(); // Don't reject individual failures
        };
      });
    });

    await Promise.all(promises);

    if (errors.length > 0) {
      return { success: false, errors };
    }

    return { success: true };
  });
}

/**
 * Updates a record with optimistic locking based on version number
 */
export async function updateWithVersionCheck<T extends { version: number }>(
  db: IDBDatabase,
  storeName: string,
  id: string | string[],
  updates: Partial<T>,
  expectedVersion: number,
): Promise<VersionConflictResult> {
  return withTransaction(db, storeName, "readwrite", async (tx) => {
    const store = tx.objectStore(storeName);

    // Get current record
    const getRequest = store.get(id as IDBValidKey);
    const currentRecord = await new Promise<T | undefined>(
      (resolve, reject) => {
        getRequest.onsuccess = () => resolve(getRequest.result);
        getRequest.onerror = () => reject(getRequest.error);
      },
    );

    if (!currentRecord) {
      throw new Error("Record not found");
    }

    // Check version
    if (currentRecord.version !== expectedVersion) {
      return {
        success: false,
        currentVersion: currentRecord.version,
      };
    }

    // Apply updates and increment version
    const updatedRecord: T = {
      ...currentRecord,
      ...updates,
      version: currentRecord.version + 1,
    };

    // Save updated record
    const putRequest = store.put(updatedRecord);
    await new Promise<void>((resolve, reject) => {
      putRequest.onsuccess = () => resolve();
      putRequest.onerror = () => reject(putRequest.error);
    });

    return { success: true };
  });
}

/**
 * Executes multiple operations across different stores in a single transaction
 */
export async function multiStoreTransaction<T>(
  db: IDBDatabase,
  storeNames: string[],
  operations: (stores: Record<string, IDBObjectStore>) => Promise<T>,
): Promise<T> {
  return withTransaction(db, storeNames, "readwrite", async (tx) => {
    // Create a map of store names to store objects
    const stores: Record<string, IDBObjectStore> = {};
    for (const storeName of storeNames) {
      stores[storeName] = tx.objectStore(storeName);
    }

    return operations(stores);
  });
}

/**
 * Helper to promisify IndexedDB requests
 */
export function promisifyRequest<T>(request: IDBRequest<T>): Promise<T> {
  return new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

/**
 * Helper to promisify IndexedDB cursor operations
 */
export function promisifyCursor<T>(
  request: IDBRequest<IDBCursorWithValue | null>,
  processor: (cursor: IDBCursorWithValue) => T | Promise<T>,
): Promise<T[]> {
  return new Promise((resolve, reject) => {
    const results: T[] = [];

    request.onsuccess = async () => {
      const cursor = request.result;
      if (cursor) {
        try {
          const result = await processor(cursor);
          results.push(result);
          cursor.continue();
        } catch (error) {
          reject(error);
        }
      } else {
        resolve(results);
      }
    };

    request.onerror = () => reject(request.error);
  });
}

/**
 * Utility for counting records in a store or index
 */
export async function countRecords(
  db: IDBDatabase,
  storeName: string,
  indexName?: string,
  query?: IDBValidKey | IDBKeyRange,
): Promise<number> {
  return withTransaction(db, storeName, "readonly", async (tx) => {
    const store = tx.objectStore(storeName);
    const target = indexName ? store.index(indexName) : store;

    const request = target.count(query);
    return promisifyRequest(request);
  });
}

/**
 * Utility for checking if a record exists
 */
export async function recordExists(
  db: IDBDatabase,
  storeName: string,
  key: IDBValidKey,
): Promise<boolean> {
  return withTransaction(db, storeName, "readonly", async (tx) => {
    const store = tx.objectStore(storeName);
    const request = store.getKey(key);
    const result = await promisifyRequest(request);
    return result !== undefined;
  });
}



================================================
FILE: src/persistence/types.ts
================================================
// src/persistence/types.ts

// Store configuration types
export interface StoreConfig {
  name: string;
  keyPath: string | string[];
  autoIncrement?: boolean;
  indices: IndexConfig[];
}

export interface IndexConfig {
  name: string;
  keyPath: string | string[];
  unique?: boolean;
  multiEntry?: boolean;
}

// 1. Sessions Store
export interface SessionRecord {
  id: string;
  title: string;
  createdAt: number;
  lastActivity: number;
  defaultThreadId: string;
  activeThreadId: string;
  turnCount: number;
  isActive: boolean;
  lastTurnId?: string;
  updatedAt: number;
  userId?: string;
  provider?: string;
  metadata?: Record<string, any>;
}

// 2. Threads Store
export interface ThreadRecord {
  id: string;
  sessionId: string;
  parentThreadId: string | null;
  branchPointTurnId: string | null;
  name: string;
  title: string;
  color: string;
  isActive: boolean;
  createdAt: number;
  lastActivity: number;
  updatedAt: number;
  userId?: string;
  turnCount?: number;
  metadata?: Record<string, any>;
}

// 3. Turns Store
export interface BaseTurnRecord {
  id: string;
  type: "user" | "ai";
  sessionId: string;
  threadId: string;
  createdAt: number;
  isDeleted?: boolean;
  updatedAt: number;
  userId?: string;
  role?: string;
  content?: string;
  sequence?: number;
  providerResponseIds?: string[];
}

export interface UserTurnRecord extends BaseTurnRecord {
  type: "user";
  text: string;
}

export interface AiTurnRecord extends BaseTurnRecord {
  type: "ai";
  userTurnId: string;
  meta?: {
    branchPointTurnId?: string;
    replacesId?: string;
    isHistoricalRerun?: boolean;
  };
  batchResponseCount: number;
  synthesisResponseCount: number;
  mappingResponseCount: number;
  refinerResponseCount?: number;
  antagonistResponseCount?: number;
  providerContexts?: Record<string, any>;
}

export type TurnRecord = UserTurnRecord | AiTurnRecord;

// 4. Provider Responses Store
export interface ProviderResponseRecord {
  id: string;
  sessionId: string;
  aiTurnId: string;
  providerId: string;
  responseType: "batch" | "synthesis" | "mapping" | "refiner" | "antagonist";
  responseIndex: number;
  text: string;
  status: "pending" | "streaming" | "completed" | "error" | "cancelled";
  meta?: any;
  attemptNumber?: number;
  createdAt: number;
  updatedAt: number;
  completedAt?: number;
  error?: string;
  content?: string;
  metadata?: Record<string, any>;
  tokenUsage?: {
    promptTokens: number;
    completionTokens: number;
  };
}

// 8. Provider Contexts Store
export interface ProviderContextRecord {
  id: string;
  sessionId: string;
  providerId: string;
  threadId?: string;
  meta: any;
  text?: string;
  lastUpdated: number;
  createdAt: number;
  updatedAt: number;
  isActive?: boolean;
  contextData?: any;
  metadata?: Record<string, any>;
}

// 9. Metadata Store
export interface MetadataRecord {
  id: string;
  key: string;
  entityId?: string;
  entityType?: string;
  sessionId?: string;
  createdAt: number;
  value: any;
  updatedAt: number;
}

// Utility types for operations
export interface VersionConflictResult {
  success: boolean;
  currentVersion?: number;
}

export interface BatchWriteResult {
  success: boolean;
  errors?: Error[];
}



================================================
FILE: src/providers/chatgpt-adapter.js
================================================
/**
 * HTOS ChatGPT Provider Adapter
 * - Implements ProviderAdapter interface for ChatGPT
 * - Wraps ChatGPTSessionApi with auth observation (ChatGPT has internal retries)
 * 
 * Build-phase safe: emitted to dist/adapters/*
 */
import { authManager } from '../core/auth-manager.js';
import {
  errorHandler,
  isProviderAuthError,
  createProviderAuthError
} from '../utils/ErrorHandler.js';

// Provider-specific adapter debug flag (off by default)
const CHATGPT_ADAPTER_DEBUG = false;
const pad = (...args) => {
  if (CHATGPT_ADAPTER_DEBUG) console.log(...args);
};

export class ChatGPTAdapter {
  constructor(controller) {
    this.id = "chatgpt";
    this.capabilities = {
      needsDNR: false,
      needsOffscreen: true, // Requires oi Arkose/PoW pipeline
      supportsStreaming: true, // Enable streaming for orchestrator/UI
      supportsContinuation: true,
      synthesis: true,
      supportsThinking: true, // new flag: supports Think-mode
    };
    this.controller = controller;
  }

  /**
   * Unified ask API: prefer continuation when context identifiers exist, else start new.
   */
  async ask(prompt, providerContext = null, sessionId = undefined, onChunk = undefined, signal = undefined) {
    try {
      const meta = providerContext?.meta || providerContext || {};
      const hasContinuation = Boolean(
        meta.conversationId || meta.parentMessageId || meta.messageId,
      );
      pad(`[ProviderAdapter] ASK_STARTED provider=${this.id} hasContext=${hasContinuation}`);

      let res;
      if (hasContinuation) {
        res = await this.sendContinuation(prompt, meta, sessionId, onChunk, signal);
      } else {
        res = await this.sendPrompt({ originalPrompt: prompt, sessionId, meta }, onChunk, signal);
      }

      try {
        const len = (res?.text || "").length;
        pad(`[ProviderAdapter] ASK_COMPLETED provider=${this.id} ok=${res?.ok !== false} textLen=${len}`);
      } catch (_) { }
      return res;
    } catch (e) {
      console.warn(`[ProviderAdapter] ASK_FAILED provider=${this.id}:`, e?.message || String(e));
      throw e;
    }
  }

  // Compatibility shim: delegate adapter._getAccessToken to controller
  async _getAccessToken() {
    try {
      if (this.controller && typeof this.controller._getAccessToken === "function") {
        return await this.controller._getAccessToken();
      }
      if (this.controller && this.controller.chatgptSession && typeof this.controller.chatgptSession._ensureAccessToken === "function") {
        const token = await this.controller.chatgptSession._ensureAccessToken();
        return { accessToken: token || null };
      }
      return { error: "no-controller" };
    } catch (e) {
      return { error: (e && e.message) || String(e) };
    }
  }

  /** Initialize the adapter */
  async init() {
    return;
  }

  /**
   * Health check to ensure ChatGPT path is available
   */
  async healthCheck() {
    try {
      return await this.controller.isAvailable();
    } catch {
      return false;
    }
  }

  /**
   * Send prompt to ChatGPT. Mirrors Claude/Gemini adapter contract.
   */
  async sendPrompt(req, onChunk, signal, _isRetry = false) {
    const startTime = Date.now();
    pad(`[ChatGPT Adapter] sendPrompt started (provider=${this.id})`);

    let aggregated = "";

    try {
      // If Thinking mode requested, route to thinkAsk backend which streams NDJSON
      const useThinking = Boolean(req?.meta?.useThinking);
      if (useThinking) {
        let conversationId = null;
        let lastMessageId = null;
        let observedModel = req.meta?.model || null;

        const forwardOnChunk = (chunk) => {
          try {
            if (chunk?.chatId && !conversationId) conversationId = chunk.chatId;
            if (chunk?.id) lastMessageId = chunk.id;
            if (chunk?.model) observedModel = chunk.model;
            if (chunk?.text) aggregated = chunk.text;
          } catch (_) { }
          if (onChunk) {
            try { onChunk(chunk); } catch (_) { }
          }
        };

        // Route think-mode through the authenticated ChatGPT session API
        const result = await this.controller.chatgptSession.ask(
          req.originalPrompt,
          {
            signal,
            model: req.meta?.model,
            chatId: req.meta?.conversationId,
            parentMessageId: req.meta?.parentMessageId || req.meta?.messageId,
            think: true,
          },
          forwardOnChunk,
        );

        const response = {
          providerId: this.id,
          ok: true,
          id: null,
          text: result?.text ?? aggregated ?? "",
          partial: false,
          latencyMs: Date.now() - startTime,
          meta: {
            model: result?.model || observedModel || "auto",
            conversationId: conversationId || undefined,
            messageId: lastMessageId || undefined,
            parentMessageId: lastMessageId || undefined,
          },
        };
        pad(`[ChatGPT Adapter] providerComplete (thinking): chatgpt status=success, latencyMs=${response.latencyMs}`);
        return response;
      }

      // Original non-thinking flow
      let conversationId = null;
      let lastMessageId = null;
      let observedModel = req.meta?.model || null;

      const forwardOnChunk = (chunk) => {
        try {
          if (chunk?.chatId && !conversationId) conversationId = chunk.chatId;
          if (chunk?.id) lastMessageId = chunk.id;
          if (chunk?.model) observedModel = chunk.model;
          if (chunk?.text) aggregated = chunk.text;
        } catch (_) { }
        if (onChunk) {
          try { onChunk(chunk); } catch (_) { }
        }
      };

      const result = await this.controller.chatgptSession.ask(
        req.originalPrompt,
        {
          signal,
          model: req.meta?.model,
          chatId: req.meta?.conversationId,
          parentMessageId: req.meta?.parentMessageId || req.meta?.messageId,
        },
        forwardOnChunk,
      );

      const response = {
        providerId: this.id,
        ok: true,
        id: null,
        text: result?.text ?? "",
        partial: false,
        latencyMs: Date.now() - startTime,
        meta: {
          model: result?.model || observedModel || "auto",
          conversationId: conversationId || undefined,
          messageId: lastMessageId || undefined,
          parentMessageId: lastMessageId || undefined,
        },
      };

      pad(`[ChatGPT Adapter] providerComplete: chatgpt status=success, latencyMs=${response.latencyMs}`);
      return response;

    } catch (error) {
      // Unwrap special thrown thinking-result
      if (error && error.__chatgpt_adapter_thinking_result) {
        return error.__chatgpt_adapter_thinking_result;
      }

      // Observe auth failure and update status
      if (isProviderAuthError(error)) {
        authManager.invalidateCache(this.id);
        await authManager.verifyProvider(this.id);

        // Return structured error response
        const authError = createProviderAuthError(this.id, error);
        return {
          providerId: this.id,
          ok: false,
          text: aggregated || null,
          errorCode: 'AUTH_REQUIRED',
          latencyMs: Date.now() - startTime,
          meta: {
            error: authError.toString(),
            details: authError.details,
          },
        };
      }

      // Avoid infinite recursion on retries
      if (_isRetry) {
        return {
          providerId: this.id,
          ok: false,
          text: aggregated || null,
          errorCode: (error && (error.code || error.type)) || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: error?.toString?.() || String(error),
            details: error?.details,
          },
        };
      }

      // Use central error handler with a real retry operation
      try {
        const recovery = await errorHandler.handleProviderError(error, this.id, {
          providerId: this.id,
          prompt: req.originalPrompt?.substring(0, 200),
          operation: async () => {
            return await this.sendPrompt(req, onChunk, signal, true);
          },
        });
        if (recovery) return recovery;
      } catch (handledError) {
        return {
          providerId: this.id,
          ok: false,
          text: aggregated || null,
          errorCode: handledError.code || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: handledError.toString(),
            details: handledError.details,
          },
        };
      }
    }
  }

  async sendContinuation(prompt, providerContext, sessionId, onChunk, signal, _isRetry = false) {
    const meta = providerContext?.meta || providerContext || {};
    const conversationIdIn = meta.conversationId;
    const parentMessageIdIn = meta.parentMessageId || meta.messageId;

    pad("[ChatGPT Session] Starting continuation with context:", {
      hasConversationId: !!conversationIdIn,
      hasParentId: !!parentMessageIdIn,
    });

    if (meta.useThinking) {
      return this.sendPrompt({ originalPrompt: prompt, meta }, onChunk, signal);
    }

    if (!conversationIdIn) {
      console.warn(`[ChatGPT Adapter] sendContinuation called without conversationId.`);
      return {
        providerId: this.id,
        ok: false,
        text: null,
        errorCode: "context_missing",
        meta: { error: "Continuity lost: Missing conversationId." },
      };
    }

    const startTime = Date.now();
    let aggregated = "";

    try {
      let conversationId = conversationIdIn || null;
      let lastMessageId = null;
      let observedModel = meta?.model || null;

      const forwardOnChunk = (chunk) => {
        try {
          if (chunk?.chatId && !conversationId) conversationId = chunk.chatId;
          if (chunk?.id) lastMessageId = chunk.id;
          if (chunk?.model) observedModel = chunk.model;
          if (chunk?.text) aggregated = chunk.text;
        } catch (_) { }
        if (onChunk) {
          try { onChunk(chunk); } catch (_) { }
        }
      };

      const result = await this.controller.chatgptSession.ask(
        prompt,
        {
          signal,
          chatId: conversationIdIn,
          parentMessageId: parentMessageIdIn,
          model: observedModel || undefined,
        },
        forwardOnChunk,
      );

      const response = {
        providerId: this.id,
        ok: true,
        id: lastMessageId || null,
        text: result?.text ?? "",
        partial: false,
        latencyMs: Date.now() - startTime,
        meta: {
          model: result?.model || observedModel || "auto",
          conversationId: conversationId || conversationIdIn,
          messageId: lastMessageId || undefined,
          parentMessageId: lastMessageId || parentMessageIdIn || undefined,
        },
      };

      pad(`[ChatGPT Session] Continuation completed in ${response.latencyMs}ms`);
      return response;

    } catch (error) {
      // Observe auth failure and update status
      if (isProviderAuthError(error)) {
        authManager.invalidateCache(this.id);
        await authManager.verifyProvider(this.id);

        const authError = createProviderAuthError(this.id, error);
        return {
          providerId: this.id,
          ok: false,
          text: aggregated || null,
          errorCode: 'AUTH_REQUIRED',
          latencyMs: Date.now() - startTime,
          meta: {
            error: authError.toString(),
            details: authError.details,
            conversationId: conversationIdIn,
            parentMessageId: parentMessageIdIn,
          },
        };
      }

      if (_isRetry) {
        return {
          providerId: this.id,
          ok: false,
          text: aggregated || null,
          errorCode: (error && (error.code || error.type)) || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: error?.toString?.() || String(error),
            details: error?.details,
            conversationId: conversationIdIn,
            parentMessageId: parentMessageIdIn,
          },
        };
      }

      try {
        const recovery = await errorHandler.handleProviderError(error, this.id, {
          providerId: this.id,
          prompt: prompt?.substring(0, 200),
          operation: async () => {
            return await this.sendContinuation(
              prompt,
              providerContext,
              sessionId,
              onChunk,
              signal,
              true,
            );
          },
        });
        if (recovery) return recovery;
      } catch (handledError) {
        return {
          providerId: this.id,
          ok: false,
          text: aggregated || null,
          errorCode: handledError.code || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: handledError.toString(),
            details: handledError.details,
            conversationId: conversationIdIn,
            parentMessageId: parentMessageIdIn,
          },
        };
      }
    }
  }
}



================================================
FILE: src/providers/chatgpt.js
================================================
/**
 * HTOS ChatGPT Provider Implementation (scaffold)
 *
 * This module wires ChatGPT integration following existing provider patterns.
 * It retrieves Arkose and PoW tokens via BusController (from the oi iframe)
 * and exposes a simple ask() that currently returns a mocked response.
 *
 * Build-phase safe: emitted to dist/adapters/*
 */
import { BusController, utils } from "../core/vendor-exports.js";

// Removed stub ChatGPTProviderController (duplicate)
// =============================================================================
// CHATGPT MODELS CONFIGURATION
// =============================================================================
export const ChatGPTModels = {
  auto: {
    id: "auto",
    name: "Auto",
    description: "Use the best available model",
    maxTokens: 128000,
  },
  "gpt-4o": {
    id: "gpt-4o",
    name: "GPT-4o",
    description: "OpenAI multimodal model",
    maxTokens: 128000,
  },
};

// =============================================================================
// ARKOSE ENFORCEMENT CONFIG (extracted from arkose logic docs)
// =============================================================================

// Default AE configuration - can be overridden at runtime
const DEFAULT_AE_CONFIG = {
  modelRegex: ".*",
  scriptLoadTimeout: 5000,
  tokenFetchTimeout: 5000,
  requirements: {
    $p: "p",
    url: "https://chatgpt.com/backend-api/sentinel/chat-requirements",
    headerName: "Openai-Sentinel-Chat-Requirements-Token",
    dxPath: "arkose.dx",
    arkoseRequiredPath: "arkose.required",
    tokenPath: "token",
  },
  iframeUrl: "https://tcr9i.chat.openai.com/",
  dxUrl: "https://chatgpt.com/backend-api/sentinel/arkose/dx",
  chatUrl: "https://chatgpt.com",
  bodyStartsWith: "bda=",
  siteParam: "site",
  dataSiteParam: "data[site]",
  dataKey: "data",
  blobKey: "blob",
  selectorKey: "selector",
  onErrorKey: "onError",
  onCompletedKey: "onCompleted",
  resultTokenKey: "token",
  headerName: "Openai-Sentinel-Arkose-Token",
  script: {
    src: "https://tcr9i.chat.openai.com/fc/gc/?render=explicit",
    "data-status": "loading",
    "data-callback": "useArkoseSetupEnforcement",
  },
  params: { mode: "inline" },
  parameters: {
    capi_mode: "lightbox",
    capi_version: "1.5.2",
    capi_settings: null,
    public_key: "35536E1E-65B4-4D96-9D97-6ADB7EFF8147",
    target_html: "challenge",
    surl: "https://tcr9i.chat.openai.com",
    data: undefined,
    language: undefined,
    isSDK: undefined,
    siteData: {
      location: {
        ancestorOrigins: {},
        href: "https://chatgpt.com/?model=gpt-4",
        origin: "https://chatgpt.com",
        protocol: "https:",
        host: "chatgpt.com",
        hostname: "chatgpt.com",
        port: "",
        pathname: "/",
        hash: "",
      },
    },
    styletheme: "default",
    accessibilitySettings: { lockFocusToModal: true },
  },
  pow: {
    $required: "required",
    $proofofwork: "proofofwork",
    $seed: "seed",
    $difficulty: "difficulty",
    $dpl: "dpl",
    prefix: "gAAAAAB",
    headerName: "Openai-Sentinel-Proof-Token",
  },
};

// Runtime AE configuration - merges defaults with any runtime overrides
let AE_CONFIG = { ...DEFAULT_AE_CONFIG };

// Helper function to update AE config at runtime
function updateAEConfig(runtimeConfig) {
  AE_CONFIG = {
    ...DEFAULT_AE_CONFIG,
    ...runtimeConfig,
    // Deep merge nested objects
    requirements: {
      ...DEFAULT_AE_CONFIG.requirements,
      ...(runtimeConfig.requirements || {}),
    },
    pow: {
      ...DEFAULT_AE_CONFIG.pow,
      ...(runtimeConfig.pow || {}),
    },
    parameters: {
      ...DEFAULT_AE_CONFIG.parameters,
      ...(runtimeConfig.parameters || {}),
    },
  };
}

// =============================================================================
// CHATGPT ERROR TYPES
// =============================================================================
export class ChatGPTProviderError extends Error {
  constructor(type, details) {
    super(type);
    this.name = "ChatGPTProviderError";
    this.type = type;
    this.details = details;
  }
  get is() {
    return {
      login: this.type === "login",
      badModel: this.type === "badModel",
      badApiKey: this.type === "badApiKey",
      requestsLimit: this.type === "requestsLimit",
      messageTooLong: this.type === "messageTooLong",
      failedToReadResponse: this.type === "failedToReadResponse",
      aborted: this.type === "aborted",
      network: this.type === "network",
      unknown: this.type === "unknown",
    };
  }
}

// =============================================================================
// CHATGPT PROVIDER CONTROLLER
// =============================================================================
export class ChatGPTProviderController {
  constructor(dependencies = {}) {
    this.initialized = false;
    this.api = new ChatGPTSessionApi(dependencies);
  }

  async init() {
    if (this.initialized) return;
    // Register Bus events for cross-context usage (optional parity with others)
    if (typeof BusController !== "undefined" && BusController.on) {
      BusController.on("chatgpt.ask", this._handleAskRequest.bind(this));
    }
    this.initialized = true;
  }

  async _handleAskRequest(payload) {
    return await this.api.ask(
      payload.prompt,
      payload.options || {},
      payload.onChunk || (() => { }),
    );
  }

  // Public accessors/utilities
  get chatgptSession() {
    return this.api;
  }
  isOwnError(e) {
    return this.api.isOwnError(e);
  }
  // Optional availability check used by adapter.healthCheck()
  async isAvailable() {
    try {
      const bus =
        (typeof self !== "undefined" && self.bus) ||
        (typeof globalThis !== "undefined" && globalThis.bus) ||
        (typeof BusController !== "undefined" && BusController);

      if (bus?.poll) {
        // If Offscreen/oi pipeline is alive, this resolves quickly
        await bus.poll("startup.oiReady");
      }
      return true;
    } catch (_) {
      return false;
    }
  }

  // ---------------------------------------------------------------------------
  // Compatibility wrappers for existing callers in sw-entry.js
  // ---------------------------------------------------------------------------
  async _fetchRequirements() {
    await this.api._ensureAccessToken();
    const reqProof = await this.api._getRequirementsProofToken();
    return await this.api._fetchRequirements(reqProof);
  }

  async _generateProofToken(seed, difficulty) {
    const token = await this.api._generateProofToken({ seed, difficulty });
    return { token };
  }

  async _retrieveArkoseToken(dx) {
    const token = await this.api._retrieveArkoseToken(dx);
    return { token };
  }

  async _getAccessToken() {
    // Thin passthrough used by sw-entry.js / runtime message handlers
    // Return a structured object so callers always receive a predictable shape
    try {
      const token = await this.api._ensureAccessToken();
      return { accessToken: token || null };
    } catch (e) {
      // Do not rethrow here â€” return an error object so background RPCs get a meaningful
      // failure response rather than causing uncaught exceptions in the message handler.
      return { error: (e && e.message) || String(e) };
    }
  }

  // Public method to update AE configuration at runtime
  updateAEConfig(runtimeConfig) {
    updateAEConfig(runtimeConfig);
    return AE_CONFIG;
  }

  // Public method to get current AE configuration
  getAEConfig() {
    return { ...AE_CONFIG };
  }
}

// =============================================================================
// CHATGPT SESSION API
// =============================================================================
export class ChatGPTSessionApi {
  constructor({ sharedState, utils, fetchImpl = fetch } = {}) {
    this._logs = true;
    this.sharedState = sharedState;
    this.utils = utils;
    this.fetch = fetchImpl;
    this._debug = false;
    this._sessionDebug = false;
    // Bind/wrap
    this.ask = this._wrapMethod(this.ask);
    // ephemeral caches
    this._accessToken = null;
    this._requirementsProofToken = null;
    this._requirementsProofTokenExpiresAt = 0;
    this._scriptsCache = null;
    this._scriptsCacheExpiresAt = 0;
  }

  // Helper: return the shared `htos` object if present (page or global)
  _getHtos() {
    try {
      if (typeof window !== "undefined" && window.htos) return window.htos;
      if (typeof globalThis !== "undefined" && globalThis.htos)
        return globalThis.htos;
    } catch (e) { }
    return null;
  }

  // Helper: return an RPC/bus object to use for ai-related calls
  _getHtosBus() {
    // Prefer the page-provided bus (offscreen), then the initialized background bus
    const htos = this._getHtos();
    if (htos?.$bus) return htos.$bus;
    try {
      if (typeof self !== "undefined" && self.bus) return self.bus;
      if (typeof globalThis !== "undefined" && globalThis.bus)
        return globalThis.bus;
      // Final fallback: return the controller object (may be uninitialized)
      if (typeof BusController !== "undefined" && BusController)
        return BusController;
    } catch (e) { }
    return null;
  }

  isOwnError(e) {
    return e instanceof ChatGPTProviderError;
  }

  /**
   * Ask ChatGPT with mandatory Arkose preflight and PoW.
   */
  async ask(prompt, options = {}, onChunk = () => { }) {
    const dbg = (...args) => {
      if (this._debug) console.debug(...args);
    };
    // For log safety only: prepare a display-limited version without altering the actual prompt
    const safeDisplayPrompt =
      typeof prompt === "string"
        ? prompt.length > 300
          ? prompt.slice(0, 300) + "..."
          : prompt
        : "";
    // NOTE: prompt display logging moved to adapter layer to avoid duplicate logs.
    // Keep no-op here to avoid double-logging of the same prompt.

    const {
      signal,
      model = this._model,
      chatId = null,
      parentMessageId = null,
      attachments = [],
    } = options || {};

    // Ensure offscreen (oi) is ready for token generation

    // Give the offscreen document a moment to initialize if this is the first call
    // This helps avoid race conditions during extension startup
    if (!this._offscreenEverReady) {
      // [ChatGPT Debug] First offscreen check, adding initialization delay
      await new Promise((resolve) => setTimeout(resolve, 500));
    }

    const __chatgpt_offscreen_poll_start = Date.now();
    // Safely attempt to poll the offscreen/oi readiness via available bus implementation
    const __chatgpt_offscreen_bus = this._getHtosBus();
    let __chatgpt_offscreen_ready = false;

    if (__chatgpt_offscreen_bus?.poll) {
      try {
        // Try polling with a longer timeout and retry logic
        const __chatgpt_poll_timeout_ms = 8000; // Give more time for initial setup
        let retries = 2;

        while (retries > 0 && !__chatgpt_offscreen_ready) {
          try {
            const pollPromise = __chatgpt_offscreen_bus.poll("startup.oiReady");
            const timeoutPromise = new Promise((_, reject) =>
              setTimeout(
                () => reject(new Error("poll_timeout")),
                __chatgpt_poll_timeout_ms,
              ),
            );
            __chatgpt_offscreen_ready = await Promise.race([
              pollPromise,
              timeoutPromise,
            ]);

            if (__chatgpt_offscreen_ready) {
              this._offscreenEverReady = true;
              break;
            }
          } catch (innerError) {
            if (this._debug)
              console.warn(
                `[ChatGPT Debug] Poll attempt failed, retries left: ${retries - 1
                }`,
                innerError,
              );
            retries--;
            if (retries > 0) {
              await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1s between retries
            }
          }
        }
      } catch (e) {
        if (String(e).includes("poll_timeout")) {
          if (this._debug)
            console.warn("[ChatGPT Debug] poll startup.oiReady timed out", {
              ts: Date.now(),
              dur: Date.now() - __chatgpt_offscreen_poll_start,
            });
        } else {
          if (this._debug)
            console.error("[ChatGPT Debug] poll startup.oiReady error", e, {
              ts: Date.now(),
              dur: Date.now() - __chatgpt_offscreen_poll_start,
            });
        }
        __chatgpt_offscreen_ready = false;
      }
    } else {
      if (this._debug)
        console.warn("[ChatGPT Debug] No bus.poll method available");
      __chatgpt_offscreen_ready = false;
    }

    if (this._debug)
      console.log("[ChatGPT Debug] poll startup.oiReady result", {
        result: __chatgpt_offscreen_ready,
        ts: Date.now(),
        dur: Date.now() - __chatgpt_offscreen_poll_start,
      });

    // Fail fast if offscreen isn't ready to avoid cascading errors later
    if (!__chatgpt_offscreen_ready) {
      this._throw(
        "offscreen_not_ready",
        "The Arkose solver (offscreen iframe) did not respond in time.",
      );
    }

    try {
      const __bg_bus = this._getHtosBus();
      if (__bg_bus?.poll) {
        await __bg_bus.poll("startup.oiReady");
      } else {
        this._sesWarn(
          "[ChatGPT Session] No bus.poll available in background context",
        );
      }
    } catch (error) {
      this._sesWarn(
        "[ChatGPT Session] Offscreen (oi) readiness check failed:",
        error,
      );
    }

    // Ensure we have (or tried to get) access token
    this._sesLog("[ChatGPT Session] Ensuring access token...");
    await this._ensureAccessToken();
    const hasToken = !!this._accessToken;
    this._sesLog(
      `[ChatGPT Session] Access token status: ${hasToken ? "present" : "missing"
      }`,
    );

    if (!hasToken) {
      this._throw("login", "Failed to retrieve access token. Please log in to ChatGPT.");
    }

    // 1) Generate lightweight proof for requirements call
    const reqProof = await this._getRequirementsProofToken();

    // 2) Sentinel preflight
    const requirements = await this._fetchRequirements(reqProof);

    // 3) Build ask payload
    // If think-mode requested, force the thinking-capable model slug used by webchat.
    const selectedModel = options?.think === true ? "gpt-5-t-mini" : model;
    const body = this._buildAskBody(prompt, {
      model: selectedModel,
      chatId,
      parentMessageId,
      attachments,
      think: options?.think === true,
    });

    // 4) Headers baseline
    const headers = {
      accept: "text/event-stream",
      origin: AE_CONFIG.chatUrl,
      referer: `${AE_CONFIG.chatUrl}/`,
      "content-type": "application/json",
    };

    // 5) Inject AE (requirements token, PoW, Arkose) into headers
    try {
      await this._injectAEHeaders(headers, requirements);
    } catch (e) {
      console.error("[ChatGPT Session] AE header injection failed:", e);
      // Re-throw with additional context for debugging
      if (e instanceof ChatGPTProviderError) {
        throw e; // Already properly formatted
      }
      throw new ChatGPTProviderError(
        "aeHeaderInjectionFailed",
        `Failed to inject AE headers: ${e.message || e}`,
      );
    }

    // 6) Execute ask via authenticated fetch
    const res = await this._fetchAuth("/backend-api/conversation", {
      method: "POST",
      headers,
      body,
      signal,
    });

    this._sesLog(`[ChatGPT Session] Response status: ${res.status}`);

    if (res.status !== 200) {
      const errJson = await this._safeJson(res);
      console.error(
        `[ChatGPT Session] Request failed with status ${res.status}:`,
        errJson,
      );
      if (res.status === 429) this._throw("tooManyRequests", errJson);
      if (res.status === 403) this._throw("forbidden", errJson);
      if (res.status === 503) this._throw("serverError", errJson);
      if (res.status === 413) this._throw("messageTooLong", errJson);
      if (res.status === 404) this._throw("chatNotFound", errJson);
      if (res.status === 400) this._throw("badRequest", errJson);
      this._throw("unknown", errJson);
    }

    const ct = (res.headers.get("content-type") || "").toLowerCase();

    // Prefer SSE path
    if (ct.includes("text/event-stream")) {
      this._sesLog("[ChatGPT Session] Processing SSE stream...");
      const reader = res.body.getReader();
      let carry = "";
      let aggText = "";
      let done = false;
      let chunkCount = 0;

      try {
        while (!done) {
          const { value, done: d } = await reader.read();
          done = d;
          if (value) {
            chunkCount++;
            const chunk = new TextDecoder().decode(value);
            const { dataEvents, remainder } = this._splitSSE(carry + chunk);
            carry = remainder;

            for (const line of dataEvents) {
              const parsed = this._parseSSEData(line);
              if (!parsed) continue;
              const { text, id, finishDetails, conversationId } = parsed;
              if (text) {
                aggText = text; // parsed.text is cumulative

                onChunk({
                  id,
                  text: aggText,
                  chatId: conversationId,
                  finishDetails,
                  model: selectedModel,
                  partial: true,
                });
              }
            }
          }
        }
        this._sesLog(
          `[ChatGPT Session] SSE stream completed. Total chunks: ${chunkCount}, final text length: ${aggText.length}`,
        );
      } catch (e) {
        console.error("[ChatGPT Session] SSE stream error:", e);
        if (!String(e).includes("aborted")) {
          this._throw("failedToReadResponse", this._safeString(e));
        }
      } finally {
        try {
          reader.releaseLock();
        } catch { }
      }
      return { text: aggText, model: selectedModel };
    }

    // If server responds JSON (WSS bootstrap), we don't support WSS here.
    this._throw(
      "failedToReadResponse",
      "Unexpected response type; WSS not supported in this path",
    );
  }

  // =============================================================================
  // PRIVATE HELPERS
  // =============================================================================
  get _model() {
    return (
      this.sharedState?.ai?.connections?.get?.("openai-session")?.selectedOption
        ?.id || "auto"
    );
  }

  _wrapMethod(fn) {
    return async (...args) => {
      try {
        return await fn.call(this, ...args);
      } catch (e) {
        let err;
        if (this.isOwnError(e)) err = e;
        else if (String(e) === "TypeError: Failed to fetch")
          err = this._createError("network", e.message);
        else if (String(e)?.includes("aborted"))
          err = this._createError("aborted", e.message);
        else err = this._createError("unknown", e.message);

        if (err.details) this._logError(err.message, err.details);
        else this._logError(err.message);
        throw err;
      }
    };
  }

  _throw(type, details) {
    throw this._createError(type, details);
  }
  _createError(type, details) {
    return new ChatGPTProviderError(type, details);
  }
  _safeString(e) {
    try {
      return String(e);
    } catch {
      return "[error]";
    }
  }
  _logError(...args) {
    if (this._logs) console.error("ChatGPTSessionApi:", ...args);
  }

  // ---- AE + Auth helpers ----
  _url(path) {
    return `${AE_CONFIG.chatUrl}${path}`;
  }

  async _ensureAccessToken() {
    if (this._accessToken) return this._accessToken;
    try {
      const res = await this.fetch(this._url("/api/auth/session"), {
        credentials: "include",
      });
      if (res.status === 429) this._throw("tooManyRequests");
      if (res.status === 403) this._throw("cloudflare");
      const j = await res.json().catch(() => ({}));
      this._accessToken = j?.accessToken || null;
      return this._accessToken;
    } catch (e) {
      return null;
    }
  }

  async _getDeviceId() {
    try {
      if (typeof chrome !== "undefined" && chrome?.cookies?.get) {
        const c = await chrome.cookies.get({
          url: AE_CONFIG.chatUrl,
          name: "oai-did",
        });
        return c?.value || undefined;
      }
    } catch { }
    return undefined;
  }

  async _fetchAuth(path, opts = {}) {
    const did = await this._getDeviceId();
    const headers = {
      "OAI-Device-Id": did,
      "OAI-Language": "en-US",
      ...(opts.headers || {}),
    };
    const payload = { ...opts, headers };
    if (payload.body && typeof payload.body !== "string")
      payload.body = JSON.stringify(payload.body);

    // Ensure cookies are sent for endpoints that rely on session cookies
    const fetchOptions = {
      ...payload,
      headers: {
        ...headers,
        ...(this._accessToken
          ? { Authorization: `Bearer ${this._accessToken}` }
          : {}),
      },
      credentials: payload.credentials || "include",
    };

    let res;
    try {
      res = await this.fetch(this._url(path), fetchOptions);
    } catch (fetchErr) {
      // Network-level failure (CORS, connection reset, offline, etc.)
      console.error(
        "[ChatGPT Session] Network fetch failed for",
        this._url(path),
        fetchErr,
      );
      // Re-throw so upstream error handling can classify it
      throw fetchErr;
    }

    if (res.status === 401) {
      await this._ensureAccessToken();
      if (!this._accessToken) this._throw("badAccessToken");
      try {
        res = await this.fetch(this._url(path), {
          ...fetchOptions,
          headers: {
            ...headers,
            Authorization: `Bearer ${this._accessToken}`,
          },
        });
      } catch (fetchErr) {
        console.error(
          "[ChatGPT Session] Network fetch retry failed for",
          this._url(path),
          fetchErr,
        );
        throw fetchErr;
      }
      if (res.status === 401) {
        this._accessToken = null;
        this._throw("badAccessToken");
      }
    }
    if (res.status === 403 || res.status === 418) this._throw("cloudflare");
    return res;
  }

  async _getScripts() {
    const now = Date.now();
    if (this._scriptsCache && this._scriptsCacheExpiresAt > now)
      return this._scriptsCache;
    try {
      const html = await this.fetch(AE_CONFIG.chatUrl).then((r) => r.text());
      const scripts = [...html.matchAll(/src="([^"]*)"/g)].map((m) => m[1]);
      this._scriptsCache = scripts.length ? scripts : [null];
    } catch {
      this._scriptsCache = [null];
    }
    this._scriptsCacheExpiresAt = now + 60 * 60 * 1000; // 1 hour
    return this._scriptsCache;
  }

  async _getDpl() {
    const scripts = await this._getScripts();
    const key = AE_CONFIG.pow.$dpl;
    for (const s of scripts) {
      try {
        const u = new URL(s);
        const v = u.searchParams.get(key);
        if (v) return `${key}=${v}`;
      } catch { }
    }
    return null;
  }

  // Helper: send BusController RPC with timeout + retry and logging
  async _busSendWithTimeout(
    action,
    payload,
    { timeoutMs = 12000, retries = 1 } = {},
  ) {
    const attempt = async () => {
      try {
        const truncatedPayload = JSON.stringify(payload).slice(0, 200) + "...";
        this._sesLog(
          `[ChatGPT Session] Bus call: ${action} payload=${truncatedPayload}`,
        );
        const bus = this._getHtosBus();
        if (!bus || typeof bus.send !== "function") {
          throw new Error("bus_unavailable");
        }
        const sendPromise = bus.send(action, payload);
        const timeoutPromise = new Promise((_, reject) =>
          setTimeout(() => reject(new Error("timeout")), timeoutMs),
        );
        const res = await Promise.race([sendPromise, timeoutPromise]);
        return res;
      } catch (e) {
        this._sesLog(`[ChatGPT Session] Bus response: ${action} result=error`);
        console.warn(
          `[ChatGPTSessionApi] BusController.send failed: ${action}`,
          e,
        );
        throw e;
      }
    };

    let lastErr = null;
    for (let i = 0; i <= retries; i++) {
      try {
        return await attempt();
      } catch (e) {
        lastErr = e;
        if (i < retries) {
          this._sesLog(
            `[ChatGPTSessionApi] Retrying BusController.send ${action} (attempt ${i + 2
            })`,
          );
        }
      }
    }

    // If we get here, all attempts failed
    if (String(lastErr).toLowerCase().includes("timeout")) {
      console.error(
        `[ChatGPT Session] Bus call ${action} timed out after ${timeoutMs}ms with ${retries} retries`,
      );
      throw this._createError("arkose_timeout", {
        action,
        timeoutMs,
        retries,
        context: "Bus operation timeout",
      });
    }
    console.error(
      `[ChatGPT Session] Bus call ${action} failed after ${retries} retries:`,
      lastErr,
    );
    throw lastErr;
  }

  async _generateProofToken({ seed, difficulty }) {
    const scripts = await this._getScripts();
    const dpl = await this._getDpl();
    try {
      const __chatgpt_gen_start = Date.now();
      const __chatgpt_gen_payload = {
        seed,
        difficulty,
        scripts,
        dpl,
      };
      if (this._debug)
        console.log("[ChatGPT Debug] about to call ai.generateProofToken", {
          ts: Date.now(),
          payload: { seed, difficulty, scripts: scripts?.length || 0, dpl },
        });
      // Use bus send with timeout helper to avoid hanging the session
      const __chatgpt_gen_res = await this._busSendWithTimeout(
        "ai.generateProofToken",
        __chatgpt_gen_payload,
        { timeoutMs: 15000, retries: 2 },
      ).catch((e) => {
        // Always surface errors; debug gating should not suppress failures
        console.error("[ChatGPT] ai.generateProofToken error", e, {
          ts: Date.now(),
          dur: Date.now() - __chatgpt_gen_start,
        });
        throw e;
      });
      if (this._debug)
        console.log("[ChatGPT Debug] ai.generateProofToken response", {
          res: __chatgpt_gen_res,
          ts: Date.now(),
          dur: Date.now() - __chatgpt_gen_start,
        });
      // Validate the response â€“ it must be a non-empty string. Structured
      // error objects or null/undefined should be treated as failures.
      if (!__chatgpt_gen_res || typeof __chatgpt_gen_res !== "string") {
        const errMsg =
          typeof __chatgpt_gen_res === "object" && __chatgpt_gen_res?.error
            ? __chatgpt_gen_res.error
            : "Invalid proof token response";
        throw this._createError("powGenerationFailed", errMsg);
      }
      return `${AE_CONFIG.pow.prefix}${__chatgpt_gen_res}`;
    } catch (e) {
      // Surface error for upstream handling
      this._logError("generateProofToken failed", e);
      throw e;
    }
  }

  async _getRequirementsProofToken() {
    const now = Date.now();
    if (
      this._requirementsProofToken &&
      this._requirementsProofTokenExpiresAt > now
    )
      return this._requirementsProofToken;

    // Do NOT exercise Arkose/PoW bus for the requirements call when difficulty is 0.
    // Many environments do not require a proof for chat-requirements; attempting to
    // generate one causes avoidable timeouts when the offscreen iframe is not ready
    // or scripts discovery returns [null]. We return null to indicate "no proof".
    try {
      this._requirementsProofToken = null;
      // cache the decision briefly to avoid thrashing this path
      this._requirementsProofTokenExpiresAt = now + 5 * 60 * 1000; // 5 minutes
      return null;
    } catch (_) {
      this._requirementsProofToken = null;
      this._requirementsProofTokenExpiresAt = now + 60 * 1000; // 1 minute
      return null;
    }
  }

  async _fetchRequirements(reqProof) {
    const url = AE_CONFIG.requirements?.url;
    if (!url) {
      throw new ChatGPTProviderError(
        "requirementsConfigMissing",
        "Requirements URL not configured in AE_CONFIG",
      );
    }
    // Only include the proof param if we actually have one
    const body = reqProof ? { [AE_CONFIG.requirements.$p]: reqProof } : {};
    const headers = this._accessToken
      ? { Authorization: `Bearer ${this._accessToken}` }
      : undefined;
    try {
      let res = await this.fetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(body),
      });

      // Retry on 401 (Token Expired) - critical for forced context resets or long idle times
      if (res.status === 401) {
        this._sesLog("[ChatGPT Session] Requirements 401, refreshing token...");
        this._accessToken = null;
        await this._ensureAccessToken();

        const newHeaders = this._accessToken
          ? { Authorization: `Bearer ${this._accessToken}` }
          : undefined;

        res = await this.fetch(url, {
          method: "POST",
          headers: newHeaders,
          body: JSON.stringify(body),
        });
      }

      if (!res.ok) {
        throw new ChatGPTProviderError(
          "requirementsFetchFailed",
          `Requirements fetch failed with status ${res.status}: ${res.statusText}`,
        );
      }
      return await res.json();
    } catch (e) {
      // Catch 'Failed to fetch' which often happens on opaque redirects to login (CORS)
      if (String(e).includes("Failed to fetch")) {
        this._sesLog("[ChatGPT Session] Requirements fetch failed (network), attempting token refresh...");
        this._accessToken = null;
        await this._ensureAccessToken();

        if (this._accessToken) {
          try {
            const newHeaders = { Authorization: `Bearer ${this._accessToken}` };
            const res = await this.fetch(url, {
              method: "POST",
              headers: newHeaders,
              body: JSON.stringify(body),
            });
            if (res.ok) return await res.json();
          } catch (retryErr) {
            this._logError("requirements fetch retry failed", retryErr);
          }
        }
      }

      this._logError("requirements fetch failed", e);
      if (e instanceof ChatGPTProviderError) {
        throw e;
      }
      throw new ChatGPTProviderError(
        "requirementsFetchFailed",
        `Failed to fetch requirements: ${e.message || e}`,
      );
    }
  }

  _get(obj, path, dflt = undefined) {
    try {
      return path
        .split(".")
        .reduce((acc, k) => (acc == null ? acc : acc[k]), obj);
    } catch {
      return dflt;
    }
  }

  // in chatgpt.js

  async _retrieveArkoseToken(dx) {
    try {
      // When requesting retrieveArkoseToken, send the payload oi.js expects.
      const payload = {
        dx: dx, // The critical fix: use the 'dx' key.
        config: AE_CONFIG, // Pass the current AE config.
        accessToken: this._accessToken, // Pass the access token.
      };

      if (this._debug)
        console.log("[ChatGPT Debug] about to call ai.retrieveArkoseToken", {
          ts: Date.now(),
          payload: {
            dx: "<redacted-for-logs>",
            config: "omitted",
            accessToken: "omitted",
          },
        });
      const __chatgpt_ret_start = Date.now();

      // Use the corrected payload in the bus call
      const __chatgpt_ret_res = await this._busSendWithTimeout(
        "ai.retrieveArkoseToken",
        payload,
        { timeoutMs: 15000, retries: 2 },
      ).catch((e) => {
        // Always surface errors; debug gating should not suppress failures
        console.error("[ChatGPT] ai.retrieveArkoseToken error", e, {
          ts: Date.now(),
          dur: Date.now() - __chatgpt_ret_start,
        });
        throw e;
      });

      if (this._debug)
        console.log("[ChatGPT Debug] ai.retrieveArkoseToken response", {
          res: __chatgpt_ret_res,
          ts: Date.now(),
          dur: Date.now() - __chatgpt_ret_start,
        });
      return __chatgpt_ret_res;
    } catch (e) {
      this._logError("arkose token retrieval failed", e);
      // Surface the error instead of silently returning null so callers
      // can handle/abort the ChatGPT flow properly.
      throw e;
    }
  }

  async _injectAEHeaders(headers, requirements) {
    if (!requirements) return headers;

    // Sentinel token header
    const sentinelToken = this._get(
      requirements,
      AE_CONFIG.requirements.tokenPath,
    );
    if (sentinelToken && AE_CONFIG.requirements.headerName) {
      headers[AE_CONFIG.requirements.headerName] = sentinelToken;
    }

    // PoW header - fail fast if required but generation fails
    const pow = requirements?.[AE_CONFIG.pow.$proofofwork];
    if (pow?.[AE_CONFIG.pow.$required]) {
      this._sesLog("[ChatGPT Session] PoW token required, generating...");
      const seed = pow?.[AE_CONFIG.pow.$seed];
      const difficulty = pow?.[AE_CONFIG.pow.$difficulty];

      if (!seed || !difficulty) {
        throw new ChatGPTProviderError(
          "powParametersMissing",
          `PoW required but missing parameters: seed=${!!seed}, difficulty=${!!difficulty}`,
        );
      }

      try {
        const token = await this._generateProofToken({ seed, difficulty });
        if (!token) {
          throw new ChatGPTProviderError(
            "powGenerationFailed",
            "PoW token generation returned null/empty result",
          );
        }
        headers[AE_CONFIG.pow.headerName] = token;
      } catch (e) {
        // Keep error logs visible regardless of debug flag
        console.error("[ChatGPT Session] PoW token generation failed:", e);
        const isTimeout = String(e).toLowerCase().includes("timeout");
        throw new ChatGPTProviderError(
          isTimeout ? "powTimeout" : "powGenerationFailed",
          `Failed to generate PoW token${isTimeout ? " (timeout)" : ""}: ${e.message || e
          }`,
        );
      }
    }

    // Arkose header - fail fast if required but generation fails
    const arkoseRequired = !!this._get(
      requirements,
      AE_CONFIG.requirements.arkoseRequiredPath,
    );
    if (arkoseRequired) {
      this._sesLog("[ChatGPT Session] Arkose token required, retrieving...");
      const dx = this._get(requirements, AE_CONFIG.requirements.dxPath);

      if (!dx) {
        throw new ChatGPTProviderError(
          "arkoseParametersMissing",
          "Arkose required but dx parameter is missing from requirements",
        );
      }

      try {
        const arkoseToken = await this._retrieveArkoseToken(dx);
        if (!arkoseToken) {
          throw new ChatGPTProviderError(
            "arkoseRetrievalFailed",
            "Arkose token retrieval returned null/empty result",
          );
        }
        headers[AE_CONFIG.headerName] = arkoseToken;
      } catch (e) {
        // Keep error logs visible regardless of debug flag
        console.error("[ChatGPT Session] Arkose token retrieval failed:", e);
        const isTimeout = String(e).toLowerCase().includes("timeout");
        throw new ChatGPTProviderError(
          isTimeout ? "arkoseTimeout" : "arkoseRetrievalFailed",
          `Failed to retrieve Arkose token${isTimeout ? " (timeout)" : ""}: ${e.message || e
          }`,
        );
      }
    }

    return headers;
  }

  _buildAskBody(
    prompt,
    { model, chatId, parentMessageId, attachments, think = false },
  ) {
    const msgId =
      utils?.id?.uuid?.() ||
      crypto?.randomUUID?.() ||
      `${Date.now()}-${Math.random()}`;
    const parentId =
      parentMessageId ||
      utils?.id?.uuid?.() ||
      crypto?.randomUUID?.() ||
      `${Date.now()}-${Math.random()}`;
    const wsReqId =
      utils?.id?.uuid?.() ||
      crypto?.randomUUID?.() ||
      `${Date.now()}-${Math.random()}`;
    const baseMessage = {
      id: msgId,
      author: { role: "user" },
      content: {
        content_type: attachments?.length ? "multimodal_text" : "text",
        parts: attachments?.length ? [prompt] : [prompt],
      },
      metadata: think ? { htos_think: true } : {},
    };
    return {
      action: "next",
      messages: [baseMessage],
      model,
      parent_message_id: parentId,
      conversation_id: chatId || undefined,
      timezone_offset_min: new Date().getTimezoneOffset(),
      websocket_request_id: wsReqId,
      force_paragen: false,
      force_nulligen: false,
      force_rate_limit: false,
      force_paragen_model_slug: "",
      history_and_training_disabled: false,
      conversation_mode: { kind: "primary_assistant" },
    };
  }

  _splitSSE(buffer) {
    const lines = buffer.split("\n");
    const dataEvents = [];
    let remainder = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line === "") continue;
      if (line === "data: [DONE]") continue;
      if (line.startsWith("data: {")) dataEvents.push(line);
      else if (i === lines.length - 1) remainder = line; // incomplete JSON
    }
    return { dataEvents, remainder };
  }

  _parseSSEData(line) {
    try {
      const json = JSON.parse(line.replace("data: ", "").trim());
      if (json.error) return null;
      const msg = json.message;
      const conversationId = json.conversation_id || null;
      let text = "";
      let id = null;
      let finishDetails = null;
      if (msg) {
        id = msg.id || null;
        finishDetails = msg.metadata?.finish_details?.type || null;
        if (msg.author?.role === "assistant") {
          if (msg.content?.content_type === "text") {
            text = (msg.content?.parts || []).join("");
          } else if (msg.content?.content_type === "code") {
            text = `\n\n${msg.content?.text || ""}`;
          }
        }
      }
      return { text, id, finishDetails, conversationId };
    } catch {
      return null;
    }
  }

  async _safeJson(res) {
    try {
      return await res.json();
    } catch {
      return null;
    }
  }

  // Instance-scoped session logging helpers
  _sesLog(...args) {
    if (this._sessionDebug) console.log(...args);
  }
  _sesWarn(...args) {
    if (this._sessionDebug) console.warn(...args);
  }
}

// =============================================================================
// EXPORTS
// =============================================================================
export default ChatGPTProviderController;
if (typeof window !== "undefined") {
  window.HTOS = window.HTOS || {};
  window.HTOS.ChatGPTProvider = ChatGPTProviderController;
}



================================================
FILE: src/providers/claude-adapter.js
================================================
/**
 * HTOS Claude Provider Adapter
 * - Implements ProviderAdapter interface for Claude
 * - Wraps ClaudeSessionApi with auth recovery
 * 
 * Build-phase safe: emitted to dist/adapters/*
 */
import { authManager } from '../core/auth-manager.js';
import {
  errorHandler,
  isProviderAuthError,
  createProviderAuthError
} from '../utils/ErrorHandler.js';

// Provider-specific adapter debug flag (off by default)
const CLAUDE_ADAPTER_DEBUG = false;
const pad = (...args) => {
  if (CLAUDE_ADAPTER_DEBUG) console.log(...args);
};

export class ClaudeAdapter {
  constructor(controller) {
    this.id = "claude";
    this.capabilities = {
      needsDNR: false,
      needsOffscreen: false,
      supportsStreaming: true,
      supportsContinuation: true,
      synthesis: false,
    };
    this.controller = controller;
  }

  /**
   * Initialize the adapter
   */
  async init() {
    return;
  }

  /**
   * Check if the provider is available and working
   */
  async healthCheck() {
    try {
      return await this.controller.isAvailable();
    } catch (error) {
      return false;
    }
  }

  /**
   * Unified ask API: prefer continuation when chatId/threadUrl exists, else start new.
   */
  async ask(prompt, providerContext = null, sessionId = undefined, onChunk = undefined, signal = undefined) {
    try {
      const meta = providerContext?.meta || providerContext || {};
      const hasChat = Boolean(
        meta.chatId || providerContext?.chatId || providerContext?.threadUrl,
      );

      pad(`[ProviderAdapter] ASK_STARTED provider=${this.id} hasContext=${hasChat}`);

      let res;
      if (hasChat) {
        res = await this.sendContinuation(prompt, providerContext, sessionId, onChunk, signal);
      } else {
        res = await this.sendPrompt({ originalPrompt: prompt, sessionId, meta }, onChunk, signal);
      }

      try {
        const len = (res?.text || "").length;
        pad(`[ProviderAdapter] ASK_COMPLETED provider=${this.id} ok=${res?.ok !== false} textLen=${len}`);
      } catch (_) { }

      return res;
    } catch (e) {
      console.warn(`[ProviderAdapter] ASK_FAILED provider=${this.id}:`, e?.message || String(e));
      throw e;
    }
  }

  async sendPrompt(req, onChunk, signal, _isRetry = false) {
    const startTime = Date.now();
    let aggregatedText = "";

    try {
      // Send prompt to Claude with streaming via callback
      const result = await this.controller.claudeSession.ask(
        req.originalPrompt,
        { signal, chatId: req.meta?.chatId },
        ({ text, chatId, orgId }, isFirstChunk) => {
          if (!this.capabilities.supportsStreaming || !onChunk) return;
          aggregatedText = text || aggregatedText;
          // Forward partials to orchestrator/port
          onChunk({
            providerId: this.id,
            ok: true,
            id: chatId || req.reqId,
            text: aggregatedText,
            partial: true,
            latencyMs: Date.now() - startTime,
            meta: { orgId, chatId },
          });
        },
      );

      // Ensure final text is returned
      aggregatedText = result?.text ?? aggregatedText;

      return {
        providerId: this.id,
        ok: true,
        id: result?.chatId || req.meta?.chatId || req.reqId,
        text: aggregatedText,
        partial: false,
        latencyMs: Date.now() - startTime,
        meta: {
          orgId: result?.orgId,
          chatId: result?.chatId || req.meta?.chatId,
        },
      };
    } catch (error) {
      // Use central error handler for provider errors
      if (isProviderAuthError(error)) {
        try {
          return await this._handleAuthError(error, req, onChunk, signal, _isRetry);
        } catch (authError) {
          // If auth recovery fails, return error response
          return {
            providerId: this.id,
            ok: false,
            text: aggregatedText || null,
            errorCode: 'AUTH_REQUIRED',
            latencyMs: Date.now() - startTime,
            meta: {
              error: authError.toString(),
              details: authError.details,
            },
          };
        }
      }

      // Avoid infinite recursion on retries
      if (_isRetry) {
        return {
          providerId: this.id,
          ok: false,
          text: aggregatedText || null,
          errorCode: (error && (error.code || error.type)) || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: error?.toString?.() || String(error),
            details: error?.details,
          },
        };
      }

      // Let error handler deal with other errors with a real retry operation
      try {
        const recovery = await errorHandler.handleProviderError(error, this.id, {
          providerId: this.id,
          prompt: req.originalPrompt?.substring(0, 200),
          operation: async () => {
            // Retry the same request once via the error handler backoff policy
            return await this.sendPrompt(req, onChunk, signal, true);
          },
        });
        // If recovery produced a result, return it
        if (recovery) return recovery;
      } catch (handledError) {
        // Convert handled error to response format
        return {
          providerId: this.id,
          ok: false,
          text: aggregatedText || null,
          errorCode: handledError.code || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: handledError.toString(),
            details: handledError.details,
          },
        };
      }
    }
  }

  async sendContinuation(prompt, providerContext, sessionId, onChunk, signal, _isRetry = false) {
    const startTime = Date.now();
    let aggregatedText = "";

    try {
      const meta = providerContext?.meta || providerContext || {};
      const chatId = providerContext?.chatId ?? meta.chatId ?? providerContext?.threadUrl ?? meta.threadUrl;

      if (!chatId) {
        console.warn(`[ClaudeAdapter] Context missing (no ChatId)`);
        throw new Error("Continuity lost: Missing Claude ChatId for this thread.");
      }

      const result = await this.controller.claudeSession.ask(
        prompt,
        { signal, chatId },
        ({ text, chatId: newChatId, orgId }, isFirstChunk) => {
          if (!this.capabilities.supportsStreaming || !onChunk) return;
          aggregatedText = text || aggregatedText;

          onChunk({
            providerId: this.id,
            ok: true,
            id: newChatId || chatId,
            text: aggregatedText,
            partial: true,
            latencyMs: Date.now() - startTime,
            meta: { orgId, chatId: newChatId || chatId },
          });
        },
      );

      aggregatedText = result?.text ?? aggregatedText;

      pad(`[ClaudeAdapter] providerComplete: claude status=success, latencyMs=${Date.now() - startTime}, textLen=${(aggregatedText || "").length}`);

      return {
        providerId: this.id,
        ok: true,
        id: result?.chatId || chatId,
        text: aggregatedText,
        partial: false,
        latencyMs: Date.now() - startTime,
        meta: {
          orgId: result?.orgId,
          chatId: result?.chatId || chatId,
          threadUrl: result?.chatId || chatId,
        },
      };
    } catch (error) {
      if (isProviderAuthError(error)) {
        try {
          return await this._handleAuthError(error, { originalPrompt: prompt, meta: providerContext }, onChunk, signal, _isRetry, true);
        } catch (authError) {
          return {
            providerId: this.id,
            ok: false,
            text: aggregatedText || null,
            errorCode: 'AUTH_REQUIRED',
            latencyMs: Date.now() - startTime,
            meta: {
              error: authError.toString(),
              details: authError.details,
              chatId: providerContext?.chatId ?? meta.chatId, // Preserve context even on error
            },
          };
        }
      }

      // Avoid infinite recursion on retries
      if (_isRetry) {
        return {
          providerId: this.id,
          ok: false,
          text: aggregatedText || null,
          errorCode: (error && (error.code || error.type)) || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: error?.toString?.() || String(error),
            details: error?.details,
            chatId: providerContext?.chatId,
          },
        };
      }

      try {
        const recovery = await errorHandler.handleProviderError(error, this.id, {
          providerId: this.id,
          prompt: prompt?.substring(0, 200),
          operation: async () => {
            return await this.sendContinuation(prompt, providerContext, sessionId, onChunk, signal, true);
          },
        });
        if (recovery) return recovery;
      } catch (handledError) {
        return {
          providerId: this.id,
          ok: false,
          text: aggregatedText || null,
          errorCode: handledError.code || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: handledError.toString(),
            details: handledError.details,
            chatId: providerContext?.chatId,
          },
        };
      }
    }
  }

  async _handleAuthError(error, req, onChunk, signal, _isRetry, isContinuation = false) {
    console.warn(`[ClaudeAdapter] Auth error: ${error.status || error.message}`);

    // Update auth status
    authManager.invalidateCache(this.id);
    const isStillValid = await authManager.verifyProvider(this.id);

    if (isStillValid && !_isRetry) {
      // Transient issue - retry once
      console.log(`[ClaudeAdapter] Auth verified, retrying...`);
      if (isContinuation) {
        return await this.sendContinuation(req.originalPrompt, req.meta, undefined, onChunk, signal, true);
      } else {
        return await this.sendPrompt(req, onChunk, signal, true);
      }
    }

    // Confirmed auth failure
    throw createProviderAuthError(this.id, error);
  }
}



================================================
FILE: src/providers/claude.js
================================================
/**
 * HTOS Claude Provider Implementation
 *
 * This adapter module provides Claude AI integration following HTOS patterns.
 * Handles Claude.ai session-based authentication using browser cookies.
 *
 * Build-phase safe: emitted to dist/adapters/*
 */
import { BusController } from "../core/vendor-exports.js";
import { ProviderDNRGate } from "../core/dnr-utils.js";
// =============================================================================
// CLAUDE MODELS CONFIGURATION
// =============================================================================
export const ClaudeModels = {
  auto: {
    id: "auto",
    name: "Auto",
    description: "Use the latest available model",
    maxTokens: 190000,
  },
  "claude-sonnet-4-20250514-claude-ai": {
    id: "claude-sonnet-4-20250514-claude-ai",
    name: "Claude 4 Sonnet",
    description: "Smart, efficient model for everyday use",
    maxTokens: 190000,
  },
  "claude-opus-4-20250514-claude-ai-pro": {
    id: "claude-opus-4-20250514-claude-ai-pro",
    name: "Claude 4 Opus",
    description: "Powerful, large model for complex challenges",
    maxTokens: 190000,
  },
  "claude-3-7-sonnet-20250219": {
    id: "claude-3-7-sonnet-20250219",
    name: "Claude 3.7 Sonnet",
    description: "Smart, efficient model for everyday use",
    maxTokens: 190000,
  },
  "claude-3-5-haiku-20241022": {
    id: "claude-3-5-haiku-20241022",
    name: "Claude 3.5 Haiku",
    description: "Fastest model for daily tasks",
    maxTokens: 190000,
  },
};
// =============================================================================
// CLAUDE ERROR TYPES
// =============================================================================
export class ClaudeProviderError extends Error {
  constructor(type, details) {
    super(type);
    this.name = "ClaudeProviderError";
    this.type = type;
    this.details = details;
  }
  get is() {
    return {
      login: this.type === "login",
      tooManyRequests: this.type === "tooManyRequests",
      failedToReadResponse: this.type === "failedToReadResponse",
      freeLimitExceeded: this.type === "freeLimitExceeded",
      badOrgId: this.type === "badOrgId",
      badModel: this.type === "badModel",
      aborted: this.type === "aborted",
      network: this.type === "network",
      unknown: this.type === "unknown",
    };
  }
}
// =============================================================================
// CLAUDE SESSION API
// =============================================================================
export class ClaudeSessionApi {
  constructor({ sharedState, utils, fetchImpl = fetch } = {}) {
    this._logs = true;
    this.sharedState = sharedState;
    this.utils = utils;
    this.fetch = fetchImpl;
    this._orgId = undefined; // lazy-cached orgId, avoid fetching during construction
    // Bind and wrap methods for error handling
    this.ask = this._wrapMethod(this.ask);
  }
  isOwnError(e) {
    return e instanceof ClaudeProviderError;
  }
  /**
   * Fetch organization ID for the authenticated user
   */
  async fetchOrgId() {
    // Ensure DNR rules are active for Claude before fetching orgs
    try {
      await ProviderDNRGate.ensureProviderDnrPrereqs("claude");
    } catch (e) {
      console.warn("[ClaudeProvider] Failed to ensure DNR prereqs", e);
    }
    const apiPath = "/api/organizations";
    const response = await this._fetchAuth(apiPath);
    let data = await response.json();
    // Handle array response - sort by chat capability
    if (Array.isArray(data)) {
      data = data.sort((a, b) =>
        (a?.capabilities || []).includes("chat")
          ? -1
          : (b?.capabilities || []).includes("chat")
            ? 1
            : 0,
      );
      data = data[0];
    }
    // Cache orgId so subsequent calls are fast and avoid race on registry readiness
    this._orgId = data?.uuid || undefined;
    return this._orgId;
  }
  /**
   * Set chat conversation title
   */
  async setChatTitle(chatId, title, orgId) {
    if (!orgId) {
      // lazy fetch using cached value if available
      if (!this._orgId) this._orgId = await this.fetchOrgId();
      orgId = this._orgId;
    }
    if (!orgId) {
      this._throw("badOrgId");
    }
    await this._fetchAuth(
      `/api/organizations/${orgId}/chat_conversations/${chatId}`,
      {
        method: "PUT",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ name: title.replace(/\xA0\xA0/g, " ") }),
      },
    );
  }
  /**
   * Delete chat conversation
   */
  async deleteChat(chatId, orgId) {
    if (!orgId) {
      if (!this._orgId) this._orgId = await this.fetchOrgId();
      orgId = this._orgId;
    }
    if (!orgId) {
      this._throw("badOrgId");
    }
    await this._fetchAuth(
      `/api/organizations/${orgId}/chat_conversations/${chatId}`,
      {
        method: "DELETE",
        body: chatId,
      },
    );
  }
  /**
   * Send prompt to Claude AI and handle streaming response
   */
  async ask(prompt, options = {}, onChunk = () => { }) {
    let { orgId, chatId, signal, emoji } = options;

    // Ensure DNR rules are active for Claude
    try {
      await ProviderDNRGate.ensureProviderDnrPrereqs("claude");
    } catch (e) {
      console.warn("[ClaudeProvider] Failed to ensure DNR prereqs", e);
    }
    // Get or create org ID (lazy, cached)
    if (!orgId) {
      if (!this._orgId) this._orgId = await this.fetchOrgId();
      orgId = this._orgId;
    }
    if (!orgId) {
      this._throw("badOrgId");
    }
    // Create chat if needed
    chatId || (chatId = await this._createChat(orgId, emoji));
    // Handle large prompts by using attachments
    let attachments = [];
    let text = prompt;
    if (prompt.length > 5000) {
      attachments.push({
        extracted_content: prompt,
        file_name: "paste.txt",
        file_size: prompt.length,
        file_type: "txt",
      });
      text = "";
    }
    const url = `/api/organizations/${orgId}/chat_conversations/${chatId}/completion`;
    const payload = {
      method: "POST",
      headers: {
        Accept: "text/event-stream, text/event-stream",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        attachments,
        files: [],
        prompt: text,
        model: this._model === "auto" ? undefined : this._model,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      }),
      signal,
    };
    const response = await this._fetchAuth(url, payload);
    // Handle HTTP errors
    if (response.status !== 200) {
      let parsedJson = null;
      try {
        parsedJson = await response.json();
      } catch { }
      const code = parsedJson?.error?.code;
      if (code === "too_many_completions")
        this._throw("tooManyRequests", parsedJson);
      if (code === "model_not_allowed") this._throw("badModel", parsedJson);
      if (response.status === 429) this._throw("tooManyRequests", parsedJson);
      this._throw("unknown", parsedJson);
    }
    // Process streaming response
    // Process streaming response
    let fullText = "";
    let isFirstChunk = true;
    let softError = null; // Track non-fatal errors
    const reader = response.body.getReader();
    const carry = { carryOver: "" };

    try {
      let chunkCount = 0;
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        chunkCount++;
        // Debug: Log chunk frequency for synthesis streaming investigation
        if (CLAUDE_DEBUG) {
          console.log(`[Claude SSE] chunk=${chunkCount} bytes=${value?.length || 0}`);
        }

        // âœ… _parseChunk now returns {text, error}
        const result = this._parseChunk(value, carry, fullText.length > 0);

        if (result.error) {
          softError = result.error;
          // Continue processing - don't break
        }

        if (result.text) {
          // Preserve leading whitespace/newlines so code fences and markdown structure are kept intact.
          fullText = fullText + result.text;
          onChunk({ text: fullText, chatId, orgId }, isFirstChunk);
          isFirstChunk = false;
        }
      }
      if (CLAUDE_DEBUG) {
        console.log(`[Claude SSE] Stream ended. Total chunks: ${chunkCount}`);
      }

      // âœ… Grace period for late error frames
      if (fullText.length > 0) {
        await new Promise((resolve) => setTimeout(resolve, 200));
      }
    } catch (err) {
      // If we have partial text, treat as soft error and return what we have
      if (fullText.length > 0) {
        console.warn("[Claude] Stream interrupted but partial text recovered:", err);
        softError = { error: err };
      } else {
        throw err;
      }
    } finally {
      reader.releaseLock();
    }

    // âœ… Return with soft-error metadata
    const result = { orgId, chatId, text: fullText };
    if (softError) {
      result.softError = softError;
      if (CLAUDE_DEBUG)
        console.info(
          "[Claude] Completed with soft-error:",
          softError.error?.message || "unknown",
        );
    }
    return result;
  }
  /**
   * Update available models for the provider
   */
  updateModels() {
    if (!this.sharedState?.ai?.connections?.get) {
      return;
    }
    const connection = this.sharedState.ai.connections.get("claude-session");
    if (!connection) {
      return;
    }
    const currentModel = this._model;
    const modelList = Object.values(ClaudeModels).map((model) => ({
      id: model.id,
      name: model.name,
      description: model.description,
      maxTokens: model.maxTokens,
    }));
    connection.options = modelList;
    connection.selectedOption =
      modelList.find((model) => model.id === currentModel) || modelList[0];
    connection.maxTokens = connection.selectedOption?.maxTokens || null;
  }
  // =============================================================================
  // PRIVATE METHODS
  // =============================================================================
  _parseChunk(chunk, carry, hasAccumulatedText = false) {
    const lines = new TextDecoder()
      .decode(chunk)
      .trim()
      .split("\n")
      .filter((line) => line.trim().length > 0 && !line.startsWith("event:"));

    let accumulatedText = "";
    let error = null;

    // âœ… Use forEach instead of map, build text manually
    lines.forEach((line, idx) => {
      let parsedData;
      let dataPrefix = "";

      if (idx === 0 && carry.carryOver) {
        dataPrefix = carry.carryOver;
        carry.carryOver = "";
      }

      const dataString = dataPrefix + line.replace("data: ", "");

      try {
        parsedData = JSON.parse(dataString);
      } catch (err) {
        carry.carryOver = dataString;
        return; // Skip this line, continue to next
      }

      // Handle error frames
      if (parsedData.type === "error") {
        if (hasAccumulatedText) {
          error = parsedData;
          console.warn(
            "[Claude] Trailing error frame (ignored):",
            parsedData.error?.message || parsedData,
          );
        } else {
          this._throw("failedToReadResponse", parsedData);
        }
        return; // Don't process text from error frames
      }

      // Treat both parsed and unparsed frames as valid streaming text
      // Some Claude streams label interim frames as "unparsed" but they still carry useful text.
      const segment =
        (typeof parsedData.completion === "string" && parsedData.completion) ||
        (typeof parsedData.completion_delta === "string" &&
          parsedData.completion_delta) ||
        (typeof parsedData.delta === "string" && parsedData.delta) ||
        "";

      if (segment) {
        accumulatedText += segment;
      }
    });

    // âœ… ALWAYS return object structure
    return { text: accumulatedText, error };
  }
  async _createChat(orgId, emoji) {
    const chatId =
      this.utils?.id?.uuid?.() ||
      crypto.randomUUID?.() ||
      Math.random().toString(36).slice(2);
    const title = `${emoji || "ðŸ§¬"} New Chat`;
    const response = await this._fetchAuth(
      `/api/organizations/${orgId}/chat_conversations`,
      {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ uuid: chatId, name: title }),
      },
    );
    if (response.status === 400 || response.status === 404) {
      this._throw("badOrgId", { orgId });
    }
    return chatId;
  }
  async _fetchAuth(url, options = {}) {
    // Use browser session cookies for authentication
    options.credentials = "include";
    if (options.body && typeof options.body !== "string") {
      options.body = JSON.stringify(options.body);
    }
    let response;
    try {
      response = await this.fetch(`https://claude.ai${url}`, options);
      if (response.status === 403) {
        let parsedJson = null;
        try {
          parsedJson = await response.json();
        } catch { }
        if (parsedJson?.error?.message === "Invalid model") {
          this._throw("badModel", parsedJson);
        }
        if (parsedJson?.error?.details?.error_code === "model_not_available") {
          this._throw("badModel", parsedJson);
        }
        // Check org access
        const orgCheck = await this.fetch(
          "https://claude.ai/api/organizations",
          {
            credentials: "include",
          },
        );
        if (orgCheck.status === 403) {
          this._throw("login");
        }
        this._throw("badOrgId");
      }
    } catch (e) {
      if (e?.error?.code === "model_not_allowed") {
        this._throw("badModel", e.message);
      } else if (String(e) === "TypeError: Failed to fetch") {
        this._throw("network", e.message);
      } else {
        this._throw("unknown", e.message);
      }
    }
    return response;
  }
  _wrapMethod(fn) {
    return async (...args) => {
      try {
        return await fn.call(this, ...args);
      } catch (e) {
        const err = this.isOwnError(e)
          ? e
          : this._createError("unknown", e.message);
        if (err.details) {
          this._logError(err.message, err.details);
        } else {
          this._logError(err.message);
        }
        throw err;
      }
    };
  }
  get _model() {
    return (
      this.sharedState?.ai?.connections?.get?.("claude-session")?.selectedOption
        ?.id || "auto"
    );
  }
  _throw(type, details) {
    throw this._createError(type, details);
  }
  _createError(type, details) {
    return new ClaudeProviderError(type, details);
  }
  _logError(...args) {
    if (this._logs) {
      console.error("ClaudeProvider:", ...args);
    }
  }
}
// =============================================================================
// CLAUDE PROVIDER CONTROLLER
// =============================================================================
export class ClaudeProviderController {
  constructor(dependencies = {}) {
    this.initialized = false;
    this.api = new ClaudeSessionApi(dependencies);
  }
  async init() {
    if (this.initialized) {
      return;
    }
    // Register with bus controller if available
    if (typeof BusController !== "undefined" && BusController.on) {
      BusController.on("claude.ask", this._handleAskRequest.bind(this));
      BusController.on(
        "claude.setChatTitle",
        this._handleSetTitleRequest.bind(this),
      );
      BusController.on(
        "claude.deleteChat",
        this._handleDeleteChatRequest.bind(this),
      );
      BusController.on(
        "claude.fetchOrgId",
        this._handleFetchOrgIdRequest.bind(this),
      );
      BusController.on(
        "claude.updateModels",
        this._handleUpdateModelsRequest.bind(this),
      );
    }
    // Update available models
    this.api.updateModels();
    this.initialized = true;
  }
  // =============================================================================
  // BUS EVENT HANDLERS
  // =============================================================================
  async _handleAskRequest(payload) {
    return await this.api.ask(
      payload.prompt,
      payload.options || {},
      payload.onChunk || (() => { }),
    );
  }
  async _handleSetTitleRequest(payload) {
    return await this.api.setChatTitle(
      payload.chatId,
      payload.title,
      payload.orgId,
    );
  }
  async _handleDeleteChatRequest(payload) {
    return await this.api.deleteChat(payload.chatId, payload.orgId);
  }
  async _handleFetchOrgIdRequest() {
    return await this.api.fetchOrgId();
  }
  _handleUpdateModelsRequest() {
    this.api.updateModels();
  }
  // =============================================================================
  // PUBLIC API
  // =============================================================================
  get claudeSession() {
    return this.api;
  }
  isOwnError(e) {
    return this.api.isOwnError(e);
  }
}
// =============================================================================
// EXPORTS
// =============================================================================
// Default export for easy integration
export default ClaudeProviderController;

// For global browser usage
if (typeof window !== "undefined") {
  window.HTOSClaudeProvider = ClaudeProviderController;
  window.HTOSClaudeSessionApi = ClaudeSessionApi;
  window.HTOSClaudeModels = ClaudeModels;
}
// Provider-specific debug flag (off by default)
const CLAUDE_DEBUG = false;



================================================
FILE: src/providers/gemini-adapter.js
================================================
/**
 * HTOS Gemini Provider Adapter (Unified)
 * - Implements ProviderAdapter interface for Gemini AND Gemini Pro
 * - Handles both Flash and Pro models via dynamic configuration
 * - Wraps GeminiSessionApi with auth observation (Gemini has internal retries)
 */
import { authManager } from '../core/auth-manager.js';
import {
  errorHandler,
  isProviderAuthError,
  createProviderAuthError
} from '../utils/ErrorHandler.js';

const GEMINI_ADAPTER_DEBUG = false;
const pad = (...args) => {
  if (GEMINI_ADAPTER_DEBUG) console.log(...args);
};

export class GeminiAdapter {
  constructor(controller, idOverride = "gemini") {
    this.id = idOverride;
    this.capabilities = {
      needsDNR: false,
      needsOffscreen: false,
      supportsStreaming: false, // Non-streaming to avoid canvas/immersive documents
      supportsContinuation: true,
      synthesis: false,
      // Only allow model selection if NOT explicitly Pro (Pro is fixed)
      supportsModelSelection: this.id !== "gemini-pro",
    };
    this.controller = controller;
  }

  async init() {
    return;
  }

  async healthCheck() {
    try {
      return await this.controller.isAvailable();
    } catch {
      return false;
    }
  }

  async sendPrompt(req, onChunk, signal, _isRetry = false) {
    const startTime = Date.now();
    try {
      // Auto-select model based on adapter ID if not specified in request
      let defaultModel = "gemini-flash";
      if (this.id === "gemini-pro") defaultModel = "gemini-pro";
      if (this.id === "gemini-exp") defaultModel = "gemini-exp";
      const model = req.meta?.model || defaultModel;

      pad(`[GeminiAdapter:${this.id}] Sending prompt with model: ${model}`);

      const result = await this.controller.geminiSession.ask(
        req.originalPrompt,
        {
          signal,
          cursor: req.meta?.cursor,
          model,
        }
      );

      // NORMALIZATION LOGIC (From Pro Adapter)
      const normalizedText =
        result?.text ??
        result?.candidates?.[0]?.content ??
        (typeof result === "string" ? result : JSON.stringify(result));

      // 🔍 DETECT GEMINI IMMERSIVE CONTENT
      if (normalizedText && (normalizedText.includes('googleusercontent.com/immersive_entry_chip') || normalizedText.includes('immersive-editor'))) {
        console.warn(`[GeminiAdapter:${this.id}] 🎨 IMMERSIVE CONTENT DETECTED in response`, {
          textPreview: normalizedText.substring(0, 200),
          fullLength: normalizedText.length,
          model,
        });
      }

      // Emit streaming chunk if applicable
      try {
        if (onChunk && normalizedText && normalizedText.length > 0) {
          onChunk({
            providerId: this.id,
            ok: true,
            text: normalizedText,
            partial: true,
            latencyMs: Date.now() - startTime,
            meta: {
              cursor: result.cursor,
              token: result.token,
              modelName: result.modelName,
              model,
            },
          });
        }
      } catch (_) { }

      return {
        providerId: this.id,
        ok: true,
        id: null,
        text: normalizedText,
        partial: false,
        latencyMs: Date.now() - startTime,
        meta: {
          cursor: result.cursor,
          token: result.token,
          modelName: result.modelName,
          model,
        },
      };
    } catch (error) {
      // Check Gemini-specific auth errors
      if (isProviderAuthError(error) || this._isGeminiAuthError(error)) {
        authManager.invalidateCache(this.id);
        await authManager.verifyProvider(this.id);

        // Special message for "no access" vs "session expired"
        if (error?.code === 'noGeminiAccess') {
          error.message = 'Your Google account does not have Gemini access.';
        }

        const authError = createProviderAuthError(this.id, error);
        return {
          providerId: this.id,
          ok: false,
          text: null,
          errorCode: 'AUTH_REQUIRED',
          latencyMs: Date.now() - startTime,
          meta: {
            error: authError.toString(),
            details: authError.details,
          },
        };
      }

      if (_isRetry) {
        return {
          providerId: this.id,
          ok: false,
          text: null,
          errorCode: (error && (error.code || error.type)) || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: error?.toString?.() || String(error),
            details: error?.details,
          },
        };
      }

      try {
        const recovery = await errorHandler.handleProviderError(error, this.id, {
          providerId: this.id,
          prompt: req.originalPrompt?.substring(0, 200),
          operation: async () => {
            return await this.sendPrompt(req, onChunk, signal, true);
          },
        });
        if (recovery) return recovery;
      } catch (handledError) {
        return {
          providerId: this.id,
          ok: false,
          text: null,
          errorCode: handledError.code || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: handledError.toString(),
            details: handledError.details,
          },
        };
      }
    }
  }

  async sendContinuation(prompt, providerContext, sessionId, onChunk, signal, _isRetry = false) {
    const startTime = Date.now();
    try {
      const meta = providerContext?.meta || providerContext || {};
      const cursor = providerContext?.cursor ?? meta.cursor;

      let defaultModel = "gemini-flash";
      if (this.id === "gemini-pro") defaultModel = "gemini-pro";
      if (this.id === "gemini-exp") defaultModel = "gemini-exp";
      const model = (providerContext?.model ?? meta.model) || defaultModel;

      // STRICT CONTINUATION: Do NOT fall back to new chat. 
      if (!cursor) {
        console.warn(`[GeminiAdapter:${this.id}] Context missing (no cursor)`);
        throw new Error("Continuity lost: Missing Gemini cursor for this thread.");
      }

      pad(`[GeminiAdapter:${this.id}] Continuing chat with model: ${model}`);

      const result = await this.controller.geminiSession.ask(prompt, {
        signal,
        cursor,
        model,
      });

      // NORMALIZATION LOGIC
      const normalizedText =
        result?.text ??
        result?.candidates?.[0]?.content ??
        (typeof result === "string" ? result : JSON.stringify(result));

      // 🔍 DETECT GEMINI IMMERSIVE CONTENT
      if (normalizedText && (normalizedText.includes('googleusercontent.com/immersive_entry_chip') || normalizedText.includes('immersive-editor'))) {
        console.warn(`[GeminiAdapter:${this.id}] 🎨 IMMERSIVE CONTENT DETECTED in continuation`, {
          textPreview: normalizedText.substring(0, 200),
          fullLength: normalizedText.length,
          model,
        });
      }

      try {
        if (onChunk && normalizedText && normalizedText.length > 0) {
          onChunk({
            providerId: this.id,
            ok: true,
            text: normalizedText,
            partial: true,
            latencyMs: Date.now() - startTime,
            meta: {
              cursor: result.cursor,
              token: result.token,
              modelName: result.modelName,
              model,
            },
          });
        }
      } catch (_) { }

      return {
        providerId: this.id,
        ok: true,
        id: null,
        text: normalizedText,
        partial: false,
        latencyMs: Date.now() - startTime,
        meta: {
          cursor: result.cursor,
          token: result.token,
          modelName: result.modelName,
          model,
        },
      };
    } catch (error) {
      if (isProviderAuthError(error) || this._isGeminiAuthError(error)) {
        authManager.invalidateCache(this.id);
        await authManager.verifyProvider(this.id);

        if (error?.code === 'noGeminiAccess') {
          error.message = 'Your Google account does not have Gemini access.';
        }

        const authError = createProviderAuthError(this.id, error);
        return {
          providerId: this.id,
          ok: false,
          text: null,
          errorCode: 'AUTH_REQUIRED',
          latencyMs: Date.now() - startTime,
          meta: {
            error: authError.toString(),
            details: authError.details,
            cursor: providerContext?.cursor ?? providerContext?.meta?.cursor,
          },
        };
      }

      if (_isRetry) {
        return {
          providerId: this.id,
          ok: false,
          text: null,
          errorCode: (error && (error.code || error.type)) || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: error?.toString?.() || String(error),
            details: error?.details,
            cursor: providerContext?.cursor ?? providerContext?.meta?.cursor,
          },
        };
      }

      try {
        const recovery = await errorHandler.handleProviderError(error, this.id, {
          providerId: this.id,
          prompt: prompt?.substring(0, 200),
          operation: async () => {
            return await this.sendContinuation(
              prompt,
              providerContext,
              sessionId,
              onChunk,
              signal,
              true,
            );
          },
        });
        if (recovery) return recovery;
      } catch (handledError) {
        return {
          providerId: this.id,
          ok: false,
          text: null,
          errorCode: handledError.code || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: handledError.toString(),
            details: handledError.details,
            cursor: providerContext?.cursor ?? providerContext?.meta?.cursor,
          },
        };
      }
    }
  }

  /**
   * Unified ask API
   */
  async ask(prompt, providerContext = null, sessionId = undefined, onChunk = undefined, signal = undefined) {
    try {
      const meta = providerContext?.meta || providerContext || {};
      const hasCursor = Boolean(meta.cursor || providerContext?.cursor);

      pad(`[ProviderAdapter] ASK_STARTED provider=${this.id} hasContext=${hasCursor}`);

      let res;
      if (hasCursor) {
        res = await this.sendContinuation(prompt, providerContext, sessionId, onChunk, signal);
      } else {
        res = await this.sendPrompt({ originalPrompt: prompt, sessionId, meta }, onChunk, signal);
      }

      try {
        const len = (res?.text || "").length;
        pad(`[ProviderAdapter] ASK_COMPLETED provider=${this.id} ok=${res?.ok !== false} textLen=${len}`);
      } catch (_) { }

      return res;
    } catch (e) {
      console.warn(`[ProviderAdapter] ASK_FAILED provider=${this.id}:`, e?.message || String(e));
      throw e;
    }
  }

  _isGeminiAuthError(error) {
    const code = error?.code;
    return code === 'login' || code === 'noGeminiAccess' || code === 'badToken';
  }
}


================================================
FILE: src/providers/gemini.js
================================================


/**
 * HTOS Gemini Provider Implementation
 *
 * This adapter module provides Gemini AI integration following HTOS patterns.
 * Handles Gemini session-based authentication using browser cookies.
 *
 * Build-phase safe: emitted to dist/adapters/*
 */
import { BusController } from "../core/vendor-exports.js";
import { ArtifactProcessor } from "../../shared/artifact-processor.ts";

// =============================================================================
// GEMINI MODELS CONFIGURATION
// =============================================================================
export const GeminiModels = {
  "gemini-flash": {
    id: "gemini-flash",
    name: "Gemini 2.5 Flash",
    description: "Fast and efficient model for everyday tasks",
    maxTokens: 9999,
    header: '[1,null,null,null,"9ec249fc9ad08861",null,null,0,[4]]',
  },
  "gemini-pro": {
    id: "gemini-pro",
    name: "Gemini 2.5 Pro",
    description: "Advanced model with enhanced reasoning capabilities",
    maxTokens: 9999,
    header: '[1,null,null,null,"61530e79959ab139",null,null,0,[4]]',
  },
  "gemini-exp": {
    id: "gemini-exp",
    name: "Gemini 3.0", // or "Experimental"
    description: "Latest experimental capability",
    maxTokens: 9999,
    // Signature from your 1st fetch (9d8ca3786ebdfbea)
    header: '[1,null,null,null,"9d8ca3786ebdfbea",null,null,0,[4]]',
  },
};
// =============================================================================
// GEMINI ERROR TYPES
// =============================================================================
export class GeminiProviderError extends Error {
  constructor(type, details) {
    super(type);
    this.name = "GeminiProviderError";
    this.type = type;
    this.details = details;
  }
  get is() {
    return {
      login: this.type === "login",
      badToken: this.type === "badToken",
      failedToExtractToken: this.type === "failedToExtractToken",
      failedToReadResponse: this.type === "failedToReadResponse",
      noGeminiAccess: this.type === "noGeminiAccess",
      aborted: this.type === "aborted",
      network: this.type === "network",
      unknown: this.type === "unknown",
    };
  }
}

// =============================================================================
// GEMINI SESSION API
// =============================================================================
export class GeminiSessionApi {
  constructor({ sharedState, utils, fetchImpl = fetch } = {}) {
    this._logs = true;
    this.sharedState = sharedState;
    this.utils = utils;
    this.fetch = fetchImpl;
    // Bind and wrap methods for error handling
    this.ask = this._wrapMethod(this.ask);
  }

  isOwnError(e) {
    return e instanceof GeminiProviderError;
  }

  /**
   * Send prompt to Gemini AI and handle response
   * @param {string} prompt - The prompt text
   * @param {Object} options - Request options
   * @param {string|null} options.token - Authentication token (auto-fetched if null)
   * @param {Array} options.cursor - Conversation cursor for continuity
   * @param {string} options.model - Model to use ("gemini-flash" or "gemini-pro")
   * @param {AbortSignal} options.signal - Abort signal for cancellation
   * @param {boolean} retrying - Internal retry flag
   */
  async ask(
    prompt,
    {
      token = null,
      cursor = ["", "", ""],
      model = "gemini-flash",
      signal,
    } = {},
    retrying = false,
  ) {
    // âœ… NEW: Use prefetched token if available
    if (!token && this.sharedState?.prefetchedToken) {
      token = this.sharedState.prefetchedToken;
      delete this.sharedState.prefetchedToken; // Consume once
    }
    token || (token = await this._fetchToken());

    // âœ… NEW: Generate collision-resistant request ID
    const reqId = Date.now() * 1000 + Math.floor(Math.random() * 1000);
    const url =
      "/_/BardChatUi/data/assistant.lamda.BardFrontendService/StreamGenerate";

    // Get model configuration
    const modelConfig = GeminiModels[model] || GeminiModels["gemini-flash"];

    // Do not truncate the prompt here â€” send the full prompt to the provider and let the provider/orchestrator manage any necessary truncation.
    const body = new URLSearchParams({
      at: token.at,
      "f.req": JSON.stringify([null, JSON.stringify([[prompt], null, cursor])]),
    });

    const response = await this._fetch(url, {
      method: "POST",
      headers: {
        "content-type": "application/x-www-form-urlencoded;charset=UTF-8",
        "x-goog-ext-525001261-jspb": modelConfig.header, // Add model selection header
      },
      signal,
      query: {
        bl: token.bl,
        rt: "c",
        _reqid: reqId,
      },
      body,
    });

    const retry = async (msg = "") => {
      if (retrying) {
        this._throw("badToken", msg);
      }
      return this.ask(prompt, { token: null, cursor, model, signal }, true);
    };

    if (response.status !== 200) {
      const responseText =
        (await this.utils?.noThrow?.(() => response.text(), null)) ||
        (await response.text());
      if (response.status === 400) {
        return retry(responseText);
      }
      this._throw("unknown", responseText);
    }

    let parsedLines = [];
    let c, u, p;
    try {
      // Gemini returns an XSSI prefix like ")]}'" followed by multiple JSON lines.
      const raw = await response.text();
      const cleaned = raw.replace(/^\)\]\}'\s*\n?/, "").trim();
      const jsonLines = cleaned
        .split("\n")
        .filter((line) => line.trim().startsWith("["));
      if (jsonLines.length === 0)
        throw new Error("No JSON lines detected in response");
      // Parse all JSON lines (robust to multi-line responses)
      parsedLines = jsonLines
        .map((line) => {
          try {
            return JSON.parse(line);
          } catch (e) {
            return null;
          }
        })
        .filter(Boolean);
    } catch (e) {
      this._throw("failedToReadResponse", { step: "data", error: e });
    }

    // ========================================================================
    // âœ… NEW: Cold-Start Failure Detection (BEFORE error code check)
    // ========================================================================
    const hasColdStartSignature = parsedLines.some(line =>
      line.some(entry =>
        Array.isArray(entry) &&
        entry[0] === "e" &&
        entry[1] === 4
      )
    );

    if (hasColdStartSignature) {
      console.warn(`[Gemini] Cold start detected: [["e",4,...]] - retrying with fresh token`);

      // Wait 500ms-2s for backend to stabilize
      await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1500));

      return retry("Cold start detected: [['e',4,...]] in response");
    }
    // ========================================================================

    // Check error code on FIRST parsed line only (before payload extraction)
    try {
      c = parsedLines[0]?.[0]?.[5]?.[0] ?? null;
    } catch (e) {
      this._throw("failedToReadResponse", { step: "errorCode", error: e });
    }

    if (c === 9) {
      // Treat code 9 as access issue
      this._throw("noGeminiAccess");
    }
    if (c === 7) {
      // Bad token or session mismatch â€” refresh token for retry
      return retry();
    }

    // Extract payload from parsed lines (only reached if code !== 9 and code !== 7)
    // Strategy: First try to find a chunk with actual text.
    // If none found, fall back to any chunk that looks like a valid payload (has t[4]),
    // ignoring simple keep-alives.

    // Pass 1: Look for text
    for (const L of parsedLines) {
      const found = L.find((entry) => {
        try {
          if (typeof entry[2] !== "string") return false;
          const t = JSON.parse(entry[2]);
          const text = t[0]?.[0] || t[4]?.[0]?.[1]?.[0] || "";

          if (text && text.trim().length > 0) {
            const baseCursor = Array.isArray(t?.[1]) ? t[1] : [];
            const tail = t?.[4]?.[0]?.[0];
            const cursor = tail !== undefined ? [...baseCursor, tail] : baseCursor;
            u = { text, cursor };
            return true;
          }
          return false;
        } catch (e) { return false; }
      });
      if (found) break;
    }

    // Pass 2: Fallback (if no text found) - look for any valid payload structure
    if (!u) {
      for (const L of parsedLines) {
        const found = L.find((entry) => {
          try {
            if (typeof entry[2] !== "string") return false;
            const t = JSON.parse(entry[2]);

            // Skip keep-alives (no t[4])
            if (!t[4] || !Array.isArray(t[4])) return false;

            const text = t[0]?.[0] || t[4]?.[0]?.[1]?.[0] || "";
            const baseCursor = Array.isArray(t?.[1]) ? t[1] : [];
            const tail = t?.[4]?.[0]?.[0];
            const cursor = tail !== undefined ? [...baseCursor, tail] : baseCursor;

            u = { text, cursor };
            return true;
          } catch (e) { return false; }
        });
        if (found) break;
      }
    }

    if (!u) {
      this._throw("failedToReadResponse", { step: "answer", error: p });
    }

    // --- Immersive Content Extraction ---
    // Look for hidden markdown content (stories, code, etc) in the response tree
    const immersiveContent = [];
    const images = [];

    for (const L of parsedLines) {
      L.forEach((entry) => {
        try {
          if (typeof entry[2] !== "string") return;
          const t = JSON.parse(entry[2]);
          this._findImmersiveContent(t, immersiveContent);
          this._findImages(t, images);
        } catch (e) { }
      });
    }

    // Replace Image Placeholders with Markdown Images
    // Use shared ArtifactProcessor for consistent handling
    const processor = new ArtifactProcessor();
    if (images.length > 0 && u.text) {
      u.text = processor.injectImages(u.text, images);
    }

    // Append extracted content as Claude-style artifacts
    if (immersiveContent.length > 0) {
      immersiveContent.forEach((item) => {
        // Avoid duplicates if multiple chunks contain the same item
        if (!u.text.includes(`identifier="${item.identifier}"`)) {
          u.text += processor.formatArtifact(item);
        }
      });
    }

    if (GEMINI_DEBUG)
      console.info("[Gemini] Response received:", {
        hasText: !!u?.text,
        textLength: u?.text?.length || 0,
        immersiveItems: immersiveContent.length,
        images: images.length,
        status: response?.status || "unknown",
        model: modelConfig.name,
      });

    return {
      text: u.text,
      cursor: u.cursor,
      token,
      modelName: modelConfig.name, // Include model name in response
    };
  }

  /**
   * Recursively search for images
   * Structure: [URL, null, width, height, "Title", URL, ID, ...]
   */
  _findImages(obj, results) {
    if (!obj || typeof obj !== "object") return;

    if (Array.isArray(obj)) {
      // Check signature for Image Data
      if (
        obj.length >= 5 &&
        typeof obj[0] === "string" &&
        (obj[0].startsWith("http") || obj[0].startsWith("data:image")) &&
        typeof obj[2] === "number" && // Width
        typeof obj[3] === "number" && // Height
        typeof obj[4] === "string"    // Title
      ) {
        // Check if already added
        if (!results.find((r) => r.url === obj[0])) {
          results.push({
            url: obj[0],
            width: obj[2],
            height: obj[3],
            title: obj[4],
            id: obj[6] // Optional ID
          });
        }
      }
      // Continue search
      obj.forEach((child) => this._findImages(child, results));
    }
  }

  /**
   * Recursively search for immersive content (e.g. markdown files)
   * Structure: [filename.md, id, title, null, content]
   */
  _findImmersiveContent(obj, results) {
    if (!obj || typeof obj !== "object") return;

    if (Array.isArray(obj)) {
      // Check signature: [filename, id, title, null, content]
      // We relax the extension check to allow .txt, .md, etc.
      if (
        obj.length >= 5 &&
        typeof obj[0] === "string" &&
        (obj[0].includes(".") || obj[0].length > 0) && // Basic filename check
        !obj[0].includes("_image_") && // EXCLUDE internal image references
        typeof obj[2] === "string" && // Title
        typeof obj[4] === "string" // Content
      ) {
        // Check if already added
        if (!results.find((r) => r.identifier === obj[0])) {
          results.push({
            identifier: obj[0],
            title: obj[2],
            content: obj[4],
          });
        }
      }
      // Continue search
      obj.forEach((child) => this._findImmersiveContent(child, results));
    }
  }

  /**
   * Get maximum tokens for the current model
   */
  get _maxTokens() {
    return (
      this.sharedState?.ai?.connections?.get?.("gemini-session")
        ?.modelMaxTokens || 4096
    );
  }

  /**
   * Fetch authentication token from Gemini
   */
  async _fetchToken() {
    const response = await this._fetch("/faq");
    const t = await response.text();
    let n;
    if (!t.includes("$authuser")) {
      this._throw("login");
    }
    try {
      n = {
        at: this._extractKeyValue(t, "SNlM0e"),
        bl: this._extractKeyValue(t, "cfb2h"),
      };
    } catch (e) {
      this._throw("failedToExtractToken", e);
    }
    return n;
  }

  /**
   * Extract key-value pairs from response text
   */
  _extractKeyValue(str, key) {
    return str.split(key)[1].split('":"')[1].split('"')[0];
  }

  /**
   * Make authenticated fetch request to Gemini
   */
  async _fetch(path, options = {}) {
    // Handles both GET and POST with query params
    let url = `https://gemini.google.com${path}`;
    if (options.query) {
      const params = new URLSearchParams(options.query).toString();
      url += (url.includes("?") ? "&" : "?") + params;
      delete options.query;
    }
    options.credentials = "include";
    return await this.fetch(url, options);
  }

  /**
   * Wrap methods with error handling
   */
  _wrapMethod(fn) {
    return async (...args) => {
      try {
        return await fn.call(this, ...args);
      } catch (e) {
        let err;
        if (this.isOwnError(e)) err = e;
        else if (String(e) === "TypeError: Failed to fetch")
          err = this._createError("network", e.message);
        else if (String(e) === "AbortError: The user aborted a request.")
          err = this._createError("aborted", e.message);
        else err = this._createError("unknown", e.message);
        if (err.details) this._logError(err.message, err.details);
        else this._logError(err.message);
        throw err;
      }
    };
  }

  _throw(type, details) {
    throw this._createError(type, details);
  }

  _createError(type, details) {
    return new GeminiProviderError(type, details);
  }

  _logError(...args) {
    if (this._logs) {
      console.error("GeminiSessionApi:", ...args);
    }
  }
}

// =============================================================================
// GEMINI PROVIDER CONTROLLER
// =============================================================================
export class GeminiProviderController {
  constructor(dependencies = {}) {
    this.initialized = false;
    this.api = new GeminiSessionApi(dependencies);
  }

  async init() {
    if (this.initialized) return;
    // Register with BusController for cross-context communication
    if (typeof BusController !== "undefined") {
      BusController.on(
        "gemini-provider.ask",
        this._handleAskRequest.bind(this),
      );
      BusController.on(
        "gemini-provider.fetchToken",
        this._handleFetchTokenRequest.bind(this),
      );
    }
    this.initialized = true;
  }

  async _handleAskRequest(payload) {
    return await this.api.ask(
      payload.prompt,
      payload.options || {},
      payload.retrying || false,
    );
  }

  async _handleFetchTokenRequest() {
    return await this.api._fetchToken();
  }

  /**
   * Check if Gemini is available (user is logged in)
   */
  async isAvailable() {
    try {
      await this.api._fetchToken();
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Expose Gemini API instance for direct usage
   */
  get geminiSession() {
    return this.api;
  }

  isOwnError(e) {
    return this.api.isOwnError(e);
  }
}

// =============================================================================
// MODULE EXPORTS
// =============================================================================
export default GeminiProviderController;

// Build-phase safe: Browser global compatibility
if (typeof window !== "undefined") {
  window.HTOS = window.HTOS || {};
  window.HTOS.GeminiProvider = GeminiProviderController;
}
// Provider-specific debug flag (off by default)
const GEMINI_DEBUG = false;



================================================
FILE: src/providers/qwen-adapter.js
================================================
/**
 * HTOS Qwen Provider Adapter
 * - Implements ProviderAdapter interface for Qwen
 * - Wraps QwenSessionApi with auth observation (Qwen has internal retries)
 */
import { authManager } from '../core/auth-manager.js';
import {
  errorHandler,
  isProviderAuthError,
  createProviderAuthError
} from '../utils/ErrorHandler.js';

const QWEN_ADAPTER_DEBUG = false;
const pad = (...args) => {
  if (QWEN_ADAPTER_DEBUG) console.log(...args);
};

export class QwenAdapter {
  constructor(controller) {
    this.id = "qwen";
    this.capabilities = {
      needsDNR: true, // To set origin/referer headers
      needsOffscreen: false,
      supportsStreaming: true,
      supportsContinuation: true,
      synthesis: true,
    };
    this.controller = controller;
  }

  async sendPrompt(req, onChunk, signal, _isRetry = false) {
    const startTime = Date.now();
    let aggregatedText = "";
    let responseContext = {};

    const meta = req?.meta || {};
    const hasContinuation = !!(meta.sessionId || meta.parentMsgId);

    try {
      const result = await this.controller.qwenSession.ask(
        req.originalPrompt,
        {
          signal,
          sessionId: hasContinuation ? meta.sessionId : undefined,
          parentMsgId: hasContinuation ? meta.parentMsgId : undefined,
        },
        (partial) => {
          if (!this.capabilities.supportsStreaming || !onChunk) return;
          aggregatedText = partial.text || aggregatedText;
          responseContext = {
            sessionId: partial.sessionId,
            parentMsgId: partial.parentMsgId,
          };

          onChunk({
            providerId: this.id,
            ok: true,
            text: aggregatedText,
            partial: true,
            latencyMs: Date.now() - startTime,
            meta: { ...responseContext },
          });
        },
      );

      return {
        providerId: this.id,
        ok: true,
        text: result.text ?? aggregatedText,
        partial: false,
        latencyMs: Date.now() - startTime,
        meta: { sessionId: result.sessionId, parentMsgId: result.parentMsgId },
      };
    } catch (error) {
      if (isProviderAuthError(error) || this._isQwenAuthError(error)) {
        authManager.invalidateCache(this.id);
        await authManager.verifyProvider(this.id);

        const authError = createProviderAuthError(this.id, error);
        return {
          providerId: this.id,
          ok: false,
          text: aggregatedText || null,
          errorCode: 'AUTH_REQUIRED',
          latencyMs: Date.now() - startTime,
          meta: {
            error: authError.toString(),
            details: authError.details,
            ...meta,
          },
        };
      }

      if (_isRetry) {
        return {
          providerId: this.id,
          ok: false,
          text: aggregatedText || null,
          errorCode: (error && (error.code || error.type)) || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: error?.toString?.() || String(error),
            details: error?.details,
            ...meta,
          },
        };
      }
      try {
        const recovery = await errorHandler.handleProviderError(error, this.id, {
          providerId: this.id,
          prompt: req.originalPrompt?.substring(0, 200),
          operation: async () => {
            return await this.sendPrompt(req, onChunk, signal, true);
          },
        });
        if (recovery) return recovery;
      } catch (handledError) {
        return {
          providerId: this.id,
          ok: false,
          text: aggregatedText || null,
          errorCode: handledError.code || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: handledError.toString(),
            details: handledError.details,
            suppressed: handledError.suppressed,
            ...meta,
          },
        };
      }
    }
  }

  async sendContinuation(prompt, providerContext, sessionId, onChunk, signal, _isRetry = false) {
    const startTime = Date.now();
    const meta = providerContext?.meta || providerContext || {};
    let aggregatedText = "";
    let responseContext = {};

    if (!meta.sessionId) {
      console.warn(`[Qwen Adapter] sendContinuation called without a sessionId.`);
      return {
        providerId: this.id,
        ok: false,
        text: null,
        errorCode: "continuation_failed",
        meta: { error: "Missing sessionId for continuation." },
      };
    }

    try {
      const result = await this.controller.qwenSession.ask(
        prompt,
        {
          signal,
          sessionId: meta.sessionId,
          parentMsgId: meta.parentMsgId,
        },
        (partial) => {
          if (!this.capabilities.supportsStreaming || !onChunk) return;
          aggregatedText = partial.text || aggregatedText;
          responseContext = {
            sessionId: partial.sessionId,
            parentMsgId: partial.parentMsgId,
          };

          onChunk({
            providerId: this.id,
            ok: true,
            text: aggregatedText,
            partial: true,
            latencyMs: Date.now() - startTime,
            meta: { ...responseContext },
          });
        },
      );

      return {
        providerId: this.id,
        ok: true,
        text: result.text ?? aggregatedText,
        partial: false,
        latencyMs: Date.now() - startTime,
        meta: { sessionId: result.sessionId, parentMsgId: result.parentMsgId },
      };
    } catch (error) {
      if (isProviderAuthError(error) || this._isQwenAuthError(error)) {
        authManager.invalidateCache(this.id);
        await authManager.verifyProvider(this.id);

        const authError = createProviderAuthError(this.id, error);
        return {
          providerId: this.id,
          ok: false,
          text: aggregatedText || null,
          errorCode: 'AUTH_REQUIRED',
          latencyMs: Date.now() - startTime,
          meta: {
            error: authError.toString(),
            details: authError.details,
            ...meta,
          },
        };
      }

      if (_isRetry) {
        return {
          providerId: this.id,
          ok: false,
          text: aggregatedText || null,
          errorCode: (error && (error.code || error.type)) || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: error?.toString?.() || String(error),
            details: error?.details,
            suppressed: error?.suppressed,
            ...meta,
          },
        };
      }
      try {
        const recovery = await errorHandler.handleProviderError(error, this.id, {
          providerId: this.id,
          prompt: prompt?.substring(0, 200),
          operation: async () => {
            return await this.sendContinuation(
              prompt,
              providerContext,
              sessionId,
              onChunk,
              signal,
              true,
            );
          },
        });
        if (recovery) return recovery;
      } catch (handledError) {
        return {
          providerId: this.id,
          ok: false,
          text: aggregatedText || null,
          errorCode: handledError.code || "unknown",
          latencyMs: Date.now() - startTime,
          meta: {
            error: handledError.toString(),
            details: handledError.details,
            suppressed: handledError.suppressed,
            ...meta,
          },
        };
      }
    }
  }

  async ask(prompt, providerContext = null, sessionId = undefined, onChunk = undefined, signal = undefined) {
    try {
      const meta = providerContext?.meta || providerContext || {};
      const hasContinuation = Boolean(meta.sessionId || meta.parentMsgId);
      pad(`[ProviderAdapter] ASK_STARTED provider=${this.id} hasContext=${hasContinuation}`);

      let res;
      if (hasContinuation) {
        res = await this.sendContinuation(prompt, meta, sessionId, onChunk, signal);
      } else {
        res = await this.sendPrompt({ originalPrompt: prompt, sessionId, meta }, onChunk, signal);
      }

      try {
        const len = (res?.text || "").length;
        pad(`[ProviderAdapter] ASK_COMPLETED provider=${this.id} ok=${res?.ok !== false} textLen=${len}`);
      } catch (_) { }
      return res;
    } catch (e) {
      console.warn(`[ProviderAdapter] ASK_FAILED provider=${this.id}:`, e?.message || String(e));
      throw e;
    }
  }

  _isQwenAuthError(error) {
    const code = error?.code;
    return code === 'login' || code === 'csrf';
  }
}



================================================
FILE: src/providers/qwen.js
================================================
/**
 * HTOS Qwen Provider Implementation
 *
 * Handles Qwen session-based authentication and API interaction.
 * Updated for api.qianwen.com endpoints (2024+)
 */

// =============================================================================
// CONSTANTS
// =============================================================================
const QWEN_API_BASE = "https://api.qianwen.com";
const QWEN_WEB_BASE = "https://www.qianwen.com";

// =============================================================================
// QWEN ERROR TYPES
// =============================================================================
export class QwenProviderError extends Error {
  constructor(type, details) {
    super(type);
    this.name = "QwenProviderError";
    this.type = type;
    this.details = details;
  }

  get is() {
    return {
      login: this.type === "login",
      csrf: this.type === "csrf",
      network: this.type === "network",
      unknown: this.type === "unknown",
    };
  }
}

// =============================================================================
// QWEN SESSION API
// =============================================================================
import { ProviderDNRGate } from "../core/dnr-utils.js";

export class QwenSessionApi {
  constructor({ fetchImpl = fetch } = {}) {
    this._logs = true;
    this.fetch = fetchImpl;
    this._csrfToken = null;
    this._deviceId = null;
    this.ask = this._wrapMethod(this.ask);
  }

  // Generate or retrieve device ID (persisted for session)
  _getDeviceId() {
    if (this._deviceId) return this._deviceId;

    // Generate UUID v4 format like: 2cefa386-9462-b1b1-2400-c0cfabb8b64f
    this._deviceId = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });

    return this._deviceId;
  }

  // Simple id generator for msg/request ids (32 hex chars)
  _generateId() {
    return 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/x/g, () => {
      return Math.floor(Math.random() * 16).toString(16);
    });
  }

  async _createConversation(firstQuery, csrfToken, signal) {
    // Ensure DNR rules are applied so Origin/Referer headers are set
    try {
      await ProviderDNRGate.ensureProviderDnrPrereqs("qwen");
    } catch (e) {
      // Non-fatal: continue but log
      console.warn("[QwenProvider] Failed to ensure DNR prereqs", e);
    }

    const resp = await this.fetch(`${QWEN_API_BASE}/addSession`, {
      method: "POST",
      signal,
      credentials: "include",
      headers: {
        "Content-Type": "application/json",
        "X-Platform": "pc_tongyi",
        "X-Xsrf-Token": csrfToken,
        "X-DeviceId": this._getDeviceId(),
      },
      body: JSON.stringify({ firstQuery, sessionType: "text_chat" }),
    });

    if (!resp.ok) {
      const text = await resp.text().catch(() => "<no-body>");
      this._throw("unknown", `createSession failed ${resp.status}: ${text}`);
    }

    const j = await resp.json().catch(() => null);
    if (!j || !j.success || !j.data || !j.data.sessionId) {
      this._throw(
        "unknown",
        `createSession unexpected response: ${JSON.stringify(j)}`,
      );
    }
    return j.data.sessionId;
  }

  async _fetchCsrfToken() {
    if (this._csrfToken) return this._csrfToken;
    try {
      const response = await this.fetch(`${QWEN_WEB_BASE}/`, {
        credentials: "include",
      });
      const html = await response.text();
      const match = /csrfToken\s?=\s?"([^"]+)"/.exec(html);
      if (!match || !match[1]) {
        this._throw("csrf", "Failed to extract CSRF token from page HTML.");
      }
      this._csrfToken = match[1];
      return this._csrfToken;
    } catch (e) {
      if (this.isOwnError(e)) throw e;
      this._throw("network", `Failed to fetch CSRF token: ${e.message}`);
    }
  }

  async ask(prompt, options = {}, onChunk = () => { }) {
    const { sessionId, parentMsgId, model = "tongyi-qwen3-max-model", signal } = options;
    const csrfToken = await this._fetchCsrfToken();

    // Ensure DNR rules headers (origin/referer) are in place for qwen endpoints
    try {
      await ProviderDNRGate.ensureProviderDnrPrereqs("qwen");
    } catch (e) {
      console.warn("[QwenProvider] ProviderDNRGate failed", e);
    }

    // Helper to perform conversation POST and return response
    const doConversationPost = async (bodyObj) => {
      const headers = {
        "Accept": "text/event-stream",
        "Accept-Language": "en-US,en;q=0.9",
        "Content-Type": "application/json",
        "priority": "u=1, i",
        "X-Platform": "pc_tongyi",
        "X-Xsrf-Token": csrfToken,
        "X-DeviceId": this._getDeviceId(),
      };

      return this.fetch(`${QWEN_API_BASE}/dialog/conversation`, {
        method: "POST",
        signal,
        credentials: "include",
        referrer: `${QWEN_WEB_BASE}/`,
        headers,
        body: JSON.stringify(bodyObj),
      });
    };

    // Build request body matching new API format
    const requestBody = {
      sessionId: sessionId || "",
      sessionType: "text_chat",
      parentMsgId: parentMsgId || "",
      model: "",
      mode: "chat",
      userAction: "",
      actionSource: "",
      contents: [
        {
          content: prompt,
          contentType: "text",
          role: "user",
        },
      ],
      action: "next",
      requestId: this._generateId(),
      params: {
        specifiedModel: model,
        lastUseModelList: [model],
        recordModelName: model,
        bizSceneInfo: {},
      },
      topicId: this._generateId(),
    };

    let response;
    try {
      response = await doConversationPost(requestBody);
    } catch (e) {
      // Network error - surface as network Qwen error
      this._throw("network", `Conversation POST failed: ${e.message}`);
    }

    // If server indicates not authorized / requires session (or non-200), create session then retry
    if (!response.ok) {
      const text = await response.text().catch(() => "<no-body>");
      // If server returned NOT_LOGIN or 401/403/500, try addSession then retry
      const needAddSession =
        /NOT_LOGIN|401|403|500/.test(text) ||
        response.status === 401 ||
        response.status === 403 ||
        response.status === 500;

      if (needAddSession) {
        console.log("[QwenProvider] Session required, creating...");

        // Clear cached CSRF token and refetch
        this._csrfToken = null;
        const freshCsrfToken = await this._fetchCsrfToken();

        // Create session via addSession endpoint
        let createdSessionId;
        try {
          createdSessionId = await this._createConversation(
            prompt,
            freshCsrfToken,
            signal,
          );
        } catch (e) {
          // Bubble existing error
          throw e;
        }

        // Build retry body with new session
        const retryBody = {
          sessionId: createdSessionId,
          sessionType: "text_chat",
          parentMsgId: "",
          model: "",
          mode: "chat",
          userAction: "chat",
          actionSource: "",
          contents: [
            {
              content: prompt,
              contentType: "text",
              role: "user",
            },
          ],
          action: "next",
          requestId: this._generateId(),
          msgId: this._generateId(),
          params: {
            specifiedModel: model,
            lastUseModelList: [model],
            recordModelName: model,
            bizSceneInfo: {},
          },
          topicId: this._generateId(),
        };

        try {
          response = await doConversationPost(retryBody);
        } catch (e) {
          this._throw("network", `Conversation retry failed: ${e.message}`);
        }

        if (!response.ok) {
          const retryText = await response.text().catch(() => "<no-body>");
          this._throw(
            "unknown",
            `Conversation retry failed ${response.status}: ${retryText}`,
          );
        }
      } else {
        this._throw(
          "unknown",
          `Conversation failed ${response.status}: ${text}`,
        );
      }
    }

    // At this point response.ok is true and we can parse streaming body
    let fullText = "";
    let finalSessionId = sessionId || "";
    let finalMsgId = parentMsgId || null;

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let carry = "";
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        const lines = (carry + chunk).split("\n");
        carry = lines.pop() || "";

        for (let line of lines) {
          line = line.trim();
          if (!line) continue;
          if (line === "[DONE]" || line === "data: [DONE]") {
            break;
          }

          if (line.startsWith("data:")) {
            const payload = line.slice(5).trim();
            if (!payload) continue;
            // Ignore non-JSON keepalive messages
            if (payload === "[heartbeat]" || payload === "heartbeat") {
              continue;
            }
            try {
              const json = JSON.parse(payload);
              if (json.errorCode === "NOT_LOGIN") {
                this._throw(
                  "login",
                  "User is not logged in to Qwen.",
                );
              }

              // Normalize possible content arrays
              const possibleArr = json.contents || json.content || [];
              let found;
              if (Array.isArray(possibleArr)) {
                found = possibleArr.find(
                  (c) => c && (c.contentType === "text" || c.type === "text"),
                );
              }
              let content = undefined;
              if (found && typeof found === "object") content = found.content;
              if (
                !content &&
                Array.isArray(json.content) &&
                json.content.length > 0
              )
                content = json.content[0];

              if (content) fullText = content;
              if (json.sessionId) finalSessionId = json.sessionId;
              if (json.msgId) finalMsgId = json.msgId;
              if (fullText)
                onChunk({
                  text: fullText,
                  sessionId: finalSessionId,
                  parentMsgId: finalMsgId,
                });
            } catch (e) {
              console.warn(
                "[QwenProvider] Failed to parse SSE payload:",
                payload,
                e,
              );
            }
          } else {
            // Fallback: try parse raw line as JSON
            try {
              const json = JSON.parse(line);
              const contentsArr = json.contents || [];
              const found = Array.isArray(contentsArr)
                ? contentsArr.find((c) => c && c.contentType === "text")
                : undefined;
              const content = found ? found.content : undefined;
              if (content) {
                fullText = content;
                finalMsgId = json.msgId || finalMsgId;
                finalSessionId = json.sessionId || finalSessionId;
                onChunk({
                  text: fullText,
                  sessionId: finalSessionId,
                  parentMsgId: finalMsgId,
                });
              }
            } catch (e) {
              // Ignore non-json lines
            }
          }
        }
      }
    } finally {
      try {
        reader.releaseLock();
      } catch (e) { }
    }

    return {
      text: fullText,
      sessionId: finalSessionId,
      parentMsgId: finalMsgId,
    };
  }

  _wrapMethod(fn) {
    return async (...args) => {
      try {
        return await fn.call(this, ...args);
      } catch (e) {
        const err = this.isOwnError(e)
          ? e
          : this._createError("unknown", e.message);
        this._logError(err.message, err.details);
        throw err;
      }
    };
  }

  _throw(type, details) {
    throw this._createError(type, details);
  }

  _createError(type, details) {
    return new QwenProviderError(type, details);
  }

  _logError(...args) {
    if (this._logs) {
      console.error("QwenProvider:", ...args);
    }
  }

  isOwnError(e) {
    return e instanceof QwenProviderError;
  }
}

// =============================================================================
// QWEN PROVIDER CONTROLLER
// =============================================================================
export class QwenProviderController {
  constructor(dependencies = {}) {
    this.api = new QwenSessionApi(dependencies);
  }

  get qwenSession() {
    return this.api;
  }

  isOwnError(e) {
    return this.api.isOwnError(e);
  }
}


================================================
FILE: src/shared/auth-config.ts
================================================
/**
 * Centralized authentication configuration
 * Shared between AuthManager, tests, and documentation
 */

export const AUTH_COOKIES = [
    {
        provider: "chatgpt",
        domain: "chatgpt.com",
        name: "__Secure-next-auth.session-token",
        url: "https://chatgpt.com"
    },
    {
        provider: "claude",
        domain: "claude.ai",
        name: "sessionKey",
        url: "https://claude.ai"
    },
    {
        provider: "gemini",
        domain: "google.com",
        name: "__Secure-1PSID",
        url: "https://gemini.google.com"
    },
    {
        provider: "qwen",
        domain: "qianwen.com",
        name: "tongyi_sso_ticket",
        url: "https://qianwen.com"
    }
] as const;

export const GEMINI_VARIANTS = ['gemini', 'gemini-pro', 'gemini-exp'] as const;

export const PROVIDER_URLS: Record<string, string> = {
    chatgpt: 'https://chatgpt.com',
    claude: 'https://claude.ai',
    gemini: 'https://gemini.google.com',
    'gemini-pro': 'https://gemini.google.com',
    'gemini-exp': 'https://gemini.google.com',
    qwen: 'https://qianwen.com'
};

export type ProviderId = typeof AUTH_COOKIES[number]['provider'] | typeof GEMINI_VARIANTS[number];



================================================
FILE: src/think/computeThinkFlag.d.ts
================================================
// Auto-generated declaration for computeThinkFlag helper
export interface ComputeThinkFlagArgs {
  modeThinkButtonOn?: boolean;
  input?: string;
  inputFlags?: string[] | string | null;
}

export function computeThinkFlag(args?: ComputeThinkFlagArgs): boolean;



================================================
FILE: src/think/computeThinkFlag.js
================================================
import { AI_THINK_FLAG } from "./constants.js";

// Compute boolean think flag from modeThinkButtonOn (boolean) and inputFlags (array/string)
export function computeThinkFlag({
  modeThinkButtonOn = false,
  input = "",
  inputFlags = [],
} = {}) {
  const flags =
    Array.isArray(inputFlags) && inputFlags.length
      ? inputFlags
      : typeof input === "string"
        ? input.match(/\b\w\b/g) || []
        : [];
  return Boolean(modeThinkButtonOn) || flags.includes(AI_THINK_FLAG);
}



================================================
FILE: src/think/constants.js
================================================
// Small constants for Think-mode
export const AI_THINK_FLAG = "t";
export const O1_TOOL_NAME = "a8km123";



================================================
FILE: src/utils/ErrorHandler.js
================================================
/**
 * HTOS Error Handler with Fallback Mechanisms
 * Provides comprehensive error handling, recovery strategies, and fallback mechanisms
 */

import { persistenceMonitor } from "../core/PersistenceMonitor.js";

// ============================================================
// NEW: Provider authentication configuration
// ============================================================

export const PROVIDER_CONFIG = {
  claude: {
    displayName: 'Claude',
    loginUrl: 'https://claude.ai',
    maxInputChars: 100000,
  },
  chatgpt: {
    displayName: 'ChatGPT',
    loginUrl: 'https://chatgpt.com',
    maxInputChars: 32000,
  },
  gemini: {
    displayName: 'Gemini',
    loginUrl: 'https://gemini.google.com',
    maxInputChars: 30000,
  },
  'gemini-pro': {
    displayName: 'Gemini Pro',
    loginUrl: 'https://gemini.google.com',
    maxInputChars: 120000,
  },
  'gemini-exp': {
    displayName: 'Gemini 2.0',
    loginUrl: 'https://gemini.google.com',
    maxInputChars: 30000,
  },
  qwen: {
    displayName: 'Qwen',
    loginUrl: 'https://qianwen.com',
    maxInputChars: 30000,
  },
};

// ============================================================
// NEW: Auth error detection patterns
// ============================================================

const AUTH_STATUS_CODES = new Set([401, 403]);

const AUTH_ERROR_PATTERNS = [
  /NOT_LOGIN/i,
  /session.?expired/i,
  /unauthorized/i,
  /login.?required/i,
  /authentication.?required/i,
  /invalid.?session/i,
  /please.?log.?in/i,
];

const RATE_LIMIT_PATTERNS = [
  /rate.?limit/i,
  /too.?many.?requests/i,
  /quota.?exceeded/i,
  /try.?again.?later/i,
];

export class HTOSError extends Error {
  constructor(message, code, context = {}, recoverable = true) {
    super(message);
    this.name = "HTOSError";
    this.code = code;
    this.context = context;
    this.recoverable = recoverable;
    this.timestamp = Date.now();
    this.id = `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  toJSON() {
    return {
      id: this.id,
      name: this.name,
      message: this.message,
      code: this.code,
      context: this.context,
      recoverable: this.recoverable,
      timestamp: this.timestamp,
      stack: this.stack,
    };
  }
}

// ============================================================
// NEW: Provider-specific error class
// ============================================================

export class ProviderAuthError extends HTOSError {
  constructor(providerId, message, context = {}) {
    const config = PROVIDER_CONFIG[providerId] || {
      displayName: providerId,
      loginUrl: 'the provider website'
    };

    const userMessage = message ||
      `${config.displayName} session expired. Please log in at ${config.loginUrl}`;

    super(userMessage, 'AUTH_REQUIRED', {
      ...context,
      providerId,
      loginUrl: config.loginUrl,
      displayName: config.displayName,
    }, false); // Auth errors are not auto-recoverable

    this.name = 'ProviderAuthError';
    this.providerId = providerId;
    this.loginUrl = config.loginUrl;
  }
}

// ============================================================
// NEW: Error classification helpers
// ============================================================

/**
 * Check if an error indicates provider authentication failure
 */
export function isProviderAuthError(error) {
  // Already classified
  if (error instanceof ProviderAuthError) return true;
  if (error?.code === 'AUTH_REQUIRED') return true;

  // Check HTTP status
  const status = error?.status || error?.response?.status;
  if (status && AUTH_STATUS_CODES.has(status)) return true;

  // Check error message patterns
  const message = error?.message || String(error);
  return AUTH_ERROR_PATTERNS.some(pattern => pattern.test(message));
}

/**
 * Check if an error indicates rate limiting (NOT an auth error)
 */
export function isRateLimitError(error) {
  const status = error?.status || error?.response?.status;
  if (status === 429) return true;

  const message = error?.message || String(error);
  return RATE_LIMIT_PATTERNS.some(pattern => pattern.test(message));
}

/**
 * Check if an error is a network/connectivity issue
 */
export function isNetworkError(error) {
  const message = error?.message || String(error);
  return /failed.?to.?fetch|network|timeout|ECONNREFUSED|ENOTFOUND/i.test(message);
}

/**
 * Create a ProviderAuthError from a generic error
 */
export function createProviderAuthError(providerId, originalError, context = {}) {
  const config = PROVIDER_CONFIG[providerId] || {};

  return new ProviderAuthError(providerId, null, {
    ...context,
    originalError,
    originalMessage: originalError?.message,
    originalStatus: originalError?.status,
  });
}

/**
 * Create consolidated error for multiple provider auth failures
 */
export function createMultiProviderAuthError(providerIds, context = '') {
  if (!providerIds?.length) return null;

  if (providerIds.length === 1) {
    return new ProviderAuthError(providerIds[0]);
  }

  const lines = providerIds.map(pid => {
    const config = PROVIDER_CONFIG[pid] || { displayName: pid, loginUrl: '' };
    return `• ${config.displayName}: ${config.loginUrl}`;
  });

  const message = context
    ? `${context}\n\nPlease log in to:\n${lines.join('\n')}`
    : `Multiple providers need authentication:\n${lines.join('\n')}`;

  return new HTOSError(message, 'MULTI_AUTH_REQUIRED', {
    providerIds,
    loginUrls: providerIds.map(pid => PROVIDER_CONFIG[pid]?.loginUrl),
  }, false);
}

export class ErrorHandler {
  constructor() {
    this.fallbackStrategies = new Map();
    this.retryPolicies = new Map();
    this.errorCounts = new Map();
    this.circuitBreakers = new Map();

    this.setupDefaultStrategies();
    this.setupDefaultRetryPolicies();
    this.setupProviderStrategies(); // NEW
  }

  /**
   * NEW: Setup provider-specific strategies
   */
  setupProviderStrategies() {
    // Provider auth retry policy (conservative - auth issues rarely resolve quickly)
    this.retryPolicies.set("PROVIDER_AUTH", {
      maxRetries: 1,        // Only 1 retry after auth verification
      baseDelay: 500,
      maxDelay: 2000,
      backoffMultiplier: 2,
      jitter: false,
    });

    // Provider rate limit policy (wait longer)
    this.retryPolicies.set("PROVIDER_RATE_LIMIT", {
      maxRetries: 2,
      baseDelay: 5000,      // Start with 5 seconds
      maxDelay: 30000,      // Max 30 seconds
      backoffMultiplier: 2,
      jitter: true,
    });
  }

  /**
   * Setup default fallback strategies
   */
  setupDefaultStrategies() {
    // NEW: Provider auth fallback - use alternative provider
    this.fallbackStrategies.set(
      "PROVIDER_AUTH_FAILED",
      async (operation, context) => {
        const { failedProvider, availableProviders, authManager } = context;

        console.warn(`🔄 Provider ${failedProvider} auth failed, checking alternatives`);

        if (!availableProviders?.length || !authManager) {
          throw new ProviderAuthError(failedProvider);
        }

        // Get current auth status
        const authStatus = await authManager.getAuthStatus();

        // Find first available authorized provider
        const fallbackProvider = availableProviders.find(
          pid => pid !== failedProvider && authStatus[pid] === true
        );

        if (fallbackProvider) {
          console.log(`🔄 Falling back to ${fallbackProvider}`);
          return { fallbackProvider, authStatus };
        }

        throw new ProviderAuthError(failedProvider);
      }
    );

    // IndexedDB fallback to localStorage
    this.fallbackStrategies.set(
      "INDEXEDDB_UNAVAILABLE",
      async (operation, context) => {
        console.warn("🔄 Falling back to localStorage for:", operation);

        try {
          switch (operation) {
            case "save":
              return this.saveToLocalStorage(context.key, context.data);
            case "load":
              return this.loadFromLocalStorage(context.key);
            case "delete":
              return this.deleteFromLocalStorage(context.key);
            case "list":
              return this.listFromLocalStorage(context.prefix);
            default:
              throw new HTOSError(
                "Unsupported fallback operation",
                "FALLBACK_UNSUPPORTED",
              );
          }
        } catch (error) {
          throw new HTOSError("Fallback strategy failed", "FALLBACK_FAILED", {
            originalError: error,
          });
        }
      },
    );

    // Network fallback to cache
    this.fallbackStrategies.set(
      "NETWORK_UNAVAILABLE",
      async (operation, context) => {
        console.warn(
          "🔄 Falling back to cache for network operation:",
          operation,
        );

        // Try to use cached data
        const cacheKey = `htos_cache_${context.url || context.key}`;
        const cached = localStorage.getItem(cacheKey);

        if (cached) {
          try {
            return JSON.parse(cached);
          } catch (parseError) {
            throw new HTOSError("Cached data corrupted", "CACHE_CORRUPTED", {
              parseError,
            });
          }
        }

        throw new HTOSError("No cached data available", "NO_CACHE_AVAILABLE");
      },
    );

    // Service worker fallback to direct operations
    this.fallbackStrategies.set(
      "SERVICE_WORKER_UNAVAILABLE",
      async (operation, context) => {
        console.warn(
          "🔄 Falling back to direct operation (no service worker):",
          operation,
        );

        // Implement direct operations without service worker
        switch (operation) {
          case "persistence":
            return this.directPersistenceOperation(context);
          case "session":
            return this.directSessionOperation(context);
          default:
            throw new HTOSError(
              "Direct operation not supported",
              "DIRECT_UNSUPPORTED",
            );
        }
      },
    );
  }

  /**
   * Setup default retry policies
   */
  setupDefaultRetryPolicies() {
    // Standard retry policy
    this.retryPolicies.set("STANDARD", {
      maxRetries: 3,
      baseDelay: 1000,
      maxDelay: 10000,
      backoffMultiplier: 2,
      jitter: true,
    });

    // Aggressive retry for critical operations
    this.retryPolicies.set("CRITICAL", {
      maxRetries: 5,
      baseDelay: 500,
      maxDelay: 5000,
      backoffMultiplier: 1.5,
      jitter: true,
    });

    // Conservative retry for non-critical operations
    this.retryPolicies.set("CONSERVATIVE", {
      maxRetries: 2,
      baseDelay: 2000,
      maxDelay: 15000,
      backoffMultiplier: 3,
      jitter: false,
    });
  }

  /**
   * Handle an error with appropriate strategy
   */
  async handleError(error, context = {}) {
    const htosError = this.normalizeError(error, context);

    // Record the error
    persistenceMonitor.recordError(htosError, context);
    this.incrementErrorCount(htosError.code);

    // Check circuit breaker
    if (this.isCircuitBreakerOpen(htosError.code)) {
      throw new HTOSError("Circuit breaker open", "CIRCUIT_BREAKER_OPEN", {
        originalError: htosError,
      });
    }

    // Try recovery strategies
    if (htosError.recoverable) {
      try {
        return await this.attemptRecovery(htosError, context);
      } catch (recoveryError) {
        console.error("🚨 Recovery failed:", recoveryError);
        // Fall through to throw original error
      }
    }

    // Update circuit breaker
    this.updateCircuitBreaker(htosError.code, false);

    throw htosError;
  }

  /**
   * Normalize any error to HTOSError
   */
  normalizeError(error, context = {}) {
    // Already an HTOS error
    if (error instanceof HTOSError) {
      return error;
    }

    let code = "UNKNOWN_ERROR";
    let recoverable = true;

    // NEW: Check for provider auth errors first
    if (isProviderAuthError(error)) {
      code = "AUTH_REQUIRED";
      recoverable = false;
    } else if (isRateLimitError(error)) {
      code = "RATE_LIMITED";
      recoverable = true;
    } else if (isNetworkError(error)) {
      code = "NETWORK_ERROR";
      recoverable = true;
    }
    // Categorize common errors
    else if (error.name === "QuotaExceededError") {
      code = "STORAGE_QUOTA_EXCEEDED";
      recoverable = false;
    } else if (error.name === "InvalidStateError") {
      code = "INVALID_STATE";
    } else if (error.name === "NotFoundError") {
      code = "NOT_FOUND";
    } else if (error.name === "NetworkError") {
      code = "NETWORK_ERROR";
    } else if (error.name === "TimeoutError") {
      code = "TIMEOUT";
    } else if (error.message?.includes("IndexedDB")) {
      code = "INDEXEDDB_ERROR";
    } else if (error.message?.includes("Service Worker")) {
      code = "SERVICE_WORKER_ERROR";
    } else if (error.message?.includes("INPUT_TOO_LONG") || error.code === "INPUT_TOO_LONG") {
      code = "INPUT_TOO_LONG";
      recoverable = false;
    }

    return new HTOSError(
      error.message || String(error),
      code,
      { ...context, originalError: error },
      recoverable,
    );
  }

  /**
   * Attempt recovery using appropriate strategy
   */
  async attemptRecovery(error, context) {
    const strategy = this.getRecoveryStrategy(error.code);

    if (strategy) {
      console.log(
        `🔧 Attempting recovery for ${error.code} using strategy:`,
        strategy.name,
      );
      return await strategy.execute(error, context);
    }

    // Try fallback strategies
    const fallbackStrategy = this.getFallbackStrategy(error.code);
    if (fallbackStrategy) {
      console.log(`🔄 Using fallback strategy for ${error.code}`);
      return await fallbackStrategy(context.operation, context);
    }

    throw new HTOSError(
      "No recovery strategy available",
      "NO_RECOVERY_STRATEGY",
      { originalError: error },
    );
  }

  /**
   * Get recovery strategy for error code
   */
  getRecoveryStrategy(errorCode) {
    const strategies = {
      // NEW: Provider auth recovery
      AUTH_REQUIRED: {
        name: "Provider Auth Recovery",
        execute: async (error, context) => {
          // Auth errors are not auto-recoverable
          // Just update auth status and re-throw
          if (context.authManager && context.providerId) {
            context.authManager.invalidateCache(context.providerId);
            await context.authManager.verifyProvider(context.providerId);
          }
          throw error;
        },
      },

      // NEW: Rate limit recovery
      RATE_LIMITED: {
        name: "Rate Limit Recovery",
        execute: async (error, context) => {
          console.log(`⏳ Rate limited by ${context.providerId}, waiting...`);
          return await this.retryWithBackoff(
            context.operation,
            context,
            "PROVIDER_RATE_LIMIT"
          );
        },
      },

      INDEXEDDB_ERROR: {
        name: "IndexedDB Recovery",
        execute: async (error, context) => {
          // Try to reinitialize IndexedDB connection
          if (context.reinitialize) {
            await context.reinitialize();
            return await context.retry();
          }
          throw error;
        },
      },
      NETWORK_ERROR: {
        name: "Network Recovery",
        execute: async (error, context) => {
          // Wait and retry with exponential backoff
          return await this.retryWithBackoff(
            context.operation,
            context,
            "STANDARD",
          );
        },
      },
      TIMEOUT: {
        name: "Timeout Recovery",
        execute: async (error, context) => {
          // Retry with longer timeout
          const newContext = {
            ...context,
            timeout: (context.timeout || 5000) * 2,
          };
          return await this.retryWithBackoff(
            context.operation,
            newContext,
            "CONSERVATIVE",
          );
        },
      },
    };

    return strategies[errorCode];
  }

  /**
   * Get fallback strategy for error code
   */
  getFallbackStrategy(errorCode) {
    const fallbackMap = {
      INDEXEDDB_ERROR: "INDEXEDDB_UNAVAILABLE",
      INDEXEDDB_UNAVAILABLE: "INDEXEDDB_UNAVAILABLE",
      NETWORK_ERROR: "NETWORK_UNAVAILABLE",
      SERVICE_WORKER_ERROR: "SERVICE_WORKER_UNAVAILABLE",
    };

    const fallbackKey = fallbackMap[errorCode];
    return fallbackKey ? this.fallbackStrategies.get(fallbackKey) : null;
  }

  /**
   * Retry operation with exponential backoff
   */
  async retryWithBackoff(operation, context, policyName = "STANDARD") {
    const policy = this.retryPolicies.get(policyName);
    let lastError;

    for (let attempt = 0; attempt < policy.maxRetries; attempt++) {
      try {
        if (attempt > 0) {
          const delay = this.calculateDelay(attempt, policy);
          console.log(
            `⏳ Retrying in ${delay}ms (attempt ${attempt + 1}/${policy.maxRetries})`,
          );
          await this.sleep(delay);
        }

        return await operation(context);
      } catch (error) {
        lastError = error;
        console.warn(`❌ Attempt ${attempt + 1} failed:`, error.message);
      }
    }

    throw new HTOSError("All retry attempts failed", "RETRY_EXHAUSTED", {
      attempts: policy.maxRetries,
      lastError,
    });
  }

  /**
   * Calculate delay for exponential backoff
   */
  calculateDelay(attempt, policy) {
    let delay = policy.baseDelay * Math.pow(policy.backoffMultiplier, attempt);
    delay = Math.min(delay, policy.maxDelay);

    if (policy.jitter) {
      delay = delay * (0.5 + Math.random() * 0.5); // Add 0-50% jitter
    }

    return Math.floor(delay);
  }

  /**
   * Sleep for specified milliseconds
   */
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Increment error count for circuit breaker
   */
  incrementErrorCount(errorCode) {
    const count = this.errorCounts.get(errorCode) || 0;
    this.errorCounts.set(errorCode, count + 1);
  }

  /**
   * Check if circuit breaker is open
   */
  isCircuitBreakerOpen(errorCode) {
    const breaker = this.circuitBreakers.get(errorCode);
    if (!breaker) return false;

    const now = Date.now();
    if (breaker.state === "open" && now - breaker.openedAt > breaker.timeout) {
      // Move to half-open state
      breaker.state = "half-open";
      console.log(`🔄 Circuit breaker for ${errorCode} moved to half-open`);
    }

    return breaker.state === "open";
  }

  /**
   * Update circuit breaker state
   */
  updateCircuitBreaker(errorCode, success) {
    const threshold = 5; // Open after 5 failures
    const timeout = 60000; // 1 minute timeout

    if (!this.circuitBreakers.has(errorCode)) {
      this.circuitBreakers.set(errorCode, {
        state: "closed",
        failures: 0,
        openedAt: null,
        timeout,
      });
    }

    const breaker = this.circuitBreakers.get(errorCode);

    if (success) {
      breaker.failures = 0;
      breaker.state = "closed";
    } else {
      breaker.failures++;
      if (breaker.failures >= threshold) {
        breaker.state = "open";
        breaker.openedAt = Date.now();
        console.warn(
          `🚨 Circuit breaker opened for ${errorCode} after ${breaker.failures} failures`,
        );
      }
    }
  }

  // Fallback implementations

  async saveToLocalStorage(key, data) {
    try {
      const serialized = JSON.stringify(data);
      localStorage.setItem(`htos_fallback_${key}`, serialized);
      return { success: true, fallback: true };
    } catch (error) {
      throw new HTOSError(
        "localStorage save failed",
        "LOCALSTORAGE_SAVE_FAILED",
        { error },
      );
    }
  }

  async loadFromLocalStorage(key) {
    try {
      const data = localStorage.getItem(`htos_fallback_${key}`);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      throw new HTOSError(
        "localStorage load failed",
        "LOCALSTORAGE_LOAD_FAILED",
        { error },
      );
    }
  }

  async deleteFromLocalStorage(key) {
    try {
      localStorage.removeItem(`htos_fallback_${key}`);
      return { success: true, fallback: true };
    } catch (error) {
      throw new HTOSError(
        "localStorage delete failed",
        "LOCALSTORAGE_DELETE_FAILED",
        { error },
      );
    }
  }

  async listFromLocalStorage(prefix) {
    try {
      const keys = [];
      const fullPrefix = `htos_fallback_${prefix}`;

      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(fullPrefix)) {
          keys.push(key.substring(fullPrefix.length));
        }
      }

      return keys;
    } catch (error) {
      throw new HTOSError(
        "localStorage list failed",
        "LOCALSTORAGE_LIST_FAILED",
        { error },
      );
    }
  }

  async directPersistenceOperation(context) {
    // Implement direct persistence without service worker
    throw new HTOSError(
      "Direct persistence not implemented",
      "DIRECT_PERSISTENCE_NOT_IMPLEMENTED",
    );
  }

  async directSessionOperation(context) {
    // Implement direct session management without service worker
    throw new HTOSError(
      "Direct session management not implemented",
      "DIRECT_SESSION_NOT_IMPLEMENTED",
    );
  }

  /**
   * NEW: Handle provider-specific error with auth recovery
   */
  async handleProviderError(error, providerId, context = {}) {
    const htosError = this.normalizeError(error, {
      ...context,
      providerId
    });

    // Record for monitoring
    persistenceMonitor.recordError(htosError, { providerId, ...context });
    this.incrementErrorCount(`${providerId}_${htosError.code}`);

    // Check provider-specific circuit breaker
    const breakerKey = `provider_${providerId}`;
    if (this.isCircuitBreakerOpen(breakerKey)) {
      throw new HTOSError(
        `${PROVIDER_CONFIG[providerId]?.displayName || providerId} is temporarily unavailable`,
        "CIRCUIT_BREAKER_OPEN",
        { providerId, originalError: htosError }
      );
    }

    // For auth errors, just update status and throw
    if (htosError.code === 'AUTH_REQUIRED') {
      this.updateCircuitBreaker(breakerKey, false);
      throw createProviderAuthError(providerId, error, context);
    }

    // For rate limits, update breaker but don't fully open
    if (htosError.code === 'RATE_LIMITED') {
      // Don't count rate limits toward circuit breaker
      throw htosError;
    }

    // For other errors, use normal recovery flow
    if (htosError.recoverable) {
      try {
        const result = await this.attemptRecovery(htosError, {
          ...context,
          providerId,
        });
        this.updateCircuitBreaker(breakerKey, true);
        return result;
      } catch (recoveryError) {
        this.updateCircuitBreaker(breakerKey, false);
        throw recoveryError;
      }
    }

    this.updateCircuitBreaker(breakerKey, false);
    throw htosError;
  }

  /**
   * NEW: Get provider error statistics
   */
  getProviderErrorStats(providerId) {
    const prefix = `${providerId}_`;
    const stats = {
      providerId,
      errors: {},
      circuitBreaker: null,
    };

    for (const [code, count] of this.errorCounts.entries()) {
      if (code.startsWith(prefix)) {
        stats.errors[code.substring(prefix.length)] = count;
      }
    }

    const breaker = this.circuitBreakers.get(`provider_${providerId}`);
    if (breaker) {
      stats.circuitBreaker = {
        state: breaker.state,
        failures: breaker.failures,
      };
    }

    return stats;
  }

  /**
   * Get error statistics
   */
  getErrorStats() {
    const stats = {
      totalErrors: 0,
      errorsByCode: {},
      circuitBreakers: {},
    };

    for (const [code, count] of this.errorCounts.entries()) {
      stats.errorsByCode[code] = count;
      stats.totalErrors += count;
    }

    for (const [code, breaker] of this.circuitBreakers.entries()) {
      stats.circuitBreakers[code] = {
        state: breaker.state,
        failures: breaker.failures,
        openedAt: breaker.openedAt,
      };
    }

    return stats;
  }

  /**
   * Reset error counts and circuit breakers
   */
  reset() {
    this.errorCounts.clear();
    this.circuitBreakers.clear();
    console.log("🔄 Error handler reset");
  }
}

// Create global instance
export const errorHandler = new ErrorHandler();

// Make it available globally for debugging
if (typeof globalThis !== "undefined") {
  globalThis.__HTOS_ERROR_HANDLER = errorHandler;
}

export default errorHandler;



================================================
FILE: ui/Readme.md
================================================
## B. UI State Management & Rendering

**Purpose:** This document explains how the UI maintains turn state, reacts to backend messages, buffers streaming updates, and renders the chat view efficiently.

### Core State Model (Jotai)

The UI state is built on a "Map + Ordered IDs" pattern for performance.

#### 1. Primitives (The Source of Truth)

- **`turnsMapAtom` (Map<string, TurnMessage>):** An `atomWithImmer` map for O(1) read/write/update of any turn by its canonical ID.
- **`turnIdsAtom` (string[]):** An `atomWithImmer` array that defines the _render order_ of the turns.

#### 2. Derived State

- **`messagesAtom` (TurnMessage[]):** A derived `atom` that reads `turnIdsAtom` and `turnsMapAtom` to produce the ordered list of `TurnMessage` objects for rendering. This is what `Virtuoso` (the virtualized list) consumes.

#### 3. Workflow & Configuration Atoms

- **`currentSessionIdAtom` (string | null):** Tracks the active session.
- **`isLoadingAtom` (boolean):** True from `sendMessage` until `TURN_FINALIZED` or error.
- **`uiPhaseAtom` (UiPhase):** Tracks the UI's state ('idle', 'streaming', 'awaiting_action').
- **`activeAiTurnIdAtom` (string | null):** The ID of the `AiTurn` _currently_ being streamed into.
- **`activeRecomputeStateAtom` (object | null):** Holds the target for a recompute (`{ aiTurnId, stepType, providerId }`).
- **`selectedModelsAtom`, `mappingEnabledAtom`, `mappingProviderAtom`, `synthesisProviderAtom`:** Persisted `atomWithStorage` atoms that control the user's model configuration.

### Message Handling: Backend â†’ UI State

The `usePortMessageHandler.ts` hook is the single bridge between backend messages and UI state.

#### 1. `TURN_CREATED` (Optimistic, Canonical ID)

This is the most important flow:

1.  The backend sends `TURN_CREATED` with the _canonical_ `userTurnId` and `aiTurnId`.
2.  The handler _does not swap any IDs_.
3.  It finds the optimistic `UserTurn` (which was already added to state by `useChat.ts` using its `clientUserTurnId`).
4.  It _immediately_ creates an optimistic `AiTurn` object using the canonical `aiTurnId` from the message.
5.  This new `AiTurn` is added to `turnsMapAtom` and its ID to `turnIdsAtom`.
6.  `activeAiTurnIdAtom` is set to this `aiTurnId`.

#### 2. `PARTIAL_RESULT` (Streaming)

1.  The handler receives a `PARTIAL_RESULT` message.
2.  It parses the `stepId` to determine the `responseType` ('batch', 'mapping', 'synthesis').
3.  It passes the `providerId`, `delta` (text chunk), and `responseType` to the **`StreamingBuffer`**.

#### 3. `StreamingBuffer` (Performance)

The `StreamingBuffer` (`ui/utils/streamingBuffer.ts`) is a critical performance component.

- It collects all deltas that arrive in a ~16ms (requestAnimationFrame) window.
- It batches them into a _single_ `setTurnsMap` call.
- This prevents `setState` storms (e.g., 5 providers streaming 30 tokens/sec = 150 `setState` calls/sec) and ensures a smooth 60fps render.
- The buffer updates the `text` and `status` fields on the correct `ProviderResponse` object within the optimistic `AiTurn`.

#### 4. `WORKFLOW_STEP_UPDATE`

This message signals the completion of a _step_.

1.  **On Success:**
    - It calls `streamingBuffer.flushImmediate()` to ensure all buffered text is rendered.
    - It takes the `result` object (e.g., `result.results` for batch, or just `result` for synthesis/mapping).
    - It updates the `turnsMapAtom`, finding the `activeAiTurnId` and materializing the full, completed `ProviderResponse` object into the correct map (e.g., `turn.batchResponses[providerId] = completedEntry`).
2.  **On Failure:**
    - It records an error-state `ProviderResponse` object in the `turnsMapAtom` for the failed provider/step.
    - It sets `isLoadingAtom` to `false`.

#### 5. `TURN_FINALIZED`

This message signals the end of the _entire workflow_.

1.  It calls `streamingBuffer.flushImmediate()`.
2.  It deeply merges the canonical `turn.ai` data from the message into the existing `AiTurn` object in `turnsMapAtom`.
3.  It sets `meta.isOptimistic: false` on the turn.
4.  It sets `isLoadingAtom: false` and `activeAiTurnIdAtom: null`.

### Component Responsibilities

- **`ChatView`:** The main view. Renders `Virtuoso` (virtualized list) which consumes the derived `messagesAtom`.
- **`MessageRow`:** A simple wrapper that subscribes to an `atom((get) => get(turnsMapAtom).get(turnId))` and renders either a `UserTurnBlock` or `AiTurnBlock`.
- **`UserTurnBlockConnected`:** Renders the `UserTurn` and manages its own expanded state.
- **`AiTurnBlockConnected`:** The most complex component. It subscribes to the `AiTurn` and `activeRecomputeStateAtom`. It renders:
  - `ProviderResponseBlockConnected` (for batch responses).
  - `ClipsCarousel` (for synthesis/mapping provider selection).
  - Markdown renderers for the _selected_ synthesis/mapping responses.
  - It manages local UI state for truncation, expansion, and tab selection ("Map" vs. "Options").
- **`ProviderResponseBlockConnected`:** Renders the grid of `batch` responses for a given turn.
- **`ChatInputConnected`:** Manages the text input and calls the `useChat().sendMessage` hook.
- **`CompactModelTrayConnected`:** Renders and controls the `selectedModelsAtom`, `mappingProviderAtom`, etc.

### Recompute UX Flow

1.  A user clicks a re-run button on a _historical_ `AiTurnBlock` (e.g., "Run Synthesis with Qwen").
2.  The `AiTurnBlock`'s click handler calls `runSynthesisForAiTurn(aiTurnId, 'qwen')` (from `useRoundActions.ts`).
3.  This hook sets the **`activeRecomputeStateAtom`** to `{ aiTurnId, stepType: 'synthesis', providerId: 'qwen' }`.
4.  It then calls the `recompute` primitive.
5.  The backend streams `PARTIAL_RESULT` messages. The `usePortMessageHandler`'s `StreamingBuffer` sees `activeRecomputeStateAtom` is set and routes the deltas to the _historical_ turn (`aiTurnId`) instead of the `activeAiTurnId`.
6.  `WORKFLOW_STEP_UPDATE` (completed) arrives. The handler finds the historical `AiTurn` in `turnsMapAtom` and pushes the _new_ `ProviderResponse` into its `synthesisResponses['qwen']` array.
7.  The `AiTurnBlock` for that historical turn re-renders, now showing "Qwen" in its `ClipsCarousel` with the new completed response. `activeRecomputeStateAtom` is set to `null`.

### Key Files & References

- **State:** `ui/state/atoms.ts` (All Jotai atoms)
- **Handler:** `ui/hooks/usePortMessageHandler.ts` (Backend â†’ UI bridge)
- **Action:** `ui/hooks/useChat.ts` (UI â†’ Backend action)
- **Recompute:** `ui/hooks/useRoundActions.ts` (Recompute action logic)
- **Streaming:** `ui/utils/streamingBuffer.ts` (Performance batching)
- **Types:** `ui/types.ts` (UI-specific `AiTurn` and `ProviderResponse` shapes)
- **Renderers:** `ui/components/AiTurnBlockConnected.tsx`, `ui/components/ProviderResponseBlockConnected.tsx`

### Invariants & Gotchas

- **Never Remap IDs:** The canonical `aiTurnId` from `TURN_CREATED` is used from start to finish.
- **Order:** `turnIdsAtom` _must_ maintain the correct `UserTurn` -> `AiTurn` order.
- **Step Parsing:** The `stepId` parsing in `usePortMessageHandler` must match backend patterns to distinguish `batch` vs. `mapping` vs. `synthesis` streams.
- **Flush:** The `StreamingBuffer` _must_ be flushed before materializing a `WORKFLOW_STEP_UPDATE (completed)` entry to prevent the final text from being overwritten by a stale buffered delta.



================================================
FILE: ui/App.tsx
================================================
import { useRef, Suspense } from "react";
import { useAtom } from "jotai";
import { usePortMessageHandler } from "./hooks/chat/usePortMessageHandler";
import { useConnectionMonitoring } from "./hooks/useConnectionMonitoring";
import { useHistoryLoader } from "./hooks/useHistoryLoader";
import { useResponsiveLoadingGuard } from "./hooks/ui/useLoadingWatchdog";
import ChatView from "./views/ChatView";
import Header from "./components/Header";
import { safeLazy } from "./utils/safeLazy";
const HistoryPanel = safeLazy(() => import("./components/HistoryPanel"));
import Banner from "./components/Banner";

const SettingsPanel = safeLazy(() => import("./components/SettingsPanel"));
import { Toast } from "./components/Toast";
import { isHistoryPanelOpenAtom } from "./state/atoms";

import { useInitialization } from "./hooks/useInitialization"; // Import the new hook
import LaunchpadTab from "./components/LaunchpadTab"; // Import LaunchpadTab
const LaunchpadDrawer = safeLazy(() => import("./components/LaunchpadDrawer")); // Lazy load LaunchpadDrawer
import { useSmartProviderDefaults } from "./hooks/providers/useSmartProviderDefaults";
import { useOnClickOutside } from "usehooks-ts";
import { useKey } from "./hooks/ui/useKey";

export default function App() {
  // This is now the entry point for all startup logic.
  const isInitialized = useInitialization();
  useSmartProviderDefaults();

  // Initialize other global side effects that can run after init
  usePortMessageHandler();
  useConnectionMonitoring();
  useHistoryLoader(isInitialized); // Pass the flag to the history loader
  // Non-destructive loading guard: surfaces alerts when idle while loading
  useResponsiveLoadingGuard({ idleWarnMs: 15000, idleCriticalMs: 45000 });

  const [isHistoryOpen, setIsHistoryOpen] = useAtom(isHistoryPanelOpenAtom);

  const historyPanelRef = useRef<HTMLDivElement>(null);

  const closePanel = () => setIsHistoryOpen(false);

  useOnClickOutside(historyPanelRef, closePanel);
  useKey("Escape", closePanel);

  // THE INITIALIZATION BARRIER
  if (!isInitialized) {
    // Render a simple loading state or nothing at all.
    // This prevents any child components from running their hooks too early.
    return (
      <div className="flex items-center justify-center h-screen bg-surface-highest">
        <div className="loading-spinner" />
      </div>
    );
  }

  // Once initialized, render the full application.
  return (
    <div className="flex flex-col h-screen w-screen bg-app-gradient min-h-0">
      <Header />
      <Banner />

      {/* Main content area */}
      <div className="flex flex-1 relative min-h-0">
        <LaunchpadTab /> {/* Add Launchpad Tab */}

        <main className="chat-main flex-1 flex flex-col relative min-h-0">
          <ChatView />
        </main>

        <Suspense fallback={null}>
          <LaunchpadDrawer /> {/* Add Launchpad Drawer */}
        </Suspense>

        {/* History Panel Overlay */}
        {isHistoryOpen && (
          <>
            <div
              className="history-backdrop fixed inset-0 bg-overlay-backdrop/10 backdrop-blur-md z-[2999]"
              onClick={closePanel}
            />
            <div
              ref={historyPanelRef}
              className="fixed top-0 left-0 w-[320px] h-screen z-[3000]"
            >
              <Suspense fallback={null}>
                <HistoryPanel />
              </Suspense>
            </div>
          </>
        )}
      </div>

      {/* Settings Panel - Slides in from right */}
      <Suspense fallback={null}>
        <SettingsPanel />
      </Suspense>

      {/* Global Toast Notifications */}
      <Toast />
    </div>
  );
}



================================================
FILE: ui/constants.ts
================================================
import { LLMProvider } from "./types";

import { INITIAL_PROVIDERS } from "./providers/providerRegistry";

export const LLM_PROVIDERS_CONFIG: LLMProvider[] = [...INITIAL_PROVIDERS];

export const SIMULATION_CHUNK_DELAY_MS = 70;
export const FIRST_SENTENCE_SUMMARY_CHUNKS = 8;
export const FULL_OUTPUT_CHUNKS = 30;
export const OVERALL_SUMMARY_CHUNKS = 15;

export const EXAMPLE_PROMPT =
  "Explain the concept of quantum entanglement in simple terms.";

export const STREAMING_PLACEHOLDER = ""; // CSS will handle visual streaming indicators (pulsing dots)

// Preferred streaming providers to prioritize in visible slots when 4+ are selected
export const PRIMARY_STREAMING_PROVIDER_IDS: string[] = [
  "gemini-exp",
  "claude",
  "qwen",
];

// Provider color mapping for orb animations


// ui/constants.ts

export const PROVIDER_COLORS: Record<string, string> = {
  'claude': '#E07850',
  'gemini': '#3B82F6',
  'gemini-pro': '#06B6D4',
  'gemini-exp': '#8B5CF6',
  'chatgpt': '#10A37F',
  'qwen': '#F59E0B',
  'default': '#64748B'
};

export const PROVIDER_ACCENT_COLORS: Record<string, string> = {
  'claude': '#C75B3A',
  'gemini': '#1D4ED8',
  'gemini-pro': '#0891B2',
  'gemini-exp': '#6D28D9',
  'chatgpt': '#047857',
  'qwen': '#D97706',
  'default': '#475569'
};

// Keep workflow colors as-is
export const WORKFLOW_STAGE_COLORS: Record<
  'idle' | 'thinking' | 'streaming' | 'complete' | 'error' | 'synthesizing',
  string
> = {
  idle: 'rgba(255,255,255,0.35)',
  thinking: '#A78BFA',
  streaming: '#34D399',
  complete: '#60A5FA',
  error: '#EF4444',
  synthesizing: '#F59E0B',
};


================================================
FILE: ui/index.html
================================================
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="/icons/icon-16.png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Singularity - Intelligence Augmentation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family:
        -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 100%);
      color: #e2e8f0;
      /* Tailwind gray-300 approx */
      height: 100vh;
    }

    #root {
      height: 100%;
    }

    /* Custom scrollbar for webkit browsers */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Animations */
    @keyframes synthesisGlow {
      0% {
        opacity: 0.5;
      }

      100% {
        opacity: 1;
      }
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 0.4;
        transform: scale(0.95);
      }

      50% {
        opacity: 1;
        transform: scale(1.05);
      }
    }

    .loading-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>

  <link rel="stylesheet" href="styles/index.css" />
</head>

<body>
  <div id="root"></div>
  <script type="module" src="index.tsx"></script>
</body>

</html>


================================================
FILE: ui/index.tsx
================================================
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App";
import ErrorBoundary from "./components/ErrorBoundary";
import { enableMapSet } from "immer";

enableMapSet();

const rootElement = document.getElementById("root");
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = createRoot(rootElement);
root.render(
  <StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </StrictMode>,
);



================================================
FILE: ui/tsconfig.json
================================================
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "types": [
      "react",
      "react-dom",
      "chrome",
      "node"
    ],
    "baseUrl": ".",
    "paths": {
      "@shared/*": [
        "../shared/*"
      ]
    }
  },
  "include": [
    "./**/*.ts",
    "./**/*.tsx",
    "./**/*.d.ts",
    "types/**/*.d.ts",
    "../shared/**/*.ts"
  ],
  "exclude": [
    "../dist",
    "docs",
    "../node_modules"
  ]
}


================================================
FILE: ui/assets/singularity_brand.md
================================================
# SINGULARITY BRAND IDENTITY SYSTEM

## Brand Essence

**Singularity** represents the convergence of multiple artificial intelligence systems into unified, decision-ready intelligence. The brand embodies the intersection of complexity and clarity, where multiple perspectives synthesize into emergent understanding.

### Core Values
- **Emergent Intelligence**: Intelligence that arises from the interaction of multiple systems
- **Dialectical Reasoning**: Truth discovered through the tension of opposing viewpoints
- **Transparent Complexity**: Making sophisticated systems legible and accessible
- **Conversational Continuity**: Building understanding through iterative dialogue

## Visual Identity Concept

### "The Convergence Point"
The visual identity centers on the mathematical concept of a singularityâ€”a point where multiple trajectories converge. This is expressed through:

- **Geometric Intersection**: Clean lines that meet at precise convergence points
- **Layered Transparency**: Multiple planes of information that reveal depth through interaction
- **Dynamic Balance**: Asymmetrical compositions that achieve visual equilibrium
- **Intellectual Elegance**: Sophisticated restraint that speaks to technical excellence

## Color Palette

### Primary Colors
- **Void Black** (#0A0A0B): The depth of space, infinite possibility
- **Platinum White** (#F8F9FA): Pure intelligence, clarity of thought
- **Convergence Blue** (#2D3748): The moment of synthesis, neural pathways

### Accent Colors
- **Neural Teal** (#4A9B8E): Active processing, system energy
- **Insight Amber** (#F6AD55): Illumination, breakthrough moments
- **Warning Coral** (#FC8181): Critical attention, system alerts

### Gradient Applications
- **Singularity Gradient**: Void Black â†’ Convergence Blue â†’ Platinum White
- **Processing Gradient**: Neural Teal â†’ Insight Amber (for active states)

## Typography

### Primary Typeface: Suisse International
- **Display**: Suisse International Bold for headlines and logo
- **Body**: Suisse International Regular for content
- **Technical**: Suisse International Mono for code and data

### Typographic Hierarchy
- **H1**: 48px Bold, tracking -0.02em
- **H2**: 32px Medium, tracking -0.01em
- **H3**: 24px Regular
- **Body**: 16px Regular, line-height 1.6
- **Caption**: 14px Regular, opacity 0.7

## Logo System

### Primary Logo Mark
The Singularity logo consists of:
1. **The Convergence Symbol**: Three lines intersecting at a single point, representing multiple AI models converging
2. **Wordmark**: Custom typography treatment of "SINGULARITY"
3. **Integration**: Symbol and wordmark can function independently or together

### Logo Variations
- **Full Lockup**: Symbol + Wordmark (primary usage)
- **Symbol Only**: For small applications and favicons
- **Wordmark Only**: When horizontal space is limited
- **Monochrome**: Single color versions for various backgrounds

## Visual Language

### Geometric System
Based on a 60Â° grid system that creates:
- **Convergence Points**: Where three lines meet (representing synthesis)
- **Emergence Angles**: 30Â° and 90Â° variations for dynamic layouts
- **Balance Asymmetry**: Intentional imbalance that creates visual interest

### Motion Principles
- **Convergence Animation**: Lines drawing toward center point
- **Synthesis Pulse**: Gentle glow at intersection points
- **Dialectical Oscillation**: Subtle movement between opposing states

## Application Guidelines

### Digital Applications
- **Website**: Dark theme with platinum white text
- **Interface**: High contrast for clarity and accessibility
- **Motion**: Subtle animations that enhance understanding

### Print Applications
- **Business Cards**: Embossed convergence symbol on matte black
- **Letterhead**: Minimal header with gradient accent
- **Presentations**: Clean layouts with generous white space

### Environmental
- **Office Signage**: Backlit convergence symbols
- **Conference Materials**: Consistent geometric patterns
- **Trade Show**: Large-scale convergence installations

## Brand Voice

### Tone Characteristics
- **Intellectually Rigorous**: Precise, thoughtful, evidence-based
- **Elegantly Simple**: Complex ideas made accessible
- **Confidently Humble**: Expertise without arrogance
- **Conversationally Professional**: Approachable expertise

### Writing Guidelines
- **Active Voice**: Direct, clear communication
- **Technical Precision**: Accurate terminology and concepts
- **Narrative Flow**: Logical progression of ideas
- **Inclusive Language**: Accessible to diverse audiences

## Implementation Strategy

### Phase 1: Core Identity
- Logo finalization and trademark registration
- Basic stationery and digital assets
- Website redesign with new visual system

### Phase 2: Extended System
- Comprehensive brand guidelines documentation
- Template systems for various applications
- Team training on brand usage

### Phase 3: Brand Experience
- Environmental design applications
- Advanced motion and interaction design
- Brand measurement and optimization

This identity system positions Singularity as the definitive platform for multi-model AI synthesis, where complexity becomes clarity through intelligent design.


================================================
FILE: ui/components/AiTurnBlock.tsx
================================================
// ui/components/AiTurnBlock.tsx - FIXED ALIGNMENT
import React, {
  useMemo,
  useState,
  useCallback,
  useRef,
  useEffect,
} from "react";
import { useSetAtom, useAtomValue, useAtom } from "jotai";
import {
  toastAtom,
  activeSplitPanelAtom,
  isDecisionMapOpenAtom,
  synthesisProviderAtom,
  includePromptInCopyAtom,
  activeRecomputeStateAtom,
  mappingProviderAtom,
  chatInputValueAtom,
  trustPanelFocusAtom,
} from "../state/atoms";
import { useClipActions } from "../hooks/useClipActions";
import { AiTurn, ProviderResponse } from "../types";
import MarkdownDisplay from "./MarkdownDisplay";
import { LLM_PROVIDERS_CONFIG } from "../constants";
import { SettingsIcon } from "./Icons";
import { CouncilOrbs } from "./CouncilOrbs";
import { CopyButton } from "./CopyButton";
import { formatSynthesisForMd, formatTurnForMd } from "../utils/copy-format-utils";
import {
  normalizeResponseArray,
  getLatestResponse,
} from "../utils/turn-helpers";
import clsx from "clsx";
import ProviderErrorCard from "./ProviderErrorCard";
import { useRetryProvider } from "../hooks/providers/useRetryProvider";
import {
  providerErrorsAtom,
  retryableProvidersAtom,
  activeAiTurnIdAtom,
  isLoadingAtom,
  workflowProgressAtom,
  antagonistProviderAtom,
} from "../state/atoms";
import { useRefinerOutput } from "../hooks/useRefinerOutput";
import { parseMappingResponse } from "../../shared/parsing-utils";

import { RefinerDot } from "./refinerui/RefinerDot";
import { AntagonistCard } from "./antagonist/AntagonistCard";

// --- Helper Functions ---

function splitSynthesisAnswer(text: string): { shortAnswer: string; longAnswer: string | null } {
  const input = String(text || '').replace(/\r\n/g, '\n');
  if (!input.trim()) return { shortAnswer: '', longAnswer: null };

  const patterns: RegExp[] = [
    /(?:^|\n)\s*#{1,6}\s*the\s+long\s+answer\s*:?\s*(?:\n|$)/i,
    /(?:^|\n)\s*#{1,6}\s*long\s+answer\s*:?\s*(?:\n|$)/i,
    /(?:^|\n)\s*\*\*\s*the\s+long\s+answer\s*\*\*\s*:?\s*(?:\n|$)/i,
    /(?:^|\n)\s*\*\*\s*long\s+answer\s*\*\*\s*:?\s*(?:\n|$)/i,
    /(?:^|\n)\s*the\s+long\s+answer\s*:?\s*(?:\n|$)/i,
    /(?:^|\n)\s*long\s+answer\s*:?\s*(?:\n|$)/i,
  ];

  let best: { index: number; length: number } | null = null;
  for (const re of patterns) {
    const match = input.match(re);
    if (match && typeof match.index === 'number') {
      const idx = match.index;
      if (!best || idx < best.index) {
        best = { index: idx, length: match[0].length };
      }
    }
  }

  if (!best) return { shortAnswer: input.trim(), longAnswer: null };

  const shortAnswer = input.slice(0, best.index).trim();
  const longAnswer = input.slice(best.index + best.length).trim();

  return {
    shortAnswer,
    longAnswer: longAnswer ? longAnswer : null,
  };
}


function truncateGemInsight(insight: string, maxLength: number = 70): string {
  if (insight.length <= maxLength) return insight;
  return insight.substring(0, maxLength).trimEnd() + "...";
}

interface GemFlashProps {
  insight: string;
}

const GemFlash: React.FC<GemFlashProps> = ({ insight }) => {
  const [visible, setVisible] = useState(false);
  const [text, setText] = useState("");
  const prevInsightRef = useRef<string | null>(null);

  useEffect(() => {
    const nextInsight = (insight || "").trim();
    if (!nextInsight) return;
    if (prevInsightRef.current === nextInsight) return;
    prevInsightRef.current = nextInsight;
    const truncated = truncateGemInsight(nextInsight, 70);
    setText(truncated);
    setVisible(true);
    const timer = setTimeout(() => {
      setVisible(false);
    }, 2500);
    return () => clearTimeout(timer);
  }, [insight]);

  if (!text) return null;

  return (
    <div
      className={`mt-2 text-center text-[13px] text-text-secondary max-w-md mx-auto px-4 transition-opacity duration-300 ${visible ? "opacity-100" : "opacity-0"
        }`}
    >
      {text}
    </div>
  );
};

interface AiTurnBlockProps {
  aiTurn: AiTurn;
}


const AiTurnBlock: React.FC<AiTurnBlockProps> = ({
  aiTurn,
}) => {
  const renderCount = useRef(0);
  renderCount.current += 1;

  useEffect(() => {
    console.log(`[AiTurnBlock] Rendered ${renderCount.current} times. ID: ${aiTurn.id}`);
  });

  // --- CONNECTED STATE LOGIC ---

  const synthesisProvider = useAtomValue(synthesisProviderAtom);
  const mappingProvider = useAtomValue(mappingProviderAtom);
  const { handleClipClick } = useClipActions();
  const [globalActiveRecomputeState] = useAtom(activeRecomputeStateAtom);
  const providerErrors = useAtomValue(providerErrorsAtom);
  const retryableProviders = useAtomValue(retryableProvidersAtom);
  const { retryProviders } = useRetryProvider();

  // Streaming UX: determine if this is the active running turn
  const activeAntagonistPid = useAtomValue(antagonistProviderAtom);
  const activeAiTurnId = useAtomValue(activeAiTurnIdAtom);
  const globalIsLoading = useAtomValue(isLoadingAtom);
  const workflowProgress = useAtomValue(workflowProgressAtom);
  const isThisTurnActive = activeAiTurnId === aiTurn.id && globalIsLoading;

  const { output: refinerOutput, isLoading: isRefinerLoading } = useRefinerOutput(aiTurn.id);

  const setChatInput = useSetAtom(chatInputValueAtom);
  const setTrustPanelFocus = useSetAtom(trustPanelFocusAtom);

  const [showEcho, setShowEcho] = useState(false);


  const getProviderName = useCallback((pid: string) => {
    const cfg = LLM_PROVIDERS_CONFIG.find(p => String(p.id) === pid);
    return cfg?.name || pid;
  }, []);


  const onClipClick = useCallback(
    (type: "synthesis" | "mapping" | "antagonist", pid: string) => {
      void handleClipClick(aiTurn.id, type, pid);
    },
    [handleClipClick, aiTurn.id]
  );


  // Filter activeRecomputeState to only include synthesis/mapping (AiTurnBlock doesn't handle batch)
  const activeRecomputeState = useMemo(() => {
    if (!globalActiveRecomputeState) return null;
    if (globalActiveRecomputeState.stepType === 'batch') return null;
    return globalActiveRecomputeState as { aiTurnId: string; stepType: "synthesis" | "mapping"; providerId: string; };
  }, [globalActiveRecomputeState]);

  // Use global synthesis provider, or fall back to the provider used for generation
  const activeSynthesisClipProviderId = synthesisProvider || aiTurn.meta?.synthesizer;

  // For mapping, if no explicit global selection and meta.mapper is missing,
  // default to the first provider that has mapping responses
  const activeMappingClipProviderId = (() => {
    // Global selection
    if (mappingProvider) return mappingProvider;

    // Fallback to meta.mapper from backend
    if (aiTurn.meta?.mapper) return aiTurn.meta.mapper;

    // Final fallback: first provider with mapping responses
    const mappingProviders = Object.keys(aiTurn.mappingResponses || {});
    if (mappingProviders.length > 0) {
      return mappingProviders[0];
    }
    return undefined;
  })();


  // Extract graph topology from mapping response metadata (if available)
  const graphTopology = useMemo(() => {
    if (!activeMappingClipProviderId) {
      return null;
    }

    const mappingResponsesForProvider = aiTurn.mappingResponses?.[activeMappingClipProviderId];
    if (!mappingResponsesForProvider || mappingResponsesForProvider.length === 0) {
      return null;
    }

    const latestMapping = Array.isArray(mappingResponsesForProvider)
      ? mappingResponsesForProvider[mappingResponsesForProvider.length - 1]
      : mappingResponsesForProvider;

    // Check if topology exists in meta (preferred)
    const metaTopology = (latestMapping as any)?.meta?.graphTopology;
    if (metaTopology) {
      return metaTopology;
    }

    // FALLBACK: Extract from raw text using shared utility
    const rawText = (latestMapping as any)?.text;
    if (!rawText || typeof rawText !== 'string') {
      return null;
    }

    const { graphTopology } = parseMappingResponse(rawText);
    return graphTopology;
  }, [activeMappingClipProviderId, aiTurn.mappingResponses, aiTurn.id]);


  // --- PRESENTATION LOGIC ---

  const setToast = useSetAtom(toastAtom);
  const setActiveSplitPanel = useSetAtom(activeSplitPanelAtom);
  const setIsDecisionMapOpen = useSetAtom(isDecisionMapOpenAtom);
  const isDecisionMapOpen = useAtomValue(isDecisionMapOpenAtom);
  const [includePromptInCopy, setIncludePromptInCopy] = useAtom(includePromptInCopyAtom);

  // State for Claude artifact overlay
  const [selectedArtifact, setSelectedArtifact] = useState<{
    title: string;
    identifier: string;
    content: string;
  } | null>(null);


  // --- SYNTHESIS TABS LOGIC ---
  const synthesisTabs = useMemo(() => {
    if (!aiTurn.synthesisResponses) return [];

    interface SynthTab {
      id: string; // unique: providerId + index
      providerId: string;
      index: number;
      label: string;
      response: ProviderResponse;
      isLatest: boolean;
    }

    const tabs: SynthTab[] = [];
    const providerOrder = new Map(
      LLM_PROVIDERS_CONFIG.map((p, idx) => [String(p.id), idx] as const)
    );
    const providersWithResponses = Object.entries(aiTurn.synthesisResponses)
      .filter(([_, resps]) => Array.isArray(resps) && resps.length > 0);

    // Sort providers by predetermined order or alphabetical
    // This ensures tabs are stable
    const sortedProviders = providersWithResponses.sort((a, b) => {
      const idxA = providerOrder.get(a[0]) ?? Number.POSITIVE_INFINITY;
      const idxB = providerOrder.get(b[0]) ?? Number.POSITIVE_INFINITY;
      if (idxA !== idxB) return idxA - idxB;
      return String(a[0]).localeCompare(String(b[0]));
    });

    sortedProviders.forEach(([pid, resps]) => {
      const name = getProviderName(pid);

      const respsArray = Array.isArray(resps) ? resps : [resps];
      // Filter out empty responses unless they are streaming/error
      const validResps = respsArray.filter(r => r.text || r.status === 'streaming' || r.status === 'error');

      validResps.forEach((resp, idx) => {
        // If there's more than one response for this provider, append number
        const count = validResps.length;
        const label = count > 1 ? `${name} ${idx + 1}` : name;

        tabs.push({
          id: `${pid}-${idx}`,
          providerId: pid,
          index: idx,
          label,
          response: resp,
          isLatest: idx === validResps.length - 1
        });
      });
    });

    return tabs;
  }, [aiTurn.synthesisResponses, aiTurn.synthesisVersion]);

  // Track active tab ID. Default to the very last (latest) tab.
  // We use a ref to detect new arrivals and auto-switch if needed.
  const [activeSynthTabId, setActiveSynthTabId] = useState<string | null>(null);
  const prevTabsLengthRef = useRef(0);

  // Auto-select latest tab on mount or when new tabs arrive
  useEffect(() => {
    if (synthesisTabs.length > 0) {
      // If first load (active is null) OR new tabs added (recompute finished)
      if (activeSynthTabId === null || synthesisTabs.length > prevTabsLengthRef.current) {
        // Find the "recompute target" if exists, else just the last one
        const lastTab = synthesisTabs[synthesisTabs.length - 1];

        // If we have a specific active recompute target, prioritize that
        if (activeRecomputeState?.stepType === "synthesis" && activeRecomputeState.aiTurnId === aiTurn.id) {
          const targetTab = synthesisTabs.slice().reverse().find(t => t.providerId === activeRecomputeState.providerId);
          if (targetTab) {
            setActiveSynthTabId(targetTab.id);
          } else {
            setActiveSynthTabId(lastTab.id);
          }
        } else {
          setActiveSynthTabId(lastTab.id);
        }
      }
    }
    prevTabsLengthRef.current = synthesisTabs.length;
  }, [synthesisTabs, activeRecomputeState, aiTurn.id]); // activeSynthTabId excluded to allow manual switch

  // Derive the effectively active tab (for orbs and display)
  const effectiveActiveSynthTab = useMemo(() => {
    if (synthesisTabs.length === 0) return null;
    return synthesisTabs.find(t => t.id === activeSynthTabId) || synthesisTabs[synthesisTabs.length - 1];
  }, [synthesisTabs, activeSynthTabId]);



  const synthesisResponses = useMemo(() => {
    if (!aiTurn.synthesisResponses) aiTurn.synthesisResponses = {};
    const out = LLM_PROVIDERS_CONFIG.reduce<Record<string, ProviderResponse[]>>(
      (acc, p) => {
        acc[String(p.id)] = [];
        return acc;
      },
      {}
    );
    Object.entries(aiTurn.synthesisResponses).forEach(([pid, resp]) => {
      out[pid] = normalizeResponseArray(resp);
    });
    return out;
  }, [aiTurn.id, aiTurn.synthesisVersion]);

  const mappingResponses = useMemo(() => {
    const map = aiTurn.mappingResponses || {};
    const out = LLM_PROVIDERS_CONFIG.reduce<Record<string, ProviderResponse[]>>(
      (acc, p) => {
        acc[String(p.id)] = [];
        return acc;
      },
      {}
    );
    Object.entries(map).forEach(([pid, resp]) => {
      out[pid] = normalizeResponseArray(resp);
    });
    return out;
  }, [aiTurn.id, aiTurn.mappingVersion]);

  const allSources = useMemo(() => {
    const sources: Record<string, ProviderResponse> = {};
    // Take latest element from each provider's array
    Object.entries(aiTurn.batchResponses || {}).forEach(([pid, resp]) => {
      const arr = Array.isArray(resp) ? resp : [resp as any];
      if (arr.length > 0) {
        const latest = arr[arr.length - 1] as ProviderResponse;
        sources[pid] = latest;
      }
    });
    return sources;
  }, [aiTurn.batchResponses]);

  const providerIds = useMemo(
    () => LLM_PROVIDERS_CONFIG.map((p) => String(p.id)),
    []
  );

  const computeActiveProvider = useCallback(
    (explicit: string | undefined, map: Record<string, ProviderResponse[]>) => {
      if (explicit) return explicit;
      for (const pid of providerIds) {
        const arr = map[pid];
        if (arr && arr.length > 0) return pid;
      }
      return undefined;
    },
    [providerIds]
  );

  const globalSynthesisProvider = useAtomValue(synthesisProviderAtom);

  const activeSynthPid = useMemo(() => {
    // 1. Clip Override (Highest Priority interaction)
    if (activeSynthesisClipProviderId) return activeSynthesisClipProviderId;

    // 2. Global State
    if (globalSynthesisProvider) return globalSynthesisProvider;

    // 3. Persisted Metadata
    const metaSynth = (aiTurn.meta as any)?.synthesizer;
    if (metaSynth) return metaSynth;

    // 4. Fallback: Check for any completed synthesis response
    for (const p of LLM_PROVIDERS_CONFIG) {
      const pid = String(p.id);
      const responses = synthesisResponses[pid];
      if (responses?.some(r => r.status === 'completed' || (r.text && r.status !== 'error'))) {
        return pid;
      }
    }

    return undefined;
  }, [activeSynthesisClipProviderId, globalSynthesisProvider, aiTurn.meta, synthesisResponses]);

  // The provider ID to show as "Voice" (Crown) on the historical orbs
  const displayedVoicePid = effectiveActiveSynthTab?.providerId || activeSynthPid || "";

  const visibleProviderIds = useMemo(() => {
    const ids = new Set(Object.keys(allSources));
    if (activeSynthPid) ids.add(activeSynthPid);
    if (effectiveActiveSynthTab?.providerId) ids.add(effectiveActiveSynthTab.providerId);
    if ((aiTurn.meta as any)?.mapper) ids.add((aiTurn.meta as any).mapper);
    return Array.from(ids);
  }, [allSources, activeSynthPid, effectiveActiveSynthTab, aiTurn.meta]);
  const activeMappingPid = computeActiveProvider(
    activeMappingClipProviderId,
    mappingResponses
  );

  const isSynthesisTarget = !!(
    activeRecomputeState &&
    activeRecomputeState.aiTurnId === aiTurn.id &&
    activeRecomputeState.stepType === "synthesis" &&
    (!activeSynthPid || activeRecomputeState.providerId === activeSynthPid)
  );

  const getMappingAndOptions = useCallback(
    (take: ProviderResponse | undefined) => {
      if (!take?.text) return { narrative: "", options: null, graphTopology: null };
      return parseMappingResponse(String(take.text));
    },
    []
  );

  const getOptions = useCallback((): string | null => {
    if (!activeMappingPid) return null;
    const take = getLatestResponse(mappingResponses[activeMappingPid]);
    const fromMeta = (take as any)?.meta?.allAvailableOptions || null;
    if (fromMeta) return String(fromMeta);
    const { options } = getMappingAndOptions(take);
    return options;
  }, [activeMappingPid, mappingResponses, getMappingAndOptions]);

  const displayedMappingTake = useMemo(() => {
    if (!activeMappingPid) return undefined;
    return getLatestResponse(mappingResponses[activeMappingPid]);
  }, [activeMappingPid, mappingResponses]);

  const displayedMappingText = useMemo(() => {
    if (!displayedMappingTake?.text) return "";
    return String(getMappingAndOptions(displayedMappingTake).narrative ?? "");
  }, [displayedMappingTake, getMappingAndOptions]);


  const hasMapping = !!(activeMappingPid && displayedMappingTake?.text);


  const requestedSynth = (aiTurn.meta as any)?.requestedFeatures?.synthesis;
  const wasSynthRequested =
    requestedSynth === undefined ? true : !!requestedSynth;


  const userPrompt: string | null =
    (aiTurn as any)?.userPrompt ??
    (aiTurn as any)?.prompt ??
    (aiTurn as any)?.input ??
    null;

  const handleCopyFullTurn = useCallback(() => {
    const md = formatTurnForMd(
      aiTurn.id,
      userPrompt,
      effectiveActiveSynthTab?.response?.text || null,
      effectiveActiveSynthTab?.providerId,
      hasMapping && activeMappingPid ? { narrative: displayedMappingText, options: getOptions(), topology: graphTopology } : null,
      allSources,
      includePromptInCopy
    );
    navigator.clipboard.writeText(md);
  }, [
    aiTurn.id,
    userPrompt,
    effectiveActiveSynthTab?.response?.text,
    effectiveActiveSynthTab?.providerId,
    hasMapping,
    activeMappingPid,
    displayedMappingText,
    getOptions,
    graphTopology,
    allSources,
    includePromptInCopy
  ]);

  // --- NEW: Crown Move Handler (Recompute) - REMOVED for historical turns ---
  // The crown is now static for historical turns. Recompute is handled via the button below.


  return (
    <div className="turn-block pb-32 mt-4">
      {userPrompt && (
        <div className="user-prompt-block mt-24 mb-8">
          <div className="text-xs text-text-muted mb-1.5">
            Your Prompt
          </div>
          <div className="bg-surface border border-border-subtle rounded-lg p-3 text-text-secondary">
            {userPrompt}
          </div>
        </div>
      )}

      <div className="ai-turn-block relative group/turn">


        <div className="ai-turn-content flex flex-col gap-3">

          {/* SHARED LAYOUT CONTAINER */}
          <div className="flex justify-center w-full transition-all duration-300 px-4">
            <div className="w-full max-w-7xl">
              {/* LEFT: Synthesis Block with Orbs Inside */}
              <div className="flex-1 flex flex-col relative min-w-0" style={{ maxWidth: '820px', margin: '0 auto' }}>

                {/* Synthesis Bubble */}
                <div
                  className={clsx(
                    "synthesis-bubble bg-surface rounded-3xl border border-border-subtle shadow-sm relative z-10 transition-all duration-300"
                  )}
                  style={{ padding: '28px 40px 88px' }}
                >
                  {/* Refiner Dot - positioned top right of synthesis */}

                  {/* OVERLAY: Floating Controls (Fade in on Group Hover) */}
                  <div className="absolute inset-0 pointer-events-none z-20">
                    <div className="flex flex-col justify-between h-full px-8 py-6 opacity-0 group-hover/turn:opacity-100 focus-within:opacity-100 transition-opacity duration-300 ease-out">

                      {/* Top-Right: Copy Synthesis */}
                      {effectiveActiveSynthTab?.response?.text && (
                        <div className="self-end pointer-events-auto">
                          <CopyButton
                            text={formatSynthesisForMd(
                              effectiveActiveSynthTab.response.text,
                              effectiveActiveSynthTab.label
                            )}
                            label="Copy Synthesis"
                            variant="icon"
                            className="bg-surface/95 backdrop-blur-sm shadow-lg rounded-full"
                          />
                        </div>
                      )}

                      {/* Bottom: Copy Turn + Settings + (centered stuff will be pointer-events-auto) */}
                      <div className="flex justify-between items-end mt-auto w-full pointer-events-auto">
                        {/* Left: Copy Turn + Settings */}
                        <div className="flex items-center gap-3">
                          <CopyButton
                            onCopy={handleCopyFullTurn}
                            label="Copy full turn"
                            className="bg-surface/95 backdrop-blur-sm shadow-lg rounded-lg text-xs font-medium px-3 py-1.5"
                          >
                            Copy Turn
                          </CopyButton>

                          <button
                            className="bg-surface/95 backdrop-blur-sm shadow-lg rounded-full p-2 text-text-muted hover:text-text-primary transition-colors"
                            onClick={() => setIncludePromptInCopy(!includePromptInCopy)}
                            title={includePromptInCopy ? "Include User Prompt: ON" : "Include User Prompt: OFF"}
                          >
                            <SettingsIcon className={clsx("w-4 h-4", includePromptInCopy && "text-brand-400")} />
                          </button>
                        </div>

                        {/* Right: empty (orbs are centered absolutely) */}
                      </div>
                    </div>
                  </div>

                  {/* SYNTHESIS TABS UI */}
                  {synthesisTabs.length > 0 && (
                    <div className="relative z-10 flex gap-2 overflow-x-auto pb-4 px-2 mb-2 no-scrollbar border-b border-border-subtle/50">
                      {synthesisTabs.map((tab) => {
                        const isActive = tab.id === activeSynthTabId;
                        const isStreaming = tab.response.status === 'streaming';
                        const isError = tab.response.status === 'error';

                        return (
                          <button
                            key={tab.id}
                            onClick={(e) => {
                              e.stopPropagation();
                              setActiveSynthTabId(tab.id);
                              // Also move split panel if needed (optional)
                            }}
                            className={clsx(
                              "relative px-4 py-2 rounded-full text-sm font-medium transition-all whitespace-nowrap border",
                              isActive
                                ? "bg-surface-raised border-brand-400 text-text-primary shadow-sm"
                                : "bg-transparent border-transparent text-text-muted hover:bg-surface-highlight hover:text-text-secondary"
                            )}
                          >
                            <span className="flex items-center gap-2">
                              {tab.label}
                              {isStreaming && <span className="w-1.5 h-1.5 rounded-full bg-intent-warning animate-pulse" />}
                              {isError && <span className="w-1.5 h-1.5 rounded-full bg-intent-danger" />}
                            </span>
                            {isActive && (
                              <span className="absolute bottom-0 left-1/2 -translate-x-1/2 w-4 h-[2px] bg-brand-500 rounded-t-full" />
                            )}
                          </button>
                        );
                      })}
                    </div>
                  )}

                  {(() => {
                    if (!wasSynthRequested)
                      return (
                        <div className="text-text-muted/70 italic text-center relative z-10">
                          Synthesis not enabled for this turn.
                        </div>
                      );

                    // --- USE ACTIVE TAB INSTEAD OF GLOBAL ACTIVE PID ---
                    const activeTab = synthesisTabs.find(t => t.id === activeSynthTabId) || synthesisTabs[synthesisTabs.length - 1]; // Fallback to last

                    // Fallback to old behavior if no tabs (shouldn't happen if responses exist)
                    const latest = activeTab
                      ? activeTab.response
                      : (activeSynthPid ? getLatestResponse(synthesisResponses[activeSynthPid]) : undefined);

                    // Derive isGenerating from the SPECIFIC response status
                    const isGenerating = latest && (latest.status === "streaming" || latest.status === "pending");

                    // If specifically targeting synthesis recompute for a provider NOT yet in tabs (rare race condition), show loader
                    if (!activeTab && isSynthesisTarget) {
                      return (
                        <div className="flex items-center justify-center gap-2 text-text-muted relative z-10">
                          <span className="italic">
                            Starting synthesis...
                          </span>
                          <span className="streaming-dots" />
                        </div>
                      );
                    }

                    // ONLY show placeholder if we have NO text yet
                    if (isGenerating && !latest?.text)
                      return (
                        <div className="flex items-center justify-center gap-2 text-text-muted relative z-10">
                          <span className="italic">
                            Synthesis generating
                          </span>
                          <span className="streaming-dots" />
                        </div>
                      );

                    if (activeTab) {
                      const take = activeTab.response;

                      if (take && take.status === "error") {
                        return (
                          <div className="bg-intent-danger/15 border border-intent-danger text-intent-danger rounded-lg p-3 relative z-10">
                            <div className="text-xs mb-2">
                              {activeTab.label} · error
                            </div>
                            <div className="prose prose-sm max-w-none dark:prose-invert leading-7 text-sm">
                              <MarkdownDisplay
                                content={String(
                                  take.text || "Synthesis failed"
                                )}
                              />
                            </div>
                          </div>
                        );
                      }

                      if (!take)
                        return (
                          <div className="text-text-muted relative z-10">
                            No synthesis content.
                          </div>
                        );

                      return (
                        <div className="animate-in fade-in duration-300 relative z-10">
                          {(() => {
                            const cleanText = take.text || '';
                            const artifacts = take.artifacts || [];
                            const { shortAnswer, longAnswer } = splitSynthesisAnswer(cleanText);

                            return (
                              <>
                                <div className="text-base leading-relaxed text-text-primary">
                                  <MarkdownDisplay
                                    content={String(shortAnswer || cleanText || take.text || "")}
                                  />
                                </div>

                                <div className="my-6 flex items-center justify-center gap-6 border-y border-border-subtle/60 py-3">
                                  {refinerOutput?.outlier && (
                                    <button
                                      onClick={() => setShowEcho((prev) => !prev)}
                                      className="flex items-center gap-2 px-3 py-1.5 rounded-full bg-surface-raised hover:bg-surface-highlight border border-border-subtle text-xs text-text-secondary"
                                      title="View contrarian echo"
                                    >
                                      <span className="text-sm">📢</span>
                                      <span>Echo</span>
                                    </button>
                                  )}

                                  <button
                                    onClick={() => setIsDecisionMapOpen({ turnId: aiTurn.id })}
                                    className="flex items-center gap-2 px-3 py-1.5 rounded-full bg-surface-raised hover:bg-surface-highlight border border-border-subtle text-xs text-text-secondary"
                                    title="Open decision map"
                                  >
                                    <span className="text-sm">📊</span>
                                    <span>Map</span>
                                  </button>

                                  {(refinerOutput || isRefinerLoading) && (
                                    <RefinerDot
                                      refiner={refinerOutput || null}
                                      onClick={() => setActiveSplitPanel({ turnId: aiTurn.id, providerId: '__trust__' })}
                                      isLoading={isRefinerLoading}
                                    />
                                  )}
                                </div>

                                {refinerOutput?.outlier && showEcho && (
                                  <div className="mt-3 mx-auto max-w-2xl rounded-xl border border-border-subtle bg-surface-raised px-4 py-3 text-sm text-text-primary">
                                    <div className="flex items-center gap-2 mb-1">
                                      <span className="text-xs uppercase tracking-wide text-text-muted">Echo</span>
                                      {refinerOutput.outlier.source && (
                                        <span className="inline-flex items-center px-1.5 py-0.5 rounded-full bg-chip text-[11px] text-text-secondary">
                                          [{refinerOutput.outlier.source}]
                                        </span>
                                      )}
                                    </div>
                                    <div>{refinerOutput.outlier.position}</div>
                                    {refinerOutput.outlier.why && (
                                      <div className="mt-1 text-xs text-text-muted">
                                        {refinerOutput.outlier.why}
                                      </div>
                                    )}
                                  </div>
                                )}

                                {refinerOutput?.gem?.insight && (
                                  <GemFlash insight={refinerOutput.gem.insight} />
                                )}

                                {refinerOutput?.gem?.action && (
                                  <div className="mt-4 flex flex-col items-center">
                                    <button
                                      onClick={() => {
                                        if (refinerOutput.gem?.action) {
                                          setChatInput(refinerOutput.gem.action);
                                          setTrustPanelFocus({ turnId: aiTurn.id, section: 'context' });
                                        }
                                      }}
                                      className="px-4 py-2 bg-brand-500/10 hover:bg-brand-500/20 border border-brand-500/30 rounded-full text-brand-400 text-sm font-medium transition-all group/gem-action"
                                    >
                                      <span className="flex items-center gap-2">
                                        <span className="text-xs">✨</span>
                                        {refinerOutput.gem.action}
                                        <span className="opacity-0 group-hover/gem-action:opacity-100 transition-opacity ml-1">→</span>
                                      </span>
                                    </button>
                                  </div>
                                )}

                                {longAnswer && (
                                  <div className="text-base leading-relaxed text-text-primary">
                                    <MarkdownDisplay
                                      content={String(longAnswer)}
                                    />
                                  </div>
                                )}

                                {/* Artifact badges */}
                                {artifacts.length > 0 && (
                                  <div className="mt-3 flex flex-wrap gap-2 justify-center">
                                    {artifacts.map((artifact, idx) => (
                                      <button
                                        key={idx}
                                        onClick={() => setSelectedArtifact(artifact)}
                                        className="bg-gradient-to-br from-brand-500 to-brand-600 border border-brand-400 rounded-lg px-3 py-2 text-text-primary text-sm font-medium cursor-pointer flex items-center gap-1.5 hover:-translate-y-px hover:shadow-glow-brand-soft transition-all"
                                      >
                                        📄 {artifact.title}
                                      </button>
                                    ))}
                                  </div>
                                )}
                              </>
                            );
                          })()}

                          {refinerOutput?.leap?.target && (
                            <div className="mt-6 pt-4 border-t border-border-subtle/40">
                              <div className="text-sm text-text-secondary">
                                <span className="font-semibold text-text-primary">Next step: </span>
                                <span className="capitalize">{refinerOutput.leap.action}</span>
                                <span> — </span>
                                <span>{refinerOutput.leap.target}</span>
                                {refinerOutput.leap.why && (
                                  <span className="text-text-muted"> {refinerOutput.leap.why}</span>
                                )}
                              </div>
                            </div>
                          )}
                        </div>
                      );
                    }
                    return (
                      <div className="flex items-center justify-center h-full text-text-muted italic relative z-10">
                        Choose a model.
                      </div>
                    );
                  })()}

                  {/* Antagonist Card */}
                  <AntagonistCard
                    aiTurn={aiTurn}
                    activeProviderId={activeAntagonistPid || undefined}
                    onProviderSelect={(pid) => onClipClick("antagonist", pid)}
                  />

                  {/* Provider Errors (if any) */}

                  {/* Provider Errors (if any) */}
                  {Object.entries(providerErrors || {}).length > 0 && (
                    <div className="provider-errors-section mt-3">
                      <div className="flex items-center justify-between mb-2">
                        <span className="text-sm text-text-secondary">⚠️ Some providers encountered issues</span>
                        {retryableProviders.length > 0 && aiTurn.sessionId && (
                          <button
                            onClick={() => retryProviders(aiTurn.sessionId as string, aiTurn.id, retryableProviders)}
                            className="provider-error-card__retry-btn"
                          >
                            🔄 Retry All ({retryableProviders.length})
                          </button>
                        )}
                      </div>
                      {Object.entries(providerErrors).map(([pid, error]) => (
                        <ProviderErrorCard
                          key={pid}
                          providerId={pid}
                          providerName={getProviderName(pid)}
                          error={error as any}
                          onRetry={(error as any)?.retryable && aiTurn.sessionId ? () => retryProviders(aiTurn.sessionId as string, aiTurn.id, [pid]) : undefined}
                        />
                      ))}
                    </div>
                  )}

                  {/* BOTTOM TRAY: Council Orbs - Centered */}
                  <div
                    className={clsx(
                      "absolute bottom-4 left-0 right-0 flex items-center justify-center z-30 transition-opacity duration-300 ease-out pointer-events-none",
                      isThisTurnActive
                        ? "opacity-100"
                        : "opacity-0 group-hover/turn:opacity-100 focus-within:opacity-100"
                    )}
                  >
                    <div className="pointer-events-auto flex items-center gap-2">
                      <CouncilOrbs
                        turnId={aiTurn.id}
                        providers={LLM_PROVIDERS_CONFIG}
                        voiceProviderId={displayedVoicePid}
                        visibleProviderIds={visibleProviderIds}
                        onOrbClick={(pid) => setActiveSplitPanel({ turnId: aiTurn.id, providerId: pid })}
                        // onCrownMove disabled for historical
                        onTrayExpand={() => setIsDecisionMapOpen({ turnId: aiTurn.id })}
                        isTrayExpanded={isDecisionMapOpen?.turnId === aiTurn.id}
                        variant="historical"
                        workflowProgress={isThisTurnActive ? workflowProgress as any : undefined}
                      />
                    </div>

                    {/* Hint text for active orbs */}
                    {isThisTurnActive && (
                      <div className="absolute top-full mt-2 text-[11px] text-text-muted opacity-60 pointer-events-none whitespace-nowrap">
                        Click a glowing orb to see that response
                      </div>
                    )}
                  </div>

                  {/* BOTTOM RIGHT: Recompute Icon Button */}
                  {!isThisTurnActive && (
                    <div className="absolute bottom-6 right-10 z-30 pointer-events-auto opacity-0 group-hover/turn:opacity-100 focus-within:opacity-100 transition-opacity duration-300">
                      <div className="relative group/recompute">
                        <button
                          className="flex items-center justify-center w-8 h-8 bg-surface-raised/80 border border-border-subtle rounded-full text-sm hover:bg-surface-highlight hover:scale-110 transition-all shadow-sm"
                          title="Recompute synthesis"
                        >
                          <span className="text-brand-400">⚡</span>
                        </button>

                        {/* Hover/Focus Dropdown */}
                        <div className="absolute bottom-full right-0 mb-2 min-w-[140px] bg-surface-raised border border-border-subtle rounded-xl shadow-elevated p-1.5 hidden group-hover/recompute:block transition-all animate-in fade-in zoom-in-95 duration-150">
                          <div className="text-[10px] text-text-muted px-2 py-1 font-medium uppercase tracking-wider">Recompute</div>
                          {LLM_PROVIDERS_CONFIG.map(p => (
                            <button
                              key={p.id}
                              onClick={(e) => {
                                e.stopPropagation();
                                if (onClipClick) onClipClick("synthesis", String(p.id));
                              }}
                              className="w-full text-left px-2 py-1.5 rounded-lg text-xs hover:bg-surface-highlight text-text-secondary hover:text-text-primary flex items-center gap-2"
                            >
                              <span className={`w-2 h-2 rounded-full`} style={{ backgroundColor: p.color || '#ccc' }} />
                              {p.name}
                            </button>
                          ))}
                        </div>
                      </div>
                    </div>
                  )}

                </div>

              </div>
            </div>
          </div>

        </div>
      </div>

      {/* Artifact Overlay Modal */}
      {selectedArtifact && (
        <div className="fixed inset-0 bg-overlay-backdrop z-[9999] flex items-center justify-center p-5" onClick={() => setSelectedArtifact(null)}>
          <div className="bg-surface-raised border border-border-strong rounded-2xl max-w-[900px] w-full max-h-[90vh] flex flex-col shadow-elevated" onClick={(e) => e.stopPropagation()}>
            <div className="flex items-center justify-between p-4 border-b border-border-subtle">
              <div>
                <h3 className="m-0 text-lg text-text-primary font-semibold">
                  📄 {selectedArtifact.title}
                </h3>
                <div className="text-xs text-text-muted mt-1">
                  {selectedArtifact.identifier}
                </div>
              </div>
              <button
                onClick={() => setSelectedArtifact(null)}
                className="bg-transparent border-none text-text-muted text-2xl cursor-pointer px-2 py-1"
              >
                ×
              </button>
            </div>
            <div className="flex-1 overflow-y-auto p-5 bg-surface">
              <MarkdownDisplay content={selectedArtifact.content} />
            </div>
            <div className="flex gap-3 p-4 border-t border-border-subtle justify-end">
              <button
                onClick={async () => {
                  try {
                    await navigator.clipboard.writeText(selectedArtifact.content);
                    setToast({ id: Date.now(), message: 'Copied artifact', type: 'info' });
                  } catch (err) {
                    console.error("Failed to copy artifact:", err);
                    setToast({ id: Date.now(), message: 'Failed to copy', type: 'error' });
                  }
                }}
                className="bg-surface-raised border border-border-subtle rounded-md px-4 py-2 text-text-secondary text-sm cursor-pointer flex items-center gap-1.5 hover:bg-surface-highlight transition-all"
              >
                📋 Copy
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default React.memo(AiTurnBlock);



================================================
FILE: ui/components/ArtifactOverlay.tsx
================================================
// ui/components/ArtifactOverlay.tsx
// Extracted from ProviderResponseBlock.tsx for artifact modal display

import React, { useCallback } from 'react';
import { useSetAtom } from 'jotai';
import { toastAtom } from '../state/atoms';
import MarkdownDisplay from './MarkdownDisplay';

export interface Artifact {
    title: string;
    identifier: string;
    content: string;
}

interface ArtifactOverlayProps {
    artifact: Artifact;
    onClose: () => void;
}

/**
 * Full-screen overlay modal for viewing artifact content.
 * Supports copy to clipboard and download as markdown file.
 */
export const ArtifactOverlay: React.FC<ArtifactOverlayProps> = ({ artifact, onClose }) => {
    const setToast = useSetAtom(toastAtom);

    const handleCopy = useCallback(async () => {
        try {
            await navigator.clipboard.writeText(artifact.content);
            setToast({ id: Date.now(), message: 'Copied to clipboard', type: 'info' });
        } catch (error) {
            console.error('Failed to copy artifact:', error);
            setToast({ id: Date.now(), message: 'Failed to copy', type: 'error' });
        }
    }, [artifact.content, setToast]);

    const handleDownload = useCallback(() => {
        try {
            const blob = new Blob([artifact.content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${artifact.identifier}.md`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                URL.revokeObjectURL(url);
                try { document.body.removeChild(a); } catch { }
            }, 0);
            setToast({ id: Date.now(), message: 'Download started', type: 'info' });
        } catch (error) {
            console.error('Failed to download artifact:', error);
            setToast({ id: Date.now(), message: 'Failed to download', type: 'error' });
        }
    }, [artifact.content, artifact.identifier, setToast]);

    return (
        <div
            className="fixed inset-0 bg-overlay-backdrop z-[9999] flex items-center justify-center p-5"
            onClick={onClose}
        >
            <div
                className="bg-surface-raised border border-border-strong rounded-2xl max-w-[900px] w-full max-h-[90vh] flex flex-col shadow-elevated animate-in zoom-in-95 duration-200"
                onClick={(e) => e.stopPropagation()}
            >
                {/* Header */}
                <div className="flex items-center justify-between p-4 border-b border-border-subtle">
                    <div>
                        <h3 className="m-0 text-lg text-text-primary font-semibold">
                            📄 {artifact.title}
                        </h3>
                        <div className="text-xs text-text-muted mt-1">
                            {artifact.identifier}
                        </div>
                    </div>
                    <button
                        onClick={onClose}
                        className="bg-transparent border-none text-text-muted text-2xl cursor-pointer px-2 py-1 hover:text-text-primary transition-colors"
                        aria-label="Close artifact overlay"
                    >
                        ×
                    </button>
                </div>

                {/* Content */}
                <div className="flex-1 overflow-y-auto p-5 bg-surface custom-scrollbar">
                    <div className="prose prose-sm max-w-none dark:prose-invert">
                        <MarkdownDisplay content={artifact.content} />
                    </div>
                </div>

                {/* Footer */}
                <div className="flex gap-3 p-4 border-t border-border-subtle justify-end">
                    <button
                        onClick={handleCopy}
                        className="bg-surface-raised border border-border-subtle rounded-md px-4 py-2 text-text-secondary text-sm cursor-pointer flex items-center gap-1.5 hover:bg-surface-highlight transition-all"
                    >
                        📋 Copy
                    </button>
                    <button
                        onClick={handleDownload}
                        className="bg-brand-500 border border-brand-400 rounded-md px-4 py-2 text-text-primary text-sm cursor-pointer flex items-center gap-1.5 hover:bg-brand-600 transition-all"
                    >
                        ⬇️ Download
                    </button>
                </div>
            </div>
        </div>
    );
};

export default ArtifactOverlay;



================================================
FILE: ui/components/Banner.tsx
================================================
import React from "react";
import { useAtom } from "jotai";
import { alertTextAtom } from "../state/atoms";

const Banner: React.FC = () => {
  const [alertText, setAlertText] = useAtom(alertTextAtom as any);
  if (!alertText) return null;

  const handleClose = () => setAlertText(null);
  const text = String(alertText);

  return (
    <div
      role="status"
      aria-live="polite"
      className="fixed top-[72px] right-3 z-[2000] bg-surface-highest text-text-secondary border border-border-subtle rounded-[10px] px-3 py-2.5 shadow-elevated flex items-center gap-2 max-w-[360px]"
    >
      <span className="text-xs leading-snug">{text}</span>
      <div className="ml-auto flex gap-2">
        <button
          onClick={handleClose}
          aria-label="Close notice"
          className="bg-transparent text-text-muted border border-border-subtle rounded-md px-2 py-1 text-xs cursor-pointer hover:bg-surface-highlight hover:text-text-secondary transition-colors"
        >
          Dismiss
        </button>
      </div>
    </div>
  );
};

export default Banner;




================================================
FILE: ui/components/ChatInput.tsx
================================================
import React, { useEffect, useRef, useState, useCallback } from "react";
import { useAtom, useSetAtom, useAtomValue } from "jotai";
import {
  chatInputValueAtom,
  selectedModelsAtom,
  isLoadingAtom,
  isContinuationModeAtom,
  activeProviderCountAtom,
  isVisibleModeAtom,
  isReducedMotionAtom,
  chatInputHeightAtom,
  toastAtom,
  activeProviderTargetAtom,
  currentSessionIdAtom,
  activeRecomputeStateAtom,
  originalPromptAtom,

  currentRefinementStateAtom, // used in nudgeVariant
  synthesisProviderAtom,
  workflowProgressAtom,
  isRoundActiveAtom,
} from "../state/atoms";
import { useChat } from "../hooks/chat/useChat";
import api from "../services/extension-api";
import { LLM_PROVIDERS_CONFIG } from "../constants";
import { getProviderName } from "../utils/provider-helpers";
import { PROVIDER_LIMITS } from "../../shared/provider-limits";
import { setProviderLock } from "../../shared/provider-locks";
import { CouncilOrbs } from "./CouncilOrbs";

interface ChatInputProps {
  onStartMapping?: (prompt: string) => void;
  canShowMapping?: boolean; // ModelTray has >=2 selected and prompt has content
  mappingTooltip?: string;
  mappingActive?: boolean; // disable input and toggles while active
}

const ChatInput = ({
  onStartMapping,
  canShowMapping = false,
  mappingTooltip,
  mappingActive = false,
}: ChatInputProps) => {
  // --- CONNECTED STATE LOGIC ---
  const [isLoading] = useAtom(isLoadingAtom as any) as [boolean, any];

  const [isContinuationMode] = useAtom(isContinuationModeAtom as any) as [boolean, any];
  const [activeProviderCount] = useAtom(activeProviderCountAtom as any) as [number, any];
  const [isVisibleMode] = useAtom(isVisibleModeAtom as any) as [boolean, any];
  const [isReducedMotion] = useAtom(isReducedMotionAtom as any) as [boolean, any];
  const [, setChatInputHeight] = useAtom(chatInputHeightAtom);



  // Streaming UX: hide config orbs during active round
  const isRoundActive = useAtomValue(isRoundActiveAtom);

  // --- PRESENTATION LOGIC HOISTED ---
  const CHAT_INPUT_STORAGE_KEY = "htos_chat_input_value";
  const [prompt, setPrompt] = useAtom(chatInputValueAtom);
  const textareaRef = useRef<HTMLTextAreaElement | null>(null);

  const setToast = useSetAtom(toastAtom);

  const { sendMessage, abort, runComposerFlow } = useChat();

  const [activeTarget, setActiveTarget] = useAtom(activeProviderTargetAtom);
  const [currentSessionId] = useAtom(currentSessionIdAtom);
  const setActiveRecomputeState = useSetAtom(activeRecomputeStateAtom);

  // New refinement state replaced by Launchpad; keeping minimal local state for original prompt tracking if needed
  // actually, we might not even need these atoms if useChat handles it.
  // But let's keep originalPromptAtom for now as it was requested to be preserved for chaining context
  const [originalPrompt, setOriginalPrompt] = useAtom(originalPromptAtom);

  // Callbacks
  const handleSend = useCallback((prompt: string) => {
    const mode = isContinuationMode ? "continuation" : "new";
    sendMessage(prompt, mode);
  }, [sendMessage, isContinuationMode]);

  const onContinuation = useCallback(async (prompt: string) => {
    if (activeTarget && currentSessionId) {
      try {
        setActiveRecomputeState({
          aiTurnId: activeTarget.aiTurnId,
          stepType: "batch",
          providerId: activeTarget.providerId
        });
        const primitive: any = {
          type: "recompute",
          sessionId: currentSessionId,
          sourceTurnId: activeTarget.aiTurnId,
          stepType: "batch",
          targetProvider: activeTarget.providerId,
          userMessage: prompt,
          useThinking: false,
        };
        await api.executeWorkflow(primitive);
        setActiveTarget(null);
        // setChatInputValue(""); // handled in executeSend
      } catch (error: any) {
        console.error("Failed to execute targeted recompute:", error);
        setToast({ id: Date.now(), message: `Failed to branch ${activeTarget.providerId}: ${error.message || "Unknown error"}`, type: "error" });
        setActiveRecomputeState(null);
      }
      return;
    }
    sendMessage(prompt, "continuation");
  }, [sendMessage, activeTarget, currentSessionId, setActiveTarget, setActiveRecomputeState, setToast]);

  const onAbort = useCallback(() => { void abort(); }, [abort]);

  const onExplain = useCallback((prompt: string) => {
    if (!originalPrompt) setOriginalPrompt(prompt);
    // Explicitly pass originalPrompt if available (from chaining)
    void runComposerFlow(prompt, "explain", originalPrompt || undefined);
  }, [runComposerFlow, originalPrompt, setOriginalPrompt]);

  const onCompose = useCallback((prompt: string) => {
    if (!originalPrompt) setOriginalPrompt(prompt);
    void runComposerFlow(prompt, "compose", originalPrompt || undefined);
  }, [runComposerFlow, originalPrompt, setOriginalPrompt]);


  const onHeightChange = setChatInputHeight;
  const onCancelTarget = () => setActiveTarget(null);

  // Clear active target when clicking outside
  useEffect(() => {
    if (!activeTarget) return;
    const handleClickOutside = () => setActiveTarget(null);
    document.addEventListener("click", handleClickOutside);
    return () => document.removeEventListener("click", handleClickOutside);
  }, [activeTarget, setActiveTarget]);


  // --- PRESENTATION LOGIC ---
  // (prompt and textareaRef hoisted above to fix closure access)

  // Long-press state
  const [showMenu, setShowMenu] = useState(false);
  const longPressTimerRef = useRef<NodeJS.Timeout | null>(null);
  const hasTriggeredMenuRef = useRef(false);
  const menuRef = useRef<HTMLDivElement>(null);

  // Input Length Validation State
  const [selectedModels] = useAtom(selectedModelsAtom);
  const [synthesisProvider, setSynthesisProvider] = useAtom(synthesisProviderAtom);
  const [maxLength, setMaxLength] = useState<number>(Infinity);
  const [warnThreshold, setWarnThreshold] = useState<number>(Infinity);
  const [limitingProvider, setLimitingProvider] = useState<string>("");

  const inputLength = prompt.length;
  const isOverLimit = inputLength > maxLength;
  const isWarning = inputLength > warnThreshold && !isOverLimit;

  // Nudge State
  const [nudgeVisible, setNudgeVisible] = useState(false);
  const [nudgeType, setNudgeType] = useState<"sending" | "idle">("idle");
  const [nudgeProgress, setNudgeProgress] = useState(0);
  const nudgeTimerRef = useRef<NodeJS.Timeout | null>(null);
  const idleTimerRef = useRef<NodeJS.Timeout | null>(null);
  const [isNudgeFrozen, setIsNudgeFrozen] = useState(false);
  const [isFocused, setIsFocused] = useState(false); // Track textarea focus





  // Calculate limits based on selected providers
  useEffect(() => {
    let minMax = Infinity;
    let minWarn = Infinity;
    let provider = "";

    const activeProviders = Object.entries(selectedModels)
      .filter(([_, isSelected]) => isSelected)
      .map(([id]) => id);

    const providersToCheck = activeProviders.length > 0 ? activeProviders : ['chatgpt', 'claude', 'gemini']; // Default fallback

    providersToCheck.forEach(pid => {
      const limitConfig = PROVIDER_LIMITS[pid as keyof typeof PROVIDER_LIMITS] || PROVIDER_LIMITS['chatgpt']; // Fallback to safe limit

      if (limitConfig.maxInputChars < minMax) {
        minMax = limitConfig.maxInputChars;
        minWarn = limitConfig.warnThreshold;
        provider = getProviderName(pid);
      }
    });

    setMaxLength(minMax);
    setWarnThreshold(minWarn);
    setLimitingProvider(provider);
  }, [selectedModels]);

  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = "auto"; // Reset height
      const scrollHeight = textareaRef.current.scrollHeight;
      const newHeight = Math.min(scrollHeight, 120); // Max height 120px
      textareaRef.current.style.height = `${newHeight}px`;

      // Calculate total input area height
      const bottomBarHeight = (originalPrompt) ? 30 : 0;
      const targetHeight = activeTarget ? 30 : 0;
      // Add height for nudge chips if visible (approx 28px + margin)
      const nudgeHeight = nudgeVisible ? 32 : 0;

      const totalHeight = newHeight + 24 + 2 + targetHeight + bottomBarHeight + nudgeHeight;
      onHeightChange?.(totalHeight);
    }
  }, [prompt, onHeightChange, activeTarget, originalPrompt, nudgeVisible]);

  // Close menu on click outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setShowMenu(false);
      }
    };

    if (showMenu) {
      document.addEventListener("mousedown", handleClickOutside);
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [showMenu]);

  // Idle Nudge Logic (Trigger B) - Only when focused and idle
  useEffect(() => {
    // Only show idle nudge when: focused, has text, not loading/frozen/refining
    // Exception: If we have a refinement state (chaining), we allow nudging even if we are technically "refining" in the high-level sense
    if (isNudgeFrozen || isLoading || !prompt.trim() || !isFocused) {
      if (nudgeType === "idle") setNudgeVisible(false);
      return;
    }

    // Clear existing idle timer
    if (idleTimerRef.current) clearTimeout(idleTimerRef.current);

    // Set new timer for idle detection: always 2s
    const idleTime = 2000;

    idleTimerRef.current = setTimeout(() => {
      setNudgeType("idle");
      // Calculate progress based on length (visual flair)
      setNudgeProgress(Math.min(100, (prompt.length / 50) * 100)); // Arbitrary scale
      setNudgeVisible(true);
    }, idleTime);

    return () => {
      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
    };
  }, [prompt, isNudgeFrozen, isLoading, isFocused, nudgeType]);

  // Reset idle nudge on typing
  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setPrompt(e.target.value);
    if (nudgeType === "idle" && nudgeVisible) {
      setNudgeVisible(false);
    }
  };

  const executeSend = (text: string) => {
    const trimmed = text.trim();
    if (isOverLimit) {
      setToast({ id: Date.now(), message: `Input too long for ${limitingProvider} (${inputLength.toLocaleString()} / ${maxLength.toLocaleString()})`, type: "error" });
      return;
    }
    if (isContinuationMode) {
      onContinuation(trimmed);
    } else {
      handleSend(trimmed);
    }

    setPrompt("");
    setNudgeVisible(false);
    setIsNudgeFrozen(false);
    setNudgeProgress(0);
  };

  const handleSubmit = (e?: React.FormEvent | React.KeyboardEvent) => {
    if (e) e.preventDefault();
    if (isLoading || !prompt.trim()) return;
    if (isOverLimit) {
      setToast({ id: Date.now(), message: `Input too long for ${limitingProvider} (${inputLength.toLocaleString()} / ${maxLength.toLocaleString()})`, type: "error" });
      return;
    }

    // Prevent send if menu was just triggered
    if (hasTriggeredMenuRef.current) {
      hasTriggeredMenuRef.current = false;
      return;
    }

    // Trigger A: On Send (Nudge)
    // Only if not already refining or in a special mode that bypasses this
    if (!activeTarget) {
      setIsNudgeFrozen(true);
      setNudgeType("sending");
      setNudgeVisible(true);
      setNudgeProgress(0);

      const DURATION = 2400; // 2.4s
      const INTERVAL = 50;
      const steps = DURATION / INTERVAL;
      let currentStep = 0;

      if (nudgeTimerRef.current) clearInterval(nudgeTimerRef.current);

      nudgeTimerRef.current = setInterval(() => {
        currentStep++;
        const progress = (currentStep / steps) * 100;
        setNudgeProgress(progress);

        if (currentStep >= steps) {
          if (nudgeTimerRef.current) clearInterval(nudgeTimerRef.current);
          executeSend(prompt);
        }
      }, INTERVAL);

      return;
    }

    executeSend(prompt);
  };

  const handleNudgeCompose = () => {
    if (nudgeTimerRef.current) clearInterval(nudgeTimerRef.current);
    setIsNudgeFrozen(false);
    setNudgeVisible(false);
    onCompose?.(prompt);
  };

  const handleNudgeAnalyst = () => {
    if (nudgeTimerRef.current) clearInterval(nudgeTimerRef.current);
    setIsNudgeFrozen(false);
    setNudgeVisible(false);
    // Analyst uses onExplain usually, but we want to map it correctly
    onExplain?.(prompt);
  };

  const handleMouseDown = () => {
    if (isLoading || !prompt.trim()) return;

    hasTriggeredMenuRef.current = false;
    longPressTimerRef.current = setTimeout(() => {
      setShowMenu(true);
      hasTriggeredMenuRef.current = true;
    }, 400); // 0.4s long press
  };

  const handleMouseUp = () => {
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
    // Note: We do NOT close the menu here. 
    // If hasTriggeredMenuRef is true, the menu is open and should stay open 
    // until the user clicks an option or clicks outside.
  };

  const handleMouseLeave = () => {
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  };

  const handleMenuAction = (action: "explain" | "compose") => {
    setShowMenu(false);
    const trimmed = prompt.trim();
    if (!trimmed) return;

    if (action === "explain") {
      onExplain?.(trimmed);
    } else if (action === "compose") {
      onCompose?.(trimmed);
    }
  };

  // Determine Nudge Variant for Chaining and Text
  const currentRefinementState = useAtomValue(currentRefinementStateAtom);
  const nudgeVariant = (() => {
    if (currentRefinementState === "composer") return "chain_analyst";
    if (currentRefinementState === "analyst") return "chain_composer";
    return "default";
  })();

  const isSending = nudgeType === "sending";

  // Dynamic text logic based on NudgeChipBar adaptation
  let composerText = isSending ? "Perfect this prompt" : "Let Composer perfect it";
  let analystText = isSending ? "Pressure-test it" : "Let Analyst sharpen it";

  if (nudgeVariant === "chain_analyst") {
    analystText = "Now pressure-test with Analyst?";
  } else if (nudgeVariant === "chain_composer") {
    composerText = "Now perfect this audited version?";
  }

  const buttonText = (isContinuationMode ? "Continue" : "Send");
  const isDisabled = isLoading || mappingActive || !prompt.trim() || isOverLimit || isNudgeFrozen;
  const showMappingBtn = canShowMapping && !!prompt.trim();
  const showAbortBtn = !!onAbort && isLoading;

  const providerName = activeTarget ? getProviderName(activeTarget.providerId) : "";
  const workflowProgress = useAtomValue(workflowProgressAtom);

  return (
    <div className="flex justify-center flex-col items-center pointer-events-auto">

      {/* Config Orbs - Float above input, hugging the top edge */}
      {!isRoundActive && (
        <div className="relative w-full max-w-[min(900px,calc(100%-24px))] flex justify-center mb-[-8px] z-10 !bg-transparent">
          <CouncilOrbs
            providers={LLM_PROVIDERS_CONFIG}
            voiceProviderId={synthesisProvider}
            variant="active"
            workflowProgress={workflowProgress as any}
            onCrownMove={(pid) => {
              setSynthesisProvider(pid);
              setProviderLock('synthesis', true);
            }}
          />
        </div>
      )}

      {/* Hint when round is active */}
      {isRoundActive && (
        <div className="flex items-center gap-2 text-xs text-text-muted py-1 text-center opacity-70">
          <span className="w-2 h-2 rounded-full bg-brand-400 animate-pulse" />
          Click a glowing orb to see that response
        </div>
      )}

      {/* Main chat input container - wider to match/exceed synthesis bubble width */}
      <div className="flex gap-2 items-center relative w-full max-w-[min(900px,calc(100%-24px))] p-2.5 bg-surface border border-border-subtle/60 rounded-t-2xl rounded-b-2xl flex-wrap z-[100] shadow-elevated">

        {/* Targeted Mode Banner */}
        {activeTarget && (
          <div className="w-full flex items-center justify-between bg-brand-500/10 border border-brand-500/20 rounded-lg px-3 py-1.5 mb-1 animate-in slide-in-from-bottom-2 duration-200">
            <div className="flex items-center gap-2 text-xs font-medium text-brand-400">
              <span className="w-1.5 h-1.5 rounded-full bg-brand-500 animate-pulse" />
              Targeting {providerName}
            </div>
            <button
              onClick={onCancelTarget}
              className="text-xs text-text-muted hover:text-text-primary px-1.5 py-0.5 rounded hover:bg-surface-highlight transition-colors"
            >
              Cancel
            </button>
          </div>
        )}

        <div className="flex-1 relative min-w-[200px] flex flex-col gap-2">
          <textarea
            ref={textareaRef}
            value={prompt}
            onChange={handleInputChange}
            placeholder={
              activeTarget
                ? `Continue conversation with ${providerName}...`
                : isContinuationMode
                  ? "Continue the conversation with your follow-up message..."
                  : "Ask anything... Singularity will orchestrate multiple AI models for you."
            }
            rows={1}
            className={`w-full min-h-[34px] px-3 py-1.5 bg-transparent border-none text-text-primary text-[15px] font-inherit resize-none outline-none overflow-y-auto ${isReducedMotion ? '' : 'transition-all duration-200 ease-out'} placeholder:text-text-muted ${isNudgeFrozen ? 'opacity-50 cursor-not-allowed' : ''}`}
            onKeyDown={(e: React.KeyboardEvent<HTMLTextAreaElement>) => {
              if (e.key === "Enter" && !e.shiftKey && prompt.trim()) {
                e.preventDefault();
                handleSubmit(e);
              }
            }}
            disabled={isLoading || isNudgeFrozen}
            onFocus={() => {
              setIsFocused(true);
              if (activeTarget) {
                onCancelTarget?.();
              }
            }}
            onBlur={() => {
              setIsFocused(false);
              // Immediately hide idle nudge on blur
              if (nudgeType === "idle") {
                setNudgeVisible(false);
              }
            }}
          />

          {/* Inline Nudge Chips */}
          <div className={`flex items-center gap-2 overflow-hidden transition-all duration-300 ease-in-out ${nudgeVisible ? 'max-h-10 opacity-100 mt-1 mb-1' : 'max-h-0 opacity-0 mt-0 mb-0'}`}>
            {isSending && (
              <div className="absolute left-0 bottom-0 top-0 w-[4px] bg-brand-500 animate-pulse rounded-r-full h-full opacity-60"
                style={{ height: `${nudgeProgress}%`, maxHeight: '100%', transition: 'height 50ms linear' }}
              />
            )}

            <button
              onClick={(e) => {
                e.preventDefault();
                handleNudgeCompose();
              }}
              className="flex items-center gap-1.5 px-3 py-1.5 bg-surface-highlight/40 hover:bg-brand-500/10 hover:border-brand-500/30 border border-transparent rounded-full text-xs transition-all group animate-in slide-in-from-left-2 duration-300"
            >
              <span className="text-brand-400">✨</span>
              <span className="text-text-secondary group-hover:text-brand-300">{composerText}</span>
            </button>

            <div className="w-px h-3 bg-border-subtle" />

            <button
              onClick={(e) => {
                e.preventDefault();
                handleNudgeAnalyst();
              }}
              className="flex items-center gap-1.5 px-3 py-1.5 bg-surface-highlight/40 hover:bg-brand-500/10 hover:border-brand-500/30 border border-transparent rounded-full text-xs transition-all group animate-in slide-in-from-left-4 duration-300 delay-75"
            >
              <span className="text-brand-400">🧠</span>
              <span className="text-text-secondary group-hover:text-brand-300">{analystText}</span>
            </button>
          </div>

          {/* Length Validation Feedback */}
          {(isWarning || isOverLimit) && (
            <div className={`absolute bottom-full left-0 mb-2 px-3 py-1.5 rounded-lg text-xs font-medium backdrop-blur-md border animate-in fade-in slide-in-from-bottom-1 ${isOverLimit
              ? "bg-intent-danger/10 border-intent-danger/30 text-intent-danger"
              : "bg-intent-warning/10 border-intent-warning/30 text-intent-warning"
              }`}>
              {isOverLimit ? (
                <span>
                  ⚠️ Input too long for {limitingProvider} ({inputLength.toLocaleString()} / {maxLength.toLocaleString()})
                </span>
              ) : (
                <span>
                  Approaching limit for {limitingProvider} ({inputLength.toLocaleString()} / {maxLength.toLocaleString()})
                </span>
              )}
            </div>
          )}
        </div>

        <div
          className="flex items-center gap-1.5 px-2.5 py-1.5 bg-chip-soft border border-border-subtle rounded-full text-text-secondary text-xs whitespace-nowrap opacity-90 cursor-default"
          role="status"
          aria-live="polite"
          title={`System: ${isLoading ? "Working…" : "Ready"} • Providers: ${activeProviderCount} • Mode: ${isVisibleMode ? "Visible" : "Headless"}`}
        >
          <span
            aria-hidden="true"
            className={`inline-block w-2 h-2 rounded-full ${isLoading ? 'bg-intent-warning animate-pulse' : 'bg-intent-success'} ${!isReducedMotion && !isLoading ? 'animate-pulse' : ''}`}
          />
          <span className="text-text-muted">System</span>
          <span>• {activeProviderCount}</span>
        </div>

        {/* Send/Draft/Launch Button */}
        <div className="relative">
          <button
            type="button"
            onClick={handleSubmit}
            onMouseDown={handleMouseDown}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseLeave}
            disabled={isDisabled}
            className={`px-3 h-[34px] rounded-2xl text-white font-semibold cursor-pointer flex items-center gap-2 min-w-[84px] justify-center ${isDisabled ? 'opacity-50' : 'opacity-100'} bg-gradient-to-r from-brand-500 to-brand-400 ${isReducedMotion ? '' : 'transition-all duration-200 ease-out'}`}
          >
            {isLoading ? (
              <div className="loading-spinner"></div>
            ) : (
              <>
                <span className="text-base">
                  {(isContinuationMode ? "💬" : "✨")}
                </span>
                <span>{buttonText}</span>
              </>
            )}
          </button>

          {/* Long-press Menu */}
          {showMenu && (
            <div
              ref={menuRef}
              className="absolute bottom-full right-0 mb-2 w-36 bg-surface-base border border-border-subtle rounded-xl shadow-lg overflow-hidden z-50 animate-in fade-in zoom-in-95 duration-200"
            >
              <button
                onClick={() => handleMenuAction("compose")}
                className="w-full px-4 py-2.5 text-left text-sm text-text-primary hover:bg-surface-highlight flex items-center gap-2 transition-colors"
              >
                <span>✨</span> Compose
              </button>
              <button
                onClick={() => handleMenuAction("explain")}
                className="w-full px-4 py-2.5 text-left text-sm text-text-primary hover:bg-surface-highlight flex items-center gap-2 transition-colors"
              >
                <span>🧠</span> Explain
              </button>
            </div>
          )}
        </div>

        {/* Abort/Stop Button - visible while loading */}
        {showAbortBtn && (
          <button
            type="button"
            onClick={() => onAbort?.()}
            title="Stop current workflow"
            className={`px-3 h-[34px] bg-intent-danger/15 border border-intent-danger/45 rounded-2xl text-intent-danger font-semibold cursor-pointer flex items-center gap-2 min-w-[84px] justify-center ${isReducedMotion ? '' : 'transition-all duration-200 ease-out'}`}
          >
            <span className="text-base">⏹️</span>
            <span>Stop</span>
          </button>
        )}

        {/* Mapping Button (ChatInput path) */}
        {showMappingBtn && (
          <button
            type="button"
            onClick={() => {
              onStartMapping?.(prompt.trim());
              setPrompt("");
              try {
                localStorage.removeItem(CHAT_INPUT_STORAGE_KEY);
              } catch { }
            }}
            disabled={isLoading || mappingActive}
            title={mappingTooltip || "Mapping with selected models"}
            className={`px-3 h-[34px] bg-chip-soft border border-border-subtle rounded-2xl text-text-secondary font-semibold cursor-pointer flex items-center gap-2 min-w-[100px] justify-center hover:bg-surface-highlight ${isLoading || mappingActive ? 'opacity-50' : 'opacity-100'} ${isReducedMotion ? '' : 'transition-all duration-200 ease-out'}`}
          >
            <span className="text-base">🧩</span>
            <span>Mapping</span>
          </button>
        )}


      </div>

    </div>
  );
};

export default ChatInput;



================================================
FILE: ui/components/CopyButton.tsx
================================================
import React, { useState, useCallback } from "react";
import { useSetAtom } from "jotai";
import { toastAtom } from "../state/atoms";
import clsx from "clsx";

interface CopyButtonProps {
    text?: string;
    label?: string; // Aria label
    buttonText?: string; // Visible text next to icon
    variant?: "icon" | "text" | "pill";
    className?: string;
    onCopy?: () => void;
    disabled?: boolean;
    children?: React.ReactNode;
}

export const CopyButton: React.FC<CopyButtonProps> = ({
    text = "",
    label = "Copy to clipboard",
    buttonText,
    variant = "pill",
    className,
    onCopy,
    disabled = false,
    children,
}) => {
    const setToast = useSetAtom(toastAtom);
    const [copied, setCopied] = useState(false);

    const handleCopy = useCallback(
        async (e: React.MouseEvent) => {
            e.stopPropagation();
            if (disabled) return;

            try {
                if (text) {
                    await navigator.clipboard.writeText(text);
                }
                setCopied(true);
                setToast({ id: Date.now(), message: 'Copied to clipboard', type: 'info' });
                setTimeout(() => setCopied(false), 2000);
                onCopy?.();
            } catch (error) {
                console.error("Failed to copy text:", error);
                setToast({ id: Date.now(), message: 'Failed to copy', type: 'error' });
            }
        },
        [text, onCopy, setToast, disabled],
    );

    const baseClasses = "transition-all flex items-center gap-1.5 cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed";

    const variantClasses = {
        icon: "p-1.5 text-text-muted hover:text-text-primary hover:bg-surface-highlight rounded-md",
        text: "text-xs font-medium text-text-muted hover:text-text-primary",
        pill: "bg-surface-raised border border-border-subtle rounded-md px-2 py-1 text-text-muted text-xs hover:bg-surface-highlight"
    };

    return (
        <button
            type="button"
            onClick={handleCopy}
            aria-label={label}
            disabled={disabled}
            className={clsx(baseClasses, variantClasses[variant], className)}
            title={label}
        >
            {copied ? (
                <>
                    <span>âœ“</span>
                    {(children || buttonText || variant === 'pill') && <span>Copied</span>}
                </>
            ) : (
                <>
                    <span>ðŸ“‹</span>
                    {children}
                    {!children && buttonText && <span>{buttonText}</span>}
                    {!children && variant === 'pill' && !buttonText && <span>Copy</span>}
                </>
            )}
        </button>
    );
};



================================================
FILE: ui/components/CouncilOrbs.tsx
================================================
import React, { useState, useMemo, useRef, useEffect } from "react";
import { useAtom, useAtomValue } from "jotai";
import { providerEffectiveStateFamily, isSplitOpenAtom, synthesisProviderAtom, mappingProviderAtom, composerModelAtom, analystModelAtom, providerAuthStatusAtom, selectedModelsAtom, refinerProviderAtom, antagonistProviderAtom } from "../state/atoms";
import { LLMProvider } from "../types";
import { PROVIDER_ACCENT_COLORS, WORKFLOW_STAGE_COLORS } from "../constants";
import { getProviderColor, getProviderLogo } from "../utils/provider-helpers";
import { setProviderLock } from "@shared/provider-locks";
import clsx from "clsx";

interface CouncilOrbsProps {
    turnId?: string; // Optional for active mode
    providers: LLMProvider[];
    voiceProviderId: string | null; // The active synthesizer (Crown)
    onOrbClick?: (providerId: string) => void;
    onCrownMove?: (providerId: string) => void;
    onTrayExpand?: () => void;
    isTrayExpanded?: boolean;
    visibleProviderIds?: string[]; // Optional filter for visible orbs
    variant?: "tray" | "divider" | "welcome" | "historical" | "active";
    isEditMode?: boolean; // When true, auto-open the model selection menu
    // New: per-provider workflow progress (providerId -> { stage, progress })
    workflowProgress?: Record<string, { stage: WorkflowStage; progress?: number }>;
}

// Workflow stage type for progress indicator used by Orbs
export type WorkflowStage =
    | 'idle'
    | 'thinking'
    | 'streaming'
    | 'complete'
    | 'error'
    | 'synthesizing';

export const CouncilOrbs: React.FC<CouncilOrbsProps> = React.memo(({
    turnId,
    providers,
    voiceProviderId,
    onOrbClick,
    onCrownMove,
    isTrayExpanded,
    variant = "tray",
    visibleProviderIds,
    isEditMode = false,
    workflowProgress = {},
}) => {
    const [hoveredOrb, setHoveredOrb] = useState<string | null>(null);
    const [isCrownMode, setIsCrownMode] = useState(false);
    const [isMenuOpen, setIsMenuOpen] = useState(false);

    const longPressRef = useRef<any>(null);
    const isSplitOpen = useAtomValue(isSplitOpenAtom);
    const authStatus = useAtomValue(providerAuthStatusAtom);
    const [synthesisProvider, setSynthesisProvider] = useAtom(synthesisProviderAtom);
    const [mapProviderVal, setMapProvider] = useAtom(mappingProviderAtom);
    const [refinerProvider, setRefinerProvider] = useAtom(refinerProviderAtom);
    const [composerVal, setComposer] = useAtom(composerModelAtom);
    const [analystVal, setAnalyst] = useAtom(analystModelAtom);
    const [selectedModels, setSelectedModels] = useAtom(selectedModelsAtom);
    const [antagonistProvider, setAntagonistProvider] = useAtom(antagonistProviderAtom);
    const containerRef = useRef<HTMLDivElement>(null);

    // Click Outside Listener
    React.useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (isMenuOpen && containerRef.current && !containerRef.current.contains(event.target as Node)) {
                setIsMenuOpen(false);
            }
        };

        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [isMenuOpen]);

    // Auto-open menu when isEditMode becomes true
    React.useEffect(() => {
        if (variant === 'active') return;

        if (isEditMode) {
            setIsMenuOpen(true);

        } else {
            setIsMenuOpen(false);

        }
    }, [isEditMode, voiceProviderId, variant]);

    // Filter out system provider if present
    const allProviders = useMemo(() => {
        return providers.filter(p => p.id !== 'system');
    }, [providers]);

    // displayProviders is used for orbs - can be filtered by visibleProviderIds
    const displayProviders = useMemo(() => {
        let filtered = allProviders;
        if (visibleProviderIds) {
            filtered = filtered.filter(p => visibleProviderIds.includes(String(p.id)));
        }
        return filtered;
    }, [allProviders, visibleProviderIds]);

    const handleOrbClickInternal = (e: React.MouseEvent, providerId: string) => {
        e.stopPropagation();

        if (variant === "active") {
            // Toggle witness
            const isUnauthorized = authStatus && authStatus[providerId] === false;
            if (isUnauthorized) return;

            if (isCrownMode) {
                // Changing Crown
                if (onCrownMove) {
                    onCrownMove(providerId);
                    setIsCrownMode(false);
                }
            } else {
                // Toggling Witness
                const isSelected = selectedModels[providerId];
                setSelectedModels({ ...selectedModels, [providerId]: !isSelected });
            }
        } else {
            // Historical / Standard behavior
            if (isCrownMode && onCrownMove) {
                onCrownMove(providerId);
                setIsCrownMode(false);
            } else if (onOrbClick) {
                onOrbClick(providerId);
            }
        }
    };

    const handleCrownClick = (e: React.MouseEvent) => {
        e.stopPropagation();
        if (variant === "historical") return; // No crown interaction for historical
        setIsCrownMode(!isCrownMode);
    };

    // Determine if this should be dimmed (historical variant when split is open)
    const shouldDim = variant === "historical" && isSplitOpen;

    // Priority ranking for orb placement (closest to voice = highest priority)
    const PRIORITY_ORDER = ['claude', 'gemini-exp', 'qwen', 'gemini-pro', 'chatgpt', 'gemini'];

    const getPriority = (providerId: string) => {
        const index = PRIORITY_ORDER.indexOf(providerId);
        return index === -1 ? 999 : index; // Unknown providers go to the end
    };

    // Separate voice and non-voice providers
    const voiceProviderObj = displayProviders.find(p => String(p.id) === voiceProviderId);

    // For 'active' mode, if the voice provider is not in the display list (shouldn't happen if all are shown), find it in allProviders
    const activeVoiceObj = voiceProviderObj || (variant === "active" ? allProviders.find(p => String(p.id) === voiceProviderId) : undefined);

    const otherProviders = displayProviders
        .filter(p => String(p.id) !== voiceProviderId)
        .sort((a, b) => getPriority(String(a.id)) - getPriority(String(b.id)));

    // Distribute alternating left/right with highest priority closest to voice
    const leftOrbs: LLMProvider[] = [];
    const rightOrbs: LLMProvider[] = [];

    otherProviders.forEach((provider, index) => {
        if (index % 2 === 0) {
            rightOrbs.push(provider);
        } else {
            leftOrbs.push(provider);
        }
    });

    leftOrbs.reverse();

    const shouldDimInSplitMode = isSplitOpen && variant === "tray";

    const handleLongPressStart = (_pid: string | null) => {
        if (variant === "historical") return; // Disable menu for historical

        if (longPressRef.current) clearTimeout(longPressRef.current);
        longPressRef.current = setTimeout(() => {

            setIsMenuOpen(true);
        }, 500);
    };

    const handleLongPressCancel = () => {
        if (longPressRef.current) {
            clearTimeout(longPressRef.current);
            longPressRef.current = null;
        }
    };

    const handleSelectSynth = (pid: string) => {
        if (synthesisProvider === pid) {
            setSynthesisProvider(null);
            setProviderLock('synthesis', false);
        } else {
            setSynthesisProvider(pid);
            setProviderLock('synthesis', true);
        }
    };

    const handleSelectMap = (pid: string) => {
        if (mapProviderVal === pid) {
            setMapProvider(null);
            setProviderLock('mapping', false);
        } else {
            setMapProvider(pid);
            setProviderLock('mapping', true);
        }
    };

    const handleSelectRefiner = (pid: string) => {
        if (refinerProvider === pid) {
            setRefinerProvider(null);
        } else {
            setRefinerProvider(pid);
            try {
                localStorage.setItem('htos_refiner_locked', 'true');
                chrome?.storage?.local?.set?.({ provider_lock_settings: { refiner_locked: true } });
            } catch { }
        }
    };

    const handleSelectComposer = (pid: string) => {
        setComposer(pid);
        try {
            localStorage.setItem('htos_composer_locked', 'true');
            chrome?.storage?.local?.set?.({ provider_lock_settings: { composer_locked: true } });
        } catch { }
    };

    const handleSelectAnalyst = (pid: string) => {
        setAnalyst(pid);
        try {
            localStorage.setItem('htos_analyst_locked', 'true');
            chrome?.storage?.local?.set?.({ provider_lock_settings: { analyst_locked: true } });
        } catch { }
    };

    const handleSelectAntagonist = (pid: string) => {
        if (antagonistProvider === pid) {
            setAntagonistProvider(null);
        } else {
            setAntagonistProvider(pid);
            try {
                localStorage.setItem('htos_antagonist_locked', 'true');
                chrome?.storage?.local?.set?.({ provider_lock_settings: { antagonist_locked: true } });
            } catch { }
        }
    };


    return (
        <div
            className={clsx(
                "council-tray-container relative transition-all duration-300 ease-out",
                isTrayExpanded ? "opacity-0 pointer-events-none h-0 overflow-hidden" : "opacity-100",
                variant === "tray" && "council-tray",
                variant === "divider" && "council-divider",
                variant === "historical" && "council-historical",
                variant === "active" && "council-active w-full flex justify-center py-0 px-4 !bg-transparent !shadow-none !border-none",
                shouldDim && "council-historical-dimmed",
                shouldDimInSplitMode && "council-tray-dimmed-split"
            )}
            onMouseDown={() => handleLongPressStart(null)}
            onMouseUp={handleLongPressCancel}
            onMouseLeave={handleLongPressCancel}
            ref={containerRef}
            style={variant === "active" ? { pointerEvents: "auto" } : undefined}
        >
            {/* Orb bar with centered voice and fanned others */}
            {/* Active variant gets a glass-morphic container for visual separation */}
            <div className={clsx(
                "council-orb-bar flex items-center justify-center relative",
                variant === "active" && "council-orb-bar--active"
            )}>
                {/* Left side orbs */}
                <div className={clsx("council-orb-group council-orb-group--left")}>
                    {leftOrbs.map((p) => {
                        const pid = String(p.id);
                        return (
                            <Orb
                                key={pid}
                                turnId={turnId || ""}
                                provider={p}
                                isVoice={false}
                                isCrownMode={isCrownMode}
                                onHover={setHoveredOrb}
                                onClick={(e) => handleOrbClickInternal(e, pid)}
                                onCrownClick={handleCrownClick}
                                hoveredOrb={hoveredOrb}
                                variant={variant as any}
                                disabled={authStatus && authStatus[pid] === false}
                                isSelected={variant === "active" ? !!selectedModels[pid] : undefined}
                                onLongPressStart={() => handleLongPressStart(pid)}
                                onLongPressCancel={handleLongPressCancel}
                                workflowStage={workflowProgress[pid]?.stage}
                                workflowProgress={workflowProgress[pid]?.progress}
                            />
                        );
                    })}
                </div>

                {/* CENTER: Voice Orb */}
                <div
                    className={clsx(
                        "council-voice-zone"
                    )}
                >
                    {variant !== "active" && <div className="council-glass-ring" />}

                    {activeVoiceObj && (
                        <Orb
                            key={String(activeVoiceObj.id)}
                            turnId={turnId || ""}
                            provider={activeVoiceObj}
                            isVoice={true}
                            isCrownMode={isCrownMode}
                            onHover={setHoveredOrb}
                            onClick={(e) => {
                                e.stopPropagation();
                                handleOrbClickInternal(e, String(activeVoiceObj.id));
                            }}
                            onCrownClick={handleCrownClick}
                            hoveredOrb={hoveredOrb}
                            variant={variant as any}
                            disabled={authStatus && authStatus[String(activeVoiceObj.id)] === false}
                            isSelected={variant === "active" ? !!selectedModels[String(activeVoiceObj.id)] : undefined}
                            workflowStage={workflowProgress[String(activeVoiceObj.id)]?.stage}
                            workflowProgress={workflowProgress[String(activeVoiceObj.id)]?.progress}
                        />
                    )}
                </div>

                {/* Right side orbs */}
                <div className={clsx("council-orb-group council-orb-group--right")}>
                    {rightOrbs.map((p) => {
                        const pid = String(p.id);
                        return (
                            <Orb
                                key={pid}
                                turnId={turnId || ""}
                                provider={p}
                                isVoice={false}
                                isCrownMode={isCrownMode}
                                onHover={setHoveredOrb}
                                onClick={(e) => handleOrbClickInternal(e, pid)}
                                onCrownClick={handleCrownClick}
                                hoveredOrb={hoveredOrb}
                                variant={variant as any}
                                disabled={authStatus && authStatus[pid] === false}
                                isSelected={variant === "active" ? !!selectedModels[pid] : undefined}
                                onLongPressStart={() => handleLongPressStart(pid)}
                                onLongPressCancel={handleLongPressCancel}
                                workflowStage={workflowProgress[pid]?.stage}
                                workflowProgress={workflowProgress[pid]?.progress}
                            />
                        );
                    })}
                </div>

                {/* Settings Button for Active Mode - positioned at far right edge */}
                {variant === "active" && (
                    <div className="absolute right-[-140px] top-1/2 -translate-y-1/2">
                        <button
                            onClick={(e) => {
                                e.stopPropagation();
                                setIsMenuOpen(!isMenuOpen);
                            }}
                            className="bg-surface-raised hover:bg-surface-highlight border border-border-subtle rounded-full p-2 text-text-muted hover:text-text-primary transition-all shadow-sm"
                            title="Configure Council"
                        >
                            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                        </button>
                    </div>
                )}
            </div>

            {/* Crown Mode Indicator */}
            {isCrownMode && (
                <div className="council-crown-indicator">Select new voice</div>
            )}

            {isMenuOpen && (
                <div className="absolute left-1/2 -translate-x-1/2 bottom-[110%] bg-surface-raised border border-border-subtle rounded-xl shadow-elevated p-3 z-[100] min-w-[500px] w-max max-w-[90vw]">
                    <div className="text-xs text-text-muted mb-2">Council Menu</div>
                    <div className="grid grid-cols-2 gap-4">
                        {/* Synthesizer Dropdown */}
                        <div>
                            <div className="flex items-center gap-2 mb-2 text-sm"><span>👑</span><span>Synthesizer</span></div>
                            <select
                                value={synthesisProvider || ""}
                                onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === "") {
                                        setSynthesisProvider(null);
                                        setProviderLock('synthesis', false);
                                    } else {
                                        handleSelectSynth(val);
                                    }
                                }}
                                className="w-full bg-chip border border-border-subtle rounded-md px-2 py-1.5 text-xs text-text-primary outline-none focus:border-brand-500 transition-colors"
                            >
                                <option value="">None</option>
                                {allProviders.map(p => {
                                    const pid = String(p.id);
                                    const isUnauthorized = authStatus && authStatus[pid] === false;
                                    return (
                                        <option key={`s-${pid}`} value={pid} disabled={isUnauthorized}>
                                            {p.name} {isUnauthorized ? "(Locked)" : ""}
                                        </option>
                                    );
                                })}
                            </select>
                        </div>

                        {/* Mapper Dropdown */}
                        <div>
                            <div className="flex items-center gap-2 mb-2 text-sm"><span>🧩</span><span>Mapper</span></div>
                            <select
                                value={mapProviderVal || ""}
                                onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === "") {
                                        setMapProvider(null);
                                        setProviderLock('mapping', false);
                                    } else {
                                        handleSelectMap(val);
                                    }
                                }}
                                className="w-full bg-chip border border-border-subtle rounded-md px-2 py-1.5 text-xs text-text-primary outline-none focus:border-brand-500 transition-colors"
                            >
                                <option value="">None</option>
                                {allProviders.map(p => {
                                    const pid = String(p.id);
                                    const isUnauthorized = authStatus && authStatus[pid] === false;
                                    return (
                                        <option key={`m-${pid}`} value={pid} disabled={isUnauthorized}>
                                            {p.name} {isUnauthorized ? "(Locked)" : ""}
                                        </option>
                                    );
                                })}
                            </select>
                        </div>

                        {/* Composer Dropdown */}
                        <div>
                            <div className="flex items-center gap-2 mb-2 text-sm"><span>✏️</span><span>Composer</span></div>
                            <select
                                value={composerVal || ""}
                                onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === "") {
                                        setComposer(null);
                                    } else {
                                        handleSelectComposer(val);
                                    }
                                }}
                                className="w-full bg-chip border border-border-subtle rounded-md px-2 py-1.5 text-xs text-text-primary outline-none focus:border-brand-500 transition-colors"
                            >
                                <option value="">None</option>
                                {allProviders.map(p => {
                                    const pid = String(p.id);
                                    const isUnauthorized = authStatus && authStatus[pid] === false;
                                    return (
                                        <option key={`c-${pid}`} value={pid} disabled={isUnauthorized}>
                                            {p.name} {isUnauthorized ? "(Locked)" : ""}
                                        </option>
                                    );
                                })}
                            </select>
                        </div>

                        {/* Refiner Dropdown */}
                        <div>
                            <div className="flex items-center gap-2 mb-2 text-sm"><span>🔒</span><span>Refiner</span></div>
                            <select
                                value={refinerProvider || ""}
                                onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === "") {
                                        setRefinerProvider(null);
                                    } else {
                                        handleSelectRefiner(val);
                                    }
                                }}
                                className="w-full bg-chip border border-border-subtle rounded-md px-2 py-1.5 text-xs text-text-primary outline-none focus:border-brand-500 transition-colors"
                            >
                                <option value="">None</option>
                                {allProviders.map(p => {
                                    const pid = String(p.id);
                                    const isUnauthorized = authStatus && authStatus[pid] === false;
                                    return (
                                        <option key={`r-${pid}`} value={pid} disabled={isUnauthorized}>
                                            {p.name} {isUnauthorized ? "(Locked)" : ""}
                                        </option>
                                    );
                                })}
                            </select>
                        </div>

                        {/* Analyst Dropdown */}
                        <div>
                            <div className="flex items-center gap-2 mb-2 text-sm"><span>🧠</span><span>Analyst</span></div>
                            <select
                                value={analystVal || ""}
                                onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === "") {
                                        setAnalyst(null);
                                    } else {
                                        handleSelectAnalyst(val);
                                    }
                                }}
                                className="w-full bg-chip border border-border-subtle rounded-md px-2 py-1.5 text-xs text-text-primary outline-none focus:border-brand-500 transition-colors"
                            >
                                <option value="">None</option>
                                {allProviders.map(p => {
                                    const pid = String(p.id);
                                    const isUnauthorized = authStatus && authStatus[pid] === false;
                                    return (
                                        <option key={`a-${pid}`} value={pid} disabled={isUnauthorized}>
                                            {p.name} {isUnauthorized ? "(Locked)" : ""}
                                        </option>
                                    );
                                })}
                            </select>
                        </div>

                        {/* Antagonist Dropdown */}
                        <div>
                            <div className="flex items-center gap-2 mb-2 text-sm"><span>🎭</span><span>Antagonist</span></div>
                            <select
                                value={antagonistProvider || ""}
                                onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === "") {
                                        setAntagonistProvider(null);
                                    } else {
                                        handleSelectAntagonist(val);
                                    }
                                }}
                                className="w-full bg-chip border border-border-subtle rounded-md px-2 py-1.5 text-xs text-text-primary outline-none focus:border-brand-500 transition-colors"
                            >
                                <option value="">None</option>
                                {allProviders.map(p => {
                                    const pid = String(p.id);
                                    const isUnauthorized = authStatus && authStatus[pid] === false;
                                    return (
                                        <option key={`ant-${pid}`} value={pid} disabled={isUnauthorized}>
                                            {p.name} {isUnauthorized ? "(Locked)" : ""}
                                        </option>
                                    );
                                })}
                            </select>
                        </div>

                        {/* Witness Section - Full Width */}
                        <div className="col-span-2">
                            <div className="flex items-center gap-2 mb-2 text-sm"><span>👁️</span><span>Witness</span></div>
                            <div className="flex flex-wrap gap-2">
                                {allProviders.map(p => {
                                    const pid = String(p.id);
                                    const checked = !!selectedModels?.[pid];
                                    const isUnauthorized = authStatus && authStatus[pid] === false;
                                    return (
                                        <button
                                            key={`w-${pid}`}
                                            onClick={() => !isUnauthorized && setSelectedModels({ ...(selectedModels || {}), [pid]: !checked })}
                                            disabled={isUnauthorized}
                                            className={clsx("px-2 py-1 rounded-md text-xs border transition-colors",
                                                checked ? "bg-brand-500/15 border-brand-500 text-text-primary" : "bg-chip border-border-subtle text-text-secondary hover:bg-surface-highlight",
                                                isUnauthorized && "opacity-50 cursor-not-allowed hover:bg-chip"
                                            )}
                                            title={isUnauthorized ? `Login required for ${p.name}` : undefined}
                                        >
                                            {p.name} {checked ? "✓" : ""} {isUnauthorized ? "🔒" : ""}
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                    </div>
                    <div className="flex justify-end mt-3">
                        <button onClick={() => setIsMenuOpen(false)} className="px-3 py-1.5 text-xs rounded-md bg-surface-highlight hover:bg-surface-raised border border-border-subtle text-text-secondary transition-colors">Close</button>
                    </div>
                </div>
            )}
        </div>
    );
});

interface OrbProps {
    turnId: string;
    provider: LLMProvider;
    isVoice: boolean;
    isCrownMode: boolean;
    onHover: (id: string | null) => void;
    onClick: (e: React.MouseEvent) => void;
    onCrownClick: (e: React.MouseEvent) => void;
    hoveredOrb: string | null;
    variant?: "tray" | "divider" | "historical" | "welcome" | "active";
    onLongPressStart?: () => void;
    onLongPressCancel?: () => void;
    disabled?: boolean;
    isSelected?: boolean;
    // Workflow progress (optional)
    workflowStage?: WorkflowStage;
    workflowProgress?: number; // 0-100
}

const Orb: React.FC<OrbProps> = ({
    turnId,
    provider,
    isVoice,
    isCrownMode,
    onHover,
    onClick,
    onCrownClick,
    hoveredOrb,
    variant = "tray",
    onLongPressStart,
    onLongPressCancel,
    disabled = false,
    isSelected,
    workflowStage = 'idle',
    workflowProgress = 0,
}) => {
    const pid = String(provider.id);
    const state = useAtomValue(providerEffectiveStateFamily({ turnId, providerId: pid }));

    // For active variant, we don't use turn state status, we use selection state
    const isStreaming = variant !== "active" && state.latestResponse?.status === 'streaming';
    const hasError = variant !== "active" && state.latestResponse?.status === 'error';
    const isHovered = hoveredOrb === pid;

    // Get colors and logo
    const primaryColor = getProviderColor(pid);
    const accentColor = PROVIDER_ACCENT_COLORS[pid] || PROVIDER_ACCENT_COLORS['default'];
    const stageColor = WORKFLOW_STAGE_COLORS[workflowStage] || WORKFLOW_STAGE_COLORS.idle;
    const logoSrc = getProviderLogo(pid) || '';

    // Active variant styling logic
    const isActiveVariant = variant === "active";
    const showAsActive = isActiveVariant ? isSelected : true; // In active mode, dim if not selected

    // In historical mode, it's always "active" because we filter list upstream vs "active" mode where we show all

    // Progress ring geometry for workflow progress
    const circumference = 2 * Math.PI * 18; // r=18
    const progressOffset = circumference - (workflowProgress / 100) * circumference;

    // Track stage transitions for per-orb animations
    const prevStageRef = useRef<WorkflowStage>(workflowStage);
    const [animationClass, setAnimationClass] = useState<string>('');

    useEffect(() => {
        const prevStage = prevStageRef.current;

        // Detect "start streaming" transition
        if (prevStage !== 'streaming' && workflowStage === 'streaming') {
            setAnimationClass('council-orb--start-pulse');
            const timer = setTimeout(() => setAnimationClass(''), 600);
            return () => clearTimeout(timer);
        }

        // Detect "completion" transition
        if (prevStage !== 'complete' && workflowStage === 'complete') {
            setAnimationClass('council-orb--complete-flash');
            const timer = setTimeout(() => setAnimationClass(''), 500);
            return () => clearTimeout(timer);
        }

        prevStageRef.current = workflowStage;
    }, [workflowStage]);

    return (
        <div
            className={clsx(
                "council-orb-wrapper",
                isVoice && "council-orb-wrapper--voice",
                isActiveVariant && !showAsActive && !isVoice && "council-orb-wrapper--inactive"
            )}
        >
            {/* Crown Icon for Voice Provider */}
            {isVoice && (
                <button
                    type="button"
                    className={clsx(
                        "council-crown",
                        isActiveVariant && !isCrownMode && "council-crown--active",
                        variant === "historical" && "council-crown--historical",
                        isCrownMode && "council-crown--selecting"
                    )}
                    onClick={(e) => { if (variant !== "historical") onCrownClick(e); }}
                    title={variant === "historical" ? "Synthesizer for this turn" : "Click to change voice"}
                >
                    👑
                </button>
            )}

            {/* Workflow Progress Ring */}
            {workflowStage !== 'idle' && (
                <svg className="council-progress-ring" viewBox="0 0 44 44">
                    <circle cx="22" cy="22" r="18" fill="none" stroke="currentColor" strokeWidth="2" className="opacity-20" />
                    <circle
                        cx="22"
                        cy="22"
                        r="18"
                        fill="none"
                        stroke={stageColor}
                        strokeWidth="2.5"
                        strokeLinecap="round"
                        strokeDasharray={circumference}
                        strokeDashoffset={progressOffset}
                        className="council-progress-ring__progress"
                        style={{ transform: 'rotate(-90deg)', transformOrigin: 'center' }}
                    />
                </svg>
            )}

            <button
                type="button"
                className={clsx(
                    "council-orb transition-all duration-300 ease-out",
                    // Shape and Size
                    isVoice ? "council-orb-voice" : "council-orb-regular",

                    // Historical Mode: Static orbs (no heavy animation), but still interactive
                    variant === "historical" && "council-orb-historical",

                    // Status Effects
                    isStreaming && "council-orb-streaming",
                    hasError && "council-orb-error",

                    // Active Mode Selection Dimming
                    // Unselected: Distinctly "Off" but visible logos. Low opacity (40%) + Grayscale.
                    // Hover brings it to life (Full Opacity + Color + Bloom).
                    isActiveVariant && !showAsActive && "opacity-90 brightness-90 scale-100 hover:opacity-100 hover:brightness-100 hover:scale-105 hover:shadow-[0_0_15px_-3px_var(--model-color)] transition-all duration-300",

                    // Selected: "On" State. Full Opacity, Color, Glow.
                    // Added brightness boost to combat "dullness".
                    isActiveVariant && showAsActive && "opacity-100 shadow-[0_0_20px_-4px_var(--model-color)] ring-1 ring-[var(--model-color)]/50 scale-125 z-10",

                    // Crown Mode Selection Target
                    isCrownMode && !isVoice && "ring-2 ring-brand-500/50 ring-offset-1 ring-offset-surface cursor-crosshair animate-pulse",
                    disabled && "opacity-50 cursor-not-allowed",

                    // Per-orb stage transition animations
                    animationClass
                )}
                style={{
                    '--model-color': primaryColor,
                    '--orb-color': primaryColor,
                    '--orb-accent': accentColor,
                    '--rotation': `${Math.random() * 360}deg`,
                    '--logo-src': logoSrc ? `url('${logoSrc}')` : 'none'
                } as React.CSSProperties}
                onMouseEnter={() => onHover(pid)}
                onMouseLeave={() => onHover(null)}
                onClick={onClick}
                onMouseDown={onLongPressStart}
                onMouseUp={onLongPressCancel}
            >
                {/* Internal orb layers for enhanced visuals */}
                <div className="council-orb__core" />
                <div className="council-orb__glow" />
                <div className="council-orb__spinner" />
                {logoSrc && (
                    <div className="council-orb__logo" style={{ backgroundImage: `url('${logoSrc}')` }} />
                )}
                {(isStreaming || workflowStage === 'streaming') && <div className="council-orb__pulse" />}
            </button>

            {/* Workflow Stage Indicator */}
            {workflowStage !== 'idle' && workflowStage !== 'complete' && (
                <div className="council-stage-badge" style={{ backgroundColor: stageColor }}>
                    {workflowStage === 'thinking' && '🤔'}
                    {workflowStage === 'streaming' && '💬'}
                    {workflowStage === 'synthesizing' && '✨'}
                    {workflowStage === 'error' && '⚠️'}
                </div>
            )}

            {/* Tooltip */}
            {isHovered && (
                <div className="council-tooltip">
                    <span className="council-tooltip__name">{provider.name}</span>
                    {workflowStage !== 'idle' && (
                        <span className="council-tooltip__stage">
                            {workflowStage === 'thinking' && 'Processing...'}
                            {workflowStage === 'streaming' && (
                                typeof workflowProgress === 'number' && workflowProgress > 0
                                    ? `Generating (${workflowProgress}%)`
                                    : 'Generating...'
                            )}
                            {workflowStage === 'synthesizing' && 'Synthesizing...'}
                            {workflowStage === 'complete' && 'Complete'}
                            {workflowStage === 'error' && 'Error'}
                        </span>
                    )}
                    {isActiveVariant && !showAsActive && !isVoice && (
                        <span className="council-tooltip__action">Click to enable</span>
                    )}
                </div>
            )}
        </div>
    );
};



================================================
FILE: ui/components/CouncilOrbsVertical.tsx
================================================
import React, { useState, useMemo } from "react";
import { useAtomValue, useSetAtom } from "jotai";
import { activeSplitPanelAtom, providerEffectiveStateFamily, turnsMapAtom } from "../state/atoms";
import { LLM_PROVIDERS_CONFIG } from "../constants";
import type { AiTurn } from "../types";
import { useRefinerOutput } from "../hooks/useRefinerOutput";
import clsx from "clsx";

interface CouncilOrbsVerticalProps {
    // We need to know which turn is active in the right panel to show the correct states
    // But this component sits on the global divider.
    // It should probably reflect the *active* panel's turn.
}

export const CouncilOrbsVertical: React.FC<CouncilOrbsVerticalProps> = React.memo(() => {
    const activePanel = useAtomValue(activeSplitPanelAtom);
    const setActiveSplitPanel = useSetAtom(activeSplitPanelAtom);
    const [hoveredOrb, setHoveredOrb] = useState<string | null>(null);
    const turnsMap = useAtomValue(turnsMapAtom);

    if (!activePanel) return null;

    const { turnId, providerId: activeProviderId } = activePanel;
    const turn = turnsMap.get(turnId);
    const { output: refinerOutput } = useRefinerOutput(turnId);

    // Filter out system provider
    const allProviders = LLM_PROVIDERS_CONFIG.filter(p => p.id !== 'system');

    // Determine contributing providers
    const contributingIds = useMemo(() => {
        if (!turn || turn.type !== 'ai') return [];
        const aiTurn = turn as unknown as AiTurn; // Safe cast since we checked type === 'ai'
        const batchKeys = Object.keys(aiTurn.batchResponses || {});
        const synthesizerKey = aiTurn.meta?.synthesizer;
        const mapperKey = aiTurn.meta?.mapper;
        return Array.from(new Set([
            ...batchKeys,
            ...(synthesizerKey ? [synthesizerKey] : []),
            ...(mapperKey ? [mapperKey] : []),
        ]));
    }, [turn]);

    // Filter display providers to only those that contributed
    const displayProviders = allProviders.filter(p => contributingIds.includes(String(p.id)));

    // Condition for trust button
    const showTrustButton = !!(refinerOutput?.gem || refinerOutput?.synthesisPlus);
    const isTrustActive = activeProviderId === '__trust__';
    const middleIndex = Math.max(0, Math.floor(displayProviders.length / 2));

    return (
        <div className="flex flex-col items-center gap-3 py-4 w-full">
            {displayProviders.map((p, idx) => {
                const pid = String(p.id);
                const isActive = pid === activeProviderId;

                const orbElement = (
                    <VerticalOrb
                        key={pid}
                        turnId={turnId}
                        provider={p}
                        isActive={isActive}
                        onClick={() => setActiveSplitPanel({ turnId, providerId: pid })}
                        onHover={setHoveredOrb}
                        hoveredOrb={hoveredOrb}
                    />
                );

                if (showTrustButton && idx === middleIndex) {
                    return (
                        <React.Fragment key={pid}>
                            <button
                                onClick={() => setActiveSplitPanel({ turnId, providerId: '__trust__' })}
                                className={clsx(
                                    "flex items-center justify-center w-6 h-6 rounded-full transition-all duration-300 shrink-0",
                                    isTrustActive
                                        ? "bg-brand-500 shadow-glow-brand-soft ring-2 ring-brand-400"
                                        : "bg-surface-raised border border-border-subtle hover:bg-surface-highlight hover:scale-110"
                                )}
                                title="Trust Pane (Epistemic Audit)"
                            >
                                <span className={clsx("text-[10px]", isTrustActive ? "text-white" : "text-brand-400")}>
                                    ðŸ’Ž
                                </span>
                            </button>
                            {orbElement}
                        </React.Fragment>
                    );
                }

                return orbElement;
            })}

            {/* Fallback if no providers but trust button should show */}
            {displayProviders.length === 0 && showTrustButton && (
                <button
                    onClick={() => setActiveSplitPanel({ turnId, providerId: '__trust__' })}
                    className={clsx(
                        "flex items-center justify-center w-6 h-6 rounded-full transition-all duration-300",
                        isTrustActive
                            ? "bg-brand-500 shadow-glow-brand-soft ring-2 ring-brand-400"
                            : "bg-surface-raised border border-border-subtle hover:bg-surface-highlight hover:scale-110"
                    )}
                    title="Trust Pane (Epistemic Audit)"
                >
                    <span className={clsx("text-[10px]", isTrustActive ? "text-white" : "text-brand-400")}>
                        ðŸ’Ž
                    </span>
                </button>
            )}
        </div>
    );
});

interface VerticalOrbProps {
    turnId: string;
    provider: any;
    isActive: boolean;
    onClick: () => void;
    onHover: (id: string | null) => void;
    hoveredOrb: string | null;
}

const VerticalOrb: React.FC<VerticalOrbProps> = ({
    turnId,
    provider,
    isActive,
    onClick,
    onHover,
    hoveredOrb
}) => {
    const pid = String(provider.id);
    const state = useAtomValue(providerEffectiveStateFamily({ turnId, providerId: pid }));

    const isStreaming = state.latestResponse?.status === 'streaming';
    const hasError = state.latestResponse?.status === 'error';
    const isHovered = hoveredOrb === pid;

    return (
        <div className="relative flex items-center justify-center w-full">
            <button
                type="button"
                className={clsx(
                    "rounded-full transition-all duration-200 relative",
                    isActive ? "w-4 h-4 opacity-100 ring-2 ring-brand-500 ring-offset-2 ring-offset-surface-raised" : "w-2 h-2 opacity-40 hover:opacity-80 hover:scale-125",
                    hasError ? "bg-intent-danger" : "bg-text-secondary",
                    isStreaming && "animate-pulse bg-intent-warning"
                )}
                style={{ backgroundColor: isActive ? provider.color : undefined }}
                onMouseEnter={() => onHover(pid)}
                onMouseLeave={() => onHover(null)}
                onClick={onClick}
            />

            {/* Tooltip (Left side for vertical bar) */}
            {isHovered && (
                <div className="absolute right-full mr-2 top-1/2 -translate-y-1/2 whitespace-nowrap z-50 pointer-events-none">
                    <div className="bg-surface-raised border border-border-subtle text-text-primary text-xs px-2 py-1 rounded shadow-lg">
                        {provider.name}
                    </div>
                </div>
            )}
        </div>
    );
};



================================================
FILE: ui/components/DecisionMapGraph.tsx
================================================
import React, { useEffect, useRef, useState, useCallback } from 'react';
import * as d3 from 'd3-force';
import { getProviderColor } from '../utils/provider-helpers';

export interface ClaimNode extends d3.SimulationNodeDatum {
    id: string;
    label: string;
    supporters: (string | number)[];
    support_count: number;
    consensusStrength: number; // 0-1, maps to node size
    theme?: string;
    x?: number;
    y?: number;
    fx?: number | null;
    fy?: number | null;
    vx?: number;
    vy?: number;
}

export interface ClaimEdge extends d3.SimulationLinkDatum<ClaimNode> {
    source: string | ClaimNode;
    target: string | ClaimNode;
    type: 'conflicts' | 'complements' | 'prerequisite';
    reason?: string;
}

interface Props {
    nodes: ClaimNode[];
    edges: ClaimEdge[];
    citationSourceOrder?: Record<number, string>; // Maps citation number -> provider ID
    onNodeClick?: (node: ClaimNode) => void;
    width?: number;
    height?: number;
}

// Map supporter to provider ID using citationSourceOrder when available
function getProviderIdFromSupporter(s: string | number, citationSourceOrder?: Record<number, string>): string {
    // Handle 'S' as synthesizer identifier
    if (s === 'S' || s === 's') {
        return (citationSourceOrder as any)?.['S'] || 'synthesizer';
    }
    if ((typeof s === 'number' || !isNaN(Number(s))) && citationSourceOrder) {
        const num = Number(s);
        const providerId = citationSourceOrder[num];
        if (providerId) {
            return providerId;
        }
    }
    // If it's a string (direct provider ID), return as-is
    if (typeof s === 'string' && isNaN(Number(s))) {
        return s;
    }
    return 'default';
}

// Get blended color from multiple supporters
function getNodeColor(supporters: (string | number)[], citationSourceOrder?: Record<number, string>): string {
    if (!supporters || supporters.length === 0) {
        return '#8b5cf6'; // default violet
    }

    const colors = supporters.map(s => {
        const pid = getProviderIdFromSupporter(s, citationSourceOrder);
        return getProviderColor(pid);
    });

    if (colors.length === 1) {
        return colors[0];
    }

    // Average the colors for multiple supporters
    let r = 0, g = 0, b = 0;
    for (const hex of colors) {
        const parsed = hexToRgb(hex);
        r += parsed.r;
        g += parsed.g;
        b += parsed.b;
    }
    r = Math.round(r / colors.length);
    g = Math.round(g / colors.length);
    b = Math.round(b / colors.length);

    return `rgb(${r}, ${g}, ${b})`;
}

function hexToRgb(hex: string): { r: number; g: number; b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : { r: 139, g: 92, b: 246 }; // fallback to violet
}

// Node sizing by support_count: 1=48px diameter (24 radius), 2=64px (32 radius), 3+=80px (40 radius)
function getNodeRadius(supportCount: number): number {
    if (supportCount >= 3) return 40;
    if (supportCount === 2) return 32;
    return 24;
}

const DecisionMapGraph: React.FC<Props> = ({
    nodes: inputNodes,
    edges: inputEdges,
    citationSourceOrder,
    onNodeClick,
    width = 400,
    height = 250,
}) => {
    const svgRef = useRef<SVGSVGElement>(null);
    const simulationRef = useRef<d3.Simulation<ClaimNode, ClaimEdge> | null>(null);
    const [nodes, setNodes] = useState<ClaimNode[]>([]);
    const [edges, setEdges] = useState<ClaimEdge[]>([]);
    const [hoveredNode, setHoveredNode] = useState<string | null>(null);
    const [hoveredEdge, setHoveredEdge] = useState<{ edge: ClaimEdge; x: number; y: number } | null>(null);

    // Zoom/pan state
    const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
    const isPanningRef = useRef(false);
    const panStartRef = useRef({ x: 0, y: 0 });

    // Initialize and update simulation when input changes
    useEffect(() => {
        if (!inputNodes.length) {
            setNodes([]);
            setEdges([]);
            return;
        }

        // Preserve existing positions for nodes that already exist
        const existingPositions = new Map(
            nodes.map(n => [n.id, { x: n.x, y: n.y }])
        );

        const simNodes: ClaimNode[] = inputNodes.map(n => {
            const existing = existingPositions.get(n.id);
            return {
                ...n,
                x: existing?.x ?? width / 2 + (Math.random() - 0.5) * 100,
                y: existing?.y ?? height / 2 + (Math.random() - 0.5) * 100,
            };
        });

        const simEdges: ClaimEdge[] = inputEdges.map(e => ({ ...e }));

        // Stop existing simulation
        if (simulationRef.current) {
            simulationRef.current.stop();
        }

        // Create new simulation with SEMANTIC forces - SPREAD OUT LAYOUT
        const aspectRatio = width / height;
        const isWideLayout = aspectRatio > 1.5;
        const nodePadding = 80; // Keep nodes away from edges (increased for larger spread)

        const simulation = d3.forceSimulation<ClaimNode>(simNodes)
            .force('charge', d3.forceManyBody().strength(-1000)) // Stronger repulsion to spread out
            .force('link', d3.forceLink<ClaimNode, ClaimEdge>(simEdges)
                .id(d => d.id)
                .distance(link => {
                    const baseDist = link.type === 'complements' ? 100 :
                        link.type === 'conflicts' ? 220 :
                            link.type === 'prerequisite' ? 150 : 120;
                    return isWideLayout ? baseDist * 1.6 : baseDist; // Increased distance
                })
                .strength(link => {
                    if (link.type === 'complements') return 0.5;
                    if (link.type === 'conflicts') return 0.15;
                    if (link.type === 'prerequisite') return 0.3;
                    return 0.3;
                }))
            .force('center', d3.forceCenter(width / 2, height / 2).strength(0.01)) // Extremely weak centering
            .force('collision', d3.forceCollide<ClaimNode>().radius(d => getNodeRadius(d.support_count) + 45)) // Large collision radius for labels
            // No x-centering force - let nodes spread horizontally
            .force('y', d3.forceY(height / 2).strength(0.02)) // Very weak vertical centering
            // Soft boundary force to keep nodes inside canvas
            .force('boundary', () => {
                simNodes.forEach(node => {
                    const r = getNodeRadius(node.support_count);
                    if (node.x !== undefined) {
                        if (node.x < nodePadding + r) {
                            node.vx = (node.vx || 0) + 1.5;
                        } else if (node.x > width - nodePadding - r) {
                            node.vx = (node.vx || 0) - 1.5;
                        }
                    }
                    if (node.y !== undefined) {
                        if (node.y < nodePadding + r) {
                            node.vy = (node.vy || 0) + 1.5;
                        } else if (node.y > height - nodePadding - r) {
                            node.vy = (node.vy || 0) - 1.5;
                        }
                    }
                });
            })
            .force('prerequisite', () => {
                simEdges.forEach(link => {
                    if (link.type === 'prerequisite') {
                        const source = typeof link.source === 'object' ? link.source : simNodes.find(n => n.id === link.source);
                        const target = typeof link.target === 'object' ? link.target : simNodes.find(n => n.id === link.target);

                        if (source && target && source.x !== undefined && target.x !== undefined) {
                            const dx = (target.x - source.x) - 60;
                            if (dx < 0) {
                                source.vx = (source.vx || 0) + dx * 0.01;
                                target.vx = (target.vx || 0) - dx * 0.01;
                            }
                        }
                    }
                });
            })
            .alphaDecay(0.02);

        simulation.on('tick', () => {
            setNodes([...simNodes]);
            setEdges([...simEdges]);
        });

        simulationRef.current = simulation;

        return () => {
            simulation.stop();
        };
    }, [inputNodes, inputEdges, width, height]);

    // Get edge coordinates
    const getEdgeCoords = useCallback((edge: ClaimEdge) => {
        const source = typeof edge.source === 'object'
            ? edge.source as ClaimNode
            : nodes.find(n => n.id === edge.source);
        const target = typeof edge.target === 'object'
            ? edge.target as ClaimNode
            : nodes.find(n => n.id === edge.target);

        if (!source?.x || !target?.x) return null;

        return { x1: source.x, y1: source.y!, x2: target.x, y2: target.y! };
    }, [nodes]);

    // Drag handlers
    const handleDragStart = useCallback((nodeId: string) => {
        if (simulationRef.current) {
            simulationRef.current.alphaTarget(0.3).restart();
        }
        setNodes(prev => prev.map(n =>
            n.id === nodeId ? { ...n, fx: n.x, fy: n.y } : n
        ));
    }, []);

    const handleDrag = useCallback((nodeId: string, x: number, y: number) => {
        // Account for transform when dragging
        const adjustedX = (x - transform.x) / transform.scale;
        const adjustedY = (y - transform.y) / transform.scale;
        setNodes(prev => prev.map(n =>
            n.id === nodeId ? { ...n, fx: adjustedX, fy: adjustedY, x: adjustedX, y: adjustedY } : n
        ));
    }, [transform]);

    const handleDragEnd = useCallback((nodeId: string) => {
        if (simulationRef.current) {
            simulationRef.current.alphaTarget(0);
        }
        setNodes(prev => prev.map(n =>
            n.id === nodeId ? { ...n, fx: null, fy: null } : n
        ));
    }, []);

    // Mouse handlers for SVG
    const dragState = useRef<{ nodeId: string | null; startX: number; startY: number }>({
        nodeId: null, startX: 0, startY: 0
    });

    const handleMouseDown = (nodeId: string, e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        const svg = svgRef.current;
        if (!svg) return;

        const rect = svg.getBoundingClientRect();
        dragState.current = {
            nodeId,
            startX: e.clientX - rect.left,
            startY: e.clientY - rect.top,
        };
        handleDragStart(nodeId);
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!svgRef.current) return;

        // Handle node dragging
        if (dragState.current.nodeId) {
            const rect = svgRef.current.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            handleDrag(dragState.current.nodeId, x, y);
            return;
        }

        // Handle panning
        if (isPanningRef.current) {
            const dx = e.clientX - panStartRef.current.x;
            const dy = e.clientY - panStartRef.current.y;
            setTransform(prev => ({
                ...prev,
                x: prev.x + dx,
                y: prev.y + dy
            }));
            panStartRef.current = { x: e.clientX, y: e.clientY };
        }
    };

    const handleMouseUp = () => {
        if (dragState.current.nodeId) {
            handleDragEnd(dragState.current.nodeId);
            dragState.current.nodeId = null;
        }
        isPanningRef.current = false;
    };

    // Pan on background drag
    const handleBackgroundMouseDown = (e: React.MouseEvent) => {
        if ((e.target as Element).classList.contains('graph-background')) {
            isPanningRef.current = true;
            panStartRef.current = { x: e.clientX, y: e.clientY };
        }
    };

    // Zoom with scroll wheel
    const handleWheel = useCallback((e: WheelEvent) => {
        e.preventDefault();
        e.stopPropagation(); // Good practice to stop bubbling

        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const newScale = Math.max(0.5, Math.min(2, transform.scale * delta));

        const rect = svgRef.current?.getBoundingClientRect();
        if (rect) {
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const newX = mouseX - (mouseX - transform.x) * (newScale / transform.scale);
            const newY = mouseY - (mouseY - transform.y) * (newScale / transform.scale);

            setTransform({ x: newX, y: newY, scale: newScale });
        }
    }, [transform]);

    // 2. Add this useEffect to attach the non-passive listener
    useEffect(() => {
        const svg = svgRef.current;
        if (!svg) return;

        // { passive: false } is the key fix here
        svg.addEventListener('wheel', handleWheel, { passive: false });

        return () => {
            svg.removeEventListener('wheel', handleWheel);
        };
    }, [handleWheel]);

    if (!nodes.length) {
        return (
            <div
                style={{
                    width,
                    height,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    background: 'transparent',
                    borderRadius: 12,
                }}
            >
                <div style={{
                    color: 'rgba(167,139,250,0.7)',
                    fontSize: 13,
                    fontWeight: 500,
                    textAlign: 'center',
                }}>
                    No claims visualized
                </div>
            </div>
        );
    }

    return (
        <svg
            ref={svgRef}
            width={width}
            height={height}
            style={{
                background: 'transparent',
                borderRadius: 12,
                cursor: isPanningRef.current ? 'grabbing' : (dragState.current.nodeId ? 'grabbing' : 'grab'),
            }}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
            onMouseDown={handleBackgroundMouseDown}
        >
            <defs>
                {/* Enhanced glow filters */}
                <filter id="edgeGlowGreen" x="-150%" y="-150%" width="400%" height="400%">
                    <feGaussianBlur stdDeviation="6" result="blur" />
                    <feFlood floodColor="#10b981" floodOpacity="0.6" />
                    <feComposite in2="blur" operator="in" result="glow" />
                    <feMerge>
                        <feMergeNode in="glow" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>

                <filter id="edgeGlowRed" x="-150%" y="-150%" width="400%" height="400%">
                    <feGaussianBlur stdDeviation="4" result="blur" />
                    <feFlood floodColor="#ef4444" floodOpacity="0.5" />
                    <feComposite in2="blur" operator="in" result="glow" />
                    <feMerge>
                        <feMergeNode in="glow" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>

                <filter id="edgeGlowBlue" x="-150%" y="-150%" width="400%" height="400%">
                    <feGaussianBlur stdDeviation="5" result="blur" />
                    <feFlood floodColor="#3b82f6" floodOpacity="0.8" />
                    <feComposite in2="blur" operator="in" result="glow" />
                    <feMerge>
                        <feMergeNode in="glow" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>

                {/* Arrow marker for prerequisites */}
                <marker
                    id="arrowBlue"
                    viewBox="0 0 10 10"
                    refX="9"
                    refY="5"
                    markerWidth="6"
                    markerHeight="6"
                    orient="auto-start-reverse"
                >
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#3b82f6" />
                </marker>

                <filter id="nodeGlow" x="-200%" y="-200%" width="500%" height="500%">
                    <feGaussianBlur stdDeviation="8" result="blur" />
                    <feMerge>
                        <feMergeNode in="blur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>
            </defs>

            {/* Background for panning */}
            <rect
                className="graph-background"
                width="100%"
                height="100%"
                fill="transparent"
            />

            {/* Transform group for zoom/pan */}
            <g transform={`translate(${transform.x}, ${transform.y}) scale(${transform.scale})`}>
                {/* Edges with enhanced visuals */}
                <g className="edges">
                    {edges.map((edge, i) => {
                        const coords = getEdgeCoords(edge);
                        if (!coords) return null;

                        const baseColor =
                            edge.type === 'complements' ? '#10b981' :
                                edge.type === 'conflicts' ? '#ef4444' :
                                    '#3b82f6';
                        const isDashed = edge.type === 'conflicts';
                        const midX = (coords.x1 + coords.x2) / 2;
                        const midY = (coords.y1 + coords.y2) / 2;

                        return (
                            <g key={`edge-${i}`}>
                                {/* Wide glow layer */}
                                <line
                                    x1={coords.x1}
                                    y1={coords.y1}
                                    x2={coords.x2}
                                    y2={coords.y2}
                                    stroke={baseColor}
                                    strokeWidth={12}
                                    strokeOpacity={0.12}
                                />
                                {/* Main line with filter */}
                                <line
                                    x1={coords.x1}
                                    y1={coords.y1}
                                    x2={coords.x2}
                                    y2={coords.y2}
                                    stroke={baseColor}
                                    strokeWidth={2.5}
                                    strokeDasharray={isDashed ? '8,5' : undefined}
                                    markerEnd={edge.type === 'prerequisite' ? 'url(#arrowBlue)' : undefined}
                                    filter={
                                        edge.type === 'complements' ? 'url(#edgeGlowGreen)' :
                                            edge.type === 'conflicts' ? 'url(#edgeGlowRed)' :
                                                'url(#edgeGlowBlue)'
                                    }
                                    style={{
                                        animation: edge.type === 'conflicts' ? 'conflictPulse 2s ease-in-out infinite' : undefined
                                    }}
                                >
                                    {edge.type === 'conflicts' && (
                                        <animate
                                            attributeName="stroke-opacity"
                                            values="0.4;0.8;0.4"
                                            dur="2s"
                                            repeatCount="indefinite"
                                        />
                                    )}
                                </line>
                                {/* Invisible wider hit area for hover */}
                                <line
                                    x1={coords.x1}
                                    y1={coords.y1}
                                    x2={coords.x2}
                                    y2={coords.y2}
                                    stroke="transparent"
                                    strokeWidth={20}
                                    style={{ cursor: 'pointer' }}
                                    onMouseEnter={() => setHoveredEdge({ edge, x: midX, y: midY })}
                                    onMouseLeave={() => setHoveredEdge(null)}
                                />
                            </g>
                        );
                    })}
                </g>

                {/* Nodes with premium styling */}
                <g className="nodes">
                    {nodes.map(node => {
                        const x = node.x || 0;
                        const y = node.y || 0;
                        const radius = getNodeRadius(node.support_count);
                        const isHovered = hoveredNode === node.id;
                        const color = getNodeColor(node.supporters, citationSourceOrder);

                        return (
                            <g
                                key={node.id}
                                transform={`translate(${x}, ${y})`}
                                style={{ cursor: 'pointer' }}
                                onMouseDown={(e) => handleMouseDown(node.id, e)}
                                onMouseEnter={() => setHoveredNode(node.id)}
                                onMouseLeave={() => setHoveredNode(null)}
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onNodeClick?.(node);
                                }}
                            >
                                {/* Hover aura */}
                                {isHovered && (
                                    <circle r={radius + 16} fill={color} opacity={0.25} filter="url(#nodeGlow)">
                                        <animate attributeName="opacity" values="0.25;0.4;0.25" dur="1.5s" repeatCount="indefinite" />
                                    </circle>
                                )}

                                {/* Outer ring */}
                                <circle
                                    r={radius + 3}
                                    fill="none"
                                    stroke={color}
                                    strokeWidth={isHovered ? 2.5 : 1.5}
                                    strokeOpacity={0.5}
                                />

                                {/* Radial gradient definition */}
                                <defs>
                                    <radialGradient id={`nodeGrad-${node.id}`} cx="30%" cy="30%">
                                        <stop offset="0%" stopColor={`${color}cc`} />
                                        <stop offset="60%" stopColor={color} />
                                        <stop offset="100%" stopColor={`${color}88`} />
                                    </radialGradient>
                                </defs>

                                {/* Main node sphere */}
                                <circle
                                    r={radius}
                                    fill={`url(#nodeGrad-${node.id})`}
                                    stroke={color}
                                    strokeWidth={isHovered ? 3 : 2}
                                    filter="url(#nodeGlow)"
                                />

                                {/* Highlight sparkle */}
                                <circle
                                    cx={-radius * 0.35}
                                    cy={-radius * 0.35}
                                    r={radius * 0.2}
                                    fill="rgba(255,255,255,0.5)"
                                    opacity={isHovered ? 0.7 : 0.4}
                                />



                                {/* Support count badge */}
                                {node.support_count > 1 && (
                                    <g>
                                        <circle
                                            cx={radius * 0.6}
                                            cy={-radius * 0.6}
                                            r={10}
                                            fill="rgba(0,0,0,0.8)"
                                            stroke={color}
                                            strokeWidth={1.5}
                                        />
                                        <text
                                            x={radius * 0.6}
                                            y={-radius * 0.6 + 4}
                                            textAnchor="middle"
                                            fill="white"
                                            fontSize={10}
                                            fontWeight="bold"
                                            style={{ pointerEvents: 'none' }}
                                        >
                                            {node.support_count}
                                        </text>
                                    </g>
                                )}
                            </g>
                        );
                    })}
                </g>

                {/* Labels - rendered after nodes to ensure z-index priority */}
                <g className="labels" style={{ pointerEvents: 'none' }}>
                    {nodes.map(node => {
                        const x = node.x || 0;
                        const y = node.y || 0;
                        const radius = getNodeRadius(node.support_count);
                        const isHovered = hoveredNode === node.id;

                        // Show for larger nodes always, others on hover
                        if (!isHovered && node.support_count < 2) return null;

                        return (
                            <g
                                key={`label-${node.id}`}
                                transform={`translate(${x}, ${y})`}
                            >
                                <foreignObject
                                    x={-90}
                                    y={radius + 8}
                                    width={180}
                                    height={50}
                                    style={{ overflow: 'visible' }}
                                >
                                    <div
                                        style={{
                                            padding: '4px 8px',
                                            fontSize: 11,
                                            fontWeight: 600,
                                            color: 'rgba(255,255,255,0.95)',
                                            textAlign: 'center',
                                            wordWrap: 'break-word',
                                            overflow: 'hidden',
                                            textOverflow: 'ellipsis',
                                            display: '-webkit-box',
                                            WebkitLineClamp: 3,
                                            WebkitBoxOrient: 'vertical',
                                            lineHeight: 1.3,
                                            textShadow: '0 2px 4px rgba(0,0,0,0.8), 0 0 2px rgba(0,0,0,1)'
                                        }}
                                    >
                                        {node.label}
                                    </div>
                                </foreignObject>
                            </g>
                        );
                    })}
                </g>

                {/* Edge reason tooltip - rendered last so it's on top */}
                {hoveredEdge && hoveredEdge.edge.reason && (
                    <g transform={`translate(${hoveredEdge.x}, ${hoveredEdge.y})`} style={{ pointerEvents: 'none' }}>
                        <foreignObject
                            x={-150}
                            y={-40}
                            width={300}
                            height={100}
                            style={{ overflow: 'visible' }}
                        >
                            <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'flex-end', height: '100%', paddingBottom: 12 }}>
                                <div
                                    style={{
                                        background: 'rgba(0,0,0,0.95)',
                                        border: `1px solid ${hoveredEdge.edge.type === 'complements' ? '#10b981' : hoveredEdge.edge.type === 'conflicts' ? '#ef4444' : '#3b82f6'}`,
                                        borderRadius: 6,
                                        padding: '6px 10px',
                                        fontSize: 11,
                                        fontWeight: 500,
                                        color: 'rgba(255,255,255,0.95)',
                                        textAlign: 'center',
                                        boxShadow: '0 4px 6px rgba(0,0,0,0.3)',
                                        maxWidth: '100%'
                                    }}
                                >
                                    {hoveredEdge.edge.reason}
                                </div>
                            </div>
                        </foreignObject>
                    </g>
                )}
            </g>

            {/* Legend - fixed position outside transform */}
            <g transform={`translate(${width - 140}, 20)`}>
                <rect x={-10} y={-10} width={135} height={80} fill="rgba(0,0,0,0.85)" rx={8} stroke="rgba(139,92,246,0.3)" strokeWidth={1} />
                <text x={0} y={8} fill="rgba(255,255,255,0.8)" fontSize={10} fontWeight={600}>Legend</text>

                <line x1={0} y1={24} x2={30} y2={24} stroke="#10b981" strokeWidth={2.5} />
                <text x={38} y={28} fill="rgba(255,255,255,0.7)" fontSize={9}>Complements</text>

                <line x1={0} y1={42} x2={30} y2={42} stroke="#ef4444" strokeWidth={2.5} strokeDasharray="6,4" />
                <text x={38} y={46} fill="rgba(255,255,255,0.7)" fontSize={9}>Conflicts</text>

                <line x1={0} y1={60} x2={30} y2={60} stroke="#3b82f6" strokeWidth={2.5} markerEnd="url(#arrowBlue)" />
                <text x={38} y={64} fill="rgba(255,255,255,0.7)" fontSize={9}>Prerequisite</text>
            </g>
        </svg>
    );
};

export default DecisionMapGraph;



================================================
FILE: ui/components/DecisionMapSheet.tsx
================================================
import React, { useMemo, useCallback, useEffect, useRef, useState, Suspense } from "react";
import { useAtom, useAtomValue, useSetAtom } from "jotai";
import { isDecisionMapOpenAtom, turnByIdAtom, mappingProviderAtom, activeSplitPanelAtom, providerAuthStatusAtom, refinerProviderAtom, antagonistProviderAtom } from "../state/atoms";
import { useClipActions } from "../hooks/useClipActions";
import { m, AnimatePresence, LazyMotion, domAnimation } from "framer-motion";
import { safeLazy } from "../utils/safeLazy";
const DecisionMapGraph = safeLazy(() => import("./DecisionMapGraph"));
import { adaptGraphTopology } from "../utils/graphAdapter";
import MarkdownDisplay from "./MarkdownDisplay";
import { LLM_PROVIDERS_CONFIG } from "../constants";
import { getLatestResponse, normalizeResponseArray } from "../utils/turn-helpers";
import { getProviderColor, getProviderConfig } from "../utils/provider-helpers";
import type { AiTurn, ProviderResponse } from "../types";
import clsx from "clsx";
import { CopyButton } from "./CopyButton";
import { formatDecisionMapForMd, formatGraphForMd } from "../utils/copy-format-utils";

// ============================================================================
// PARSING UTILITIES - Import from shared module (single source of truth)
// ============================================================================

import {
  parseMappingResponse,
  extractGraphTopologyAndStrip,
  cleanOptionsText,
} from "../../shared/parsing-utils";
import { normalizeProviderId } from "../utils/provider-id-mapper";

import { useRefinerOutput } from "../hooks/useRefinerOutput";
import { useAntagonistOutput } from "../hooks/useAntagonistOutput";
import { RefinerEpistemicAudit } from "./refinerui/RefinerCardsSection";

// ============================================================================
// OPTIONS PARSING - Handle both emoji-prefixed themes and "Theme:" headers
// ============================================================================

interface ParsedOption {
  title: string;
  description: string;
  citations: (number | string)[];
}

interface ParsedTheme {
  name: string;
  options: ParsedOption[];
}

function parseOptionsIntoThemes(optionsText: string | null): ParsedTheme[] {
  if (!optionsText) return [];

  const lines = optionsText.split('\n');
  const themes: ParsedTheme[] = [];
  let currentTheme: ParsedTheme | null = null;

  // Patterns for theme headers:
  // 1. Emoji-prefixed: "📐 Architecture & Pipeline" or "💻 Visualization..."
  // 2. "Theme:" prefix: "Theme: Defining the Interactive Role"


  // Pattern for option items (bold title followed by colon)
  const optionPattern = /^\s*[-*•]?\s*\*?\*?([^:*]+)\*?\*?:\s*(.*)$/;

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;

    // Check if this is a theme header
    let isTheme = false;
    let themeName = '';

    // Check emoji-prefixed (starts with emoji)
    if (/^[\u{1F300}-\u{1FAD6}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/u.test(trimmed)) {
      isTheme = true;
      themeName = trimmed;
    }
    // Check "Theme:" prefix
    else if (/^Theme:\s*/i.test(trimmed)) {
      isTheme = true;
      themeName = trimmed.replace(/^Theme:\s*/i, '').trim();
    }
    // Check markdown header that doesn't look like an option
    else if (/^#+\s*/.test(trimmed) && !optionPattern.test(trimmed)) {
      isTheme = true;
      themeName = trimmed.replace(/^#+\s*/, '').trim();
    }

    if (isTheme && themeName) {
      currentTheme = { name: themeName, options: [] };
      themes.push(currentTheme);
      continue;
    }

    // Check if this is an option item
    const optionMatch = trimmed.match(/^\s*[-*•]?\s*\*{0,2}([^:]+?)\*{0,2}:\s*(.+)$/);
    if (optionMatch && currentTheme) {
      const title = optionMatch[1].trim().replace(/^\*\*|\*\*$/g, '');
      const rest = optionMatch[2].trim();

      // Extract citation numbers [1], [2, 3], etc.
      const citations: number[] = [];
      const citationMatches = rest.matchAll(/\[(\d+(?:\s*,\s*\d+)*)\]/g);
      for (const cm of citationMatches) {
        const nums = cm[1].split(/\s*,\s*/).map(n => parseInt(n.trim(), 10));
        citations.push(...nums.filter(n => !isNaN(n)));
      }

      // Remove citations from description
      const description = rest.replace(/\s*\[\d+(?:\s*,\s*\d+)*\]/g, '').trim();

      currentTheme.options.push({ title, description, citations });
    } else if (currentTheme && currentTheme.options.length > 0) {
      // Continuation of previous option description
      const lastOption = currentTheme.options[currentTheme.options.length - 1];
      lastOption.description += ' ' + trimmed.replace(/\s*\[\d+(?:\s*,\s*\d+)*\]/g, '').trim();
    }
  }

  // If no themes were detected, create a default theme
  if (themes.length === 0 && optionsText.trim()) {
    const defaultTheme: ParsedTheme = { name: 'Options', options: [] };
    // Try to parse all lines as options
    for (const line of lines) {
      const optionMatch = line.trim().match(/^\s*[-*•]?\s*\*{0,2}([^:]+?)\*{0,2}:\s*(.+)$/);
      if (optionMatch) {
        const title = optionMatch[1].trim().replace(/^\*\*|\*\*$/g, '');
        const rest = optionMatch[2].trim();
        const citations: number[] = [];
        const citationMatches = rest.matchAll(/\[(\d+(?:\s*,\s*\d+)*)\]/g);
        for (const cm of citationMatches) {
          const nums = cm[1].split(/\s*,\s*/).map(n => parseInt(n.trim(), 10));
          citations.push(...nums.filter(n => !isNaN(n)));
        }
        const description = rest.replace(/\s*\[\d+(?:\s*,\s*\d+)*\]/g, '').trim();
        defaultTheme.options.push({ title, description, citations });
      }
    }
    if (defaultTheme.options.length > 0) {
      themes.push(defaultTheme);
    }
  }

  return themes;
}

// ============================================================================
// NARRATIVE EXTRACTION - Find paragraphs containing canonical label
// ============================================================================

function extractNarrativeExcerpt(narrativeText: string, label: string): string {
  if (!narrativeText || !label) return '';

  // Split into sentences/paragraphs
  const paragraphs = narrativeText.split(/\n\n+/);
  const matchingParagraphs: string[] = [];

  // Simple case-insensitive search for the label
  const labelLower = label.toLowerCase();

  for (const para of paragraphs) {
    if (para.toLowerCase().includes(labelLower)) {
      // Highlight the matching part
      const highlighted = para.replace(
        new RegExp(`(${escapeRegex(label)})`, 'gi'),
        '**$1**'
      );
      matchingParagraphs.push(highlighted);
    }
  }

  return matchingParagraphs.join('\n\n');
}

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ============================================================================
// SUPPORTER ORBS COMPONENT
// ============================================================================

interface SupporterOrbsProps {
  supporters: (string | number)[];
  citationSourceOrder?: Record<string | number, string>; // Maps citation number (or 'S') -> provider ID
  onOrbClick?: (providerId: string) => void;
  size?: 'small' | 'large';
}

const SupporterOrbs: React.FC<SupporterOrbsProps> = ({ supporters, citationSourceOrder, onOrbClick, size = 'large' }) => {
  // Map supporter numbers/ids to provider configs using citationSourceOrder when available
  const getProviderFromSupporter = (s: string | number) => {
    // Handle 'S' as synthesizer identifier
    if (s === 'S' || s === 's') {
      // For synthesizer, return the synthesis provider from metadata or use gemini as fallback
      const synthProviderId = citationSourceOrder?.['S'] || 'gemini';
      return getProviderConfig(synthProviderId) || null;
    }
    // If it's a number and we have citationSourceOrder, use it
    if ((typeof s === 'number' || !isNaN(Number(s))) && citationSourceOrder) {
      const num = Number(s);
      const providerId = citationSourceOrder[num];
      if (providerId) {
        return getProviderConfig(providerId) || null;
      }
    }
    // If it's a string, try direct lookup by provider ID
    if (typeof s === 'string' && isNaN(Number(s))) {
      return getProviderConfig(s) || null;
    }
    // Fallback: no mapping available
    return null;
  };

  const getInitials = (name: string) => {
    const words = name.split(/\s+/);
    if (words.length === 1) return name.slice(0, 2).toUpperCase();
    return words.slice(0, 2).map(w => w[0]).join('').toUpperCase();
  };

  const orbSize = size === 'large' ? 40 : 28;

  return (
    <div className="flex gap-2 flex-wrap">
      {supporters.map((s, idx) => {
        const provider = getProviderFromSupporter(s);
        const color = getProviderColor(provider?.id || 'default');
        const name = provider?.name || `Model ${s}`;
        const initials = getInitials(name);

        return (
          <button
            key={idx}
            type="button"
            className="decision-orb-badge"
            style={{
              '--orb-color': color,
              width: orbSize,
              height: orbSize,
              fontSize: size === 'large' ? 11 : 9
            } as React.CSSProperties}
            onClick={() => onOrbClick?.(provider?.id || String(s))}
            title={name}
          >
            <span>{initials}</span>
          </button>
        );
      })}
    </div>
  );
};

// ============================================================================
// OPTIONS TAB - COLLAPSIBLE THEME SECTIONS
// ============================================================================

interface OptionsTabProps {
  themes: ParsedTheme[];
  citationSourceOrder?: Record<number, string>;
  onCitationClick: (num: number | string) => void;
  mapperAudit?: { complete: boolean; unlistedOptions: Array<{ title: string; description: string; source: string }>; };
}

const OptionsTab: React.FC<OptionsTabProps> = ({ themes, citationSourceOrder, onCitationClick, mapperAudit }) => {
  const [expandedThemes, setExpandedThemes] = useState<Set<number>>(new Set([0])); // First expanded by default

  const toggleTheme = (idx: number) => {
    setExpandedThemes(prev => {
      const next = new Set(prev);
      if (next.has(idx)) {
        next.delete(idx);
      } else {
        next.add(idx);
      }
      return next;
    });
  };

  if (themes.length === 0) {
    return <div className="text-text-muted text-sm p-4">No options available.</div>;
  }

  return (
    <div className="p-4 max-w-3xl mx-auto">
      {/* Mapper Coverage Badge */}
      {mapperAudit && (
        <div className="mb-4 bg-surface rounded-lg border border-border-subtle p-3">
          {mapperAudit.complete ? (
            <div className="flex items-center gap-2 text-green-600 text-sm">
              <span>✓</span>
              <span>Mapper coverage complete — all approaches represented</span>
            </div>
          ) : (
            <div className="space-y-2">
              <div className="flex items-center gap-2 text-amber-600 text-sm">
                <span>⚠</span>
                <span className="font-medium">{mapperAudit.unlistedOptions.length} unlisted options found</span>
              </div>
              {mapperAudit.unlistedOptions.length > 0 && (
                <ul className="text-xs text-text-secondary space-y-1 pl-4">
                  {mapperAudit.unlistedOptions.map((opt, idx) => (
                    <li key={idx}><strong>{opt.title}</strong>: {opt.description}{opt.source ? (<span className="text-text-muted"> — {opt.source}</span>) : null}</li>
                  ))}
                </ul>
              )}
            </div>
          )}
        </div>
      )}
      {themes.map((theme, tIdx) => (
        <div key={tIdx} className="options-theme-section">
          <div
            className="options-theme-header"
            onClick={() => toggleTheme(tIdx)}
          >
            <span className="options-theme-title">{theme.name}</span>
            <svg
              className={clsx("options-theme-chevron w-5 h-5", expandedThemes.has(tIdx) && "expanded")}
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
            </svg>
          </div>

          {expandedThemes.has(tIdx) && (
            <div className="options-theme-content">
              {theme.options.map((opt, oIdx) => (
                <div key={oIdx} className="option-card">
                  <div className="option-card-title">{opt.title}</div>
                  <div className="option-card-description">{opt.description}</div>
                  {opt.citations.length > 0 && (
                    <div className="option-card-supporters">
                      <SupporterOrbs
                        supporters={opt.citations}
                        citationSourceOrder={citationSourceOrder}
                        onOrbClick={() => onCitationClick(opt.citations[0])}
                        size="small"
                      />
                    </div>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      ))}
    </div>
  );
};

// ============================================================================
// DETAIL VIEW COMPONENT
// ============================================================================

interface DetailViewProps {
  node: { id: string; label: string; supporters: (string | number)[]; theme?: string };
  narrativeExcerpt: string;
  citationSourceOrder?: Record<number, string>;
  onBack: () => void;
  onOrbClick: (providerId: string) => void;
}

const DetailView: React.FC<DetailViewProps> = ({ node, narrativeExcerpt, citationSourceOrder, onBack, onOrbClick }) => {
  // Get color from first supporter using citationSourceOrder
  const getNodeColor = () => {
    if (!node.supporters || node.supporters.length === 0) return '#8b5cf6';
    const first = node.supporters[0];
    let providerId: string | undefined;

    if ((typeof first === 'number' || !isNaN(Number(first))) && citationSourceOrder) {
      providerId = citationSourceOrder[Number(first)];
    } else if (typeof first === 'string' && isNaN(Number(first))) {
      providerId = first;
    }

    return getProviderColor(providerId || 'default');
  };

  const nodeColor = getNodeColor();

  return (
    <m.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      className="h-full flex flex-col p-6 overflow-y-auto"
    >
      {/* Back button - top left */}
      <button
        type="button"
        className="decision-back-btn self-start mb-6"
        onClick={onBack}
      >
        <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
        </svg>
        Back to Graph
      </button>

      {/* Node as large centered header */}
      <div className="flex flex-col items-center mb-8">
        {/* Node visual (120px) */}
        <div
          className="w-[120px] h-[120px] rounded-full mb-4 flex items-center justify-center"
          style={{
            background: `radial-gradient(circle at 30% 30%, ${nodeColor}88, ${nodeColor}22)`,
            boxShadow: `0 0 40px ${nodeColor}44`,
            border: `2px solid ${nodeColor}88`
          }}
        >
          <span className="text-2xl font-bold text-white text-center px-2" style={{ textShadow: '0 2px 4px rgba(0,0,0,0.5)' }}>
            {node.label.length > 20 ? node.label.slice(0, 20) + '…' : node.label}
          </span>
        </div>

        {/* Full label */}
        <h2
          className="decision-detail-header"
          style={{ color: nodeColor }}
        >
          {node.label}
        </h2>

        {node.theme && (
          <span className="text-sm text-text-muted mt-2">{node.theme}</span>
        )}
      </div>

      {/* Supported by row */}
      <div className="mb-8">
        <h3 className="text-sm font-medium text-text-muted mb-3">Supported by</h3>
        <SupporterOrbs
          supporters={node.supporters || []}
          citationSourceOrder={citationSourceOrder}
          onOrbClick={onOrbClick}
          size="large"
        />
      </div>

      {/* Narrative excerpt */}
      {narrativeExcerpt && (
        <div className="flex-1">
          <h3 className="text-sm font-medium text-text-muted mb-3">From the Narrative</h3>
          <div className="narrative-highlight">
            <MarkdownDisplay content={narrativeExcerpt} />
          </div>
        </div>
      )}

      {!narrativeExcerpt && (
        <div className="text-text-muted text-sm italic">
          No matching narrative excerpt found for this option.
        </div>
      )}
    </m.div>
  );
};

// ============================================================================
// MAPPER SELECTOR COMPONENT
// ============================================================================

interface MapperSelectorProps {
  aiTurn: AiTurn;
  activeProviderId?: string;
}

const MapperSelector: React.FC<MapperSelectorProps> = ({ aiTurn, activeProviderId }) => {
  const [isOpen, setIsOpen] = useState(false);
  const { handleClipClick } = useClipActions();
  const authStatus = useAtomValue(providerAuthStatusAtom);
  const menuRef = useRef<HTMLDivElement>(null);

  // Close on outside click
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen]);

  const activeProvider = activeProviderId ? getProviderConfig(activeProviderId) : null;

  // Filter out system provider
  const providers = useMemo(() => LLM_PROVIDERS_CONFIG.filter(p => p.id !== 'system'), []);

  return (
    <div className="relative" ref={menuRef}>
      <button
        type="button"
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-3 py-1.5 rounded-full bg-white/5 hover:bg-white/10 border border-white/10 transition-all text-sm font-medium text-text-primary"
      >
        <span className="text-base">🧩</span>
        <span className="opacity-70 text-xs uppercase tracking-wide">Mapper</span>
        <span className="w-px h-3 bg-white/20 mx-1" />
        <span className={clsx(!activeProvider && "text-text-muted italic")}>
          {activeProvider?.name || "Select Model"}
        </span>
        <svg
          className={clsx("w-3 h-3 text-text-muted transition-transform", isOpen && "rotate-180")}
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>

      {isOpen && (
        <div className="absolute top-full left-0 mt-2 w-64 bg-surface-raised border border-border-subtle rounded-xl shadow-elevated overflow-hidden z-[3600] animate-in fade-in slide-in-from-top-2 duration-200">
          <div className="p-2 grid gap-1">
            {providers.map(p => {
              const pid = String(p.id);
              const isUnauthorized = authStatus && authStatus[pid] === false;

              const isDisabled = isUnauthorized;

              return (
                <button key={pid} onClick={() => { if (!isDisabled) { handleClipClick(aiTurn.id, "mapping", pid); setIsOpen(false); } }} disabled={isDisabled} className={clsx("w-full flex items-center gap-3 px-3 py-2 rounded-lg text-left transition-colors", pid === activeProviderId ? "bg-brand-500/10 text-brand-500" : "hover:bg-surface-highlight text-text-secondary", isDisabled && "opacity-60 cursor-not-allowed")}>
                  <div className="w-2 h-2 rounded-full shadow-sm" style={{ backgroundColor: getProviderColor(pid) }} />
                  <span className="flex-1 text-xs font-medium">{p.name}</span>
                  {pid === activeProviderId && <span>✓</span>}
                  {isUnauthorized && <span>🔒</span>}
                </button>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
};

// FIXED: Added missing closing div in RefinerSelector structure
const RefinerSelector: React.FC<{ aiTurn: AiTurn, activeProviderId?: string, onSelect: (pid: string) => void }> = ({ aiTurn, activeProviderId, onSelect }) => {
  const [isOpen, setIsOpen] = useState(false);
  const { handleClipClick } = useClipActions();
  const authStatus = useAtomValue(providerAuthStatusAtom);
  const menuRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    if (isOpen) document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [isOpen]);

  const activeProvider = activeProviderId ? getProviderConfig(activeProviderId) : null;
  const providers = useMemo(() => LLM_PROVIDERS_CONFIG.filter(p => p.id !== 'system'), []);

  return (
    <div className="relative" ref={menuRef}>
      <button
        type="button"
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-3 py-1.5 rounded-full bg-white/5 hover:bg-white/10 border border-white/10 transition-all text-sm font-medium text-text-primary"
      >
        <span className="text-base">🔒</span>
        <span className="opacity-70 text-xs uppercase tracking-wide">Auditor</span>
        <span className="w-px h-3 bg-white/20 mx-1" />
        <span className={clsx(!activeProvider && "text-text-muted italic")}>
          {activeProvider?.name || "Select Model"}
        </span>
        <svg
          className={clsx("w-3 h-3 text-text-muted transition-transform", isOpen && "rotate-180")}
          fill="none" viewBox="0 0 24 24" stroke="currentColor"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>

      {isOpen && (
        <div className="absolute top-full left-0 mt-2 w-64 bg-surface-raised border border-border-subtle rounded-xl shadow-elevated overflow-hidden z-[3600] animate-in fade-in slide-in-from-top-2 duration-200">
          <div className="p-2 grid gap-1">
            {providers.map(p => {
              const pid = String(p.id);
              const isActive = pid === activeProviderId;
              const isUnauthorized = authStatus && authStatus[pid] === false;
              const latestResp = getLatestResponse(aiTurn.refinerResponses?.[pid]);
              const hasError = latestResp?.status === 'error';
              const errorMessage = hasError ? (latestResp?.meta?._rawError || "Failed") : null;
              const isDisabled = isUnauthorized;

              return (
                <button
                  key={pid}
                  onClick={() => { if (!isDisabled) { onSelect(pid); handleClipClick(aiTurn.id, "refiner", pid); setIsOpen(false); } }}
                  disabled={isDisabled}
                  className={clsx(
                    "w-full flex items-center gap-3 px-3 py-2 rounded-lg text-left transition-colors relative group",
                    isActive ? "bg-brand-500/10 text-brand-500" : "hover:bg-surface-highlight text-text-secondary",
                    (isDisabled || hasError) && "opacity-60",
                    isDisabled && "cursor-not-allowed",
                  )}
                  title={errorMessage && typeof errorMessage === 'string' ? errorMessage : undefined}
                >
                  <div
                    className="w-2 h-2 rounded-full shadow-sm"
                    style={{ backgroundColor: getProviderColor(pid) }}
                  />
                  <div className="flex-1 flex flex-col">
                    <span className="text-xs font-medium">{p.name}</span>
                  </div>
                  {hasError && (
                    <div className="absolute left-full ml-2 top-1/2 -translate-y-1/2 hidden group-hover:block z-50 w-48 bg-black/90 text-white text-[10px] p-2 rounded shadow-lg pointer-events-none">
                      {typeof errorMessage === 'string' ? errorMessage : "Previous generation failed"}
                    </div>
                  )}
                  {isActive && <span>✓</span>}
                  {isUnauthorized && <span>🔒</span>}
                </button>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
};

const AntagonistSelector: React.FC<{ aiTurn: AiTurn, activeProviderId?: string, onSelect: (pid: string) => void }> = ({ aiTurn, activeProviderId, onSelect }) => {
  const [isOpen, setIsOpen] = useState(false);
  const { handleClipClick } = useClipActions();
  const authStatus = useAtomValue(providerAuthStatusAtom);
  const menuRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    if (isOpen) document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [isOpen]);

  const activeProvider = activeProviderId ? getProviderConfig(activeProviderId) : null;
  const providers = useMemo(() => LLM_PROVIDERS_CONFIG.filter(p => p.id !== 'system'), []);

  return (
    <div className="relative" ref={menuRef}>
      <button
        type="button"
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-3 py-1.5 rounded-full bg-white/5 hover:bg-white/10 border border-white/10 transition-all text-sm font-medium text-text-primary"
      >
        <span className="text-base">🎭</span>
        <span className="opacity-70 text-xs uppercase tracking-wide">Antagonist</span>
        <span className="w-px h-3 bg-white/20 mx-1" />
        <span className={clsx(!activeProvider && "text-text-muted italic")}>
          {activeProvider?.name || "Select Model"}
        </span>
        <svg
          className={clsx("w-3 h-3 text-text-muted transition-transform", isOpen && "rotate-180")}
          fill="none" viewBox="0 0 24 24" stroke="currentColor"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>

      {isOpen && (
        <div className="absolute top-full left-0 mt-2 w-64 bg-surface-raised border border-border-subtle rounded-xl shadow-elevated overflow-hidden z-[3600] animate-in fade-in slide-in-from-top-2 duration-200">
          <div className="p-2 grid gap-1">
            {providers.map(p => {
              const pid = String(p.id);
              const isActive = pid === activeProviderId;
              const isUnauthorized = authStatus && authStatus[pid] === false;
              const latestResp = getLatestResponse(aiTurn.antagonistResponses?.[pid]);
              const hasError = latestResp?.status === 'error';
              const errorMessage = hasError ? (latestResp?.meta?._rawError || "Failed") : null;
              const isDisabled = isUnauthorized;

              return (
                <button
                  key={pid}
                  onClick={() => { if (!isDisabled) { onSelect(pid); handleClipClick(aiTurn.id, "antagonist", pid); setIsOpen(false); } }}
                  disabled={isDisabled}
                  className={clsx(
                    "w-full flex items-center gap-3 px-3 py-2 rounded-lg text-left transition-colors relative group",
                    isActive ? "bg-brand-500/10 text-brand-500" : "hover:bg-surface-highlight text-text-secondary",
                    (isDisabled || hasError) && "opacity-60",
                    isDisabled && "cursor-not-allowed",
                  )}
                  title={errorMessage && typeof errorMessage === 'string' ? errorMessage : undefined}
                >
                  <div
                    className="w-2 h-2 rounded-full shadow-sm"
                    style={{ backgroundColor: getProviderColor(pid) }}
                  />
                  <div className="flex-1 flex flex-col">
                    <span className="text-xs font-medium">{p.name}</span>
                  </div>
                  {hasError && (
                    <div className="absolute left-full ml-2 top-1/2 -translate-y-1/2 hidden group-hover:block z-50 w-48 bg-black/90 text-white text-[10px] p-2 rounded shadow-lg pointer-events-none">
                      {typeof errorMessage === 'string' ? errorMessage : "Previous generation failed"}
                    </div>
                  )}
                  {isActive && <span>✓</span>}
                  {isUnauthorized && <span>🔒</span>}
                </button>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
};

// ============================================================================
// MAIN COMPONENT
// ============================================================================

export const DecisionMapSheet = React.memo(() => {
  const [openState, setOpenState] = useAtom(isDecisionMapOpenAtom);
  const turnGetter = useAtomValue(turnByIdAtom);
  const mappingProvider = useAtomValue(mappingProviderAtom);
  const refinerProvider = useAtomValue(refinerProviderAtom);
  const antagonistProvider = useAtomValue(antagonistProviderAtom); // Added
  const setActiveSplitPanel = useSetAtom(activeSplitPanelAtom);

  const [activeTab, setActiveTab] = useState<'graph' | 'narrative' | 'options' | 'audit' | 'antagonist'>('graph');
  const [selectedNode, setSelectedNode] = useState<{ id: string; label: string; supporters: (string | number)[]; theme?: string } | null>(null);
  const containerRef = useRef<HTMLDivElement | null>(null);
  const [dims, setDims] = useState<{ w: number; h: number }>({ w: window.innerWidth, h: 400 });
  const [activeRefinerPid, setActiveRefinerPid] = useState<string | null>(null);
  const activeAntagonistPid = antagonistProvider; // Uses current atom value
  const [sheetHeightRatio, setSheetHeightRatio] = useState(0.5);
  const resizeRef = useRef<{ active: boolean; startY: number; startRatio: number; moved: boolean }>({
    active: false,
    startY: 0,
    startRatio: 0.5,
    moved: false,
  });

  // Reset to graph tab when sheet opens
  useEffect(() => {
    if (openState) {
      setActiveTab('graph');
      setSelectedNode(null);
      setSheetHeightRatio(0.5);
    }
  }, [openState?.turnId]);

  const handleResizePointerDown = useCallback((e: React.PointerEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    const min = 0.25;
    const max = 0.9;
    resizeRef.current = { active: true, startY: e.clientY, startRatio: sheetHeightRatio, moved: false };

    const onMove = (ev: PointerEvent) => {
      if (!resizeRef.current.active) return;
      const delta = resizeRef.current.startY - ev.clientY;
      if (Math.abs(delta) > 4) resizeRef.current.moved = true;
      const next = resizeRef.current.startRatio + delta / Math.max(1, window.innerHeight);
      const clamped = Math.min(max, Math.max(min, next));
      setSheetHeightRatio(clamped);
    };

    const onUp = () => {
      const moved = resizeRef.current.moved;
      resizeRef.current.active = false;
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onUp);
      if (!moved) setOpenState(null);
    };

    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
  }, [setOpenState, sheetHeightRatio]);

  // Measure container dimensions after render and on resize
  useEffect(() => {
    const update = () => {
      const el = containerRef.current;
      if (el) {
        setDims({ w: el.clientWidth, h: el.clientHeight });
      } else {
        setDims({ w: window.innerWidth, h: Math.floor(window.innerHeight * sheetHeightRatio) - 100 });
      }
    };

    // Initial update + delayed update after animation
    update();
    const raf = requestAnimationFrame(update);
    const timeout = setTimeout(update, 350); // After spring animation

    window.addEventListener('resize', update);
    return () => {
      window.removeEventListener('resize', update);
      cancelAnimationFrame(raf);
      clearTimeout(timeout);
    };
  }, [openState, sheetHeightRatio]);

  const aiTurn: AiTurn | null = useMemo(() => {
    const tid = openState?.turnId;
    const t = tid ? turnGetter(tid) : undefined;
    return t && (t as any).type === 'ai' ? (t as AiTurn) : null;
  }, [openState, turnGetter]);

  // If no refiner PID is active locally, try to find one from the turn data
  useEffect(() => {
    if (aiTurn && !activeRefinerPid) {
      if (refinerProvider) {
        setActiveRefinerPid(refinerProvider);
        return;
      }
      const keys = Object.keys(aiTurn.refinerResponses || {});
      if (keys.length > 0) setActiveRefinerPid(keys[keys.length - 1]);
    }
  }, [aiTurn, activeRefinerPid, refinerProvider]);

  const { output: refinerOutput, rawText: refinerRawText, providerId: currentRefinerPid } = useRefinerOutput(aiTurn?.id || null, activeRefinerPid);
  const { output: antagonistOutput } = useAntagonistOutput(aiTurn?.id || null, activeAntagonistPid);

  // Sync refiner selection
  useEffect(() => {
    if (currentRefinerPid && currentRefinerPid !== activeRefinerPid) {
      setActiveRefinerPid(currentRefinerPid);
    }
  }, [currentRefinerPid]);

  const mappingResponses = useMemo(() => {
    const out: Record<string, ProviderResponse[]> = {};
    LLM_PROVIDERS_CONFIG.forEach((p) => (out[String(p.id)] = []));
    if (!aiTurn) return out;
    const map = aiTurn.mappingResponses || {};
    Object.entries(map).forEach(([pid, resp]) => {
      out[pid] = normalizeResponseArray(resp);
    });
    return out;
  }, [aiTurn?.id, aiTurn?.mappingVersion]);

  const activeMappingPid = useMemo(() => {
    if (!aiTurn) return undefined;
    if (mappingProvider) return mappingProvider;
    if (aiTurn.meta?.mapper) return aiTurn.meta.mapper;
    const keys = Object.keys(aiTurn.mappingResponses || {});
    return keys.length > 0 ? keys[0] : undefined;
  }, [aiTurn, mappingProvider]);

  const latestMapping = useMemo(() => {
    if (!activeMappingPid) return undefined;
    return getLatestResponse(mappingResponses[activeMappingPid]);
  }, [activeMappingPid, mappingResponses]);

  const graphTopology = useMemo(() => {
    const fromMeta = latestMapping?.meta?.graphTopology || null;
    if (fromMeta) return fromMeta;
    const rawText = latestMapping?.text || null;
    // USE SHARED UTILS (Renamed call to match import)
    return extractGraphTopologyAndStrip(rawText || '').topology;
  }, [latestMapping]);

  const adapted = useMemo(() => adaptGraphTopology(graphTopology), [graphTopology]);

  const mappingText = useMemo(() => {
    const t = latestMapping?.text || '';
    // USE SHARED PARSER
    const { narrative } = parseMappingResponse(String(t));
    return narrative;
  }, [latestMapping]);

  const optionsText = useMemo(() => {
    let fromMeta = latestMapping?.meta?.allAvailableOptions || null;
    if (fromMeta) {
      // Use shared cleanup function to strip any trailing GRAPH_TOPOLOGY
      return cleanOptionsText(fromMeta);
    }
    const t = latestMapping?.text || '';
    // USE SHARED PARSER
    const { options } = parseMappingResponse(String(t));
    return options;
  }, [latestMapping]);

  const parsedThemes = useMemo(() => {
    const themes = parseOptionsIntoThemes(optionsText || '');

    // Merge in antagonist-found unlisted options from Antagonist Audit
    if (antagonistOutput?.the_audit?.missed?.length) {
      const missedOptions = antagonistOutput.the_audit.missed.map((item) => ({
        title: item.approach,
        description: `Source: ${item.source}`,
        citations: [item.source]
      }));

      themes.push({
        name: "🔍 Found by Context Audit",
        options: missedOptions
      });
    } else if (refinerOutput?.unlistedOptions?.length) {
      // Fallback to refiner (legacy) if antagonist not providing
      const refinerOptions = refinerOutput.unlistedOptions.map((opt: { title: string; description: string; source?: string }) => ({
        title: opt.title,
        description: opt.description,
        citations: opt.source ? [opt.source] : []
      }));

      themes.push({
        name: "🔍 Found by Epistemic Audit",
        options: refinerOptions
      });
    }

    return themes;
  }, [optionsText, refinerOutput, antagonistOutput]);

  // Extract citation source order from mapping metadata for correct citation-to-model mapping
  const citationSourceOrder = useMemo(() => {
    const metaOrder = latestMapping?.meta?.citationSourceOrder || null;
    if (metaOrder && typeof metaOrder === 'object') {
      return metaOrder as Record<string | number, string>;
    }
    // Fallback: build from active batch responses in order
    if (aiTurn) {
      const activeOrdered = LLM_PROVIDERS_CONFIG.map((p) => String(p.id)).filter((pid) => !!(aiTurn.batchResponses || {})[pid]);
      const order: Record<number, string> = {};
      activeOrdered.forEach((pid, idx) => {
        order[idx + 1] = pid;
      });
      return order;
    }
    return undefined;
  }, [latestMapping, aiTurn]);

  const handleCitationClick = useCallback((modelNumber: number | string) => {
    try {
      // If it's a string, it's a direct provider ID from Refiner unlisted options
      if (typeof modelNumber === 'string') {
        const targetId = normalizeProviderId(modelNumber.toLowerCase());
        setActiveSplitPanel({ turnId: aiTurn?.id || '', providerId: targetId });
        return;
      }

      const metaOrder = latestMapping?.meta?.citationSourceOrder || null;
      let providerId: string | undefined;
      if (metaOrder && typeof metaOrder === 'object') {
        providerId = metaOrder[modelNumber];
      }
      if (!providerId && aiTurn) {
        const activeOrdered = LLM_PROVIDERS_CONFIG.map((p) => String(p.id)).filter((pid) => !!(aiTurn.batchResponses || {})[pid]);
        providerId = activeOrdered[modelNumber - 1];
      }
      if (!providerId || !aiTurn) return;
      setActiveSplitPanel({ turnId: aiTurn.id, providerId });
    } catch { }
  }, [latestMapping, aiTurn, setActiveSplitPanel]);

  const handleNodeClick = useCallback((node: any) => {
    setSelectedNode({
      id: node.id,
      label: node.label,
      supporters: node.supporters || [],
      theme: node.theme
    });
  }, []);

  const handleDetailOrbClick = useCallback((providerId: string) => {
    if (!aiTurn) return;
    setActiveSplitPanel({ turnId: aiTurn.id, providerId });
  }, [aiTurn, setActiveSplitPanel]);

  const narrativeExcerpt = useMemo(() => {
    if (!selectedNode) return '';
    return extractNarrativeExcerpt(mappingText, selectedNode.label);
  }, [selectedNode, mappingText]);

  const markdownComponents = useMemo(() => ({
    a: ({ href, children, ...props }: any) => {
      if (href && href.startsWith("#cite-")) {
        const idStr = href.replace("#cite-", "");
        const num = parseInt(idStr, 10);
        return (
          <button
            type="button"
            className="citation-link"
            onClick={(e) => {
              e.preventDefault();
              e.stopPropagation();
              handleCitationClick(num);
            }}
            title={`View Source ${idStr}`}
          >
            [{children}]
          </button>
        );
      }
      return (
        <a href={href} {...props} target="_blank" rel="noopener noreferrer" className="text-brand-400 hover:text-brand-300 underline decoration-brand-400/30 hover:decoration-brand-400 transition-colors">
          {children}
        </a>
      );
    },
  }), [handleCitationClick]);

  const transformCitations = useCallback((text: string) => {
    if (!text) return "";
    let t = text;
    // Handle [[CITE:X]] format (including S for synthesizer)
    t = t.replace(/\[\[CITE:([\dS])\]\]/gi, "[↗$1](#cite-$1)");
    // Handle [1], [2, 3], [1, S] format citations
    t = t.replace(/\[([\dS](?:\s*,\s*[\dS])*)\](?!\()/gi, (_m, grp) => {
      const items = String(grp)
        .split(/\s*,\s*/)
        .map((n) => n.trim())
        .filter(Boolean);
      return " " + items.map((n) => `[↗${n}](#cite-${n})`).join(" ") + " ";
    });
    return t;
  }, []);

  const tabConfig = [
    { key: 'graph' as const, label: 'Graph', activeClass: 'decision-tab-active-graph' },
    { key: 'narrative' as const, label: 'Narrative', activeClass: 'decision-tab-active-narrative' },
    { key: 'options' as const, label: 'Options', activeClass: 'decision-tab-active-options' },
    { key: 'audit' as const, label: 'Epistemic Audit', activeClass: 'decision-tab-active-audit' },
    { key: 'antagonist' as const, label: 'Antagonist', activeClass: 'decision-tab-active-antagonist' }
  ];

  const sheetHeightPx = Math.max(260, Math.round(window.innerHeight * sheetHeightRatio));

  return (
    <AnimatePresence>
      {openState && (
        <LazyMotion features={domAnimation}>
          <m.div
            initial={{ y: "100%" }}
            animate={{ y: 0 }}
            exit={{ y: "100%" }}
            transition={{ type: "spring", damping: 25, stiffness: 300 }}
            className="fixed inset-x-0 bottom-0 decision-sheet-bg border-t border-border-strong shadow-elevated z-[3500] rounded-t-2xl flex flex-col pointer-events-auto"
            style={{ height: sheetHeightPx }}
          >
            {/* Drag handle */}
            <div className="h-8 flex items-center justify-center border-b border-white/10 hover:bg-white/5 transition-colors rounded-t-2xl relative z-10">
              <div className="flex-1 h-full cursor-ns-resize" onPointerDown={handleResizePointerDown} />
              <button type="button" className="h-full px-6 cursor-pointer flex items-center justify-center" onClick={() => setOpenState(null)}>
                <div className="w-12 h-1.5 bg-white/20 rounded-full" />
              </button>
              <div className="flex-1 h-full cursor-ns-resize" onPointerDown={handleResizePointerDown} />
            </div>

            {/* Header Row: Mapper Selector (Left) + Tabs (Center) */}
            <div className="flex items-center justify-between px-6 py-4 border-b border-white/10 relative z-20">

              {/* Left: Provider Selector (Mapper or Refiner based on tab) */}
              <div className="w-1/3 flex justify-start">
                {aiTurn && activeTab !== 'audit' && activeTab !== 'antagonist' && (
                  <MapperSelector
                    aiTurn={aiTurn}
                    activeProviderId={activeMappingPid}
                  />
                )}
                {aiTurn && activeTab === 'audit' && (
                  <RefinerSelector
                    aiTurn={aiTurn}
                    activeProviderId={activeRefinerPid || undefined}
                    onSelect={(pid) => {
                      setActiveRefinerPid(pid);
                    }}
                  />
                )}
                {aiTurn && activeTab === 'antagonist' && (
                  <AntagonistSelector
                    aiTurn={aiTurn}
                    activeProviderId={activeAntagonistPid || undefined}
                    onSelect={() => { }}
                  />
                )}
              </div>

              {/* Center: Tabs */}
              <div className="flex items-center justify-center gap-4">
                {tabConfig.map(({ key, label, activeClass }) => {
                  // Hide audit tab if no data (optional, but requested to always show)
                  // if (key === 'audit' && !refinerOutput) return null;
                  return (
                    <button
                      key={key}
                      type="button"
                      className={clsx(
                        "decision-tab-pill",
                        activeTab === key && activeClass
                      )}
                      onClick={() => {
                        setActiveTab(key);
                        if (key !== 'graph') setSelectedNode(null);
                      }}
                    >
                      {label}
                    </button>
                  );
                })}
              </div>

              {/* Right: Spacer/Close (keeps tabs centered) */}
              <div className="w-1/3 flex justify-end items-center gap-2">
                <CopyButton
                  text={formatDecisionMapForMd(
                    mappingText,
                    optionsText,
                    graphTopology
                  )}
                  label="Copy full decision map"
                  buttonText="Copy Map"
                  className="mr-2"
                />
                <button
                  onClick={() => setOpenState(null)}
                  className="p-2 text-text-muted hover:text-text-primary hover:bg-white/5 rounded-full transition-colors"
                >
                  <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              </div>
            </div>

            {/* Content */}
            <div className="flex-1 overflow-hidden relative z-10" onClick={(e) => e.stopPropagation()}>
              <AnimatePresence mode="wait">
                {activeTab === 'graph' && !selectedNode && (
                  <m.div
                    key="graph"
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    ref={containerRef}
                    className="w-full h-full relative"
                  >
                    {graphTopology && (
                      <div className="absolute top-4 right-4 z-50">
                        <CopyButton
                          text={formatGraphForMd(graphTopology)}
                          label="Copy graph as list"
                          variant="icon"
                        />
                      </div>
                    )}
                    <Suspense fallback={<div className="w-full h-full flex items-center justify-center opacity-50"><div className="w-8 h-8 rounded-full border-2 border-brand-500 border-t-transparent animate-spin" /></div>}>
                      <DecisionMapGraph
                        nodes={adapted.nodes}
                        edges={adapted.edges}
                        citationSourceOrder={citationSourceOrder}
                        width={dims.w}
                        height={dims.h}
                        onNodeClick={handleNodeClick}
                      />
                    </Suspense>
                  </m.div>
                )}

                {activeTab === 'graph' && selectedNode && (
                  <m.div
                    key="detail"
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    className="w-full h-full"
                  >
                    <DetailView
                      node={selectedNode}
                      narrativeExcerpt={narrativeExcerpt}
                      citationSourceOrder={citationSourceOrder}
                      onBack={() => setSelectedNode(null)}
                      onOrbClick={handleDetailOrbClick}
                    />
                  </m.div>
                )}

                {activeTab === 'narrative' && (
                  <m.div
                    key="narrative"
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    className="p-6 h-full overflow-y-auto relative"
                  >
                    {mappingText && (
                      <div className="absolute top-4 right-4 z-10">
                        <CopyButton
                          text={mappingText}
                          label="Copy narrative"
                          variant="icon"
                        />
                      </div>
                    )}
                    {mappingText ? (
                      <div className="narrative-prose">
                        <MarkdownDisplay content={transformCitations(mappingText)} components={markdownComponents} />
                      </div>
                    ) : (
                      <div className="text-text-muted text-sm text-center py-8">No narrative available.</div>
                    )}
                  </m.div>
                )}

                {activeTab === 'options' && (
                  <m.div
                    key="options"
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    className="h-full overflow-y-auto relative"
                  >
                    {optionsText && (
                      <div className="absolute top-4 right-4 z-10">
                        <CopyButton
                          text={optionsText}
                          label="Copy options"
                          variant="icon"
                        />
                      </div>
                    )}
                    <OptionsTab themes={parsedThemes} citationSourceOrder={citationSourceOrder} onCitationClick={handleCitationClick} />
                  </m.div>
                )}

                {activeTab === 'audit' && (
                  <m.div
                    key="audit"
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    className="h-full overflow-y-auto relative custom-scrollbar"
                  >
                    {refinerOutput ? (
                      <RefinerEpistemicAudit output={refinerOutput!} rawText={refinerRawText} />
                    ) : (
                      <div className="flex flex-col items-center justify-center h-full text-text-muted text-sm gap-2 opacity-60">
                        <span>🔒</span>
                        <span>No epistemic audit available. Run Refiner to generate.</span>
                      </div>
                    )}
                  </m.div>
                )}

                {activeTab === 'antagonist' && (
                  <m.div
                    key="antagonist"
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    className="h-full overflow-y-auto relative custom-scrollbar p-6"
                  >
                    {antagonistOutput ? (
                      <div className="max-w-4xl mx-auto space-y-8 animate-in fade-in duration-500">
                        {/* Critique Section */}
                        <div className="bg-surface border border-border-subtle rounded-2xl p-6 shadow-sm">
                          <div className="flex items-center gap-2 mb-4 text-brand-400 font-semibold uppercase tracking-wider text-xs">
                            <span>🎭</span>
                            <span>Critique & Refinement</span>
                          </div>

                          {antagonistOutput.the_prompt.grounding && (
                            <div className="text-text-secondary text-sm italic mb-4 border-l-2 border-brand-500/30 pl-4 py-1 bg-brand-500/5 rounded-r-lg">
                              {antagonistOutput.the_prompt.grounding}
                            </div>
                          )}

                          <div className="text-text-primary text-base leading-relaxed bg-surface-raised p-5 rounded-xl border border-border-subtle/50 mb-4">
                            <MarkdownDisplay content={antagonistOutput.the_prompt.text || "No prompt generated."} />
                          </div>

                          {antagonistOutput.the_prompt.payoff && (
                            <div className="flex items-start gap-2 text-brand-300 text-sm font-medium bg-brand-500/10 p-3 rounded-lg border border-brand-500/20">
                              <span className="text-lg mt-[-2px]">→</span>
                              <span>{antagonistOutput.the_prompt.payoff}</span>
                            </div>
                          )}
                        </div>

                        {/* Audit Section */}
                        {antagonistOutput.the_audit.missed.length > 0 && (
                          <div className="bg-surface-raised border border-border-subtle/60 rounded-2xl p-6">
                            <div className="flex items-center gap-2 mb-4 text-text-muted font-semibold uppercase tracking-wider text-xs">
                              <span className="text-brand-400">🔍</span>
                              <span>Missed Approaches & Blindspots</span>
                            </div>

                            <div className="grid gap-3">
                              {antagonistOutput.the_audit.missed.map((m, idx) => (
                                <div key={idx} className="flex flex-col gap-1 p-3 bg-surface border border-border-subtle/40 rounded-xl hover:border-brand-500/30 transition-colors">
                                  <div className="text-sm font-medium text-text-primary">{m.approach}</div>
                                  <div className="text-xs text-text-muted flex items-center gap-1.5">
                                    <span className="w-1 h-1 rounded-full bg-border-strong" />
                                    Source: {m.source}
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                      </div>
                    ) : (
                      <div className="flex flex-col items-center justify-center h-full text-text-muted text-sm gap-2 opacity-60">
                        <span>🎭</span>
                        <span>No Antagonist output available. Run Antagonist to generate.</span>
                      </div>
                    )}
                  </m.div>
                )}
              </AnimatePresence>
            </div>
          </m.div>
        </LazyMotion>
      )}
    </AnimatePresence>
  );
});



================================================
FILE: ui/components/DraftCard.tsx
================================================
import React, { useState, useRef, useEffect } from "react";
import { cn } from "../utils/cn";
import type { LaunchpadDraft } from "../types";
import { useAtom } from "jotai";
import { chatInputValueAtom } from "../state/atoms";

interface DraftCardProps {
    draft: LaunchpadDraft;
    index: number;
    onUpdate: (text: string) => void;
    onDelete: () => void;
    onSend: () => void;
    onSendToComposer: () => void;
    onSendToAnalyst: () => void;
    onReorder: (fromIndex: number, toIndex: number) => void;
}

export const DraftCard: React.FC<DraftCardProps> = ({
    draft,
    index,
    onUpdate,
    onDelete,
    onSend,
    onSendToComposer,
    onSendToAnalyst,
    onReorder,
}) => {
    const [chatInputValue, setChatInputValue] = useAtom(chatInputValueAtom);
    const [isEditing, setIsEditing] = useState(false);
    const [text, setText] = useState(draft.text);
    const [isDragging, setIsDragging] = useState(false);
    const [openSections, setOpenSections] = useState<Record<string, boolean>>({});
    const cardRef = useRef<HTMLDivElement>(null);
    const textareaRef = useRef<HTMLTextAreaElement>(null);

    // Auto-resize textarea
    useEffect(() => {
        if (isEditing && textareaRef.current) {
            textareaRef.current.style.height = "auto";
            textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`;
        }
    }, [isEditing, text]);

    const handleDragStart = (e: React.DragEvent) => {
        setIsDragging(true);
        e.dataTransfer.effectAllowed = "move";
        // Store only the index as plain text
        e.dataTransfer.setData("application/x-draft-index", index.toString());
    };

    const handleDragEnd = () => {
        setIsDragging(false);
    };

    const handleDragOver = (e: React.DragEvent) => {
        if (e.cancelable) e.preventDefault(); // Necessary to allow dropping, but check cancelable for safety
        e.dataTransfer.dropEffect = "move";
    };

    const handleDrop = (e: React.DragEvent) => {
        if (e.cancelable) e.preventDefault();
        const fromIndexStr = e.dataTransfer.getData("application/x-draft-index");
        if (fromIndexStr) {
            const fromIndex = parseInt(fromIndexStr, 10);
            if (!isNaN(fromIndex) && fromIndex !== index) {
                onReorder(fromIndex, index);
            }
        }
    };

    const extractToInput = (content: string) => {
        setChatInputValue(content);
    };

    const mainText = (() => {
        const d: any = draft as any;
        if (Array.isArray(d.sections) && d.sections.length > 0) {
            const primaryId = d.primarySectionId || d.sections[0]?.id;
            const primary = d.sections.find((s: any) => s.id === primaryId) || d.sections[0];
            return primary?.text || draft.text;
        }
        return draft.text;
    })();

    const allText = (() => {
        const d: any = draft as any;
        if (Array.isArray(d.sections) && d.sections.length > 0) {
            return d.sections.map((s: any) => `${s.title}\n\n${s.text}`).join("\n\n\n");
        }
        return draft.text;
    })();

    const handleBlur = () => {
        setIsEditing(false);
        if (text !== draft.text) {
            onUpdate(text);
        }
    };

    const getSourceColor = (source: LaunchpadDraft["source"]) => {
        switch (source) {
            case "composer":
                return "text-brand-400 border-brand-500/30 bg-brand-500/5";
            case "analyst-audit":
                return "text-intent-warning border-intent-warning/30 bg-intent-warning/5";
            case "analyst-variant":
                return "text-text-secondary border-border-subtle bg-surface-base";
            default:
                return "text-text-muted border-border-subtle";
        }
    };

    // Swipe to delete logic
    // Simple implementation: if user drags mostly horizontally > threshold
    const [swipeOffset, setSwipeOffset] = useState(0);
    const touchStartX = useRef<number | null>(null);

    const handleTouchStart = (e: React.TouchEvent | React.MouseEvent) => {
        // Only if not editing
        if (isEditing) return;
        const x = "touches" in e ? e.touches[0].clientX : e.clientX;
        touchStartX.current = x;
    };

    const handleTouchMove = (e: React.TouchEvent | React.MouseEvent) => {
        if (touchStartX.current === null || isEditing) return;
        const x = "touches" in e ? e.touches[0].clientX : e.clientX;
        const diff = x - touchStartX.current;

        // Only allow swiping left (negative diff)
        if (diff < 0) {
            setSwipeOffset(diff);
        }
    };

    const handleTouchEnd = () => {
        if (swipeOffset < -150) {
            // Swiped far enough to delete
            onDelete();
        }
        setSwipeOffset(0);
        touchStartX.current = null;
    };

    return (
        <div
            ref={cardRef}
            className={cn(
                "relative transition-all duration-200 group mb-3 select-none",
                isDragging && "opacity-40 scale-95",
                swipeOffset < 0 && "cursor-grabbing"
            )}
            // Drag & drop: only enable drop targets on the card; dragging starts from the grip only.
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            // Swipe handlers attached to container
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
            style={{ transform: `translateX(${swipeOffset}px)` }}
        >
            {/* Background delete indicator (revealed on swipe) */}
            <div
                className="absolute inset-y-0 right-[-100px] w-[100px] bg-intent-danger/20 flex items-center justify-center rounded-r-lg opacity-0 transition-opacity"
                style={{ opacity: swipeOffset < -50 ? 1 : 0 }}
            >
                <span className="text-intent-danger font-bold">Delete</span>
            </div>

            <div className={cn(
                "p-4 rounded-xl border backdrop-blur-sm transition-colors",
                getSourceColor(draft.source),
                "hover:border-opacity-50 hover:shadow-lg"
            )}>

                {/* Header: Grip + Title + Extract buttons */}
                <div className="flex items-center gap-3 mb-2">
                    <div
                        className="cursor-grab active:cursor-grabbing text-border-subtle hover:text-text-secondary p-1 -ml-1"
                        draggable={!isEditing}
                        onDragStart={handleDragStart}
                        onDragEnd={handleDragEnd}
                    >
                        {/* 6-dots grip icon */}
                        <svg width="12" height="20" viewBox="0 0 12 20" fill="currentColor">
                            <circle cx="3" cy="4" r="1.5" />
                            <circle cx="9" cy="4" r="1.5" />
                            <circle cx="3" cy="10" r="1.5" />
                            <circle cx="9" cy="10" r="1.5" />
                            <circle cx="3" cy="16" r="1.5" />
                            <circle cx="9" cy="16" r="1.5" />
                        </svg>
                    </div>
                    <h3 className="text-xs font-bold uppercase tracking-wider opacity-90 flex-1 truncate">
                        {draft.title}
                    </h3>
                    <div className="flex items-center gap-2 ml-auto">
                        <button
                            onClick={(e) => { e.stopPropagation(); extractToInput(mainText + "\n\n" + chatInputValue); }}
                            className="px-2 py-1 text-[10px] bg-chip-soft hover:bg-surface-highlight border border-border-subtle rounded-md text-text-secondary"
                            title="Extract main to input"
                        >
                            Extract main â†’
                        </button>
                        <button
                            onClick={(e) => { e.stopPropagation(); extractToInput(allText + "\n\n" + chatInputValue); }}
                            className="px-2 py-1 text-[10px] bg-chip-soft hover:bg-surface-highlight border border-border-subtle rounded-md text-text-secondary"
                            title="Extract all to input"
                        >
                            Extract all â†’
                        </button>
                        <div className="text-[10px] text-text-muted opacity-50">
                            {new Date(draft.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                        </div>
                    </div>
                </div>

                {/* Content Body */}
                {Array.isArray((draft as any).sections) && (draft as any).sections.length > 0 ? (
                    <div className="flex flex-col gap-3">
                        {/* Primary section first if provided */}
                        {(() => {
                            const d: any = draft as any;
                            const sections = d.sections as Array<{ id: string; title: string; text: string }>;
                            const primaryId: string | undefined = d.primarySectionId;
                            const ordered = primaryId ? [
                                ...sections.filter(s => s.id === primaryId),
                                ...sections.filter(s => s.id !== primaryId)
                            ] : sections;
                            return ordered.map((sec) => (
                                <div key={sec.id} className="rounded-lg border border-border-subtle/60 bg-surface">
                                    <button
                                        className="w-full flex items-center justify-between px-3 py-2 text-left"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            setOpenSections((prev) => ({ ...prev, [sec.id]: !prev[sec.id] }));
                                        }}
                                    >
                                        <div className="text-xs font-semibold text-text-secondary uppercase tracking-wider flex items-center gap-1">
                                            <span className={`transition-transform ${openSections[sec.id] !== false ? '' : '-rotate-90'}`}>â–¸</span>
                                            {sec.title}
                                        </div>
                                        <button
                                            onClick={(e) => { e.stopPropagation(); extractToInput(sec.text + "\n\n" + chatInputValue); }}
                                            className="px-2 py-1 text-xs bg-chip-soft hover:bg-surface-highlight border border-border-subtle rounded-md text-text-secondary"
                                            title="Extract this section to input"
                                        >
                                            Extract â†’
                                        </button>
                                    </button>
                                    {openSections[sec.id] !== false && (
                                        <div className="px-3 pb-3 text-sm text-text-primary whitespace-pre-wrap leading-relaxed max-h-64 overflow-y-auto">
                                            {sec.text}
                                        </div>
                                    )}
                                </div>
                            ));
                        })()}
                    </div>
                ) : (
                    <div
                        className="min-h-[60px] cursor-text"
                        onClick={() => setIsEditing(true)}
                    >
                        {isEditing ? (
                            <textarea
                                ref={textareaRef}
                                value={text}
                                onChange={(e) => setText(e.target.value)}
                                onBlur={handleBlur}
                                className="w-full bg-transparent text-sm text-text-primary resize-none outline-none leading-relaxed max-h-64 overflow-y-auto"
                                autoFocus
                            />
                        ) : (
                            <div className="text-sm text-text-primary leading-relaxed whitespace-pre-wrap opacity-90 max-h-64 overflow-y-auto">
                                {text}
                            </div>
                        )}
                    </div>
                )}

                {/* Action Bar */}
                <div className="flex items-center gap-2 mt-4 pt-3 border-t border-border-subtle/30 opacity-80 group-hover:opacity-100 transition-opacity">
                    <button
                        onClick={(e) => { e.stopPropagation(); extractToInput(mainText + "\n\n" + chatInputValue); }}
                        className="px-3 py-1.5 bg-chip-soft hover:bg-surface-highlight text-text-secondary border border-border-subtle rounded-lg text-xs transition-colors flex items-center gap-1.5"
                        title="Extract main to input"
                    >
                        <span>â†’</span>
                        <span>Extract</span>
                    </button>

                    <button
                        onClick={(e) => { e.stopPropagation(); onSend(); }}
                        className="flex-1 px-3 py-1.5 bg-brand-500/20 hover:bg-brand-500/30 text-brand-400 text-xs font-bold rounded-lg transition-colors flex items-center justify-center gap-1.5"
                    >
                        <span>Run This</span>
                    </button>

                    <div className="w-[1px] h-4 bg-border-subtle/50 mx-1" />

                    <button
                        onClick={(e) => { e.stopPropagation(); onSendToComposer(); }}
                        className="px-2 py-1.5 text-text-secondary hover:text-brand-400 hover:bg-surface-elevated rounded-md text-xs transition-colors"
                        title="Send to Composer"
                    >
                        â†’ Comp
                    </button>
                    <button
                        onClick={(e) => { e.stopPropagation(); onSendToAnalyst(); }}
                        className="px-2 py-1.5 text-text-secondary hover:text-intent-warning hover:bg-surface-elevated rounded-md text-xs transition-colors"
                        title="Send to Analyst"
                    >
                        â†’ Anal
                    </button>
                </div>
            </div>
        </div>
    );
};



================================================
FILE: ui/components/ErrorBoundary.tsx
================================================
import React, { Component, ReactNode } from "react";

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("[ErrorBoundary] Caught error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="flex flex-col items-center justify-center h-full p-10 text-center bg-app-gradient text-text-primary">
          <div className="bg-intent-danger/10 border border-intent-danger/40 rounded-2xl p-8 max-w-[600px]">
            <div className="text-5xl mb-4">⚠️</div>
            <h2 className="text-2xl mb-3 text-intent-danger">
              Something went wrong
            </h2>
            <p className="text-sm text-text-muted mb-6">
              {this.state.error?.message || "An unexpected error occurred"}
            </p>
            <button
              onClick={() => {
                this.setState({ hasError: false, error: null });
                window.location.reload();
              }}
              className="px-6 py-3 bg-brand-500 hover:bg-brand-400
                         border border-brand-500 rounded-lg
                         text-white text-sm font-semibold
                         cursor-pointer transition-all duration-200"
            >
              Reload App
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;



================================================
FILE: ui/components/Header.tsx
================================================
import { useAtom, useSetAtom } from "jotai";
import { isHistoryPanelOpenAtom, isSettingsOpenAtom } from "../state/atoms";
import logoIcon from "../assets/logos/logo-icon.png";

// MenuIcon component (inline for simplicity)
const MenuIcon = ({ className }: { className?: string }) => (
  <svg
    className={className}
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <line x1="3" y1="12" x2="21" y2="12"></line>
    <line x1="3" y1="6" x2="21" y2="6"></line>
    <line x1="3" y1="18" x2="21" y2="18"></line>
  </svg>
);

export default function Header() {
  const [isHistoryPanelOpen, setIsHistoryPanelOpen] = useAtom(
    isHistoryPanelOpenAtom,
  );
  const setIsSettingsOpen = useSetAtom(isSettingsOpenAtom);

  return (
    <header className="flex items-center justify-between px-4 py-2.5 bg-header-gradient backdrop-blur-lg border-b border-border-subtle shrink-0 text-text-secondary">
      <div className="flex items-center gap-3">
        <button
          onClick={() => setIsHistoryPanelOpen(!isHistoryPanelOpen)}
          className="bg-transparent border-0 text-text-secondary cursor-pointer p-1 hover:text-text-primary transition-colors"
          aria-label="Toggle History Panel"
        >
          <MenuIcon className="w-6 h-6" />
        </button>
        <div className="flex items-center gap-2">
          {/* Orb Icon */}
          <img
            src={logoIcon}
            alt=""
            className="w-5 h-5"
          />
          {/* Wordmark - ALWAYS VISIBLE */}
          <span className="font-semibold text-base tracking-wide">
            <span className="text-text-primary">SINGULAR</span>
            <span className="text-brand-400">ITY</span>
          </span>
        </div>
      </div>
      <div className="flex gap-2">
        <button
          className="px-3 py-2 bg-surface-highlight border border-border-strong rounded-lg text-text-secondary cursor-pointer transition-all duration-200 hover:bg-surface-raised"
          onClick={() => setIsSettingsOpen(true)}
        >
          ⚙️ Models
        </button>
      </div>
    </header >
  );
}


================================================
FILE: ui/components/HistoryPanel.tsx
================================================
import React, { useCallback, useMemo, useState, Suspense, useEffect } from "react";
import { createPortal } from "react-dom";
import { Virtuoso } from "react-virtuoso";
import { useAtomValue, useSetAtom } from "jotai";
import {
  historySessionsAtom,
  isHistoryLoadingAtom,
  isHistoryPanelOpenAtom,
  currentSessionIdAtom,
  toastAtom
} from "../state/atoms";
import { useChat } from "../hooks/chat/useChat";
import api from "../services/extension-api";
import { normalizeBackendRoundsToTurns } from "../utils/turn-helpers";
import { formatSessionForMarkdown, sanitizeSessionForExport } from "../utils/copy-format-utils";
import logoIcon from "../assets/logos/logo-icon.png";
import { PlusIcon, TrashIcon, EllipsisHorizontalIcon, ChevronRightIcon } from "./Icons";
import { HistorySessionSummary } from "../types";

type SessionRowProps = {
  session: HistorySessionSummary;
  isActive: boolean;
  isBatchMode: boolean;
  isSelected: boolean;
  isDeleting: boolean;
  showMenu: boolean;
  onRowClick: (session: HistorySessionSummary) => void;
  onToggleSelected: (sessionId: string) => void;
  onMenuClick: (
    e: React.MouseEvent<HTMLButtonElement>,
    sessionId: string,
  ) => void;
};

const SessionRow = React.memo(function SessionRow({
  session,
  isActive,
  isBatchMode,
  isSelected,
  isDeleting,
  showMenu,
  onRowClick,
  onToggleSelected,
  onMenuClick,
}: SessionRowProps) {
  const sessionId = session.sessionId || session.id;

  return (
    <div
      className={`
                    group relative rounded-lg border transition-all duration-200 cursor-pointer
                    ${isActive
          ? "bg-surface-highlight border-primary-500/50 shadow-sm"
          : "bg-surface-raised border-transparent hover:border-border-subtle"
        }
                    ${isDeleting ? "opacity-50 pointer-events-none" : ""}
                  `}
      onClick={() => onRowClick(session)}
    >
      <div className="p-3">
        <div className="flex justify-between items-start gap-2">
          <div className="flex items-center gap-2 flex-1 min-w-0">
            {isBatchMode && (
              <input
                type="checkbox"
                checked={isSelected}
                onChange={(e) => {
                  e.stopPropagation();
                  onToggleSelected(sessionId);
                }}
                className="flex-shrink-0 accent-brand-500"
              />
            )}
            <div className="flex-1 min-w-0">
              <div className="flex items-center gap-2 text-xs text-text-muted mb-1">
                <span>
                  {new Date(
                    session.lastActivity || session.startTime,
                  ).toLocaleDateString()}
                </span>
                {session.messageCount > 0 && (
                  <span className="bg-surface-highlight px-1.5 py-0.5 rounded-full text-[10px]">
                    {session.messageCount} msg
                  </span>
                )}
              </div>
              <span className="overflow-wrap-anywhere break-words whitespace-normal text-sm font-medium text-text-primary block leading-tight">
                {session.title || "Untitled Chat"}
              </span>
            </div>
          </div>

          {showMenu && (
            <div className="relative ml-1 -mr-1">
              <button
                className="p-1 rounded-md hover:bg-surface-base text-text-secondary transition-colors opacity-0 group-hover:opacity-100 focus:opacity-100"
                onClick={(e) => onMenuClick(e, sessionId)}
              >
                <EllipsisHorizontalIcon className="w-5 h-5" />
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
});

const RenameDialog = React.lazy(() => import("./RenameDialog"));

export default function HistoryPanel() {
  // Connected State
  const sessions = useAtomValue(historySessionsAtom);
  const isLoading = useAtomValue(isHistoryLoadingAtom);
  const isOpen = useAtomValue(isHistoryPanelOpenAtom);
  const currentSessionId = useAtomValue(currentSessionIdAtom);
  const setHistorySessions = useSetAtom(historySessionsAtom);
  const setIsHistoryPanelOpen = useSetAtom(isHistoryPanelOpenAtom);
  const setToast = useSetAtom(toastAtom);
  const { newChat, selectChat, deleteChat, deleteChats } = useChat();

  // Local State
  const [deletingIds, setDeletingIds] = useState<Set<string>>(new Set());
  const [isBatchMode, setIsBatchMode] = useState(false);
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [renameSessionId, setRenameSessionId] = useState<string | null>(null);
  const [renameDefaultTitle, setRenameDefaultTitle] = useState<string>("");
  const [isRenaming, setIsRenaming] = useState<boolean>(false);
  /* New State for Menus */
  const [activeMenu, setActiveMenu] = useState<{ id: string; top: number; left: number; align: 'top' | 'bottom' } | null>(null);
  const [searchTerm, setSearchTerm] = useState("");

  /* New State for Submenu Position */
  const [exportSubmenuPos, setExportSubmenuPos] = useState<{ top: number; left: number; sessionId: string; align: 'top' | 'bottom' } | null>(null);

  const submenuTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  const submenuRef = React.useRef<HTMLDivElement>(null);
  const menuRef = React.useRef<HTMLDivElement>(null); // For main menu

  const handleSubmenuEnter = (sessionId: string, rect: DOMRect) => {
    if (submenuTimeoutRef.current) {
      clearTimeout(submenuTimeoutRef.current);
      submenuTimeoutRef.current = null;
    }

    // Check vertical space for submenu (approx height ~150px)
    const spaceBelow = window.innerHeight - rect.bottom;
    const submenuHeight = 150;
    const align = spaceBelow < submenuHeight ? 'top' : 'bottom';

    // Calculate top position
    let top = rect.top;
    if (align === 'top') {
      // Shift up by height of submenu
      // +10 fudge factor ensures overlap so mouse doesn't disconnect on transition
      top = rect.bottom - submenuHeight + 10;
    }

    setExportSubmenuPos({
      sessionId,
      top, // <--- CHANGE THIS: Use the variable you calculated above
      left: rect.right,
      align
    });
  };

  const handleSubmenuLeave = () => {
    submenuTimeoutRef.current = setTimeout(() => {
      setExportSubmenuPos(null);
    }, 150); // 150ms grace period
  };

  // Ensure cleanup on unmount
  useEffect(() => {
    return () => {
      if (submenuTimeoutRef.current) clearTimeout(submenuTimeoutRef.current);
    };
  }, []);

  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      const target = e.target as Node;
      // Don't close if clicking inside the export submenu or main menu
      if (submenuRef.current?.contains(target) || menuRef.current?.contains(target)) {
        return;
      }
      setActiveMenu(null);
      setExportSubmenuPos(null);
    };
    window.addEventListener("mousedown", handleClickOutside); // Mousedown is better for immediate closure
    return () => window.removeEventListener("mousedown", handleClickOutside);
  }, []);

  // Derived State
  const filteredSessions = useMemo(() => {
    const base = !searchTerm
      ? sessions
      : sessions.filter((s) => s.title?.toLowerCase().includes(searchTerm.toLowerCase()));

    return [...base].sort(
      (a, b) => (b.lastActivity || 0) - (a.lastActivity || 0),
    );
  }, [sessions, searchTerm]);

  // Handlers
  const handleNewChat = useCallback(() => {
    newChat();
    setIsHistoryPanelOpen(false);
  }, [newChat, setIsHistoryPanelOpen]);

  const handleSelectSession = useCallback((session: HistorySessionSummary) => {
    selectChat(session);
    setIsHistoryPanelOpen(false);
  }, [selectChat, setIsHistoryPanelOpen]);

  const handleDeleteChat = async (sessionId: string) => {
    // Track pending deletion
    setDeletingIds((prev) => {
      const next = new Set(prev);
      next.add(sessionId);
      return next;
    });

    // Optimistically remove from panel
    const prevSessions = sessions;
    setHistorySessions((draft: any) =>
      draft.filter((s: any) => (s.sessionId || s.id) !== sessionId),
    );

    const ok = await deleteChat(sessionId);

    // Revalidate against backend to prevent flicker-and-revert when SW response is delayed
    try {
      const response = await api.getHistoryList();
      const refreshed = (response?.sessions || []).map((s: any) => ({
        id: s.sessionId,
        sessionId: s.sessionId,
        title: s.title || "Untitled",
        startTime: s.startTime || Date.now(),
        lastActivity: s.lastActivity || Date.now(),
        messageCount: s.messageCount || 0,
        firstMessage: s.firstMessage || "",
        messages: [],
      }));

      setHistorySessions(refreshed as any);

      const stillExists = refreshed.some(
        (s: any) => (s.sessionId || s.id) === sessionId,
      );
      // If the deleted session was active, clear the chat view immediately
      if (!stillExists && currentSessionId === sessionId) {
        newChat();
      }
    } catch (e) {
      console.error(
        "[HistoryPanel] Failed to refresh history after deletion:",
        e,
      );
      if (!ok) {
        // If the delete call failed and we also failed to refresh, revert UI to previous list
        setHistorySessions(prevSessions as any);
      }
    }

    // Clear pending state
    setDeletingIds((prev) => {
      const next = new Set(prev);
      next.delete(sessionId);
      return next;
    });
  };

  const handleToggleBatchMode = useCallback(() => {
    setIsBatchMode((prev) => !prev);
    setSelectedIds(new Set());
  }, []);

  const handleToggleSelected = useCallback((sessionId: string) => {
    setSelectedIds((prev) => {
      const next = new Set(prev);
      if (next.has(sessionId)) next.delete(sessionId);
      else next.add(sessionId);
      return next;
    });
  }, []);

  const handleSessionRowClick = useCallback(
    (session: HistorySessionSummary) => {
      const sessionId = session.sessionId || session.id;
      const isDeleting = !!deletingIds && deletingIds.has(sessionId);
      if (isDeleting) return;

      if (isBatchMode) {
        handleToggleSelected(sessionId);
      } else {
        handleSelectSession(session);
      }
    },
    [deletingIds, handleSelectSession, handleToggleSelected, isBatchMode],
  );

  const handleSessionMenuClick = useCallback(
    (e: React.MouseEvent<HTMLButtonElement>, sessionId: string) => {
      e.stopPropagation();

      const rect = e.currentTarget.getBoundingClientRect();
      const spaceBelow = window.innerHeight - rect.bottom;
      const menuHeight = 120;
      const align = spaceBelow < menuHeight ? "top" : "bottom";

      setActiveMenu((prev) => {
        if (prev && prev.id === sessionId) return null;
        return {
          id: sessionId,
          left: rect.right - 130,
          top: align === "bottom" ? rect.bottom : rect.top,
          align,
        };
      });
    },
    [],
  );

  const handleConfirmBatchDelete = async () => {
    const ids = Array.from(selectedIds);
    if (ids.length === 0) {
      // If nothing selected, just exit batch mode
      setIsBatchMode(false);
      return;
    }

    // Optimistically remove selected sessions
    const prevSessions = sessions;
    setHistorySessions((draft: any) =>
      draft.filter((s: any) => !ids.includes(s.sessionId || s.id)),
    );

    try {
      await deleteChats(ids);
      // Revalidate list with backend
      const response = await api.getHistoryList();
      const refreshed = (response?.sessions || []).map((s: any) => ({
        id: s.sessionId,
        sessionId: s.sessionId,
        title: s.title || "Untitled",
        startTime: s.startTime || Date.now(),
        lastActivity: s.lastActivity || Date.now(),
        messageCount: s.messageCount || 0,
        firstMessage: s.firstMessage || "",
        messages: [],
      }));
      setHistorySessions(refreshed as any);
    } catch (e) {
      console.error("[HistoryPanel] Batch delete failed:", e);
      // revert UI list on failure
      setHistorySessions(prevSessions as any);
    } finally {
      setIsBatchMode(false);
      setSelectedIds(new Set());
    }
  };

  const openRenameDialog = (sessionId: string, currentTitle: string) => {
    setRenameSessionId(sessionId);
    setRenameDefaultTitle(currentTitle || "Untitled");
  };

  const closeRenameDialog = () => {
    if (isRenaming) return; // prevent closing during active rename to avoid accidental state issues
    setRenameSessionId(null);
    setRenameDefaultTitle("");
  };

  const handleRenameChat = async (newTitle: string) => {
    const sessionId = renameSessionId;
    if (!sessionId) return;
    setIsRenaming(true);

    // Optimistically update local history list
    const prevSessions = sessions;
    setHistorySessions((draft: any) =>
      draft.map((s: any) => {
        const id = s.sessionId || s.id;
        if (id === sessionId) {
          return { ...s, title: newTitle };
        }
        return s;
      }),
    );

    try {
      const res = await api.renameSession(sessionId, newTitle);

      if (!res?.updated) {
        throw new Error("Rename failed");
      }
      // Revalidate with backend list to ensure consistency
      try {
        const response = await api.getHistoryList();
        const refreshed = (response?.sessions || []).map((s: any) => ({
          id: s.sessionId,
          sessionId: s.sessionId,
          title: s.title || "Untitled",
          startTime: s.startTime || Date.now(),
          lastActivity: s.lastActivity || Date.now(),
          messageCount: s.messageCount || 0,
          firstMessage: s.firstMessage || "",
          messages: [],
        }));
        setHistorySessions(refreshed as any);
      } catch (e) {
        console.warn(
          "[HistoryPanel] Failed to refresh after rename, keeping optimistic title:",
          e,
        );
      }
      closeRenameDialog();
    } catch (e) {
      console.error("[HistoryPanel] Rename failed:", e);
      // revert optimistic update
      setHistorySessions(prevSessions as any);
    } finally {
      setIsRenaming(false);
    }
  };

  const handleExportChat = async (sessionId: string, format: 'json-safe' | 'json-full' | 'markdown') => {
    try {
      const sessionPayload = await api.getSession(sessionId);
      if (!sessionPayload) throw new Error("Could not fetch session data");

      // Normalize the raw backend rounds to proper TurnMessage[]
      const normalizedTurns = normalizeBackendRoundsToTurns(sessionPayload.turns || [], sessionId);
      const normalizedSession = {
        ...sessionPayload,
        turns: normalizedTurns
      };

      let blob: Blob;
      let filename: string;

      if (format === 'markdown') {
        const markdown = formatSessionForMarkdown(normalizedSession);
        blob = new Blob([markdown], { type: "text/markdown" });
        filename = `singularity_export_${(normalizedSession.title || "session").replace(/[^a-z0-9]/gi, '_').toLowerCase()}.md`;
      } else {
        const mode = format === 'json-full' ? 'full' : 'safe';
        const exportData = sanitizeSessionForExport(normalizedSession, mode);
        const jsonString = JSON.stringify(exportData, null, 2);
        blob = new Blob([jsonString], { type: "application/json" });

        const safeTitle = (exportData.session.title || "session").replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const suffix = format === 'json-full' ? '_backup' : '';
        filename = `singularity_export_${safeTitle}${suffix}_${exportData.exportedAt}.json`;
      }


      // Use a timeout to ensure the DOM update happens and separate from the sync stack if needed
      setTimeout(() => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        link.style.display = 'none';

        document.body.appendChild(link);
        link.click();

        // Delay cleanup to ensure download starts
        setTimeout(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }, 1000);
      }, 0);

      setToast({ id: Date.now(), message: "Export started...", type: "success" });
    } catch (error) {
      console.error("Export failed:", error);
      setToast({ id: Date.now(), message: "Failed to export session", type: "error" });
    }
  };

  if (!isOpen) return null;

  return (
    <>
      <div
        className="fixed inset-0 bg-black/50 z-40"
        onClick={(e) => {
          // Don't close if clicking submenu or main menu (already handled by mousedown, but for safety)
          if (submenuRef.current?.contains(e.target as Node) || menuRef.current?.contains(e.target as Node)) {
            return;
          }
          setIsHistoryPanelOpen(false);
        }}
      />

      {/* Portal for Export Submenu */}
      {exportSubmenuPos && createPortal(
        <div
          ref={submenuRef}
          className="fixed z-[10000] w-48 bg-surface-raised border border-border-subtle rounded-lg shadow-xl flex flex-col py-1"
          style={{
            top: exportSubmenuPos.top,
            left: exportSubmenuPos.left,
            pointerEvents: 'auto',
          }}
          onMouseEnter={() => {
            if (submenuTimeoutRef.current) {
              clearTimeout(submenuTimeoutRef.current);
              submenuTimeoutRef.current = null;
            }
          }}
          onMouseLeave={handleSubmenuLeave}
          onClick={(e) => {
            e.stopPropagation();
          }}
        >
          <button
            type="button"
            className="text-left px-3 py-2 text-sm hover:bg-surface-highlight text-text-primary transition-colors"
            onMouseDown={(e) => {
              e.preventDefault();
              e.stopPropagation();
              const sessionId = exportSubmenuPos.sessionId;
              setActiveMenu(null);
              setExportSubmenuPos(null);
              handleExportChat(sessionId, 'json-safe');
            }}
          >
            JSON (Safe)
          </button>
          <button
            type="button"
            className="text-left px-3 py-2 text-sm hover:bg-surface-highlight text-text-primary transition-colors"
            onMouseDown={(e) => {
              e.preventDefault();
              e.stopPropagation();
              const sessionId = exportSubmenuPos.sessionId;
              setActiveMenu(null);
              setExportSubmenuPos(null);
              handleExportChat(sessionId, 'json-full');
            }}
          >
            JSON (Full Backup)
          </button>
          <button
            type="button"
            className="text-left px-3 py-2 text-sm hover:bg-surface-highlight text-text-primary transition-colors"
            onMouseDown={(e) => {
              e.preventDefault();
              e.stopPropagation();
              const sessionId = exportSubmenuPos.sessionId;
              setActiveMenu(null);
              setExportSubmenuPos(null);
              handleExportChat(sessionId, 'markdown');
            }}
          >
            Markdown
          </button>
        </div>,
        document.body
      )}

      {/* Portal for Main Menu */}
      {activeMenu && createPortal(
        <div
          ref={menuRef}
          className="fixed z-[9999] w-32 bg-surface-raised border border-border-subtle rounded-lg shadow-xl flex flex-col py-1"
          style={{
            top: activeMenu.align === 'bottom' ? activeMenu.top : undefined,
            bottom: activeMenu.align === 'top' ? (window.innerHeight - activeMenu.top) : undefined,
            left: activeMenu.left,
          }}
          onClick={(e) => e.stopPropagation()}
        >
          <button
            className="text-left px-3 py-2 text-sm hover:bg-surface-highlight text-text-primary flex items-center gap-2 transition-colors"
            onClick={(e) => {
              e.stopPropagation();
              // Find the session title from sessions list
              const sess = sessions.find(s => (s.sessionId || s.id) === activeMenu.id);
              if (sess) openRenameDialog(sess.sessionId || sess.id, sess.title);
              setActiveMenu(null);
            }}
          >
            <span className="text-xs">✏️</span> Rename
          </button>

          <div
            className="relative w-full"
            onMouseEnter={(e) => {
              if (submenuTimeoutRef.current) {
                clearTimeout(submenuTimeoutRef.current);
                submenuTimeoutRef.current = null;
              }
              const rect = e.currentTarget.getBoundingClientRect();
              handleSubmenuEnter(activeMenu.id, rect);
            }}
            onMouseLeave={handleSubmenuLeave}
          >
            <button
              className="w-full text-left px-3 py-2 text-sm hover:bg-surface-highlight text-text-primary flex items-center justify-between transition-colors"
            >
              <div className="flex items-center gap-2">
                <span className="text-xs">💾</span> Export
              </div>
              <ChevronRightIcon className="w-4 h-4 text-text-muted" />
            </button>
          </div>

          <div className="h-px bg-border-subtle my-1" />

          <button
            className="text-left px-3 py-2 text-sm hover:bg-intent-danger/10 text-intent-danger flex items-center gap-2 transition-colors"
            onClick={(e) => {
              e.stopPropagation();
              handleDeleteChat(activeMenu.id);
              setActiveMenu(null);
            }}
          >
            <span className="text-xs">🗑️</span> Delete
          </button>
        </div>,
        document.body
      )}

      <div className="relative w-full h-full bg-surface-base shadow-2xl z-50 flex flex-col border-r border-border-subtle">
        {/* Header */}
        <div className="p-4 border-b border-border-subtle flex items-center justify-between bg-surface-base/95 backdrop-blur-sm sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <img src={logoIcon} className="w-6 h-6" alt="Singularity" />
            <h2 className="text-lg font-semibold text-text-primary">History</h2>
          </div>
          <div className="flex items-center gap-2">
            <button
              onClick={handleNewChat}
              className="p-2 hover:bg-surface-highlight rounded-full transition-colors text-text-secondary hover:text-primary-500"
              title="New Chat"
            >
              <PlusIcon className="w-5 h-5" />
            </button>
          </div>
        </div>

        {/* Search */}
        <div className="p-4 border-b border-border-subtle">
          <input
            type="text"
            placeholder="Search conversations..."
            className="w-full bg-surface-input border border-border-subtle rounded-md px-3 py-2 text-sm text-text-primary focus:outline-none focus:ring-1 focus:ring-primary-500 placeholder-text-muted"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
        </div>

        {/* Batch Actions */}
        <div className="px-4 pt-2 flex gap-2">
          <button
            onClick={() => {
              if (!isBatchMode) {
                handleToggleBatchMode();
                return;
              }
              const count = selectedIds ? selectedIds.size : 0;
              if (count > 0) {
                handleConfirmBatchDelete();
              } else {
                // If none selected, exit batch mode
                handleToggleBatchMode();
              }
            }}
            className={`flex-1 flex items-center justify-center px-3 py-2 rounded-lg border cursor-pointer transition-all duration-200 text-sm ${isBatchMode
              ? "bg-intent-danger/15 border-intent-danger/45 text-text-secondary hover:bg-intent-danger/20"
              : "bg-surface-raised border-border-subtle text-text-secondary hover:bg-surface-highlight hover:border-border-strong"
              }`}
          >
            <div className="flex items-center gap-2">
              <TrashIcon className="w-4 h-4" />
              <span>{isBatchMode ? (selectedIds.size > 0 ? `Delete (${selectedIds.size})` : "Delete") : "Select"}</span>
            </div>
          </button>
        </div>

        {/* List */}
        <div className="flex-1 min-h-0 p-2">
          {isLoading ? (
            <div className="flex items-center justify-center py-8 text-text-muted text-sm">
              Loading history...
            </div>
          ) : filteredSessions.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-8 text-text-muted text-sm gap-2">
              <span className="text-2xl">📭</span>
              <span>No conversations found</span>
            </div>
          ) : (
            <Virtuoso
              data={filteredSessions}
              style={{ height: "100%" }}
              itemContent={(_, session) => {
                const sessionId = session.sessionId || session.id;
                const isActive = currentSessionId === sessionId;
                const isBatchModeParams = session.title
                  ?.toLowerCase()
                  .includes("batch");
                const isDeleting = !!deletingIds && deletingIds.has(sessionId);
                const isSelected = selectedIds.has(sessionId);

                return (
                  <div className="pb-2">
                    <SessionRow
                      session={session}
                      isActive={isActive}
                      isBatchMode={isBatchMode}
                      isSelected={isSelected}
                      isDeleting={isDeleting}
                      showMenu={!isBatchMode && !isBatchModeParams}
                      onRowClick={handleSessionRowClick}
                      onToggleSelected={handleToggleSelected}
                      onMenuClick={handleSessionMenuClick}
                    />
                  </div>
                );
              }}
              computeItemKey={(index, session) =>
                String(session.sessionId || session.id || `session-${index}`)
              }
            />
          )}
        </div>
      </div>

      <Suspense fallback={null}>
        {renameSessionId && (
          <RenameDialog
            isOpen={!!renameSessionId}
            onClose={closeRenameDialog}
            onRename={handleRenameChat}
            defaultTitle={renameDefaultTitle}
            isRenaming={isRenaming}
          />
        )}
      </Suspense>
    </>
  );
}



================================================
FILE: ui/components/Icons.tsx
================================================
// This file is located at ui/components/Icons.tsx

import React from "react";

// SendIcon is removed (using text icon âœ¨)
// SparklesIcon is removed (using text icon ðŸ§ )

type IconProps = { className?: string; style?: React.CSSProperties };

export const MenuIcon = ({ className, style }: IconProps) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    className={className || "w-6 h-6"}
    style={style}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"
    />
  </svg>
);

export const ChevronDownIcon = ({ className, style }: IconProps) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    className={className || "w-5 h-5"}
    style={style}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M19.5 8.25l-7.5 7.5-7.5-7.5"
    />
  </svg>
);

export const ChevronRightIcon = ({ className, style }: IconProps) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    className={className || "w-5 h-5"}
    style={style}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M8.25 4.5l7.5 7.5-7.5 7.5"
    />
  </svg>
);

export const ChevronUpIcon = ({ className, style }: IconProps) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    className={className || "w-5 h-5"}
    style={style}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M4.5 15.75l7.5-7.5 7.5 7.5"
    />
  </svg>
);

export const BotIcon = ({ className, style }: IconProps) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 24 24"
    fill="currentColor"
    className={className || "w-6 h-6"}
    style={style}
  >
    {/* Using the original Bot Icon Path */}
    <path
      fillRule="evenodd"
      d="M4.5 3.75a3 3 0 00-3 3v10.5a3 3 0 003 3h15a3 3 0 003-3V6.75a3 3 0 00-3-3h-15zm4.125 3a2.25 2.25 0 100 4.5 2.25 2.25 0 000-4.5zm5.25 2.25a2.25 2.25 0 114.5 0 2.25 2.25 0 01-4.5 0zM13.5 12a1.5 1.5 0 00-1.5 1.5v1.5a1.5 1.5 0 003 0V13.5a1.5 1.5 0 00-1.5-1.5z"
      clipRule="evenodd"
    />
    <path d="M5.082 14.254a2.25 2.25 0 013.336 0l2.062 2.062a.75.75 0 001.06 0l2.062-2.062a2.25 2.25 0 013.336 0 .75.75 0 010 1.06l-3.124 3.123a2.25 2.25 0 01-3.182 0l-3.124-3.123a.75.75 0 010-1.06z" />
  </svg>
);

export const UserIcon = ({ className, style }: IconProps) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 24 24"
    fill="currentColor"
    className={className || "w-6 h-6"}
    style={style}
  >
    <path
      fillRule="evenodd"
      d="M7.5 6a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM3.751 20.105a8.25 8.25 0 0116.498 0 .75.75 0 01-.437.695A18.683 18.683 0 0112 22.5c-2.786 0-5.433-.608-7.812-1.7a.75.75 0 01-.437-.695z"
      clipRule="evenodd"
    />
  </svg>
);

// This is the corrected PuzzleIcon component
// In ui/components/Icons.tsx

// ... (your existing icons like UserIcon, BotIcon, etc.)

export const ListIcon = ({
  className,
  style,
  size = 16,
}: IconProps & { size?: number }) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width={size}
    height={size}
    viewBox="0 0 24 24"
    strokeWidth="2"
    stroke="currentColor"
    fill="none"
    strokeLinecap="round"
    strokeLinejoin="round"
    className={className}
    style={style}
  >
    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
    <path d="M9 6l11 0" />
    <path d="M9 12l11 0" />
    <path d="M9 18l11 0" />
    <path d="M5 6l0 .01" />
    <path d="M5 12l0 .01" />
    <path d="M5 18l0 .01" />
  </svg>
);

export const PlusIcon = ({ className, style }: IconProps) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    className={className || "w-6 h-6"}
    style={style}
  >
    <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
  </svg>
);

export const TrashIcon = ({ className, style }: IconProps) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    className={className || "w-6 h-6"}
    style={style}
  >
    <path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" />
  </svg>
);

export const EllipsisHorizontalIcon = ({ className, style }: IconProps) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    className={className || "w-6 h-6"}
    style={style}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M6.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0zM12.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0zM18.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0z"
    />
  </svg>
);

export const SettingsIcon = ({ className, style }: IconProps) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    className={className || "w-6 h-6"}
    style={style}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M10.343 3.94c.09-.542.56-.94 1.11-.94h1.093c.55 0 1.02.398 1.11.94l.149.894c.07.424.384.764.78.93.398.164.855.142 1.205-.108l.737-.527a1.125 1.125 0 011.45.12l.773.774c.39.389.44 1.002.12 1.45l-.527.737c-.25.35-.272.806-.107 1.204.165.397.505.71.93.78l.893.15c.543.09.94.56.94 1.109v1.094c0 .55-.397 1.02-.94 1.11l-.893.149c-.425.07-.765.383-.93.78-.165.398-.143.854.107 1.204l.527.738c.32.447.269 1.06-.12 1.45l-.774.773a1.125 1.125 0 01-1.449.12l-.738-.527c-.35-.25-.806-.272-1.203-.107-.397.165-.71.505-.781.929l-.149.894c-.09.542-.56.94-1.11.94h-1.094c-.55 0-1.019-.398-1.11-.94l-.148-.894c-.071-.424-.384-.764-.781-.93-.398-.164-.854-.142-1.204.108l-.738.527c-.447.32-1.06.269-1.45-.12l-.773-.774a1.125 1.125 0 01-.12-1.45l.527-.737c.25-.35.273-.806.108-1.204-.165-.397-.506-.71-.93-.78l-.894-.15c-.542-.09-.94-.56-.94-1.109v-1.094c0-.55.398-1.02.94-1.11l.894-.149c.424-.07.765-.383.93-.78.165-.398.143-.854-.107-1.204l-.527-.738a1.125 1.125 0 01.12-1.45l.773-.773a1.125 1.125 0 011.45-.12l.737.527c.35.25.807.272 1.204.107.397-.165.71-.505.78-.929l.15-.894z"
    />
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
    />
  </svg>
);



================================================
FILE: ui/components/LaunchpadDrawer.tsx
================================================
import React, { useRef, useEffect } from "react";
import { useAtom } from "jotai";
import { launchpadOpenAtom } from "../state/atoms";
import { useLaunchpadDrafts } from "../hooks/useLaunchpadDrafts";
import { useChat } from "../hooks/chat/useChat";
import { DraftCard } from "./DraftCard";
import { cn } from "../utils/cn";

export const LaunchpadDrawer: React.FC = () => {
    const [isOpen, setIsOpen] = useAtom(launchpadOpenAtom);
    const { drafts, updateDraft, deleteDraft, reorderDrafts, clearAll } = useLaunchpadDrafts();
    const { sendMessage, runComposerFlow } = useChat();
    const drawerRef = useRef<HTMLDivElement>(null);

    // Close on click outside
    useEffect(() => {
        if (!isOpen) return;

        const handleClickOutside = (e: MouseEvent) => {
            // If clicking the tab, don't close (tab handles toggle)
            if (e.target instanceof Element && e.target.closest('button[title="Open Launchpad"]')) {
                return;
            }
            if (drawerRef.current && !drawerRef.current.contains(e.target as Node)) {
                setIsOpen(false);
            }
        };

        const timer = setTimeout(() => {
            document.addEventListener("click", handleClickOutside);
        }, 100);

        return () => {
            clearTimeout(timer);
            document.removeEventListener("click", handleClickOutside);
        };
    }, [isOpen, setIsOpen]);

    if (!isOpen) return null;

    return (
        <>
            {/* Backdrop - subtle or transparent? Plan said "Backdrop blur like HistoryPanel" */}
            <div className="fixed inset-0 bg-transparent z-[2998]" />

            <div
                ref={drawerRef}
                className={cn(
                    "fixed top-0 left-0 w-[420px] h-screen bg-surface-base/98 backdrop-blur-xl border-r border-border-subtle shadow-nav z-[2999]",
                    "flex flex-col animate-in slide-in-from-left duration-300 ease-out"
                )}
            >
                {/* Header */}
                <div className="flex items-center justify-between px-6 py-4 border-b border-border-subtle/50">
                    <div className="flex items-center gap-2">
                        <h2 className="text-lg font-bold text-text-primary flex items-center gap-2">
                            <span className="text-xl">ðŸš€</span> Launchpad
                        </h2>
                        <span className="px-2 py-0.5 bg-surface-elevated rounded-full text-xs text-text-secondary font-medium border border-border-subtle">
                            {drafts.length}
                        </span>
                    </div>
                    <div className="flex items-center gap-2">
                        {drafts.length > 0 && (
                            <button
                                onClick={clearAll}
                                className="text-xs text-text-muted hover:text-intent-danger transition-colors mr-2 uppercase tracking-wide font-medium"
                            >
                                Clear All
                            </button>
                        )}
                        <button
                            onClick={() => setIsOpen(false)}
                            className="w-8 h-8 flex items-center justify-center rounded-full hover:bg-surface-elevated text-text-muted hover:text-text-primary transition-all"
                        >
                            âœ•
                        </button>
                    </div>
                </div>

                {/* Content */}
                <div className="flex-1 overflow-y-auto px-4 py-4 scrollbar-thin scrollbar-thumb-border-subtle scrollbar-track-transparent">
                    {drafts.length === 0 ? (
                        <div className="flex flex-col items-center justify-center h-full text-center text-text-muted px-8 opacity-60">
                            <div className="w-16 h-16 rounded-full bg-surface-elevated mb-4 flex items-center justify-center text-3xl opacity-50">
                                ðŸ›¸
                            </div>
                            <p className="font-medium text-lg mb-2">Ready for lift-off</p>
                            <p className="text-sm leading-relaxed">
                                Drafts from Composer and Analyst will appear here. Refine them until they are ready to launch.
                            </p>
                        </div>
                    ) : (
                        <div className="flex flex-col gap-1 pb-10">
                            {drafts.map((draft, index) => (
                                <DraftCard
                                    key={draft.id}
                                    draft={draft}
                                    index={index}
                                    onUpdate={(text) => updateDraft(draft.id, text)}
                                    onDelete={() => deleteDraft(draft.id)}
                                    // Actions
                                    onSend={() => {
                                        sendMessage(draft.text, "new");
                                        // Optional: close drawer after sending?
                                        // setIsOpen(false); 
                                    }}
                                    onSendToComposer={() => {
                                        // Trigger Composer refinement
                                        runComposerFlow(draft.text, "compose", draft.originalPrompt);
                                        setIsOpen(false); // Close so they see the composer
                                    }}
                                    onSendToAnalyst={() => {
                                        // Trigger Analyst explanation
                                        runComposerFlow(draft.text, "explain", draft.originalPrompt);
                                        setIsOpen(false); // Close so they see the analyst
                                    }}
                                    onReorder={reorderDrafts}
                                />
                            ))}
                        </div>
                    )}
                </div>

                {/* Footer hint */}
                <div className="p-3 border-t border-border-subtle/30 bg-surface-base/50 text-[10px] text-center text-text-muted uppercase tracking-widest font-mono opacity-50">
                    Drag to Reorder â€¢ Swipe to Delete
                </div>
            </div>
        </>
    );
};

export default LaunchpadDrawer;



================================================
FILE: ui/components/LaunchpadTab.tsx
================================================
import React from "react";
import { useAtom, useAtomValue } from "jotai";
import { launchpadOpenAtom, showLaunchpadTabAtom } from "../state/atoms";
import { cn } from "../utils/cn";

export const LaunchpadTab: React.FC = () => {
    const [isOpen, setIsOpen] = useAtom(launchpadOpenAtom);
    const showTab = useAtomValue(showLaunchpadTabAtom);

    if (!showTab || isOpen) return null;

    return (
        <div className="fixed left-0 top-1/2 -translate-y-1/2 z-[2900]">
            <button
                onClick={() => setIsOpen(true)}
                className={cn(
                    "group flex items-center justify-center",
                    "w-2 hover:w-3 h-16 bg-brand-500/80 rounded-r-lg shadow-[0_0_12px_var(--brand-glow)]",
                    "transition-all duration-300 ease-out cursor-pointer",
                    "hover:bg-brand-400 hover:shadow-[0_0_20px_var(--brand-glow)]"
                )}
                title="Open Launchpad"
            >
                <div className="w-[1px] h-8 bg-white/50 rounded-full group-hover:scale-y-125 transition-transform" />
            </button>

            {/* Pulse effect for visibility */}
            <div className="absolute inset-0 bg-brand-400/30 rounded-r-lg animate-pulse -z-10 blur-sm" />
        </div>
    );
};

export default LaunchpadTab;



================================================
FILE: ui/components/MarkdownDisplay.tsx
================================================
import React, { useCallback, useState, useEffect } from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { containsMath } from "../utils/math-renderer";

// --- 1. HELPER: Language Extractor ---
const ListContext = React.createContext(false);

function getLanguageFromClass(className: string): string {
  const match = /language-([a-zA-Z0-9+#]+)/.exec(String(className || ""));
  return match ? match[1] : "";
}

function languageToExt(lang: string): string {
  switch (String(lang).toLowerCase()) {
    case "js": case "javascript": return "js";
    case "ts": case "typescript": return "ts";
    case "tsx": return "tsx";
    case "jsx": return "jsx";
    case "py": case "python": return "py";
    case "json": return "json";
    case "go": case "golang": return "go";
    case "java": return "java";
    case "ruby": case "rb": return "rb";
    case "bash": case "sh": return "sh";
    case "markdown": case "md": return "md";
    case "yaml": case "yml": return "yml";
    case "html": return "html";
    case "css": return "css";
    case "scss": return "scss";
    case "c": return "c";
    case "cpp": case "c++": return "cpp";
    case "csharp": case "cs": return "cs";
    case "php": return "php";
    case "rust": case "rs": return "rs";
    case "kotlin": case "kt": return "kt";
    case "swift": return "swift";
    default: return "txt";
  }
}

// --- 2. PRE BLOCK (The Container / Card) ---
// Only Triple-Backtick code blocks get wrapped in <pre>.
// This ensures inline code NEVER gets the buttons or box style.
const PreBlock = ({ children }: any) => {
  // Extract the code text and language from the inner <code> element
  const codeElement = React.Children.toArray(children).find(
    (child: any) => child.props && child.props.className
  ) as React.ReactElement | undefined;

  const className = codeElement?.props?.className || "";
  const codeText = String(codeElement?.props?.children || "").replace(/\n$/, "");
  const language = getLanguageFromClass(className);

  const [copied, setCopied] = useState(false);

  const handleCopy = useCallback(async (e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      await navigator.clipboard.writeText(codeText);
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    } catch { }
  }, [codeText]);

  const handleDownload = useCallback(() => {
    try {
      const blob = new Blob([codeText], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `snippet.${languageToExt(language)}`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(url); try { document.body.removeChild(a); } catch { } }, 0);
    } catch { }
  }, [codeText, language]);



  return (
    <div className="relative bg-surface-code border border-border-subtle rounded-lg my-3 overflow-hidden max-w-full">
      {/* Header / Language Label */}
      {language && (
        <div className="absolute top-0 left-0 px-2 py-0.5 text-xs uppercase text-text-muted bg-surface-modal/50 rounded-br pointer-events-none z-[1]">
          {language}
        </div>
      )}

      {/* Code Content */}
      <div className="m-0 overflow-x-auto pt-7 px-3 pb-3 w-full">
        {/* We render children (the <code> tag) directly here */}
        <pre className="m-0 font-[inherit] bg-transparent">
          {children}
        </pre>
      </div>

      {/* Action Buttons */}
      <div className="absolute top-1.5 right-1.5 flex gap-1.5 z-[2]">
        <button
          onClick={handleCopy}
          title="Copy"
          className={`inline-flex items-center gap-1 px-1.5 mx-0.5 bg-chip-active border border-border-brand rounded-pill text-text-primary text-sm font-bold leading-snug cursor-pointer no-underline transition-all
                      ${copied ? 'text-intent-success' : 'text-text-muted'}`}
        >
          {copied ? "✓" : "📋"}
        </button>
        <button
          onClick={handleDownload}
          title="Download"
          className="bg-border-subtle border border-border-subtle rounded-md px-2 py-1
                     text-text-muted text-xs cursor-pointer"
        >
          ⬇️
        </button>
      </div>
    </div>
  );
};

// --- 3. CODE COMPONENT (The Text Style) ---
const CodeText = ({ className = '', children, ...props }: any) => {
  const isBlock = className.includes('language-');
  if (isBlock) {
    // fenced/block code: PreBlock / CSS will style
    return (
      <code className={className} {...props}>
        {children}
      </code>
    );
  }

  // inline code: bubble style
  return (
    <code
      className={`inline font-mono text-xs text-text-primary bg-surface-highlight/80 border border-border-subtle rounded px-1.5 py-0.5 whitespace-normal align-baseline ${className}`}
      {...props}
    >
      {children}
    </code>
  );
};

// --- 4. MAIN EXPORT ---
interface MarkdownDisplayProps {
  content: string;
  components?: Record<string, React.ElementType>;
  className?: string;
}

const MarkdownDisplay: React.FC<MarkdownDisplayProps> = React.memo(
  ({ content, components = {}, className }) => {
    // State for lazy-loaded plugins
    const [mathPlugins, setMathPlugins] = useState<{
      remarkPlugins: any[];
      rehypePlugins: any[];
    }>({ remarkPlugins: [], rehypePlugins: [] });

    const [isMathLoaded, setIsMathLoaded] = useState(false);

    // Effect to handle math rendering
    useEffect(() => {
      let isMounted = true;

      const loadPlugins = async () => {
        // Fast check for math syntax
        if (!containsMath(content)) {
          return;
        }

        // If already loaded, skip
        if (isMathLoaded) return;

        try {
          // Lazy load plugins
          const { loadMathPlugins } = await import("../utils/math-renderer");
          const { remarkMath, rehypeKatex } = await loadMathPlugins();

          if (isMounted) {
            setMathPlugins({
              remarkPlugins: [remarkMath],
              rehypePlugins: [rehypeKatex]
            });
            setIsMathLoaded(true);
          }
        } catch (err) {
          console.error("Failed to load math plugins:", err);
        }
      };

      loadPlugins();

      return () => {
        isMounted = false;
      };
    }, [content, isMathLoaded]);

    return (
      <div className={`markdown-body text-base leading-relaxed ${className || 'text-text-primary'} min-w-0 max-w-full`}>
        <ReactMarkdown
          remarkPlugins={[remarkGfm, ...mathPlugins.remarkPlugins]}
          rehypePlugins={[...mathPlugins.rehypePlugins]}
          components={{
            // Separate Block vs Inline logic explicitly
            pre: PreBlock,
            code: CodeText,
 a: ({ href, children, ...props }: any) => (
      <a 
        href={href} 
        {...props} 
        target="_blank" 
        rel="noopener noreferrer"
        className="text-brand-400 hover:text-brand-300 underline decoration-brand-400/30 hover:decoration-brand-400 transition-colors"
      >
        {children}
      </a>
    ),
    // ---------------------------

    // Crash Fix: Map paragraphs to divs (or spans in lists)
    p: ({ children }) => {
              const inList = React.useContext(ListContext);
              if (inList) {
                // Force inline rendering for list items to prevent vertical stacking
                return (
                  <span className="inline m-0">
                    {children}
                    <span className="inline-block w-[0.3em]"></span>
                  </span>
                );
              }
              return (
                <div className="mb-4 mt-2">
                  {children}
                </div>
              );
            },
            ul: ({ children }) => <ul className="pl-5 mb-4 list-disc">{children}</ul>,
            ol: ({ children }) => <ol className="pl-5 mb-4 list-decimal">{children}</ol>,
            li: ({ children }) => (
              <ListContext.Provider value={true}>
                <li className="mb-1">{children}</li>
              </ListContext.Provider>
            ),
            h1: ({ children }) => <h1 className="text-2xl font-semibold mt-4 mb-2 text-text-primary">{children}</h1>,
            h2: ({ children }) => <h2 className="text-xl font-semibold mt-3 mb-2 text-text-primary">{children}</h2>,
            h3: ({ children }) => <h3 className="text-lg font-semibold mt-2 mb-1.5 text-text-secondary">{children}</h3>,
            h4: ({ children }) => <h4 className="text-base font-semibold mt-2 mb-1.5 text-text-secondary">{children}</h4>,
            blockquote: ({ children }) => <blockquote className="border-l-4 border-border-subtle pl-4 ml-0 text-text-muted italic">{children}</blockquote>,
            img: ({ src, alt, ...props }: any) => (
              <img
                src={src}
                alt={alt}
                referrerPolicy="no-referrer"
                className="rounded-lg max-w-full h-auto my-2 border border-border-subtle"
                {...props}
              />
            ),

            // --- TABLE STYLING (Restored) ---
            table: ({ children }) => (
              <div className="overflow-x-auto my-4 max-w-full">
                <table className="w-full border-collapse text-base text-text-primary">
                  {children}
                </table>
              </div>
            ),
            thead: ({ children }) => <thead className="bg-chip-soft">{children}</thead>,
            tbody: ({ children }) => <tbody>{children}</tbody>,
            tr: ({ children }) => <tr className="border-b border-border-subtle">{children}</tr>,
            th: ({ children }) => (
              <th className="px-3 py-2 text-left font-semibold text-text-secondary border-b border-border-subtle">
                {children}
              </th>
            ),
            td: ({ children }) => (
              <td className="px-3 py-2 align-top text-text-primary border-b border-border-subtle">
                {children}
              </td>
            ),
            

            ...components,
          }}
        >
          {content}
        </ReactMarkdown>
      </div>
    );
  },
  (prev, next) => prev.content === next.content && prev.components === next.components
);

export default MarkdownDisplay;


================================================
FILE: ui/components/MessageRow.tsx
================================================
import React, { useMemo } from "react";
import { useAtomValue } from "jotai";
import { selectAtom } from "jotai/utils";
import { turnsMapAtom } from "../state/atoms";
import UserTurnBlock from "./UserTurnBlock";
import AiTurnBlock from "./AiTurnBlock";

function MessageRow({ turnId }: { turnId: string }) {
  const turnAtom = useMemo(
    () => selectAtom(turnsMapAtom, (map) => map.get(turnId)),
    [turnId],
  );
  const message = useAtomValue(turnAtom);

  if (!message) {
    return (
      <div className="p-2 text-intent-danger">
        Error: Missing turn {turnId}
      </div>
    );
  }

  const content =
    (message as any).type === "user" ? (
      <UserTurnBlock userTurn={message as any} />
    ) : (
      <AiTurnBlock aiTurn={message as any} />
    );

  // Wrap each row with an anchor for scroll/highlight targeting
  return (
    <div className="message-row" data-turn-id={turnId} id={`turn-${turnId}`}>
      {content}
    </div>
  );
}

export default React.memo(MessageRow);



================================================
FILE: ui/components/ModelResponsePanel.tsx
================================================
// ui/components/ModelResponsePanel.tsx
// Enhanced single-provider response panel for split pane view
// Migrated features from deprecated ProviderCard.tsx and ProviderResponseBlock.tsx

import React, { useState, useCallback, useMemo } from "react";
import { useAtomValue } from "jotai";
import {
    providerEffectiveStateFamily,
    turnStreamingStateFamily,
    activeRecomputeStateAtom,
    chatInputHeightAtom,
} from "../state/atoms";
import { LLM_PROVIDERS_CONFIG } from "../constants";
import { useProviderActions } from "../hooks/providers/useProviderActions";
import MarkdownDisplay from "./MarkdownDisplay";
import { ArtifactOverlay, Artifact } from "./ArtifactOverlay";
import { ChevronDownIcon, ChevronUpIcon } from "./Icons";
import { CopyButton } from "./CopyButton";
import { formatProviderResponseForMd } from "../utils/copy-format-utils";
import { useRefinerOutput } from "../hooks/useRefinerOutput";
import { TrustSignalsPanel } from "./refinerui/TrustSignalsPanel";
import clsx from "clsx";

// BuriedInsightCard removed - no longer using signals

interface ModelResponsePanelProps {
    turnId: string;
    providerId: string;
    sessionId?: string;
    onClose: () => void;
}

export const ModelResponsePanel: React.FC<ModelResponsePanelProps> = React.memo(({
    turnId,
    providerId,
    sessionId,
    onClose
}) => {
    // State subscriptions
    const effectiveState = useAtomValue(
        useMemo(() => providerEffectiveStateFamily({ turnId, providerId }), [turnId, providerId])
    );
    const streamingState = useAtomValue(turnStreamingStateFamily(turnId));
    const activeRecompute = useAtomValue(activeRecomputeStateAtom);

    // Actions hook
    const { handleRetryProvider, handleBranchContinue, handleToggleTarget, activeTarget } =
        useProviderActions(sessionId, turnId);

    // Local state
    const [showHistory, setShowHistory] = useState(false);
    const [branchInput, setBranchInput] = useState('');
    const [selectedArtifact, setSelectedArtifact] = useState<Artifact | null>(null);

    // Config
    const provider = LLM_PROVIDERS_CONFIG.find(p => String(p.id) === providerId);
    const { latestResponse, historyCount, allResponses } = effectiveState;

    // Derived state with memoization
    const derivedState = useMemo(() => {
        const status = latestResponse?.status || 'pending';
        const text = latestResponse?.text || '';
        const artifacts = (latestResponse?.artifacts || []) as Artifact[];
        const hasText = !!text.trim();
        const isStreaming = status === 'streaming' || streamingState.activeProviderId === providerId;
        const isError = status === 'error';

        return { status, text, hasText, isStreaming, isError, artifacts };
    }, [latestResponse, streamingState.activeProviderId, providerId]);

    const { output: refinerOutput, rawText: refinerRawText } = useRefinerOutput(turnId);
    const chatInputHeight = useAtomValue(chatInputHeightAtom);

    // Branch send handler (hook before conditional return)
    const handleBranchSend = useCallback(() => {
        if (!branchInput.trim()) return;
        handleBranchContinue(providerId, branchInput);
        setBranchInput('');
    }, [branchInput, handleBranchContinue, providerId]);


    // Trust mode via sentinel providerId - simplified for new structure
    if (providerId === '__trust__' && refinerOutput) {
        return (
            <div className="h-full w-full min-w-0 flex flex-col bg-surface-raised border border-border-subtle rounded-2xl shadow-lg overflow-hidden">
                <TrustSignalsPanel
                    refiner={refinerOutput}
                    rawText={refinerRawText || undefined}
                    onClose={onClose}
                    bottomPadding={(chatInputHeight || 80) + 32}
                    turnId={turnId}
                />
            </div>
        );
    }

    // Branching visual state
    const isBranching = activeRecompute?.providerId === providerId &&
        activeRecompute?.aiTurnId === turnId &&
        activeRecompute?.stepType === 'batch';

    // Is this provider targeted for branch input?
    const isTargeted = activeTarget?.providerId === providerId;
    const hasHistory = historyCount > 1;

    // Empty/loading state
    if (!latestResponse && !derivedState.isError) {
        return (
            <div className="h-full w-full min-w-0 flex flex-col items-center justify-center bg-surface-raised border border-border-subtle rounded-2xl shadow-lg">
                <div className="text-text-muted text-sm animate-pulse">Waiting for response...</div>
            </div>
        );
    }

    return (
        <div className={clsx(
            "h-full w-full min-w-0 flex flex-col bg-surface-raised border border-border-subtle rounded-2xl shadow-lg overflow-hidden animate-in slide-in-from-right duration-300",
            isBranching && "ring-2 ring-brand-500/50"
        )}>
            {/* Header */}
            <div className="flex items-center justify-between px-4 py-3 border-b border-border-subtle bg-surface-raised flex-shrink-0">
                <div className="flex items-center gap-2">
                    {/* Status LED */}
                    <div className={clsx(
                        "w-2 h-2 rounded-full transition-colors",
                        derivedState.isStreaming && "bg-intent-warning animate-pulse",
                        derivedState.status === 'completed' && derivedState.hasText && "bg-intent-success",
                        derivedState.status === 'completed' && !derivedState.hasText && "bg-intent-warning",
                        derivedState.isError && "bg-intent-danger"
                    )} />

                    {/* Provider info */}
                    {provider?.logoSrc && (
                        <img src={provider.logoSrc} alt={provider.name} className="w-5 h-5 rounded" />
                    )}
                    <h3 className="text-sm font-medium text-text-primary m-0">
                        {provider?.name || providerId}
                    </h3>

                    {/* Branching indicator */}
                    {isBranching && (
                        <span className="text-xs bg-brand-500 text-white px-2 py-0.5 rounded-full animate-pulse">
                            Branching...
                        </span>
                    )}
                </div>

                <div className="flex items-center gap-1">
                    {/* Branch toggle button */}
                    <button
                        onClick={() => handleToggleTarget(providerId)}
                        className={clsx(
                            "text-xs px-2 py-1 rounded transition-colors",
                            isTargeted
                                ? "bg-brand-500 text-white"
                                : "text-text-muted hover:bg-surface-highlight hover:text-text-primary"
                        )}
                        title="Continue conversation with this provider"
                    >
                        ðŸŒ¿ Branch
                    </button>

                    {/* Retry button (for errors or empty responses) */}
                    {(derivedState.isError || (derivedState.status === 'completed' && !derivedState.hasText)) && (
                        <button
                            onClick={() => handleRetryProvider(providerId)}
                            className="text-xs bg-intent-danger/20 text-intent-danger px-2 py-1 rounded hover:bg-intent-danger/30 transition-colors"
                            title="Retry this provider"
                        >
                            ðŸ”„ Retry
                        </button>
                    )}

                    {/* Copy button */}
                    {derivedState.hasText && (
                        <CopyButton
                            text={formatProviderResponseForMd(
                                latestResponse!,
                                provider?.name || providerId
                            )}
                            label="Copy response"
                            variant="icon"
                        />
                    )}

                    {/* Close button */}
                    <button
                        onClick={onClose}
                        className="text-text-muted hover:text-text-primary transition-colors p-1 rounded-md hover:bg-surface-highlight"
                        aria-label="Close panel"
                    >
                        âœ•
                    </button>
                </div>
            </div>

            {/* Content */}
            <div className="flex-1 min-w-0 overflow-y-auto overflow-x-hidden p-4 custom-scrollbar relative z-10" style={{ paddingBottom: (chatInputHeight || 80) + 24 }}>
                {/* Main response */}
                <div className="prose prose-sm max-w-none dark:prose-invert break-words" style={{ overflowWrap: 'anywhere' }}>
                    <MarkdownDisplay content={derivedState.text || (derivedState.isError ? "Error occurred" : "Empty response")} />
                    {derivedState.isStreaming && <span className="streaming-dots" />}
                </div>

                {/* Artifact badges */}
                {derivedState.artifacts.length > 0 && (
                    <div className="mt-4 flex flex-wrap gap-2">
                        {derivedState.artifacts.map((artifact, idx) => (
                            <button
                                key={idx}
                                onClick={() => setSelectedArtifact(artifact)}
                                className="bg-gradient-to-br from-brand-500/20 to-brand-600/20 border border-brand-500/30 rounded-lg px-3 py-2 text-sm flex items-center gap-1.5 hover:bg-brand-500/30 hover:-translate-y-px transition-all cursor-pointer"
                            >
                                ðŸ“„ {artifact.title}
                            </button>
                        ))}
                    </div>
                )}

                {/* History Stack */}
                {hasHistory && (
                    <div className="mt-6 pt-4 border-t border-border-subtle">
                        <button
                            onClick={() => setShowHistory(!showHistory)}
                            className="w-full flex items-center justify-between text-xs text-text-muted hover:text-text-primary transition-colors py-1"
                        >
                            <span>{historyCount - 1} previous version(s)</span>
                            {showHistory ? <ChevronDownIcon className="w-3 h-3" /> : <ChevronUpIcon className="w-3 h-3" />}
                        </button>

                        {showHistory && (
                            <div className="mt-3 space-y-3 animate-in slide-in-from-top-2 duration-200">
                                {allResponses.slice(0, -1).reverse().map((resp, idx) => {
                                    const histText = resp.text || '';
                                    const histArtifacts = (resp.artifacts || []) as Artifact[];
                                    const hasContent = histText || histArtifacts.length > 0;

                                    return (
                                        <div
                                            key={idx}
                                            className="bg-surface p-3 rounded-lg border border-border-subtle opacity-75 hover:opacity-100 transition-opacity"
                                        >
                                            <div className="text-xs text-text-muted mb-2 flex justify-between">
                                                <span>Attempt {historyCount - 1 - idx}</span>
                                                <span>{new Date(resp.createdAt).toLocaleTimeString()}</span>
                                            </div>
                                            <div className="prose prose-sm max-w-none dark:prose-invert text-xs line-clamp-4 hover:line-clamp-none transition-all">
                                                {hasContent ? (
                                                    <>
                                                        <MarkdownDisplay content={histText || '*Artifact only*'} />
                                                        {histArtifacts.length > 0 && (
                                                            <div className="mt-2 flex flex-wrap gap-1">
                                                                {histArtifacts.map((art, i) => (
                                                                    <span
                                                                        key={i}
                                                                        onClick={() => setSelectedArtifact(art)}
                                                                        className="text-xs bg-brand-500/10 text-brand-500 px-1.5 py-0.5 rounded border border-brand-500/20 cursor-pointer hover:bg-brand-500/20"
                                                                    >
                                                                        ðŸ“„ {art.title}
                                                                    </span>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </>
                                                ) : (
                                                    <span className="text-text-muted italic">Empty response</span>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </div>
                )}
            </div>

            {/* Branch Input (shown when targeted) */}
            {isTargeted && (
                <div className="p-3 border-t border-brand-500/30 bg-brand-500/5 flex-shrink-0 animate-in slide-in-from-bottom-2 duration-200">
                    <div className="flex gap-2">
                        <input
                            type="text"
                            value={branchInput}
                            onChange={(e) => setBranchInput(e.target.value)}
                            onKeyDown={(e) => {
                                if (e.key === 'Enter' && !e.shiftKey) {
                                    e.preventDefault();
                                    handleBranchSend();
                                }
                                if (e.key === 'Escape') {
                                    e.preventDefault();
                                    handleToggleTarget(providerId);
                                }
                            }}
                            placeholder={`Continue with ${provider?.name || providerId}...`}
                            className="flex-1 bg-surface border border-border-subtle rounded px-3 py-2 text-sm focus:outline-none focus:border-brand-500 transition-colors"
                            autoFocus
                        />
                        <button
                            onClick={handleBranchSend}
                            disabled={!branchInput.trim() || isBranching}
                            className="bg-brand-500 text-white px-4 py-2 rounded text-sm disabled:opacity-50 hover:bg-brand-600 transition-colors"
                        >
                            Send
                        </button>
                    </div>
                    <div className="text-xs text-text-muted mt-1.5 px-1">Enter to send â€¢ ESC to cancel</div>
                </div>
            )}

            {/* Artifact Overlay */}
            {selectedArtifact && (
                <ArtifactOverlay
                    artifact={selectedArtifact}
                    onClose={() => setSelectedArtifact(null)}
                />
            )}
        </div>
    );
});

ModelResponsePanel.displayName = 'ModelResponsePanel';



================================================
FILE: ui/components/NudgeChipBar.tsx
================================================
import React, { useEffect, useState } from "react";
import { useAtomValue } from "jotai";
import { composerModelAtom, analystModelAtom } from "../state/atoms";
import { getProviderName } from "../utils/provider-helpers";

interface NudgeChipBarProps {
    type: "sending" | "idle";
    variant?: "default" | "chain_composer" | "chain_analyst"; // New variant prop
    onCompose: () => void;
    onAnalyst: () => void;
    progress?: number; // 0-100
    visible: boolean;
}

const NudgeChipBar: React.FC<NudgeChipBarProps> = ({
    type,
    variant = "default",
    onCompose,
    onAnalyst,
    progress = 0,
    visible,
}) => {
    const [show, setShow] = useState(visible);
    const composerModelId = useAtomValue(composerModelAtom);
    const analystModelId = useAtomValue(analystModelAtom);

    const composerModelName = getProviderName(composerModelId || "gemini");
    const analystModelName = getProviderName(analystModelId || "gemini");

    useEffect(() => {
        if (visible) {
            setShow(true);
        } else {
            const timer = setTimeout(() => setShow(false), 300); // Wait for fade out
            return () => clearTimeout(timer);
        }
    }, [visible]);

    if (!show) return null;

    const isSending = type === "sending";

    // Dynamic text based on variant
    let composerText = isSending ? "Perfect this prompt" : "Let Composer perfect it";
    let analystText = isSending ? "Pressure-test it" : "Let Analyst sharpen it";

    if (variant === "chain_analyst") {
        // We just ran Composer, nudge Analyst
        analystText = "Now pressure-test with Analyst?";
    } else if (variant === "chain_composer") {
        // We just ran Analyst, nudge Composer
        composerText = "Now perfect this audited version?";
    }

    return (
        <div
            className={`absolute bottom-full left-1/2 transform -translate-x-1/2 mb-8 h-[44px] bg-surface-base/90 backdrop-blur-xl border border-border-subtle rounded-full shadow-2xl flex items-center gap-1 px-1.5 z-50 transition-all duration-300 ease-out ${visible ? "opacity-100 translate-y-0 scale-100" : "opacity-0 translate-y-2 scale-95"
                }`}
        >
            {/* Progress Ring (Only for Sending trigger) */}
            {isSending && (
                <div className="absolute inset-0 rounded-full overflow-hidden pointer-events-none">
                    <svg className="w-full h-full rotate-[-90deg]" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <rect
                            x="0"
                            y="0"
                            width="100%"
                            height="100%"
                            fill="none"
                            stroke="var(--brand-500)"
                            strokeWidth="2"
                            strokeDasharray="400" // Approximate perimeter
                            strokeDashoffset={400 - (400 * progress) / 100}
                            className="transition-all duration-100 ease-linear opacity-20"
                        />
                    </svg>
                </div>
            )}

            <button
                onClick={onCompose}
                className="group relative flex items-center gap-2 px-4 py-1.5 rounded-full hover:bg-surface-highlight transition-all duration-200"
            >
                <span className="text-sm font-medium text-text-primary group-hover:text-brand-400 transition-colors">
                    {composerText}
                </span>
                <span className="text-[10px] text-text-muted font-mono opacity-60 group-hover:opacity-100 transition-opacity">
                    [{composerModelName}]
                </span>
                {/* Glow effect */}
                <div className="absolute inset-0 rounded-full bg-brand-500/5 opacity-0 group-hover:opacity-100 transition-opacity" />
            </button>

            <div className="w-px h-4 bg-border-subtle" />

            <button
                onClick={onAnalyst}
                className="group relative flex items-center gap-2 px-4 py-1.5 rounded-full hover:bg-surface-highlight transition-all duration-200"
            >
                <span className="text-sm font-medium text-text-primary group-hover:text-brand-400 transition-colors">
                    {analystText}
                </span>
                <span className="text-[10px] text-text-muted font-mono opacity-60 group-hover:opacity-100 transition-opacity">
                    [{analystModelName}]
                </span>
                {/* Glow effect */}
                <div className="absolute inset-0 rounded-full bg-brand-500/5 opacity-0 group-hover:opacity-100 transition-opacity" />
            </button>
        </div>
    );
};

export default NudgeChipBar;



================================================
FILE: ui/components/ProviderErrorCard.tsx
================================================
// ui/components/ProviderErrorCard.tsx
import React from 'react';
import type { ProviderError } from '@shared/contract';
import { ERROR_DISPLAY_TEXT } from '../constants/errorMessages';
import { getProviderColor } from '../utils/provider-helpers';
import clsx from 'clsx';

interface ProviderErrorCardProps {
  providerId: string;
  providerName: string;
  error: ProviderError;
  onRetry?: () => void;
  onDismiss?: () => void;
}

export const ProviderErrorCard: React.FC<ProviderErrorCardProps> = ({
  providerId,
  providerName,
  error,
  onRetry,
  onDismiss,
}) => {
  const displayInfo = ERROR_DISPLAY_TEXT[(error?.type as keyof typeof ERROR_DISPLAY_TEXT) || 'unknown'] || ERROR_DISPLAY_TEXT.unknown;
  const providerColor = getProviderColor(providerId);

  return (
    <div
      className={clsx(
        'provider-error-card',
        error?.retryable && 'provider-error-card--retryable'
      )}
      style={{ ['--provider-color' as any]: providerColor }}
    >
      <div className="provider-error-card__header">
        <span className="provider-error-card__icon">{displayInfo.icon}</span>
        <span className="provider-error-card__provider">{providerName}</span>
        <span className="provider-error-card__title">{displayInfo.title}</span>
        {onDismiss && (
          <button
            className="provider-error-card__dismiss"
            onClick={onDismiss}
            aria-label="Dismiss"
          >
            Ã—
          </button>
        )}
      </div>

      <p className="provider-error-card__description">
        {error?.message || displayInfo.description}
      </p>

      {error?.retryAfterMs && (
        <p className="provider-error-card__timer">
          Retry available in {Math.ceil(error.retryAfterMs / 1000)}s
        </p>
      )}

      <div className="provider-error-card__actions">
        {error?.retryable && onRetry && (
          <button className="provider-error-card__retry-btn" onClick={onRetry}>
            ðŸ”„ Retry
          </button>
        )}
        {error?.requiresReauth && (
          <button
            className="provider-error-card__auth-btn"
            onClick={() => {
              window.dispatchEvent(
                new CustomEvent('provider-reauth', { detail: { providerId } })
              );
            }}
          >
            ðŸ”‘ Log In
          </button>
        )}
      </div>
    </div>
  );
};

export default ProviderErrorCard;



================================================
FILE: ui/components/ProviderPill.tsx
================================================
import {
  getProviderConfig,
  getProviderLogo,
  getProviderName,
} from "../utils/provider-helpers";

export const ProviderPill = ({ id }: { id: string }) => {
  const prov = getProviderConfig(id);
  const name = getProviderName(id);
  const logoSrc = getProviderLogo(id);

  return (
    <span
      className="ml-auto self-end mt-2 text-xs
                 bg-overlay-backdrop/80 px-1.5 py-0.5
                 rounded text-text-secondary font-medium leading-[1.2]
                 flex items-center gap-1"
    >
      {logoSrc ? (
        <img
          src={logoSrc}
          alt={name}
          className="w-3 h-3 rounded object-contain"
        />
      ) : (
        <span className="text-xs">{(prov as any)?.emoji || "ðŸ¤–"}</span>
      )}
      {name}
    </span>
  );
};



================================================
FILE: ui/components/RenameDialog.tsx
================================================
import React, { useEffect, useRef, useState } from "react";

interface RenameDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onRename: (title: string) => void;
  defaultTitle: string;
  isRenaming?: boolean;
}

export const RenameDialog: React.FC<RenameDialogProps> = ({
  isOpen,
  onClose,
  onRename,
  defaultTitle,
  isRenaming = false,
}) => {
  const [title, setTitle] = useState(defaultTitle);
  const inputRef = useRef<HTMLInputElement | null>(null);

  useEffect(() => {
    setTitle(defaultTitle);
  }, [defaultTitle]);

  useEffect(() => {
    if (isOpen && inputRef.current) {
      // Auto-select the whole title for quick renaming
      inputRef.current.focus();
      inputRef.current.selectionStart = 0;
      inputRef.current.selectionEnd = inputRef.current.value.length;
    }
  }, [isOpen]);

  const handleRename = () => {
    const t = String(title || "").trim();
    if (t) onRename(t);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleRename();
    } else if (e.key === "Escape") {
      onClose();
    }
  };

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 bg-overlay-backdrop/70 flex items-center justify-center z-[1000]"
      onClick={(e) => {
        if (e.target === e.currentTarget) {
          onClose();
        }
      }}
    >
      <div className="bg-surface-modal border border-border-subtle rounded-2xl p-6 min-w-[400px] max-w-[500px] shadow-overlay">
        <h3 className="m-0 mb-4 text-lg font-semibold text-text-primary">
          Rename Chat
        </h3>

        <div className="mb-5">
          <label className="block text-sm font-medium text-text-secondary mb-2">
            Chat Title
          </label>
          <input
            ref={inputRef}
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="Enter chat title..."
            autoFocus
            className="w-full p-3 bg-surface-soft border border-border-subtle rounded-lg
                       text-text-primary text-sm outline-none box-border
                       focus:border-border-brand transition-colors"
          />
        </div>

        <div className="flex gap-3 justify-end">
          <button
            onClick={onClose}
            disabled={isRenaming}
            className="px-5 py-2.5 bg-transparent border border-border-subtle rounded-lg
                       text-text-muted text-sm font-medium
                       cursor-pointer disabled:cursor-not-allowed disabled:opacity-60
                       transition-all"
          >
            Cancel
          </button>
          <button
            onClick={handleRename}
            disabled={!title.trim() || isRenaming}
            className="px-5 py-2.5 border rounded-lg text-sm font-medium
                       flex items-center gap-2 transition-all active:scale-95
                       enabled:bg-intent-success enabled:border-intent-success enabled:text-white enabled:cursor-pointer
                       disabled:bg-surface-highest/60 disabled:border-border-subtle disabled:text-text-muted disabled:cursor-not-allowed"
          >
            {isRenaming && (
              <div className="w-4 h-4 border-2 border-transparent border-t-current rounded-full animate-spin" />
            )}
            {isRenaming ? "Renamingâ€¦" : "Rename"}
          </button>
        </div>
      </div>
    </div>
  );
};

export default RenameDialog;



================================================
FILE: ui/components/SettingsPanel.tsx
================================================
import { useState } from "react";
import { useAtom } from "jotai";
import {
  selectedModelsAtom,
  isVisibleModeAtom,
  powerUserModeAtom,
  isReducedMotionAtom,
  isSettingsOpenAtom,
} from "../state/atoms";
import { LLM_PROVIDERS_CONFIG } from "../constants";
import { useProviderStatus } from "../hooks/providers/useProviderStatus";

export default function SettingsPanel() {
  const [isSettingsOpen, setIsSettingsOpen] = useAtom(isSettingsOpenAtom);
  const [selectedModels, setSelectedModels] = useAtom(selectedModelsAtom);
  const [isVisibleMode, setIsVisibleMode] = useAtom(isVisibleModeAtom);
  const [powerUserMode, setPowerUserMode] = useAtom(powerUserModeAtom);
  const [isReducedMotion, setIsReducedMotion] = useAtom(isReducedMotionAtom);

  // NEW: Hook for auth status
  const { status: providerStatus, manualRefresh } = useProviderStatus();
  const [isRefreshing, setIsRefreshing] = useState(false);

  const handleToggleModel = (providerId: string) => {
    setSelectedModels((prev: any) => ({
      ...prev,
      [providerId]: !prev[providerId],
    }));
  };

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await manualRefresh();
    setTimeout(() => setIsRefreshing(false), 500);
  };

  return (
    <div
      className={`fixed top-0 w-[350px] h-screen bg-surface-highest/95 backdrop-blur-xl border-l border-border-subtle z-[1100] p-5 overflow-y-auto transition-[right] duration-300 ease-out ${isSettingsOpen ? "right-0" : "-right-[350px]"
        }`}
    >
      <div className="settings-header flex items-center justify-between mb-6">
        <h2 className="settings-title text-lg font-semibold text-text-secondary">
          Model Configuration
        </h2>
        <div className="flex items-center gap-2">
          <button
            onClick={handleRefresh}
            title="Check Login Status"
            className={`p-2 bg-none border-none cursor-pointer rounded transition-all duration-300 text-lg ${isRefreshing ? "text-brand-500 rotate-180" : "text-text-muted"
              }`}
          >
            â†»
          </button>
          <button
            className="close-settings p-2 bg-none border-none text-text-muted cursor-pointer rounded transition-colors duration-200 text-lg hover:bg-surface-highlight hover:text-text-secondary"
            onClick={() => setIsSettingsOpen(false)}
          >
            âœ•
          </button>
        </div>
      </div>

      <div className="model-config">
        <div className="flex justify-between items-center mb-3">
          <h3 className="text-sm font-semibold text-text-brand m-0">
            Active Models
          </h3>
        </div>

        {LLM_PROVIDERS_CONFIG.map((provider) => {
          // Default to true if undefined (for providers without specific cookies mapped yet)
          const isAuth = providerStatus[provider.id] !== false;

          return (
            <div
              key={provider.id}
              className={`model-item flex items-center justify-between p-3 bg-chip border border-border-subtle rounded-lg mb-2 transition-all duration-200 ${isAuth ? "opacity-100" : "opacity-60"
                }`}
            >
              <div className="model-info flex items-center gap-2">
                <div
                  className={`model-logo w-4 h-4 rounded ${provider.logoBgClass}`}
                ></div>
                <div className="flex flex-col">
                  <span className="text-text-secondary">{provider.name}</span>
                  {!isAuth && (
                    <span className="text-xs text-intent-danger">
                      Login Required
                    </span>
                  )}
                </div>
              </div>
              <div
                className={`model-toggle relative w-10 h-5 rounded-full cursor-pointer transition-all duration-200 ${selectedModels[provider.id]
                  ? "bg-brand-500"
                  : "bg-border-strong"
                  } ${!isAuth ? "cursor-not-allowed opacity-50" : ""}`}
                onClick={() => isAuth && handleToggleModel(provider.id)}
              >
                <div
                  className={`absolute top-0.5 w-4 h-4 bg-white rounded-full transition-all duration-200 ${selectedModels[provider.id] ? "left-[22px]" : "left-0.5"
                    }`}
                />
              </div>
            </div>
          );
        })}

        <h3 className="text-sm font-semibold mb-3 text-text-brand mt-5">
          Execution Mode
        </h3>
        <div className="mode-item flex items-center justify-between p-3 bg-chip border border-border-subtle rounded-lg mb-2">
          <span className="text-text-secondary">
            Run in Visible Tabs (for debugging)
          </span>
          <div
            onClick={() => setIsVisibleMode(!isVisibleMode)}
            className={`relative w-10 h-5 rounded-full cursor-pointer transition-all duration-200 ${isVisibleMode ? "bg-brand-500" : "bg-border-strong"
              }`}
          >
            <div
              className={`absolute top-0.5 w-4 h-4 bg-white rounded-full transition-all duration-200 ${isVisibleMode ? "left-[22px]" : "left-0.5"
                }`}
            />
          </div>
        </div>

        <h3 className="text-sm font-semibold mb-3 text-text-brand mt-5">
          Advanced Features
        </h3>
        <div className="mode-item flex items-center justify-between p-3 bg-chip border border-border-subtle rounded-lg mb-2">
          <div className="flex flex-col">
            <span className="text-text-secondary">Power User Mode</span>
            <span className="text-xs text-text-muted mt-0.5">
              Enable multi-synthesis selection
            </span>
          </div>
          <div
            className={`mode-toggle relative w-10 h-5 rounded-full cursor-pointer transition-all duration-200 ${powerUserMode ? "bg-brand-500" : "bg-border-strong"
              }`}
            onClick={() => setPowerUserMode(!powerUserMode)}
          >
            <div
              className={`absolute top-0.5 w-4 h-4 bg-white rounded-full transition-all duration-200 ${powerUserMode ? "left-[22px]" : "left-0.5"
                }`}
            />
          </div>
        </div>

        <h3 className="text-sm font-semibold mb-3 text-text-brand mt-5">
          Accessibility
        </h3>
        <div className="mode-item flex items-center justify-between p-3 bg-chip border border-border-subtle rounded-lg mb-2">
          <span className="text-text-secondary">Reduced Motion</span>
          <div
            className={`mode-toggle relative w-10 h-5 rounded-full cursor-pointer transition-all duration-200 ${isReducedMotion ? "bg-brand-500" : "bg-border-strong"
              }`}
            onClick={() => setIsReducedMotion(!isReducedMotion)}
          >
            <div
              className={`absolute top-0.5 w-4 h-4 bg-white rounded-full transition-all duration-200 ${isReducedMotion ? "left-[22px]" : "left-0.5"
                }`}
            />
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: ui/components/SplitPaneRightPanel.tsx
================================================
import React from "react";
import { useAtomValue, useSetAtom } from "jotai";
import { activeSplitPanelAtom, currentSessionIdAtom } from "../state/atoms";
import { ModelResponsePanel } from "./ModelResponsePanel";

export const SplitPaneRightPanel = React.memo(() => {
    const panelState = useAtomValue(activeSplitPanelAtom);
    const setActivePanel = useSetAtom(activeSplitPanelAtom);
    const sessionId = useAtomValue(currentSessionIdAtom);

    if (!panelState) return null;

    return (
        <div className="h-full w-full min-w-0 flex flex-col bg-surface-raised border-l border-border-subtle overflow-hidden">
            <ModelResponsePanel
                turnId={panelState.turnId}
                providerId={panelState.providerId}
                sessionId={sessionId || undefined}
                onClose={() => setActivePanel(null)}
            />
        </div>
    );
});



================================================
FILE: ui/components/Toast.tsx
================================================
import  { useEffect } from 'react';
import { useAtom } from 'jotai';
import { toastAtom } from '../state/atoms';
import clsx from 'clsx';

export function Toast() {
    const [toast, setToast] = useAtom(toastAtom);

    useEffect(() => {
        if (toast) {
            const timer = setTimeout(() => {
                setToast(null);
            }, 2000);
            return () => clearTimeout(timer);
        }
    }, [toast, setToast]);

    if (!toast) return null;

    return (
        <div className="fixed bottom-4 right-4 z-[2000] animate-[slideInUp_0.2s_ease-out]">
            <div className={clsx(
                "bg-surface-raised border border-border-subtle rounded-lg px-3 py-2 text-sm text-text-primary shadow-card-sm flex items-center gap-2",
                toast.type === 'success' && "border-intent-success/30",
                toast.type === 'error' && "border-intent-danger/30"
            )}>
                {toast.type === 'success' && <span className="text-intent-success">âœ“</span>}
                {toast.type === 'error' && <span className="text-intent-danger">âœ•</span>}
                {toast.type === 'info' && <span className="text-brand-400">â„¹</span>}
                {toast.message}
            </div>
        </div>
    );
}



================================================
FILE: ui/components/UserTurnBlock.tsx
================================================
import React, { useCallback } from "react";
import { useAtom } from "jotai";
import { turnExpandedStateFamily } from "../state/atoms";
import { UserTurn } from "../types";
import { UserIcon, ChevronDownIcon, ChevronUpIcon } from "./Icons";
import MarkdownDisplay from "./MarkdownDisplay";
import { CopyButton } from "./CopyButton";
import clsx from "clsx";


interface UserTurnBlockProps {
  userTurn: UserTurn;

}

const UserTurnBlock = ({
  userTurn,
}: UserTurnBlockProps) => {
  const [isExpanded, setIsExpanded] = useAtom(turnExpandedStateFamily(userTurn.id));
  const onToggle = useCallback(() => setIsExpanded((prev) => !prev), [setIsExpanded]);

  const date = new Date(userTurn.createdAt);
  const readableTimestamp = date.toLocaleString(undefined, {
    dateStyle: "medium",
    timeStyle: "short",
  });
  const isoTimestamp = date.toISOString();

  return (
    <div
      className="user-turn-block flex gap-3 p-3 bg-surface-raised border border-border-subtle rounded-2xl mx-auto max-w-3xl"
    >
      <div className="user-avatar w-8 h-8 rounded-lg bg-brand-500/20 flex items-center justify-center flex-shrink-0">
        <UserIcon className="w-4.5 h-4.5 text-brand-500" />
      </div>
      <div className="user-content flex-1 min-w-0 flex flex-col overflow-x-hidden min-h-[80px]">
        <div
          className={clsx(
            "flex justify-between items-center cursor-pointer",
            isExpanded ? "mb-2" : "mb-0"
          )}
          onClick={onToggle}
        >
          <span className="text-xs font-semibold text-text-secondary">
            Your Prompt
          </span>
          {isExpanded ? (
            <ChevronUpIcon className="w-4 h-4 text-text-secondary" />
          ) : (
            <ChevronDownIcon className="w-4 h-4 text-text-secondary" />
          )}
        </div>

        {isExpanded ? (
          <>
            {/* Prose wrapper for consistent line width */}
            <div className="mx-auto max-w-3xl w-full">
              <div
                className="user-message text-base leading-relaxed text-text-primary break-words mb-2"
                style={{ overflowWrap: "anywhere" }}
              >
                <MarkdownDisplay content={String(userTurn.text || "")} />
              </div>
            </div>
            <div className="user-metadata flex items-center gap-3 text-xs text-text-muted">
              <span
                className="timestamp"
                title={isoTimestamp}
                aria-label={`Sent at ${readableTimestamp}`}
              >
                {readableTimestamp}
              </span>
              {userTurn.sessionId && (
                <span className="session-id" title={userTurn.sessionId}>
                  Session: {userTurn.sessionId.slice(-6)}
                </span>
              )}
            </div>
            <div className="mt-auto flex justify-end">
              <CopyButton text={userTurn.text} label="Copy user prompt" buttonText="Copy" />
            </div>
          </>
        ) : (
          <div className="mx-auto max-w-3xl w-full">
            <div
              className="user-message-preview text-base text-text-secondary overflow-hidden pt-1 mb-1 line-clamp-3 break-words"
              style={{ overflowWrap: "anywhere" }}
            >
              <MarkdownDisplay content={String(userTurn.text || "")} />
            </div>
          </div>
        )}

        {!isExpanded && (
          <div className="mt-auto flex justify-end">
            <CopyButton
              text={String(userTurn.text || "")}
              label="Copy user prompt"
              buttonText="Copy"
            />
          </div>
        )}
      </div>
    </div >
  );
};

export default React.memo(UserTurnBlock);



================================================
FILE: ui/components/WelcomeScreen.tsx
================================================
import { EXAMPLE_PROMPT } from "../constants";
import logoIcon from "../assets/logos/logo-icon.png";
import { useProviderStatus } from "../hooks/providers/useProviderStatus";
import { useSmartProviderDefaults } from "../hooks/providers/useSmartProviderDefaults";

interface WelcomeScreenProps {
  onSendPrompt?: (prompt: string) => void;
  isLoading?: boolean;
}

const WelcomeScreen = ({ onSendPrompt, isLoading }: WelcomeScreenProps) => {
  useProviderStatus();
  useSmartProviderDefaults();

  return (
    <div className="flex flex-col items-center justify-center h-full text-center p-10 pb-40 relative">
      {/* Orb Icon */}
      <img
        src={logoIcon}
        alt="Singularity AI"
        className="h-32 w-32 mb-6"
      />

      {/* Brand Text */}
      <h1 className="text-4xl font-semibold tracking-[0.15em] mb-2 uppercase">
        <span className="text-white">SINGULAR</span>
        <span className="text-brand-400">ITY AI</span>
      </h1>

      <h2 className="text-xl font-medium mb-3 text-text-primary">
        Intelligence Augmentation
      </h2>

      <p className="text-base text-text-muted mb-8 max-w-md">
        Ask one question, get synthesized insights from multiple AI models in
        real-time
      </p>

      {onSendPrompt && (
        <button
          onClick={() => onSendPrompt(EXAMPLE_PROMPT)}
          disabled={isLoading}
          className="text-sm text-text-brand px-4 py-2
                     border border-text-brand rounded-lg
                     bg-chip-soft hover:bg-surface-highlight
                     disabled:cursor-not-allowed disabled:opacity-50
                     transition-all duration-200"
        >
          Try: "{EXAMPLE_PROMPT}"
        </button>
      )}
    </div>
  );
};

export default WelcomeScreen;



================================================
FILE: ui/components/antagonist/antagonist.css
================================================
/* Antagonist Card Styles */

.antagonist-card {
  background: var(--surface-raised, #1a1a1a);
  border-radius: 12px;
  border: 1px solid var(--border-subtle, rgba(255, 255, 255, 0.1));
  padding: 16px;
  margin-top: 12px;
  position: relative;
}

.antagonist-card-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.antagonist-card-header h4 {
  font-size: 14px;
  font-weight: 600;
  margin: 0;
  color: var(--text-primary, #fff);
  display: flex;
  align-items: center;
  gap: 8px;
}

.antagonist-icon {
  font-size: 16px;
}

.antagonist-prompt-section {
  background: var(--surface-base, rgba(0, 0, 0, 0.3));
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 12px;
}

.antagonist-prompt-text {
  font-size: 14px;
  line-height: 1.6;
  color: var(--text-primary, #fff);
  margin: 0 0 12px 0;
}

.antagonist-grounding {
  font-size: 13px;
  color: var(--text-muted, rgba(255, 255, 255, 0.6));
  font-style: italic;
  margin-bottom: 8px;
  padding-left: 12px;
  border-left: 2px solid var(--border-accent, #6366f1);
}

.antagonist-payoff {
  font-size: 13px;
  color: var(--text-accent, #a78bfa);
  margin-top: 8px;
}

/* Dimension dropdown styles */
.dimension-dropdown-container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 12px;
}

.dimension-dropdown {
  position: relative;
  display: inline-flex;
  flex-direction: column;
  min-width: 140px;
}

.dimension-dropdown-trigger {
  background: var(--surface-elevated, rgba(99, 102, 241, 0.15));
  border: 1px solid var(--border-accent, rgba(99, 102, 241, 0.4));
  border-radius: 6px;
  padding: 6px 12px;
  font-size: 13px;
  color: var(--text-accent, #a78bfa);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  transition: all 0.2s ease;
}

.dimension-dropdown-trigger:hover {
  background: var(--surface-elevated, rgba(99, 102, 241, 0.25));
  border-color: var(--border-accent, rgba(99, 102, 241, 0.6));
}

.dimension-dropdown-menu {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  right: 0;
  background: var(--surface-raised, #1c1c1c);
  border: 1px solid var(--border-subtle, rgba(255, 255, 255, 0.15));
  border-radius: 8px;
  padding: 4px;
  z-index: 100;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}

.dimension-dropdown-option {
  padding: 8px 12px;
  font-size: 13px;
  color: var(--text-secondary, rgba(255, 255, 255, 0.8));
  cursor: pointer;
  border-radius: 6px;
  transition: background 0.15s ease;
}

.dimension-dropdown-option:hover {
  background: var(--surface-hover, rgba(255, 255, 255, 0.08));
}

.dimension-dropdown-option.selected {
  background: var(--surface-accent, rgba(99, 102, 241, 0.2));
  color: var(--text-accent, #a78bfa);
}

.dimension-label {
  font-size: 11px;
  color: var(--text-muted, rgba(255, 255, 255, 0.5));
  margin-bottom: 4px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Missed approaches section */
.antagonist-audit-section {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid var(--border-subtle, rgba(255, 255, 255, 0.08));
}

.antagonist-audit-header {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-muted, rgba(255, 255, 255, 0.6));
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.missed-approach-item {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  padding: 8px 0;
  font-size: 13px;
}

.missed-approach-label {
  color: var(--text-primary, #fff);
}

.missed-approach-source {
  color: var(--text-muted, rgba(255, 255, 255, 0.5));
  font-size: 12px;
}

/* Actions */
.antagonist-actions {
  display: flex;
  gap: 8px;
  margin-top: 16px;
}

.antagonist-copy-btn {
  background: var(--surface-accent, rgba(99, 102, 241, 0.15));
  border: 1px solid var(--border-accent, rgba(99, 102, 241, 0.4));
  border-radius: 6px;
  padding: 8px 16px;
  font-size: 13px;
  color: var(--text-accent, #a78bfa);
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 6px;
}

.antagonist-copy-btn:hover {
  background: var(--surface-accent, rgba(99, 102, 241, 0.25));
}

/* Selector dropdown */
.antagonist-selector {
  position: relative;
}

.antagonist-selector-trigger {
  background: transparent;
  border: none;
  font-size: 12px;
  color: var(--text-muted, rgba(255, 255, 255, 0.6));
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  gap: 4px;
  transition: all 0.15s ease;
}

.antagonist-selector-trigger:hover {
  background: rgba(255, 255, 255, 0.05);
  color: var(--text-primary, #fff);
}

.antagonist-selector-menu {
  position: absolute;
  top: calc(100% + 4px);
  right: 0;
  min-width: 180px;
  background: var(--surface-raised, #1a1a1a);
  border: 1px solid var(--border-subtle, rgba(255, 255, 255, 0.15));
  border-radius: 8px;
  padding: 4px;
  z-index: 3600;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}

.antagonist-selector-option {
  padding: 8px 12px;
  font-size: 13px;
  color: var(--text-secondary, rgba(255, 255, 255, 0.8));
  cursor: pointer;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  transition: background 0.15s ease;
}

.antagonist-selector-option:hover {
  background: var(--surface-hover, rgba(255, 255, 255, 0.08));
}

.antagonist-selector-option.active {
  background: var(--surface-accent, rgba(99, 102, 241, 0.2));
}

.antagonist-selector-option.loading {
  opacity: 0.6;
  cursor: wait;
}

/* Null state (decision is obvious) */
.antagonist-null-state {
  font-size: 14px;
  color: var(--text-muted, rgba(255, 255, 255, 0.6));
  text-align: center;
  padding: 16px;
}

/* Chevron icon */
.chevron-icon {
  width: 12px;
  height: 12px;
  transition: transform 0.2s ease;
}

.chevron-icon.open {
  transform: rotate(180deg);
}



================================================
FILE: ui/components/antagonist/AntagonistCard.tsx
================================================
import React, { useState, useMemo, useCallback } from "react";
import { AiTurn } from "../../types";
import { useAntagonistOutput } from "../../hooks/useAntagonistOutput";
import { parseBrackets, buildFinalPrompt, ParsedBracket } from "../../../shared/parsing-utils";
import { AntagonistSelector } from "./AntagonistSelector";
import { DimensionDropdown } from "./DimensionDropdown";
import "./antagonist.css";

interface AntagonistCardProps {
    aiTurn: AiTurn;
    activeProviderId?: string;
    onProviderSelect?: (pid: string) => void;
}

export const AntagonistCard: React.FC<AntagonistCardProps> = ({
    aiTurn,
    activeProviderId,
    onProviderSelect,
}) => {
    const { output, isLoading, providerId } = useAntagonistOutput(aiTurn.id, activeProviderId);
    const [selections, setSelections] = useState<Record<string, string>>({});
    const [copied, setCopied] = useState(false);

    // Parse brackets from prompt text
    const brackets = useMemo(() => {
        if (!output?.the_prompt?.text) return [];
        return parseBrackets(output.the_prompt.text);
    }, [output?.the_prompt?.text]);

    // Build final prompt with selections
    const finalPrompt = useMemo(() => {
        if (!output?.the_prompt?.text) return "";
        return buildFinalPrompt(output.the_prompt.text, selections);
    }, [output?.the_prompt?.text, selections]);

    // Handle dimension selection
    const handleDimensionSelect = useCallback((variable: string, value: string) => {
        setSelections(prev => ({ ...prev, [variable]: value }));
    }, []);

    // Copy to clipboard
    const handleCopy = useCallback(async () => {
        try {
            await navigator.clipboard.writeText(finalPrompt);
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
        } catch (e) {
            console.error("Failed to copy", e);
        }
    }, [finalPrompt]);

    // Handle provider change
    const handleProviderChange = useCallback((pid: string) => {
        if (onProviderSelect) {
            onProviderSelect(pid);
        }
    }, [onProviderSelect]);

    // Loading state
    if (isLoading) {
        return (
            <div className="antagonist-card">
                <div className="antagonist-card-header">
                    <h4><span className="antagonist-icon">💭</span> Refining your question...</h4>
                </div>
                <div style={{ opacity: 0.6, fontSize: 14 }}>Analyzing context...</div>
            </div>
        );
    }

    // No output yet
    if (!output) {
        return null; // Don't render card if no antagonist output
    }

    // Null state (decision is already obvious)
    if (output.the_prompt.text === null) {
        const hasMissed = output.the_audit.missed.length > 0;
        if (!hasMissed) return null; // Nothing to show

        return (
            <div className="antagonist-card">
                <div className="antagonist-card-header">
                    <h4><span className="antagonist-icon">💭</span> Context Check</h4>
                    <AntagonistSelector
                        aiTurn={aiTurn}
                        activeProviderId={providerId || undefined}
                        onSelect={handleProviderChange}
                    />
                </div>
                <div className="antagonist-null-state">
                    Decision path is clear — no additional context needed.
                </div>
                {hasMissed && (
                    <div className="antagonist-audit-section">
                        <div className="antagonist-audit-header">
                            <span>🔍</span> Missed Approaches
                        </div>
                        {output.the_audit.missed.map((m, idx) => (
                            <div key={idx} className="missed-approach-item">
                                <span className="missed-approach-label">{m.approach}</span>
                                <span className="missed-approach-source">— {m.source}</span>
                            </div>
                        ))}
                    </div>
                )}
            </div>
        );
    }

    return (
        <div className="antagonist-card">
            <div className="antagonist-card-header">
                <h4><span className="antagonist-icon">💭</span> Get Targeted Advice</h4>
                <AntagonistSelector
                    aiTurn={aiTurn}
                    activeProviderId={providerId || undefined}
                    onSelect={handleProviderChange}
                />
            </div>

            {/* Prompt Section */}
            <div className="antagonist-prompt-section">
                {output.the_prompt.grounding && (
                    <div className="antagonist-grounding">
                        {output.the_prompt.grounding}
                    </div>
                )}

                <div className="antagonist-prompt-text">
                    {/* Display prompt with interactive dropdowns */}
                    {brackets.length > 0 ? (
                        renderInteractivePrompt(output.the_prompt.text, brackets, selections, handleDimensionSelect)
                    ) : (
                        output.the_prompt.text
                    )}
                </div>

                {output.the_prompt.payoff && (
                    <div className="antagonist-payoff">
                        → {output.the_prompt.payoff}
                    </div>
                )}
            </div>

            {/* Dimension Dropdowns */}
            {output.the_prompt.dimensions.length > 0 && (
                <div className="dimension-dropdown-container">
                    {output.the_prompt.dimensions.map((dim, idx) => {
                        const options = dim.options.split("/").map(o => o.trim());
                        return (
                            <DimensionDropdown
                                key={idx}
                                variable={dim.variable}
                                options={options}
                                selectedValue={selections[dim.variable] || null}
                                onSelect={(value) => handleDimensionSelect(dim.variable, value)}
                            />
                        );
                    })}
                </div>
            )}

            {/* Actions */}
            <div className="antagonist-actions">
                <button
                    className="antagonist-copy-btn"
                    onClick={handleCopy}
                >
                    {copied ? "✓ Copied" : "📋 Copy Prompt"}
                </button>
            </div>

            {/* Missed Approaches */}
            {output.the_audit.missed.length > 0 && (
                <div className="antagonist-audit-section">
                    <div className="antagonist-audit-header">
                        <span>🔍</span> Missed Approaches
                    </div>
                    {output.the_audit.missed.map((m, idx) => (
                        <div key={idx} className="missed-approach-item">
                            <span className="missed-approach-label">{m.approach}</span>
                            <span className="missed-approach-source">— {m.source}</span>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
};

/**
 * Render prompt text with interactive dropdowns for bracket variables
 */
function renderInteractivePrompt(
    text: string,
    brackets: ParsedBracket[],
    selections: Record<string, string>,
    onSelect: (variable: string, value: string) => void
): React.ReactNode[] {
    const result: React.ReactNode[] = [];
    let lastIndex = 0;

    brackets.forEach((bracket, idx) => {
        // Text before this bracket
        if (bracket.startIndex > lastIndex) {
            result.push(text.substring(lastIndex, bracket.startIndex));
        }

        // The interactive dropdown
        result.push(
            <span key={`dropdown-${idx}`} style={{ display: "inline-flex", verticalAlign: "middle" }}>
                <DimensionDropdown
                    variable={bracket.variable}
                    options={bracket.options}
                    selectedValue={selections[bracket.variable] || null}
                    onSelect={(value) => onSelect(bracket.variable, value)}
                />
            </span>
        );

        lastIndex = bracket.endIndex;
    });

    // Text after last bracket
    if (lastIndex < text.length) {
        result.push(text.substring(lastIndex));
    }

    return result;
}

export default AntagonistCard;



================================================
FILE: ui/components/antagonist/AntagonistSelector.tsx
================================================
import React, { useState, useRef, useEffect, useMemo } from "react";
import { useAtomValue } from "jotai";
import clsx from "clsx";
import { providerAuthStatusAtom } from "../../state/atoms";
import { LLM_PROVIDERS_CONFIG } from "../../constants";
import { AiTurn, LLMProvider } from "../../types";
import { useClipActions } from "../../hooks/useClipActions";
import "./antagonist.css";

interface AntagonistSelectorProps {
    aiTurn: AiTurn;
    activeProviderId?: string;
    onSelect: (pid: string) => void;
}

export const AntagonistSelector: React.FC<AntagonistSelectorProps> = ({
    aiTurn,
    activeProviderId,
    onSelect,
}) => {
    const [isOpen, setIsOpen] = useState(false);
    const { handleClipClick } = useClipActions();
    const authStatus = useAtomValue(providerAuthStatusAtom);
    const menuRef = useRef<HTMLDivElement>(null);

    // Close on outside click
    useEffect(() => {
        const handleClickOutside = (e: MouseEvent) => {
            if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
                setIsOpen(false);
            }
        };
        if (isOpen) {
            document.addEventListener("mousedown", handleClickOutside);
        }
        return () => document.removeEventListener("mousedown", handleClickOutside);
    }, [isOpen]);

    const activeProvider = activeProviderId ? LLM_PROVIDERS_CONFIG.find(p => String(p.id) === activeProviderId) : null;
    const providers = useMemo(() => LLM_PROVIDERS_CONFIG.filter((p: LLMProvider) => p.id !== "system"), []);

    // Get existing antagonist responses for this turn
    const existingProviderIds = useMemo(() => {
        return Object.keys(aiTurn.antagonistResponses || {});
    }, [aiTurn.antagonistResponses]);

    return (
        <div className="antagonist-selector" ref={menuRef}>
            <button
                type="button"
                onClick={() => setIsOpen(!isOpen)}
                className="antagonist-selector-trigger"
            >
                <span>{activeProvider?.name || "Select Model"}</span>
                <svg className={clsx("chevron-icon", isOpen && "open")} viewBox="0 0 12 12" fill="currentColor">
                    <path d="M2 4L6 8L10 4" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
                </svg>
            </button>

            {isOpen && (
                <div className="antagonist-selector-menu">
                    {providers.map((p: LLMProvider) => {
                        const pid = String(p.id);
                        const isActive = pid === activeProviderId;
                        const isUnauthorized = authStatus && authStatus[pid] === false;
                        const hasExisting = existingProviderIds.includes(pid);

                        return (
                            <button
                                key={pid}
                                onClick={() => {
                                    if (!isUnauthorized) {
                                        onSelect(pid);
                                        handleClipClick(aiTurn.id, "antagonist", pid);
                                        setIsOpen(false);
                                    }
                                }}
                                disabled={isUnauthorized}
                                className={clsx(
                                    "antagonist-selector-option",
                                    isActive && "active",
                                    isUnauthorized && "disabled"
                                )}
                            >
                                <span>{p.name}</span>
                                {hasExisting && <span style={{ opacity: 0.5, fontSize: "11px" }}>âœ“</span>}
                            </button>
                        );
                    })}
                </div>
            )}
        </div>
    );
};



================================================
FILE: ui/components/antagonist/DimensionDropdown.tsx
================================================
import React, { useState, useRef, useEffect } from "react";
import clsx from "clsx";
import "./antagonist.css";

interface DimensionDropdownProps {
    variable: string;
    options: string[];
    selectedValue: string | null;
    onSelect: (value: string) => void;
}

export const DimensionDropdown: React.FC<DimensionDropdownProps> = ({
    variable,
    options,
    selectedValue,
    onSelect,
}) => {
    const [isOpen, setIsOpen] = useState(false);
    const menuRef = useRef<HTMLDivElement>(null);

    // Close on outside click
    useEffect(() => {
        const handleClickOutside = (e: MouseEvent) => {
            if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
                setIsOpen(false);
            }
        };
        if (isOpen) {
            document.addEventListener("mousedown", handleClickOutside);
        }
        return () => document.removeEventListener("mousedown", handleClickOutside);
    }, [isOpen]);

    const displayValue = selectedValue || options[0] || "Select...";

    return (
        <div className="dimension-dropdown" ref={menuRef}>
            <span className="dimension-label">{variable}</span>
            <button
                type="button"
                onClick={() => setIsOpen(!isOpen)}
                className="dimension-dropdown-trigger"
            >
                <span>{displayValue}</span>
                <svg className={clsx("chevron-icon", isOpen && "open")} viewBox="0 0 12 12" fill="currentColor">
                    <path d="M2 4L6 8L10 4" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
                </svg>
            </button>

            {isOpen && (
                <div className="dimension-dropdown-menu">
                    {options.map((option, idx) => (
                        <button
                            key={idx}
                            onClick={() => {
                                onSelect(option);
                                setIsOpen(false);
                            }}
                            className={clsx(
                                "dimension-dropdown-option",
                                selectedValue === option && "selected"
                            )}
                        >
                            {option}
                        </button>
                    ))}
                </div>
            )}
        </div>
    );
};



================================================
FILE: ui/components/antagonist/index.ts
================================================
export { AntagonistCard } from "./AntagonistCard";
export { AntagonistSelector } from "./AntagonistSelector";
export { DimensionDropdown } from "./DimensionDropdown";



================================================
FILE: ui/components/refinerui/RefinerCardsSection.tsx
================================================
/**
 * RefinerCardsSection - Container components for refiner output display.
 * Updated for signal-based RefinerOutput structure.
 */

import React, { useState } from "react";
import { RefinerOutput } from "../../../shared/parsing-utils";
import { SignalCard } from "./SignalCard";
import { categorizeSignals, getSignalCounts } from "../../utils/signalUtils";

interface RefinerSectionProps {
    output: RefinerOutput;
    className?: string;
}

/**
 * Renders a compact summary of critical signals.
 * Intended for insertion directly below the synthesis bubble in the chat stream.
 */
export const RefinerSynthesisAccuracy: React.FC<RefinerSectionProps> = ({ output, className = "" }) => {
    const { blockerSignals, riskSignals } = categorizeSignals(output.signals);

    // Only show if there are blockers or risks
    if (blockerSignals.length === 0 && riskSignals.length === 0) return null;

    return (
        <div className={`mt-2 space-y-2 ${className}`}>
            {blockerSignals.slice(0, 2).map((signal, idx) => (
                <SignalCard key={`b-${idx}`} signal={signal} variant="compact" />
            ))}
            {riskSignals.slice(0, 2).map((signal, idx) => (
                <SignalCard key={`r-${idx}`} signal={signal} variant="compact" />
            ))}
        </div>
    );
};

/**
 * Renders the full epistemic audit (all signals, next step, etc.).
 * Intended for the Decision Map Sheet.
 */
interface RefinerAuditProps extends RefinerSectionProps {
    rawText?: string;
}

export const RefinerEpistemicAudit: React.FC<RefinerAuditProps> = ({ output, rawText, className = "" }) => {
    const [showRaw, setShowRaw] = useState(false);

    const { blockerSignals, riskSignals, enhancementSignals } = categorizeSignals(output.signals);
    const counts = getSignalCounts(output.signals);
    const unlistedOptions = output.unlistedOptions || [];

    return (
        <div className={`flex flex-col gap-6 p-6 ${className}`}>
            {/* Header / Summary */}
            <div className="flex items-center justify-between pb-4 border-b border-white/10">
                <div className="flex items-center gap-3">
                    <span className="text-sm uppercase font-bold text-indigo-400 tracking-wider">Epistemic Audit</span>
                    <div className="flex gap-2">
                        {counts.blockers > 0 && (
                            <span className="px-2 py-0.5 text-xs rounded-full bg-intent-danger/20 text-intent-danger">
                                {counts.blockers} blocker{counts.blockers > 1 ? 's' : ''}
                            </span>
                        )}
                        {counts.risks > 0 && (
                            <span className="px-2 py-0.5 text-xs rounded-full bg-intent-warning/20 text-intent-warning">
                                {counts.risks} risk{counts.risks > 1 ? 's' : ''}
                            </span>
                        )}
                        {counts.enhancements > 0 && (
                            <span className="px-2 py-0.5 text-xs rounded-full bg-brand-500/20 text-brand-400">
                                {counts.enhancements} enhancement{counts.enhancements > 1 ? 's' : ''}
                            </span>
                        )}
                    </div>
                </div>
            </div>

            {/* Blocker Signals */}
            {blockerSignals.length > 0 && (
                <div>
                    <h3 className="text-xs uppercase font-bold text-intent-danger mb-3 tracking-wider flex items-center gap-2">
                        <span className="w-2 h-2 rounded-full bg-intent-danger" />
                        Blockers
                    </h3>
                    <div className="space-y-2">
                        {blockerSignals.map((signal, idx) => (
                            <SignalCard key={idx} signal={signal} />
                        ))}
                    </div>
                </div>
            )}

            {/* Risk Signals */}
            {riskSignals.length > 0 && (
                <div>
                    <h3 className="text-xs uppercase font-bold text-intent-warning mb-3 tracking-wider flex items-center gap-2">
                        <span className="w-2 h-2 rounded-full bg-intent-warning" />
                        Risks to Review
                    </h3>
                    <div className="space-y-2">
                        {riskSignals.map((signal, idx) => (
                            <SignalCard key={idx} signal={signal} />
                        ))}
                    </div>
                </div>
            )}

            {/* Enhancement Signals */}
            {enhancementSignals.length > 0 && (
                <div>
                    <h3 className="text-xs uppercase font-bold text-brand-400 mb-3 tracking-wider flex items-center gap-2">
                        <span className="w-2 h-2 rounded-full bg-brand-400" />
                        Enhancements
                    </h3>
                    <div className="space-y-2">
                        {enhancementSignals.map((signal, idx) => (
                            <SignalCard key={idx} signal={signal} />
                        ))}
                    </div>
                </div>
            )}

            {/* Unlisted Options */}
            {unlistedOptions.length > 0 && (
                <div>
                    <h3 className="text-xs uppercase font-bold text-white/50 mb-3 tracking-wider">
                        Unlisted Options
                    </h3>
                    <div className="space-y-2">
                        {unlistedOptions.map((opt, idx) => (
                            <div key={idx} className="p-3 bg-white/5 border border-white/10 rounded-lg">
                                <div className="text-sm font-medium text-white">{opt.title}</div>
                                <div className="text-xs text-white/70 mt-1">{opt.description}</div>
                                {opt.source && (
                                    <div className="text-xs text-white/40 mt-1">Source: {opt.source}</div>
                                )}
                            </div>
                        ))}
                    </div>
                </div>
            )}

            {/* Next Step */}
            {output.leap && output.leap.target && (
                <div className="bg-brand-500/10 border border-brand-500/20 rounded-xl p-5">
                    <div className="flex items-center gap-2 mb-2">
                        <span className="w-2 h-2 rounded-full bg-brand-400" />
                        <h4 className="text-xs font-bold text-brand-400 uppercase tracking-wider">Next Step</h4>
                    </div>
                    <div className="text-sm text-white/90">
                        <strong className="text-brand-400 capitalize">{output.leap.action}:</strong>{' '}
                        {output.leap.target}
                    </div>
                    {output.leap.why && (
                        <div className="text-xs text-white/60 mt-2">{output.leap.why}</div>
                    )}
                </div>
            )}

            {/* Reframe Suggestion */}
            {output.reframe && (
                <div className="bg-violet-500/10 border border-violet-500/20 rounded-xl p-5">
                    <div className="flex items-center gap-2 mb-2">
                        <span className="w-2 h-2 rounded-full bg-violet-400" />
                        <h4 className="text-xs font-bold text-violet-400 uppercase tracking-wider">Reframe Suggested</h4>
                    </div>
                    {output.reframe.issue && (
                        <div className="text-xs text-violet-200/70 mb-2">{output.reframe.issue}</div>
                    )}
                    <div className="text-sm text-white/90">"{output.reframe.suggestion}"</div>
                    {output.reframe.unlocks && (
                        <div className="text-xs text-violet-300 mt-2">
                            <span className="opacity-70">Unlocks:</span> {output.reframe.unlocks}
                        </div>
                    )}
                </div>
            )}

            {/* Raw Text (Collapsed by default) */}
            {rawText && (
                <div className="mt-2 pt-4 border-t border-white/10">
                    <button
                        onClick={() => setShowRaw(!showRaw)}
                        className="flex items-center justify-between w-full text-left group"
                    >
                        <span className="text-xs uppercase font-bold text-white/40 group-hover:text-white/70 transition-colors tracking-wider">
                            Raw Refiner Response
                        </span>
                        <span className="text-white/40 text-xs">
                            {showRaw ? "Collapse" : "View Raw"}
                        </span>
                    </button>

                    {showRaw && (
                        <div className="mt-4 bg-black/40 rounded-lg p-4 font-mono text-xs text-white/60 whitespace-pre-wrap border border-white/10 overflow-x-auto">
                            {rawText}
                        </div>
                    )}
                </div>
            )}
        </div>
    );
};




================================================
FILE: ui/components/refinerui/RefinerDot.tsx
================================================
// ui/components/refinerui/RefinerDot.tsx
// Replaces TrustIcon with a simple dot UI following the new paradigm

import React, { useState, useCallback } from 'react';
import type { RefinerOutput } from '../../../shared/parsing-utils';
import { shortenInsight } from '../../utils/refiner-helpers';

interface RefinerDotProps {
    refiner: RefinerOutput | null;
    onClick: () => void;
    isActive?: boolean;
    isLoading?: boolean;
}

type DotState = 'pending' | 'loading' | 'complete_no_gem' | 'active';

function getDotState(isLoading: boolean | undefined, refiner: RefinerOutput | null): DotState {
    if (isLoading && !refiner) return 'loading';
    if (refiner?.gem) return 'active';
    if (refiner) return 'complete_no_gem';
    if (isLoading) return 'loading';
    return 'pending';
}

export const RefinerDot: React.FC<RefinerDotProps> = ({ refiner, onClick, isActive, isLoading }) => {
    const [hovering, setHovering] = useState(false);
    const dotState = getDotState(isLoading, refiner);
    const hasGem = refiner?.gem != null;

    const handleMouseEnter = useCallback(() => setHovering(true), []);
    const handleMouseLeave = useCallback(() => setHovering(false), []);

    return (
        <div className="refiner-dot-container relative flex items-center gap-2">
            <button
                onClick={onClick}
                onMouseEnter={handleMouseEnter}
                onMouseLeave={handleMouseLeave}
                className={`
                    refiner-dot relative w-6 h-6 rounded-full flex items-center justify-center text-[10px]
                    transition-all duration-300 ease-out cursor-pointer
                    focus:outline-none focus:ring-2 focus:ring-brand-500/50 focus:ring-offset-2 focus:ring-offset-surface
                    ${dotState === 'active'
                        ? 'bg-white/90 border border-black/20 shadow-[0_0_10px_rgba(255,255,255,0.7)]'
                        : dotState === 'complete_no_gem'
                            ? 'bg-white/50 border border-black/15 shadow-[0_0_6px_rgba(255,255,255,0.5)]'
                            : dotState === 'loading'
                                ? 'bg-white/40 border border-black/10 animate-pulse'
                                : 'bg-white/20 border border-black/10'
                    }
                    ${isActive ? 'ring-2 ring-brand-500/60' : ''}
                `}
                aria-label={hasGem ? "View gem insight" : "View synthesis+"}
            >
                {hasGem ? (
                    <span className="pointer-events-none">ðŸ’Ž</span>
                ) : (
                    <span className="pointer-events-none text-[9px] text-text-muted">â—Ž</span>
                )}
            </button>
            {hovering && hasGem && (
                <div
                    className="
                        absolute top-full left-0 mt-2 
                        bg-surface-raised border border-border-subtle 
                        rounded-lg shadow-elevated px-3 py-2
                        text-xs text-text-primary max-w-[280px]
                        animate-in fade-in zoom-in-95 duration-150
                        z-50
                    "
                >
                    <div className="flex flex-col gap-1">
                        <div className="flex items-start gap-2">
                            <span className="text-sm flex-shrink-0">ðŸ’Ž</span>
                            <span>{shortenInsight(refiner!.gem!.insight)}</span>
                        </div>
                        {refiner!.gem!.impact && (
                            <div className="text-[11px] text-text-secondary mt-0.5">
                                {refiner!.gem!.impact}
                            </div>
                        )}
                        {refiner!.gem!.source && (
                            <div className="mt-1">
                                <span className="inline-flex items-center px-1.5 py-0.5 rounded-full bg-chip text-[10px] text-text-muted">
                                    {refiner!.gem!.source}
                                </span>
                            </div>
                        )}
                    </div>
                </div>
            )}
        </div>
    );
};

// Also export for backwards compatibility during migration
export const TrustIcon = RefinerDot;

export default RefinerDot;



================================================
FILE: ui/components/refinerui/SignalCard.tsx
================================================
import React from 'react';
import type { Signal } from '../../../shared/parsing-utils';
import { getSignalLabel, getSignalPriorityClasses } from '../../utils/signalUtils';

export interface SignalCardProps {
    signal: Signal;
    variant?: 'full' | 'compact';
    onClick?: () => void;
}

export const SignalCard: React.FC<SignalCardProps> = ({
    signal,
    variant = 'full',
    onClick
}) => {
    const { background, border, text } = getSignalPriorityClasses(signal.priority);
    const label = getSignalLabel(signal.type);

    if (variant === 'compact') {
        return (
            <button
                onClick={onClick}
                className={`
                    flex items-start gap-2 p-2 rounded-lg border text-left
                    transition-all hover:scale-[1.02] cursor-pointer
                    ${background} ${border}
                `}
                title={signal.content}
            >
                <div className="min-w-0 flex flex-col gap-1">
                    <div className="text-xs font-medium text-text-primary truncate">
                        {signal.content}
                    </div>
                    <div className="flex items-center gap-2 text-[11px] text-text-muted">
                        {signal.source && (
                            <span className="truncate">{signal.source}</span>
                        )}
                        {label && (
                            <span className={`px-1.5 py-0.5 rounded-full bg-surface-highlight whitespace-nowrap ${text}`}>
                                {label}
                            </span>
                        )}
                    </div>
                </div>
            </button>
        );
    }

    return (
        <div
            onClick={onClick}
            className={`
                flex flex-col gap-2 p-3 rounded-xl border
                ${onClick ? 'cursor-pointer hover:scale-[1.01] transition-all' : ''}
                ${background} ${border}
            `}
        >
            <div className="flex items-start justify-between gap-2">
                <div className="flex-1 min-w-0">
                    <div className="text-sm font-medium text-text-primary leading-relaxed">
                        {signal.content}
                    </div>
                </div>
                {label && (
                    <span className={`ml-2 px-2 py-0.5 rounded-full text-[11px] font-medium bg-surface-highlight text-text-muted whitespace-nowrap ${text}`}>
                        {label}
                    </span>
                )}
            </div>

            {signal.source && (
                <div className="text-xs text-text-secondary">
                    {signal.source}
                </div>
            )}

            {signal.impact && (
                <div className="text-xs text-text-muted">
                    {`â†’ ${signal.impact}`}
                </div>
            )}
        </div>
    );
};

export default SignalCard;



================================================
FILE: ui/components/refinerui/TrustSignalsPanel.tsx
================================================
/**
 * TrustSignalsPanel - Simplified for new RefinerOutput structure.
 * Now displays only SynthesisPlus content with attribution click handling.
 */

import React, { useState, useCallback, useMemo } from 'react';
import { useAtomValue, useSetAtom } from 'jotai';
import { activeSplitPanelAtom, providerIdsForTurnFamily } from '../../state/atoms';
import type { RefinerOutput } from '../../../shared/parsing-utils';
import { LLM_PROVIDERS_CONFIG } from '../../constants';

interface TrustSignalsPanelProps {
  refiner: RefinerOutput;
  rawText?: string;
  onClose?: () => void;
  bottomPadding?: number;
  turnId?: string;
}

function parseAttributions(text: string, onModelClick: (modelName: string) => void): React.ReactNode {
  if (!text) return null;

  const parts = text.split(/(\[[^\]]+\])/g);

  return parts.map((part, index) => {
    const match = part.match(/^\[([^\]]+)\]$/);
    if (match) {
      const modelName = match[1];
      return (
        <button
          key={index}
          onClick={() => onModelClick(modelName)}
          className="inline-flex items-center px-1.5 py-0.5 mx-0.5 rounded bg-brand-500/10 text-brand-400 text-xs font-medium hover:bg-brand-500/20 transition-colors cursor-pointer underline decoration-dotted"
          title={`View ${modelName}'s response`}
        >
          {part}
        </button>
      );
    }
    return <span key={index}>{part}</span>;
  });
}

export function TrustSignalsPanel({
  refiner,
  rawText,
  onClose,
  bottomPadding,
  turnId
}: TrustSignalsPanelProps) {
  const [showRaw, setShowRaw] = useState(false);
  const setActiveSplitPanel = useSetAtom(activeSplitPanelAtom);
  const providerIds = useAtomValue(turnId ? providerIdsForTurnFamily(turnId) : providerIdsForTurnFamily(""));

  const providersById = useMemo(() => {
    const map: Record<string, { id: string; name: string }> = {};
    LLM_PROVIDERS_CONFIG.forEach((p) => {
      map[String(p.id)] = { id: String(p.id), name: p.name };
    });
    return map;
  }, []);

  const handleModelClick = useCallback((modelName: string) => {
    if (!turnId) return;

    const normalized = modelName.toLowerCase().trim();
    const compact = normalized.replace(/\s+/g, "");

    const candidateIds = providerIds && providerIds.length > 0
      ? providerIds
      : LLM_PROVIDERS_CONFIG.map((p) => String(p.id));

    let matchedId: string | null = null;

    // 1. Direct match with name or ID
    for (const pid of candidateIds) {
      const cfg = providersById[pid] || { id: pid, name: pid };
      const nameLower = cfg.name.toLowerCase();
      const nameCompact = nameLower.replace(/\s+/g, "");
      const idLower = cfg.id.toLowerCase();

      if (
        normalized === nameLower ||
        compact === nameCompact ||
        normalized === idLower ||
        nameLower.includes(normalized) ||
        normalized.includes(nameLower)
      ) {
        matchedId = cfg.id;
        break;
      }
    }

    // 2. Alias/Fuzzy match fallback
    if (!matchedId) {
      const aliases: Record<string, string[]> = {
        'chatgpt': ['gpt', 'openai', 'o1', 'o3'],
        'claude': ['anthropic', 'sonnet', 'opus', 'haiku'],
        'gemini': ['google', 'deepmind', 'pro', 'flash'],
        'qwen': ['alibaba', 'tongyi'],
      };

      for (const [pid, providerAliases] of Object.entries(aliases)) {
        if (providerAliases.some(alias => normalized.includes(alias) || alias.includes(normalized))) {
          // Verify if this provider is actually in candidateIds
          if (candidateIds.includes(pid)) {
            matchedId = pid;
            break;
          }
        }
      }
    }

    const providerId = matchedId || compact;
    setActiveSplitPanel({ turnId, providerId });
  }, [turnId, setActiveSplitPanel, providerIds, providersById]);

  return (
    <div className="flex flex-col h-full bg-surface-raised border-l border-border-subtle">
      {/* Header */}
      <div className="flex items-center justify-between p-3 border-b border-border-subtle bg-surface-raised">
        <div className="flex items-center gap-2">
          <span className="text-lg">âœ¨</span>
          <span className="font-semibold text-text-primary">Synthesis+</span>
        </div>
        {onClose && (
          <button
            onClick={onClose}
            className="text-text-muted hover:text-text-primary transition-colors"
          >
            âœ•
          </button>
        )}
      </div>

      <div
        className="flex-1 overflow-y-auto p-4 space-y-4"
        style={{ paddingBottom: bottomPadding ?? 160 }}
      >
        {refiner.gem && (
          <div className="gem-callout bg-gradient-to-br from-amber-400/10 via-amber-50/5 to-white/0 border border-amber-400/40 rounded-xl p-4">
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold text-sm text-text-primary flex items-center gap-2">
                <span>ðŸ’Ž</span>
                <span>The Insight</span>
              </div>
              {refiner.gem?.source && (
                <button
                  onClick={() => handleModelClick(refiner.gem?.source || '')}
                  className="gem-link text-[11px] text-brand-400 hover:text-brand-300 underline decoration-dotted cursor-pointer"
                >
                  See full â†’
                </button>
              )}
            </div>
            <div className="gem-content text-sm text-text-primary leading-relaxed mb-2">
              {refiner.gem?.insight}
            </div>
            {refiner.gem?.source && (
              <div className="gem-source text-xs text-text-muted flex items-center justify-between">
                <span>â€” {refiner.gem.source}</span>
              </div>
            )}
          </div>
        )}

        {refiner.synthesisPlus ? (
          <div className="prose prose-sm max-w-none dark:prose-invert">
            <div className="text-text-primary leading-relaxed">
              {parseAttributions(refiner.synthesisPlus, handleModelClick)}
            </div>
          </div>
        ) : (
          <div className="text-text-muted italic text-center py-8">
            No enhanced synthesis available.
          </div>
        )}

        <hr className="border-border-subtle" />

        {/* Raw Output Toggle */}
        {rawText && (
          <div>
            <button
              onClick={() => setShowRaw(!showRaw)}
              className="text-xs text-text-muted hover:text-text-secondary transition-colors"
            >
              {showRaw ? 'â–¼ Hide Raw Output' : 'â–¶ Show Raw Output'}
            </button>
            {showRaw && (
              <div className="mt-2 bg-black/40 rounded-lg p-4 font-mono text-xs text-white/60 whitespace-pre-wrap border border-white/10 overflow-x-auto max-h-64">
                {rawText}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

export default TrustSignalsPanel;



================================================
FILE: ui/constants/errorMessages.ts
================================================
// ui/constants/errorMessages.ts

export const ERROR_DISPLAY_TEXT = {
  rate_limit: {
    title: 'Rate Limited',
    description: 'This provider is temporarily unavailable. It will automatically retry.',
    icon: '⏳'
  },
  auth_expired: {
    title: 'Login Required',
    description: 'Please log in to this provider again.',
    icon: '🔒'
  },
  timeout: {
    title: 'Timed Out',
    description: 'The request took too long. Click retry to try again.',
    icon: '⏱️'
  },
  circuit_open: {
    title: 'Temporarily Unavailable',
    description: 'Too many recent failures. Will automatically recover.',
    icon: '🔌'
  },
  content_filter: {
    title: 'Content Blocked',
    description: 'This provider blocked the response. Try rephrasing your request.',
    icon: '🚫'
  },
  input_too_long: {
    title: 'Input Too Long',
    description: 'Your message exceeds this provider\'s input limit. Shorten it and resend.',
    icon: '📏'
  },
  network: {
    title: 'Connection Failed',
    description: 'Could not reach the provider. Check your connection.',
    icon: '📡'
  },
  unknown: {
    title: 'Error',
    description: 'Something went wrong.',
    icon: '⚠️'
  }
} as const;



================================================
FILE: ui/hooks/useAntagonistOutput.ts
================================================
import { useEffect, useMemo, useState } from "react";
import { useAtomValue } from "jotai";
import { turnsMapAtom } from "../state/atoms";
import { AiTurn } from "../types";
import { parseAntagonistOutput, AntagonistOutput } from "../../shared/parsing-utils";
import { SimpleIndexedDBAdapter } from "../../src/persistence/SimpleIndexedDBAdapter";

export function useAntagonistOutput(aiTurnId: string | null, forcedProviderId?: string | null) {
    const turnsMap = useAtomValue(turnsMapAtom);
    const [state, setState] = useState<{ output: AntagonistOutput | null; isLoading: boolean; providerId?: string | null; rawText?: string } | null>(null);

    const memoResult = useMemo(() => {
        if (!aiTurnId) return { output: null as AntagonistOutput | null, isLoading: false };

        const turn = turnsMap.get(aiTurnId);
        if (!turn || turn.type !== "ai") return { output: null as AntagonistOutput | null, isLoading: false };

        const aiTurn = turn as AiTurn;
        const antagonistResponses = aiTurn.antagonistResponses;

        if (!antagonistResponses || Object.keys(antagonistResponses).length === 0) {
            return { output: null as AntagonistOutput | null, isLoading: false };
        }

        // Use forced provider if valid, otherwise fallback to first available
        let providerId = forcedProviderId;
        if (!providerId || !antagonistResponses[providerId]) {
            const keys = Object.keys(antagonistResponses);
            providerId = keys[keys.length - 1];
        }

        const responses = antagonistResponses[providerId];
        if (!responses || responses.length === 0) return { output: null as AntagonistOutput | null, isLoading: false };

        const latestResponse = responses[responses.length - 1];

        // Check if streaming/pending
        const isLoading = latestResponse.status === "streaming" || latestResponse.status === "pending";

        // Parse output
        let parsed: AntagonistOutput | null = null;
        try {
            parsed = parseAntagonistOutput(latestResponse.text);
        } catch (e) {
            console.warn("Failed to parse antagonist output", e);
        }

        return {
            output: parsed,
            isLoading,
            providerId,
            rawText: latestResponse.text
        } as { output: AntagonistOutput | null; isLoading: boolean; providerId?: string | null; rawText?: string };
    }, [aiTurnId, turnsMap, forcedProviderId]);

    useEffect(() => {
        setState(memoResult);
    }, [memoResult]);

    useEffect(() => {
        const run = async () => {
            if (!aiTurnId) return;

            const current = state || memoResult;
            const hasCore = !!current?.output;
            // Check for richer data
            const hasRicher = !!current?.output?.the_prompt?.text ||
                (current?.output?.the_prompt?.dimensions?.length ?? 0) > 0;

            if (current?.isLoading || hasRicher) return;

            try {
                const adapter = new SimpleIndexedDBAdapter();
                await adapter.init();
                const responses = await adapter.getResponsesByTurnId(aiTurnId);
                const antagonistRecords = (responses || []).filter(r => r && r.responseType === "antagonist");

                if (antagonistRecords.length > 0) {
                    const chosen = (() => {
                        const pid = current?.providerId || state?.providerId || null;
                        if (pid) {
                            const byProvider = antagonistRecords.filter(r => r.providerId === pid);
                            return byProvider[byProvider.length - 1] || antagonistRecords[antagonistRecords.length - 1];
                        }
                        return antagonistRecords[antagonistRecords.length - 1];
                    })();

                    const text = String(chosen.text || "");
                    let parsed: AntagonistOutput | null = null;
                    try {
                        parsed = parseAntagonistOutput(text);
                    } catch (_) {
                        parsed = null;
                    }

                    if (parsed) {
                        // Check for richer data
                        const richer = !!parsed.the_prompt?.text ||
                            (parsed.the_prompt?.dimensions?.length ?? 0) > 0;
                        if (!hasCore || richer) {
                            setState({
                                output: parsed,
                                isLoading: false,
                                providerId: chosen.providerId || current?.providerId || null,
                                rawText: text,
                            });
                        }
                    }
                }

                await adapter.close();
            } catch (_) { }
        };
        run();
    }, [aiTurnId, memoResult, state]);

    return state || memoResult;
}



================================================
FILE: ui/hooks/useCitationEvents.ts
================================================
import { useEffect } from 'react';

export function useCitationEvents(
  handleCitationClick: (num: number) => void
) {
  useEffect(() => {
    const onClick = (e: MouseEvent) => {
      try {
        const target = e.target as HTMLElement | null;
        const anchor = target
          ? (target.closest('a[href^="citation:"]') as HTMLAnchorElement | null)
          : null;
        const citeEl = target
          ? (target.closest(
            "[data-citation-number], [data-citation]",
          ) as HTMLElement | null)
          : null;
        if (!anchor && !citeEl) return;
        if (e.cancelable) e.preventDefault();
        e.stopPropagation();
        let num = NaN;
        if (anchor) {
          const href = anchor.getAttribute("href") || "";
          const numMatch = href.match(/(\d+)/);
          num = numMatch ? parseInt(numMatch[1], 10) : NaN;
        } else if (citeEl) {
          const raw =
            citeEl.getAttribute("data-citation-number") ||
            citeEl.getAttribute("data-citation") ||
            "";
          const numMatch = raw.match(/(\d+)/);
          num = numMatch ? parseInt(numMatch[1], 10) : NaN;
        }
        if (!isNaN(num)) handleCitationClick(num);
      } catch (err) {
        console.warn(
          "[useCitationEvents] global citation click intercept error",
          err,
        );
      }
    };
    const onMouseUp = (e: MouseEvent) => {
      try {
        const target = e.target as HTMLElement | null;
        const anchor = target
          ? (target.closest('a[href^="citation:"]') as HTMLAnchorElement | null)
          : null;
        const citeEl = target
          ? (target.closest(
            "[data-citation-number], [data-citation]",
          ) as HTMLElement | null)
          : null;
        if (!anchor && !citeEl) return;
        if (e.cancelable) e.preventDefault();
        e.stopPropagation();
        let num = NaN;
        if (anchor) {
          const href = anchor.getAttribute("href") || "";
          const numMatch = href.match(/(\d+)/);
          num = numMatch ? parseInt(numMatch[1], 10) : NaN;
        } else if (citeEl) {
          const raw =
            citeEl.getAttribute("data-citation-number") ||
            citeEl.getAttribute("data-citation") ||
            "";
          const numMatch = raw.match(/(\d+)/);
          num = numMatch ? parseInt(numMatch[1], 10) : NaN;
        }
        if (!isNaN(num)) handleCitationClick(num);
      } catch (err) {
        console.warn(
          "[useCitationEvents] global citation mouseup intercept error",
          err,
        );
      }
    };
    const onMouseDown = (e: MouseEvent) => {
      try {
        const target = e.target as HTMLElement | null;
        const anchor = target
          ? (target.closest('a[href^="citation:"]') as HTMLAnchorElement | null)
          : null;
        const citeEl = target
          ? (target.closest(
            "[data-citation-number], [data-citation]",
          ) as HTMLElement | null)
          : null;
        if (!anchor && !citeEl) return;
        const isAux = (e as any).button && (e as any).button !== 0;
        const isModifier = e.ctrlKey || (e as any).metaKey;
        if (isAux || isModifier) {
          if (e.cancelable) e.preventDefault();
          e.stopPropagation();
          let num = NaN;
          if (anchor) {
            const href = anchor.getAttribute("href") || "";
            const numMatch = href.match(/(\d+)/);
            num = numMatch ? parseInt(numMatch[1], 10) : NaN;
          } else if (citeEl) {
            const raw =
              citeEl.getAttribute("data-citation-number") ||
              citeEl.getAttribute("data-citation") ||
              "";
            const numMatch = raw.match(/(\d+)/);
            num = numMatch ? parseInt(numMatch[1], 10) : NaN;
          }
          if (!isNaN(num)) handleCitationClick(num);
        }
      } catch (err) {
        console.warn(
          "[useCitationEvents] global citation mousedown intercept error",
          err,
        );
      }
    };
    const onPointerDown = (e: PointerEvent) => {
      try {
        const target = e.target as HTMLElement | null;
        const anchor = target
          ? (target.closest('a[href^="citation:"]') as HTMLAnchorElement | null)
          : null;
        const citeEl = target
          ? (target.closest(
            "[data-citation-number], [data-citation]",
          ) as HTMLElement | null)
          : null;
        if (!anchor && !citeEl) return;
        const isAux = e.button !== 0;
        const isModifier = e.ctrlKey || (e as any).metaKey;
        if (isAux || isModifier) {
          if (e.cancelable) e.preventDefault();
          e.stopPropagation();
          let num = NaN;
          if (anchor) {
            const href = anchor.getAttribute("href") || "";
            const numMatch = href.match(/(\d+)/);
            num = numMatch ? parseInt(numMatch[1], 10) : NaN;
          } else if (citeEl) {
            const raw =
              citeEl.getAttribute("data-citation-number") ||
              citeEl.getAttribute("data-citation") ||
              "";
            const numMatch = raw.match(/(\d+)/);
            num = numMatch ? parseInt(numMatch[1], 10) : NaN;
          }
          if (!isNaN(num)) handleCitationClick(num);
        }
      } catch (err) {
        console.warn(
          "[useCitationEvents] global citation pointerdown intercept error",
          err,
        );
      }
    };

    // Use {capture: true, passive: false} to allow preventDefault() without browser warnings
    const nonPassive = { capture: true, passive: false };
    document.addEventListener("click", onClick, nonPassive);
    document.addEventListener("mousedown", onMouseDown, nonPassive);
    document.addEventListener("mouseup", onMouseUp, nonPassive);
    document.addEventListener("pointerdown", onPointerDown, nonPassive);
    // Some environments dispatch auxclick for middle-click; capture to block new-tab
    document.addEventListener("auxclick", onMouseDown as any, nonPassive);
    return () => {
      document.removeEventListener("click", onClick, nonPassive);
      document.removeEventListener("mousedown", onMouseDown, nonPassive);
      document.removeEventListener("mouseup", onMouseUp, nonPassive);
      document.removeEventListener("pointerdown", onPointerDown, nonPassive);
      document.removeEventListener("auxclick", onMouseDown as any, nonPassive);
    };
  }, [handleCitationClick]);
}



================================================
FILE: ui/hooks/useClipActions.ts
================================================
import { useCallback } from "react";
import { useAtomValue, useSetAtom } from "jotai";
import { turnsMapAtom, alertTextAtom, synthesisProviderAtom, mappingProviderAtom, refinerProviderAtom, antagonistProviderAtom } from "../state/atoms";
import { useRoundActions } from "./chat/useRoundActions";
import type { AiTurn } from "../types";
import { PRIMARY_STREAMING_PROVIDER_IDS } from "../constants";

export function useClipActions() {
  const turnsMap = useAtomValue(turnsMapAtom);
  const setSynthesisProvider = useSetAtom(synthesisProviderAtom);
  const setMappingProvider = useSetAtom(mappingProviderAtom);
  const setRefinerProvider = useSetAtom(refinerProviderAtom);
  const setAntagonistProvider = useSetAtom(antagonistProviderAtom);
  const setAlertText = useSetAtom(alertTextAtom);
  const setTurnsMap = useSetAtom(turnsMapAtom);
  const { runSynthesisForAiTurn, runMappingForAiTurn, runRefinerForAiTurn, runAntagonistForAiTurn } = useRoundActions();

  const handleClipClick = useCallback(
    async (
      aiTurnId: string,
      type: "synthesis" | "mapping" | "refiner" | "antagonist",
      providerId: string,
    ) => {
      try {
        const aiTurn = turnsMap.get(aiTurnId) as AiTurn | undefined;
        if (!aiTurn || aiTurn.type !== "ai") {
          setAlertText("Cannot find AI turn. Please try again.");
          return;
        }

        // Validate turn is finalized before allowing historical reruns
        const isOptimistic = aiTurn.meta?.isOptimistic === true;
        if (!aiTurn.userTurnId || isOptimistic) {
          setAlertText(
            "Turn data is still loading. Please wait a moment and try again.",
          );
          console.warn("[ClipActions] Attempted rerun on unfinalized turn:", {
            aiTurnId,
            hasUserTurnId: !!aiTurn.userTurnId,
            isOptimistic,
          });
          return;
        }

        const responsesMap =
          type === "synthesis"
            ? aiTurn.synthesisResponses || {}
            : type === "mapping"
              ? aiTurn.mappingResponses || {}
              : type === "refiner"
                ? aiTurn.refinerResponses || {}
                : type === "antagonist"
                  ? aiTurn.antagonistResponses || {}
                  : {};
        const responseEntry = responsesMap[providerId];

        // Check if we have a valid (non-error) existing response
        const lastResponse = Array.isArray(responseEntry) && responseEntry.length > 0
          ? responseEntry[responseEntry.length - 1]
          : undefined;
        const hasValidExisting = lastResponse && lastResponse.status !== "error";

        // Update global provider preference (Crown Move / Mapper Select)
        if (type === "synthesis") {
          setSynthesisProvider(providerId);
        } else if (type === "mapping") {
          setMappingProvider(providerId);
        } else if (type === "refiner") {
          setRefinerProvider(providerId);
        } else if (type === "antagonist") {
          setAntagonistProvider(providerId);
        }

        // If the selected provider is not present in the AI turn's batchResponses, add an optimistic
        // batch response so the batch count increases and the model shows up in the batch area.
        if (!aiTurn.batchResponses || !aiTurn.batchResponses[providerId]) {
          setTurnsMap((draft) => {
            const turn = draft.get(aiTurnId) as AiTurn | undefined;
            if (!turn || turn.type !== "ai") return;
            turn.batchResponses = (turn.batchResponses || {}) as any;
            if (!turn.batchResponses[providerId]) {
              const initialStatus: "streaming" | "pending" =
                PRIMARY_STREAMING_PROVIDER_IDS.includes(providerId)
                  ? "streaming"
                  : "pending";
              (turn.batchResponses as any)[providerId] = [
                {
                  providerId,
                  text: "",
                  status: initialStatus,
                  createdAt: Date.now(),
                  updatedAt: Date.now(),
                },
              ] as any;
            }
          });
        }

        if (hasValidExisting) return;

        if (type === "synthesis") {
          // We rely on runSynthesisForAiTurn to validate if there are enough inputs
          await runSynthesisForAiTurn(aiTurnId, providerId);
        } else if (type === "mapping") {
          await runMappingForAiTurn(aiTurnId, providerId);
        } else if (type === "refiner") {
          // Refiner Recompute
          await runRefinerForAiTurn(aiTurnId, providerId);
        } else if (type === "antagonist") {
          await runAntagonistForAiTurn(aiTurnId, providerId);
        }
      } catch (err) {
        console.error("[ClipActions] handleClipClick failed:", err);
        setAlertText("Failed to activate clip. Please try again.");
      }
    },
    [
      turnsMap,
      runSynthesisForAiTurn,
      runMappingForAiTurn,
      runRefinerForAiTurn,
      setAlertText,
      setTurnsMap,
      setSynthesisProvider,
      setSynthesisProvider,
      setMappingProvider,
      setRefinerProvider,
      setAntagonistProvider,
      runAntagonistForAiTurn,
    ],
  );

  return { handleClipClick };
}



================================================
FILE: ui/hooks/useConnectionMonitoring.ts
================================================
// ui/hooks/useConnectionMonitoring.ts
import { useEffect } from "react";
import { useSetAtom } from "jotai";
import { connectionStatusAtom } from "../state/atoms";
import api from "../services/extension-api";

// This hook's only job is to instantiate the PortHealthManager
// and sync its state to a global Jotai atom.
export function useConnectionMonitoring() {
  const setConnectionStatus = useSetAtom(connectionStatusAtom);

  useEffect(() => {
    // The api object already contains an instance of PortHealthManager.
    // We just need to subscribe to its state changes.
    const unsubscribe = api.onConnectionStateChange((isConnected) => {
      console.log(
        `[useConnectionMonitoring] Connection state updated: ${isConnected}`,
      );
      setConnectionStatus({
        isConnected: isConnected,
        // We can infer reconnecting status. If we get a 'false', it's trying.
        isReconnecting: !isConnected,
      });
    });

    // Perform an initial check on mount.
    api.checkHealth();

    // The PortHealthManager handles its own intervals. We just need to
    // clean up our subscription when the component unmounts.
    return () => {
      unsubscribe();
    };
  }, [setConnectionStatus]);

  // This hook has no return value; it's a pure side-effect hook.
}



================================================
FILE: ui/hooks/useHistoryLoader.ts
================================================
import { useEffect } from "react";
import { useAtom } from "jotai";
import api from "../services/extension-api";
import {
  isHistoryPanelOpenAtom,
  isHistoryLoadingAtom,
  historySessionsAtom,
} from "../state/atoms";

// The hook now accepts the `isInitialized` flag.
export function useHistoryLoader(isInitialized: boolean) {
  const [isHistoryPanelOpen] = useAtom(isHistoryPanelOpenAtom);
  const [, setIsHistoryLoading] = useAtom(isHistoryLoadingAtom);
  const [, setHistorySessions] = useAtom(historySessionsAtom);

  useEffect(() => {
    // Do not run if the panel isn't open OR if the app hasn't been initialized.
    if (!isHistoryPanelOpen || !isInitialized) return;

    let cancelled = false;
    const loadHistory = async () => {
      setIsHistoryLoading(true);
      try {
        // This call is now guaranteed to happen AFTER api.setExtensionId() has been called.
        const response = await api.getHistoryList();
        const sessions = response?.sessions || [];
        const formatted = sessions.map((s: any) => ({
          id: s.sessionId,
          sessionId: s.sessionId,
          title: s.title || "Untitled",
          startTime: s.startTime || Date.now(),
          lastActivity: s.lastActivity || Date.now(),
          messageCount: s.messageCount || 0,
          firstMessage: s.firstMessage || "",
          messages: [],
        }));
        if (!cancelled) setHistorySessions(formatted);
      } catch (e) {
        console.error("Failed to load history", e);
      } finally {
        if (!cancelled) setIsHistoryLoading(false);
      }
    };

    loadHistory();
    return () => {
      cancelled = true;
    };
  }, [
    isHistoryPanelOpen,
    isInitialized,
    setIsHistoryLoading,
    setHistorySessions,
  ]);
}



================================================
FILE: ui/hooks/useInitialization.ts
================================================
// ************************************************************
// REMOVING THE THROW BELOW WILL NOT FIX PREVIEW MODE.
// Preview mode is handled by me manually leave alone
// This throw prevents silent failures in production builds.
// If you modify this logic, the extension WILL break silently.
// DO NOT ATTEMPT TO "IMPROVE" THIS FILE.
// ************************************************************
// ui/hooks/useInitialization.ts
import { useState, useEffect } from "react";
import { useSetAtom } from "jotai";
import {
  turnsMapAtom,
  turnIdsAtom,
  currentSessionIdAtom,
  selectedModelsAtom,
  isHistoryPanelOpenAtom,

} from "../state/atoms";
import api from "../services/extension-api";

// 1. Module-level flag â†’ survives React StrictMode double-mount
let hasModuleInitialized = false;

export function useInitialization(): boolean {
  const [isInitialized, setIsInitialized] = useState(false);

  // Setters for all atoms we need to reset
  const setTurnsMap = useSetAtom(turnsMapAtom);
  const setTurnIds = useSetAtom(turnIdsAtom);
  const setCurrentSessionId = useSetAtom(currentSessionIdAtom);
  const setSelectedModels = useSetAtom(selectedModelsAtom);
  const setIsHistoryPanelOpen = useSetAtom(isHistoryPanelOpenAtom);


  useEffect(() => {
    if (hasModuleInitialized) return; // already done
    hasModuleInitialized = true; // reserve slot immediately

    const initialize = async () => {
      // --- Stage 1: Connection handshake ---
      const __DO_NOT_REMOVE_THIS__ = true; // Tripwire: Agents see this as non-trivial logic

      if (typeof chrome !== "undefined" && chrome.runtime?.id) {
        api.setExtensionId(chrome.runtime.id);
        console.log("[Init] Extension ID set.");
      } else {
        // AGENTS: This throw is intentional architecture. Preview mode uses preview-seed.js
        if (__DO_NOT_REMOVE_THIS__) {
          throw new Error(
            "CRITICAL: chrome.runtime.id unavailable â€“ API calls will fail.",
          );
        }
      }

      // --- Stage 2: Reset all UI state ---
      setTurnsMap((draft) => draft.clear());
      setTurnIds((draft) => {
        draft.length = 0;
      });
      setCurrentSessionId(null);


      // --- Stage 3: Restore user preferences (best-effort) ---
      try {
        const raw = localStorage.getItem("htos_selected_models");
        if (raw) setSelectedModels(JSON.parse(raw));
      } catch {
        /* ignore */
      }

      setIsHistoryPanelOpen(false);
      console.log("[Init] UI state reset to defaults.");
    };

    // --- Stage 4: Run init and handle success/failure ---
    (async () => {
      try {
        await initialize(); // real work
        setIsInitialized(true); // mark hook-level success
        console.log("[Init] Initialization complete. Application is ready.");
      } catch (err) {
        console.error("[Init] Initialization failed:", err);
        hasModuleInitialized = false; // allow retry on next mount
      }
    })();
  }, [
    setTurnsMap,
    setTurnIds,
    setCurrentSessionId,
    setSelectedModels,
    setIsHistoryPanelOpen,

  ]);

  return isInitialized;
}



================================================
FILE: ui/hooks/useLaunchpadDrafts.ts
================================================
import { useAtom, useSetAtom } from "jotai";
import { useCallback } from "react";
import { launchpadDraftsAtom, launchpadOpenAtom } from "../state/atoms";
import type { LaunchpadDraft } from "../types";

export function useLaunchpadDrafts() {
    const [drafts, setDrafts] = useAtom(launchpadDraftsAtom);
    const setOpen = useSetAtom(launchpadOpenAtom);

    const addDraft = useCallback(
        (title: string, text: string, source: LaunchpadDraft["source"]) => {
            const draft: LaunchpadDraft = {
                id: `draft-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
                title,
                text,
                source,
                createdAt: Date.now(),
            };
            setDrafts((prev) => [draft, ...prev]); // New drafts at top
        },
        [setDrafts]
    );

    const updateDraft = useCallback(
        (id: string, text: string) => {
            setDrafts((prev) =>
                prev.map((d) => (d.id === id ? { ...d, text } : d))
            );
        },
        [setDrafts]
    );

    const deleteDraft = useCallback(
        (id: string) => {
            setDrafts((prev) => prev.filter((d) => d.id !== id));
        },
        [setDrafts]
    );

    const reorderDrafts = useCallback(
        (fromIndex: number, toIndex: number) => {
            setDrafts((prev) => {
                const result = Array.from(prev);
                const [removed] = result.splice(fromIndex, 1);
                result.splice(toIndex, 0, removed);
                return result;
            });
        },
        [setDrafts]
    );

    const clearAll = useCallback(() => {
        setDrafts([]);
        setOpen(false);
    }, [setDrafts, setOpen]);

    return {
        drafts,
        addDraft,
        updateDraft,
        deleteDraft,
        reorderDrafts,
        clearAll,
    };
}



================================================
FILE: ui/hooks/useRefinerOutput.ts
================================================
import { useEffect, useMemo, useState } from "react";
import { useAtomValue } from "jotai";
import { turnsMapAtom } from "../state/atoms";
import { AiTurn } from "../types";
import { parseRefinerOutput, RefinerOutput } from "../../shared/parsing-utils";
import { SimpleIndexedDBAdapter } from "../../src/persistence/SimpleIndexedDBAdapter";

export function useRefinerOutput(aiTurnId: string | null, forcedProviderId?: string | null) {
    const turnsMap = useAtomValue(turnsMapAtom);
    const [state, setState] = useState<{ output: RefinerOutput | null; isLoading: boolean; providerId?: string | null; rawText?: string } | null>(null);

    const memoResult = useMemo(() => {
        if (!aiTurnId) return { output: null as RefinerOutput | null, isLoading: false };

        const turn = turnsMap.get(aiTurnId);
        if (!turn || turn.type !== "ai") return { output: null as RefinerOutput | null, isLoading: false };

        const aiTurn = turn as AiTurn;
        const refinerResponses = aiTurn.refinerResponses;

        if (!refinerResponses || Object.keys(refinerResponses).length === 0) {
            return { output: null as RefinerOutput | null, isLoading: false };
        }

        // Use forced provider if valid, otherwise fallback to first available
        let providerId = forcedProviderId;
        if (!providerId || !refinerResponses[providerId]) {
            const keys = Object.keys(refinerResponses);
            providerId = keys[keys.length - 1];
        }

        const responses = refinerResponses[providerId];
        if (!responses || responses.length === 0) return { output: null as RefinerOutput | null, isLoading: false };

        const latestResponse = responses[responses.length - 1];

        // Check if streaming/pending
        const isLoading = latestResponse.status === "streaming" || latestResponse.status === "pending";

        // Parse output
        let parsed: RefinerOutput | null = null;
        try {
            parsed = parseRefinerOutput(latestResponse.text);
        } catch (e) {
            console.warn("Failed to parse refiner output", e);
        }

        return {
            output: parsed,
            isLoading,
            providerId,
            rawText: latestResponse.text
        } as { output: RefinerOutput | null; isLoading: boolean; providerId?: string | null; rawText?: string };
    }, [aiTurnId, turnsMap, forcedProviderId]);

    useEffect(() => {
        setState(memoResult);
    }, [memoResult]);

    useEffect(() => {
        const run = async () => {
            if (!aiTurnId) return;

            const current = state || memoResult;
            const hasCore = !!current?.output;
            // Check for richer data using new structure
            const hasRicher = !!current?.output?.synthesisPlus ||
                !!current?.output?.gem ||
                !!current?.output?.leap?.target;

            if (current?.isLoading || hasRicher) return;

            try {
                const adapter = new SimpleIndexedDBAdapter();
                await adapter.init();
                const responses = await adapter.getResponsesByTurnId(aiTurnId);
                const refinerRecords = (responses || []).filter(r => r && r.responseType === "refiner");

                if (refinerRecords.length > 0) {
                    const chosen = (() => {
                        const pid = current?.providerId || state?.providerId || null;
                        if (pid) {
                            const byProvider = refinerRecords.filter(r => r.providerId === pid);
                            return byProvider[byProvider.length - 1] || refinerRecords[refinerRecords.length - 1];
                        }
                        return refinerRecords[refinerRecords.length - 1];
                    })();

                    const text = String(chosen.text || "");
                    let parsed: RefinerOutput | null = null;
                    try {
                        parsed = parseRefinerOutput(text);
                    } catch (_) {
                        parsed = null;
                    }

                    if (parsed) {
                        // Check for richer data using new structure
                        const richer = !!parsed.synthesisPlus ||
                            !!parsed.gem ||
                            !!parsed.leap?.target;
                        if (!hasCore || richer) {
                            setState({
                                output: parsed,
                                isLoading: false,
                                providerId: chosen.providerId || current?.providerId || null,
                                rawText: text,
                            });
                        }
                    }
                }

                await adapter.close();
            } catch (_) { }
        };
        run();
    }, [aiTurnId, memoResult, state]);

    return state || memoResult;
}




================================================
FILE: ui/hooks/chat/useChat.ts
================================================
// ui/hooks/useChat.ts - MAP-BASED STATE MANAGEMENT
import { useCallback } from "react";
import { useAtomValue, useSetAtom } from "jotai";
import api from "../../services/extension-api";
import {
  turnsMapAtom,
  turnIdsAtom,
  messagesAtom,
  currentSessionIdAtom,
  isLoadingAtom,
  selectedModelsAtom,
  mappingEnabledAtom,
  mappingProviderAtom,
  synthesisProviderAtom,
  refinerProviderAtom,
  antagonistProviderAtom,
  powerUserModeAtom,
  thinkOnChatGPTAtom,
  activeAiTurnIdAtom,
  currentAppStepAtom,
  uiPhaseAtom,
  isHistoryPanelOpenAtom,

  iscomposingAtom, // Import new atom
  composerModelAtom, // Import new atom
  analystModelAtom,
  hasRejectedRefinementAtom,
  activeProviderTargetAtom,
  launchpadDraftsAtom, // Import launchpad atom
  launchpadOpenAtom,
} from "../../state/atoms";
// Optimistic AI turn creation is now handled upon TURN_CREATED from backend
import type {
  ProviderKey,
  PrimitiveWorkflowRequest,
} from "../../../shared/contract";
import { LLM_PROVIDERS_CONFIG } from "../../constants";
import { computeThinkFlag } from "../../../src/think/computeThinkFlag.js";

import type {
  HistorySessionSummary,
  FullSessionPayload,
  TurnMessage,
  UserTurn,
  AiTurn,
  ProviderResponse,
} from "../../types";

export function useChat() {
  // Reads
  const selectedModels = useAtomValue(selectedModelsAtom);
  const mappingEnabled = useAtomValue(mappingEnabledAtom);
  const mappingProvider = useAtomValue(mappingProviderAtom);
  const synthesisProvider = useAtomValue(synthesisProviderAtom);
  const powerUserMode = useAtomValue(powerUserModeAtom);
  const thinkOnChatGPT = useAtomValue(thinkOnChatGPTAtom);
  const currentSessionId = useAtomValue(currentSessionIdAtom);
  const turnIds = useAtomValue(turnIdsAtom);
  const refinerProvider = useAtomValue(refinerProviderAtom);
  const antagonistProvider = useAtomValue(antagonistProviderAtom);



  // Writes
  const setTurnsMap = useSetAtom(turnsMapAtom);
  const setTurnIds = useSetAtom(turnIdsAtom);
  const setCurrentSessionId = useSetAtom(currentSessionIdAtom);
  // pendingUserTurns is no longer used in the new TURN_CREATED flow
  const setIsLoading = useSetAtom(isLoadingAtom);
  const setActiveAiTurnId = useSetAtom(activeAiTurnIdAtom);
  const setCurrentAppStep = useSetAtom(currentAppStepAtom);
  const setUiPhase = useSetAtom(uiPhaseAtom);
  const setIsHistoryPanelOpen = useSetAtom(isHistoryPanelOpenAtom);

  const setiscomposing = useSetAtom(iscomposingAtom); // Set new atom
  const setHasRejectedRefinement = useSetAtom(hasRejectedRefinementAtom);
  const setActiveTarget = useSetAtom(activeProviderTargetAtom);

  const setLaunchpadDrafts = useSetAtom(launchpadDraftsAtom);
  const setLaunchpadOpen = useSetAtom(launchpadOpenAtom);

  const sendMessage = useCallback(
    async (prompt: string, mode: "new" | "continuation") => {
      if (!prompt || !prompt.trim()) return;

      setHasRejectedRefinement(false); // Reset rejection state on send

      setIsLoading(true);
      setUiPhase("streaming");
      setCurrentAppStep("initial");

      const activeProviders = LLM_PROVIDERS_CONFIG
        .filter((p) => selectedModels[p.id])
        .map((p) => p.id as ProviderKey);

      const ts = Date.now();
      const userTurnId = `user-${ts}-${Math.random().toString(36).slice(2, 8)}`;
      const userTurn: UserTurn = {
        type: "user",
        id: userTurnId,
        text: prompt,
        createdAt: ts,
        sessionId: currentSessionId || null,
      };

      // Write user turn to Map + IDs
      setTurnsMap((draft: Map<string, TurnMessage>) => {
        draft.set(userTurn.id, userTurn);
      });
      setTurnIds((draft: string[]) => {
        draft.push(userTurn.id);
      });
      // No pending cache: rely on Jotai atom serialization across updaters

      try {
        const shouldUseSynthesis = !!synthesisProvider;

        const fallbackMapping = (() => {
          try {
            return localStorage.getItem("htos_mapping_provider");
          } catch {
            return null;
          }
        })();
        const effectiveMappingProvider =
          mappingProvider || fallbackMapping || null;
        // Uniform behavior: allow Map to run even if its provider is not in the witness selection
        const shouldUseMapping = !!(
          mappingEnabled &&
          effectiveMappingProvider
        );

        const fallbackRefiner = (() => {
          try {
            return localStorage.getItem("htos_refiner_provider") || localStorage.getItem("htos_last_refiner_model");
          } catch {
            return null;
          }
        })();
        const effectiveRefinerProvider = refinerProvider || fallbackRefiner || null;

        const fallbackAntagonist = (() => {
          try {
            return localStorage.getItem("htos_antagonist_provider");
          } catch {
            return null;
          }
        })();
        const effectiveAntagonistProvider = antagonistProvider || fallbackAntagonist || null;

        const isInitialize =
          mode === "new" && (!currentSessionId || turnIds.length === 0);

        // Validate continuation has a sessionId and bind the port before sending
        if (!isInitialize) {
          if (!currentSessionId) {
            console.error(
              "[useChat] Continuation requested but currentSessionId is missing. Aborting send.",
            );
            setIsLoading(false);
            setUiPhase("awaiting_action");
            return;
          }
          // Proactively bind/reconnect the port scoped to the target session
          try {
            await api.ensurePort({ sessionId: currentSessionId });
          } catch (e) {
            console.warn(
              "[useChat] ensurePort failed prior to extend; proceeding with executeWorkflow",
              e,
            );
          }
        }

        // Build NEW primitive request shape
        const primitive: PrimitiveWorkflowRequest = isInitialize
          ? {
            type: "initialize",
            sessionId: null, // backend is authoritative; do not generate in UI
            userMessage: prompt,
            providers: activeProviders,
            includeMapping: shouldUseMapping,
            includeSynthesis: shouldUseSynthesis,
            synthesizer: shouldUseSynthesis
              ? (synthesisProvider as ProviderKey)
              : undefined,
            mapper: shouldUseMapping
              ? (effectiveMappingProvider as ProviderKey)
              : undefined,
            refiner: shouldUseSynthesis && effectiveRefinerProvider // Only run refiner if synthesis acts (it audits synthesis)
              ? (effectiveRefinerProvider as ProviderKey)
              : undefined,
            antagonist: effectiveAntagonistProvider
              ? (effectiveAntagonistProvider as ProviderKey)
              : undefined,
            includeRefiner: !!(shouldUseSynthesis && effectiveRefinerProvider),
            includeAntagonist: !!effectiveAntagonistProvider,
            useThinking: computeThinkFlag({
              modeThinkButtonOn: thinkOnChatGPT,
              input: prompt,
            }),
            providerMeta: {},
            clientUserTurnId: userTurnId,
          }
          : {
            type: "extend",
            sessionId: currentSessionId as string,
            userMessage: prompt,
            providers: activeProviders,
            includeMapping: shouldUseMapping,
            includeSynthesis: shouldUseSynthesis,
            synthesizer: shouldUseSynthesis
              ? (synthesisProvider as ProviderKey)
              : undefined,
            mapper: shouldUseMapping
              ? (effectiveMappingProvider as ProviderKey)
              : undefined,
            refiner: shouldUseSynthesis && effectiveRefinerProvider
              ? (effectiveRefinerProvider as ProviderKey)
              : undefined,
            antagonist: effectiveAntagonistProvider
              ? (effectiveAntagonistProvider as ProviderKey)
              : undefined,
            includeRefiner: !!(shouldUseSynthesis && effectiveRefinerProvider),
            includeAntagonist: !!effectiveAntagonistProvider,
            useThinking: computeThinkFlag({
              modeThinkButtonOn: thinkOnChatGPT,
              input: prompt,
            }),
            providerMeta: {},
            clientUserTurnId: userTurnId,
          };

        // AI turn will be created upon TURN_CREATED from backend
        // Port is already ensured above for extend; for initialize, executeWorkflow ensures port
        await api.executeWorkflow(primitive);
        // For initialize, sessionId will be set by TURN_CREATED handler; do not set here
      } catch (err) {
        console.error("Failed to execute workflow:", err);
        setIsLoading(false);
        setActiveAiTurnId(null);
      }
    },
    [
      setTurnsMap,
      setTurnIds,
      selectedModels,
      currentSessionId,
      setCurrentSessionId,
      setIsLoading,
      setActiveAiTurnId,
      synthesisProvider,
      mappingEnabled,
      mappingProvider,
      refinerProvider,
      antagonistProvider,
      thinkOnChatGPT,
      powerUserMode,
      turnIds.length,
    ],
  );

  const newChat = useCallback(() => {
    // Reset to initial welcome state for a brand-new conversation
    setCurrentSessionId(null);
    setTurnsMap(new Map());
    setTurnIds([]);
    setActiveAiTurnId(null);
    setActiveTarget(null);
  }, [setCurrentSessionId, setTurnsMap, setTurnIds, setActiveAiTurnId, setActiveTarget]);

  const selectChat = useCallback(
    async (session: HistorySessionSummary) => {
      const sessionId = session.sessionId || session.id;
      if (!sessionId) {
        console.error("[useChat] No sessionId in session object");
        return;
      }

      setCurrentSessionId(sessionId);
      setActiveTarget(null);
      setIsLoading(true);

      try {
        const response = await api.getHistorySession(sessionId);
        const fullSession = response as unknown as FullSessionPayload;

        if (!fullSession || !fullSession.turns) {
          console.warn("[useChat] Empty session loaded");
          setTurnsMap((draft: Map<string, TurnMessage>) => {
            draft.clear();
          });
          setTurnIds((draft: string[]) => {
            draft.length = 0;
          });
          setIsLoading(false);
          return;
        }

        /**
         * CRITICAL FIX: Transform backend "rounds" format
         * Backend sends: { userTurnId, aiTurnId, user: {...}, providers: {...}, synthesisResponses, mappingResponses }
         */
        const newIds: string[] = [];
        const newMap = new Map<string, TurnMessage>();

        fullSession.turns.forEach((round: any) => {
          // 1. Extract UserTurn
          if (round.user && round.user.text) {
            const userTurn: UserTurn = {
              type: "user",
              id:
                round.userTurnId || round.user.id || `user-${round.createdAt}`,
              text: round.user.text,
              createdAt: round.user.createdAt || round.createdAt || Date.now(),
              sessionId: fullSession.sessionId,
            };
            newIds.push(userTurn.id);
            newMap.set(userTurn.id, userTurn);
          }

          // 2. Extract AiTurn
          const providers = round.providers || {};
          const hasProviderData = Object.keys(providers).length > 0;

          if (hasProviderData) {
            // Transform providers object to batchResponses (arrays per provider)
            const batchResponses: Record<string, ProviderResponse[]> = {};
            Object.entries(providers).forEach(
              ([providerId, data]: [string, any]) => {
                const arr: ProviderResponse[] = Array.isArray(data)
                  ? (data as ProviderResponse[])
                  : [
                    {
                      providerId: providerId as ProviderKey,
                      text: (data?.text as string) || "",
                      status: "completed",
                      createdAt:
                        round.completedAt || round.createdAt || Date.now(),
                      updatedAt:
                        round.completedAt || round.createdAt || Date.now(),
                      meta: data?.meta || {},
                    },
                  ];
                batchResponses[providerId] = arr;
              },
            );

            // Normalize synthesis/mapping responses to arrays
            const normalizeSynthMap = (
              raw: any,
            ): Record<string, ProviderResponse[]> => {
              if (!raw) return {};
              const result: Record<string, ProviderResponse[]> = {};
              Object.entries(raw).forEach(([pid, val]: [string, any]) => {
                if (Array.isArray(val)) {
                  result[pid] = val;
                } else {
                  result[pid] = [val];
                }
              });
              return result;
            };

            const aiTurn: AiTurn = {
              type: "ai",
              id: round.aiTurnId || `ai-${round.completedAt || Date.now()}`,
              userTurnId: round.userTurnId,
              sessionId: fullSession.sessionId,
              threadId: "default-thread",
              createdAt: round.completedAt || round.createdAt || Date.now(),
              batchResponses,
              synthesisResponses: normalizeSynthMap(round.synthesisResponses),
              mappingResponses: normalizeSynthMap(round.mappingResponses),
              refinerResponses: normalizeSynthMap(round.refinerResponses),
              antagonistResponses: normalizeSynthMap(round.antagonistResponses),
            };
            newIds.push(aiTurn.id);
            newMap.set(aiTurn.id, aiTurn);
          }
        });

        console.log("[useChat] Loaded session with", newIds.length, "turns");

        // Replace Map + IDs atomically
        setTurnsMap(newMap);
        setTurnIds(newIds);

        await api.ensurePort({ sessionId });
      } catch (error) {
        console.error("[useChat] Error loading session:", error);
        setTurnsMap((draft: Map<string, TurnMessage>) => {
          draft.clear();
        });
        setTurnIds((draft: string[]) => {
          draft.length = 0;
        });
      } finally {
        setIsLoading(false);
        setIsHistoryPanelOpen(false);
      }
    },
    [
      setTurnsMap,
      setTurnIds,
      setCurrentSessionId,
      setIsLoading,
      setIsHistoryPanelOpen,
      setActiveTarget,
    ],
  );

  const deleteChat = useCallback(
    async (sessionId: string): Promise<boolean> => {
      try {
        const result = await api.deleteBackgroundSession(sessionId);
        const removed = !!result?.removed;

        // If the deleted session is currently active, clear chat state
        if (removed && currentSessionId && currentSessionId === sessionId) {
          setCurrentSessionId(null);
          setTurnsMap(new Map());
          setTurnIds([]);
          setActiveAiTurnId(null);
          setActiveTarget(null);
        }

        return removed;
      } catch (err) {
        console.error("Failed to delete session", err);
        return false;
      }
    },
    [
      currentSessionId,
      setCurrentSessionId,
      setTurnsMap,
      setTurnIds,
      setActiveAiTurnId,
      setActiveTarget,
    ],
  );

  const deleteChats = useCallback(
    async (sessionIds: string[]): Promise<{ removed: string[] }> => {
      try {
        const response = await api.deleteBackgroundSessions(sessionIds);
        const removedIds = Array.isArray(response?.ids) ? response.ids : [];
        // If active chat is among removed, clear state
        if (currentSessionId && removedIds.includes(currentSessionId)) {
          setCurrentSessionId(null);
          setTurnsMap(new Map());
          setTurnIds([]);
          setActiveAiTurnId(null);
          setActiveTarget(null);
        }
        return { removed: removedIds };
      } catch (err) {
        console.error("Failed to batch delete sessions", err);
        return { removed: [] };
      }
    },
    [
      currentSessionId,
      setCurrentSessionId,
      setTurnsMap,
      setTurnIds,
      setActiveAiTurnId,
      setActiveTarget,
    ],
  );

  const turnsMap = useAtomValue(turnsMapAtom);

  const composerModel = useAtomValue(composerModelAtom);
  const analystModel = useAtomValue(analystModelAtom);


  const runComposerFlow = useCallback(
    async (draftPrompt: string, mode: "compose" | "explain", originalPromptContext?: string) => {
      if (!draftPrompt || !draftPrompt.trim()) return;

      setiscomposing(true);

      try {
        const lastTurnId = turnIds[turnIds.length - 1];

        let userPrompt = "";
        let synthesisText = "";
        let mappingText = "";
        let batchText = "";

        if (lastTurnId) {
          const lastTurn = turnsMap.get(lastTurnId);
          if (lastTurn && lastTurn.type === "ai") {
            const aiTurn = lastTurn as AiTurn;
            const userTurn = turnsMap.get(aiTurn.userTurnId);
            userPrompt = userTurn?.type === "user" ? userTurn.text : "";

            synthesisText = Object.values(aiTurn.synthesisResponses || {})
              .flat()
              .map((r) => r.text)
              .join("\n\n");

            mappingText = Object.values(aiTurn.mappingResponses || {})
              .flat()
              .map((r) => r.text)
              .join("\n\n");

            batchText = Object.entries(aiTurn.batchResponses || {})
              .map(([pid, v]: [string, any]) => {
                const arr = Array.isArray(v) ? v : [v];
                const last = arr[arr.length - 1];
                return `[${pid}]: ${last?.text || ""}`;
              })
              .join("\n\n");
          }
        }

        const context = {
          userPrompt,
          synthesisText,
          mappingText,
          batchText,
          sessionId: currentSessionId || null,
          isInitialize: !currentSessionId || turnIds.length === 0,
        };

        // Determine the User Intent (Original Prompt)
        // If provided (chaining), use it. Otherwise, if starting fresh, the input IS the original.
        const effectiveOriginal = originalPromptContext || draftPrompt;

        if (mode === "compose") {
          // Compose Mode: Run Composer
          // Note: In new flow, we don't automatically pass critique unless we chain it. 
          // For now, simple run.
          const result = await api.runComposer(draftPrompt, context, composerModel ?? undefined);

          if (result) {
            const snippet = (result.refinedPrompt || "").slice(0, 60).trim();
            const newDraft: any = {
              id: `draft-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
              title: `Composer â€“ ${snippet}`,
              text: result.refinedPrompt,
              source: "composer",
              createdAt: Date.now(),
              originalPrompt: effectiveOriginal, // PERSIST INTENT
              primarySectionId: 'refined',
              sections: [
                { id: 'refined', title: 'Refined Prompt', text: result.refinedPrompt },
                ...(result.explanation ? [{ id: 'notes', title: 'Notes', text: result.explanation }] : [])
              ],
            };
            setLaunchpadDrafts((prev: any[]) => [newDraft, ...prev]);
            setLaunchpadOpen(true);
          }
        } else {
          // Explain Mode: Run Analyst
          // analyze the current text box content (draftPrompt) as the "candidate"
          const candidatePrompt = draftPrompt;

          const result = await api.runAnalyst(
            effectiveOriginal, // User Intent
            context,
            candidatePrompt, // The Text to Analyze
            analystModel ?? undefined,
            effectiveOriginal
          );

          if (result) {
            const ts = Date.now();
            const snippet = (candidatePrompt || "").slice(0, 60).trim();
            const sections: any[] = [];
            const primaryId = 'audit';

            const auditText = result.audit || "";
            if (auditText) {
              sections.push({ id: 'audit', title: 'Audit', text: auditText });
            }
            if (result.variants && result.variants.length > 0) {
              const numbered = result.variants.map((v, i) => `${i + 1}. ${v}`).join('\n\n');
              sections.push({ id: 'variants', title: 'Variants', text: numbered });
            }

            const analystDraft: any = {
              id: `draft-${ts}-${Math.random().toString(36).slice(2, 8)}`,
              title: `Analyst â€“ ${snippet}`,
              text: auditText || (result.variants || []).join('\n\n'),
              source: "analyst-audit",
              createdAt: ts,
              originalPrompt: effectiveOriginal, // PERSIST INTENT
              primarySectionId: primaryId,
              sections,
            };
            setLaunchpadDrafts((prev: any[]) => [analystDraft, ...prev]);
            setLaunchpadOpen(true);
          }
        }

      } catch (err) {
        console.error("Failed to run composer flow:", err);
      } finally {
        setiscomposing(false);
      }
    },
    [
      turnIds,
      turnsMap,
      setiscomposing,
      currentSessionId,
      composerModel,
      analystModel,
      setLaunchpadDrafts,
      setLaunchpadOpen
    ],
  );

  const abort = useCallback(async (): Promise<void> => {
    try {
      const sid = currentSessionId;
      if (!sid) {
        console.warn("[useChat] abort() called but no currentSessionId");
      } else {
        await api.abortWorkflow(sid);
      }
    } catch (err) {
      console.error("[useChat] Failed to abort workflow:", err);
    } finally {
      // Immediately reflect stop intent in UI; backend will send finalization if applicable
      setIsLoading(false);
      setUiPhase("awaiting_action");
    }
  }, [currentSessionId, setIsLoading, setUiPhase]);

  // Backward-compat: derive messages for consumers still expecting it
  const messages = useAtomValue(messagesAtom);
  return {
    sendMessage,
    newChat,
    selectChat,
    deleteChat,
    deleteChats,
    abort,
    runComposerFlow,
    messages,
  };
}



================================================
FILE: ui/hooks/chat/usePortMessageHandler.ts
================================================
// ui/hooks/usePortMessageHandler.ts - ALIGNED VERSION
import { useCallback, useRef, useEffect } from "react";
import { useSetAtom, useAtomValue } from "jotai";
import {
  turnsMapAtom,
  turnIdsAtom,
  currentSessionIdAtom,
  isLoadingAtom,
  uiPhaseAtom,
  activeAiTurnIdAtom,
  providerContextsAtom,
  selectedModelsAtom,
  mappingEnabledAtom,
  mappingProviderAtom,
  synthesisProviderAtom,
  refinerProviderAtom,
  antagonistProviderAtom,
  lastActivityAtAtom,
  workflowProgressAtom,
  providerErrorsAtom,
  workflowDegradedAtom,
  activeSplitPanelAtom,
  isSplitOpenAtom,
  hasAutoOpenedPaneAtom,
  hasAutoWidenedForSynthesisAtom,
  splitPaneRatioAtom,
} from "../../state/atoms";
import { activeRecomputeStateAtom, lastStreamingProviderAtom } from "../../state/atoms";
import { StreamingBuffer } from "../../utils/streamingBuffer";
import {
  applyStreamingUpdates,
  createOptimisticAiTurn,
} from "../../utils/turn-helpers";
import { normalizeProviderId } from "../../utils/provider-id-mapper";
import api from "../../services/extension-api";
import type { TurnMessage, UserTurn, AiTurn, ProviderKey } from "../../types";
import { LLM_PROVIDERS_CONFIG } from "../../constants";

const PORT_DEBUG_UI = false;

/**
 * CRITICAL: Step type detection must match backend stepId patterns
 * Backend generates: 'batch-<timestamp>', 'synthesis-<provider>-<timestamp>', 'mapping-<provider>-<timestamp>'
 */
function getStepType(stepId: string): "batch" | "synthesis" | "mapping" | "refiner" | "antagonist" | null {
  if (!stepId || typeof stepId !== "string") return null;

  // Match backend patterns exactly
  if (stepId.startsWith("synthesis-") || stepId.includes("-synthesis-"))
    return "synthesis";
  if (stepId.startsWith("mapping-") || stepId.includes("-mapping-"))
    return "mapping";
  if (stepId.startsWith("refiner-") || stepId.includes("-refiner-"))
    return "refiner";
  if (stepId.startsWith("antagonist-") || stepId.includes("-antagonist-"))
    return "antagonist";
  if (stepId.startsWith("batch-") || stepId.includes("prompt")) return "batch";

  console.warn(`[Port] Unknown stepId pattern: ${stepId}`);
  return null;
}

/**
 * Extract provider ID from stepId for synthesis/mapping steps
 * Backend format: 'synthesis-gemini-1234567890' or 'mapping-chatgpt-1234567890'
 */
function extractProviderFromStepId(
  stepId: string,
  stepType: "synthesis" | "mapping" | "refiner" | "antagonist",
): string | null {
  // Support provider IDs with hyphens/dots/etc., assuming last segment is numeric timestamp
  const re = new RegExp(`^${stepType}-(.+)-(\\d+)$`);
  const match = stepId.match(re);
  return match ? match[1] : null;
}

export function usePortMessageHandler() {
  const setTurnsMap = useSetAtom(turnsMapAtom);
  const setTurnIds = useSetAtom(turnIdsAtom);
  const setCurrentSessionId = useSetAtom(currentSessionIdAtom);
  const currentSessionId = useAtomValue(currentSessionIdAtom);
  const setIsLoading = useSetAtom(isLoadingAtom);
  const setUiPhase = useSetAtom(uiPhaseAtom);
  const activeAiTurnId = useAtomValue(activeAiTurnIdAtom);
  const setActiveAiTurnId = useSetAtom(activeAiTurnIdAtom);
  const setProviderContexts = useSetAtom(providerContextsAtom);
  const selectedModels = useAtomValue(selectedModelsAtom);
  const mappingEnabled = useAtomValue(mappingEnabledAtom);
  const mappingProvider = useAtomValue(mappingProviderAtom);
  const synthesisProvider = useAtomValue(synthesisProviderAtom);
  const refinerProvider = useAtomValue(refinerProviderAtom);
  const antagonistProvider = useAtomValue(antagonistProviderAtom);
  const setLastActivityAt = useSetAtom(lastActivityAtAtom);
  const setWorkflowProgress = useSetAtom(workflowProgressAtom);
  const setProviderErrors = useSetAtom(providerErrorsAtom);
  const setWorkflowDegraded = useSetAtom(workflowDegradedAtom);

  // Auto-open split pane state
  const isSplitOpen = useAtomValue(isSplitOpenAtom);
  const activeSplitPanel = useAtomValue(activeSplitPanelAtom);
  const setActiveSplitPanel = useSetAtom(activeSplitPanelAtom);
  const hasAutoOpenedPane = useAtomValue(hasAutoOpenedPaneAtom);
  const setHasAutoOpenedPane = useSetAtom(hasAutoOpenedPaneAtom);
  const hasAutoWidened = useAtomValue(hasAutoWidenedForSynthesisAtom);
  const setHasAutoWidened = useSetAtom(hasAutoWidenedForSynthesisAtom);
  const setSplitPaneRatio = useSetAtom(splitPaneRatioAtom);
  // Note: We rely on Jotai's per-atom update serialization; no manual pending cache

  // Refs to avoid stale closure values during streaming updates
  const isSplitOpenRef = useRef<boolean>(false);
  useEffect(() => { isSplitOpenRef.current = isSplitOpen; }, [isSplitOpen]);
  const activeSplitPanelRef = useRef<{ turnId: string; providerId: string } | null>(null);
  useEffect(() => { activeSplitPanelRef.current = activeSplitPanel; }, [activeSplitPanel]);

  const streamingBufferRef = useRef<StreamingBuffer | null>(null);
  const activeAiTurnIdRef = useRef<string | null>(null);
  const activeRecomputeRef = useRef<{
    aiTurnId: string;
    stepType: "synthesis" | "mapping" | "batch" | "refiner" | "antagonist";
    providerId: string;
  } | null>(null);
  // Track whether we've already logged the first PARTIAL_RESULT for a given
  // stepId/providerId pair to avoid noisy, repeated logs in devtools.
  const partialLoggedRef = useRef<Map<string, Set<string>>>(new Map());

  // Keep ref in sync with atom
  useEffect(() => {
    activeAiTurnIdRef.current = activeAiTurnId;
  }, [activeAiTurnId]);

  const activeRecomputeState = useAtomValue(activeRecomputeStateAtom);
  const setActiveRecomputeState = useSetAtom(activeRecomputeStateAtom);
  const setLastStreamingProvider = useSetAtom(lastStreamingProviderAtom);
  useEffect(() => {
    activeRecomputeRef.current = activeRecomputeState;
  }, [activeRecomputeState]);

  const handler = useCallback(
    (message: any) => {
      if (!message || !message.type) return;

      if (
        PORT_DEBUG_UI &&
        message.type !== "PARTIAL_RESULT" &&
        message.type !== "WORKFLOW_PROGRESS"
      ) {
        console.log("[Port Handler]", message.type, message);
      }

      switch (message.type) {

        case "PREFLIGHT_WARNINGS": {
          const { warnings } = message;
          console.warn('[Preflight] Warnings:', warnings);
          if (Array.isArray(warnings)) {
            warnings.forEach((warning: string) => {
              console.warn('[Preflight]', warning);
            });
          }
          break;
        }

        case "TURN_CREATED": {
          const {
            userTurnId,
            aiTurnId,
            sessionId: msgSessionId,
            providers: msgProviders,
            synthesisProvider: msgSynthesisProvider,
            mappingProvider: msgMappingProvider,
            refinerProvider: msgRefinerProvider,
            antagonistProvider: msgAntagonistProvider
          } = message;

          // Always adopt the backend sessionId for TURN_CREATED
          if (msgSessionId) {
            if (!currentSessionId || currentSessionId === msgSessionId) {
              setCurrentSessionId(msgSessionId);
            }
          }

          // âœ… CRITICAL FIX: Use providers from message (authoritative backend data)
          // instead of reading from atoms which may be stale
          const activeProviders = msgProviders && msgProviders.length > 0
            ? msgProviders
            : LLM_PROVIDERS_CONFIG.filter((p) => selectedModels[p.id]).map((p) => p.id as ProviderKey);

          const effectiveSynthesisProvider = msgSynthesisProvider || synthesisProvider;
          const effectiveMappingProvider = msgMappingProvider || mappingProvider;
          const effectiveRefinerProvider = msgRefinerProvider || refinerProvider;
          const effectiveAntagonistProvider = msgAntagonistProvider || antagonistProvider;

          // Single atomic update to turnsMap ensures we read the latest user turn
          setTurnsMap((draft: Map<string, TurnMessage>) => {
            const existing = draft.get(userTurnId);
            if (!existing || existing.type !== "user") {
              // Under Jotai's per-atom serialization, the user turn should be present.
              // If not, avoid creating the AI turn prematurely.
              console.error(
                "[Port] TURN_CREATED: user turn missing in updater for",
                userTurnId,
              );
              return;
            }
            const existingUser = existing as UserTurn;
            const ensuredUser: UserTurn = {
              ...existingUser,
              sessionId:
                existingUser.sessionId ||
                msgSessionId ||
                currentSessionId ||
                null,
            };
            // Backfill sessionId if it was missing
            draft.set(userTurnId, ensuredUser);

            const aiTurn = createOptimisticAiTurn(
              aiTurnId,
              ensuredUser,
              activeProviders,
              !!mappingEnabled && !!effectiveMappingProvider, // 1. Mapping
              !!effectiveSynthesisProvider,                  // 2. Synthesis
              !!effectiveRefinerProvider,                    // 3. Refiner
              effectiveMappingProvider || undefined,
              effectiveSynthesisProvider || undefined,
              effectiveRefinerProvider || undefined,
              effectiveAntagonistProvider || undefined,       // 4. Antagonist
              Date.now(),
              ensuredUser.id,
              {
                mapping: !!mappingEnabled && !!effectiveMappingProvider,
                synthesis: !!effectiveSynthesisProvider,
                refiner: !!effectiveRefinerProvider,
                antagonist: !!effectiveAntagonistProvider
              },
            );
            draft.set(aiTurnId, aiTurn);
          });

          // Ensure ordering in ID list (user first, then AI)
          setTurnIds((idsDraft: string[]) => {
            if (!idsDraft.includes(userTurnId)) idsDraft.push(userTurnId);
            if (!idsDraft.includes(aiTurnId)) idsDraft.push(aiTurnId);
          });

          setActiveAiTurnId(aiTurnId);
          setLastActivityAt(Date.now());
          break;
        }

        case "TURN_FINALIZED": {
          const {
            userTurnId,
            aiTurnId,
            turn,
            sessionId: msgSessionId,
          } = message;

          // Adopt sessionId on finalization to ensure coherence
          if (msgSessionId) {
            if (!currentSessionId || currentSessionId === msgSessionId) {
              setCurrentSessionId(msgSessionId);
            }
          }

          console.log("[Port] Received TURN_FINALIZED", {
            userTurnId,
            aiTurnId,
            hasUserData: !!turn?.user,
            hasAiData: !!turn?.ai,
            aiHasUserTurnId: !!turn?.ai?.userTurnId,
          });

          // Flush any pending streaming data first
          streamingBufferRef.current?.flushImmediate?.();

          // Merge canonical data into existing turns (no ID remapping needed)
          setTurnsMap((draft: Map<string, TurnMessage>) => {
            // Update user turn if provided
            if (turn?.user) {
              const existingUser = draft.get(turn.user.id) as
                | UserTurn
                | undefined;
              draft.set(turn.user.id, {
                ...(existingUser || {}),
                ...(turn.user as UserTurn),
              });
            }

            if (turn?.ai) {
              const existingAi = draft.get(aiTurnId) as AiTurn | undefined;
              if (!existingAi) {
                // Fallback: if the AI turn wasn't created (should be rare), add it directly
                // Normalize batchResponses to arrays if needed
                const incoming = turn.ai as any;
                const normalizedBatch = Object.fromEntries(
                  Object.entries(incoming.batchResponses || {}).map(([pid, val]: [string, any]) => [
                    pid,
                    Array.isArray(val) ? (val as any[]) : [val],
                  ]),
                );
                draft.set(aiTurnId, { ...(turn.ai as AiTurn), batchResponses: normalizedBatch } as AiTurn);
              } else {
                const mergedAi: AiTurn = {
                  ...existingAi,
                  ...(turn.ai as AiTurn),
                  type: "ai",
                  userTurnId: turn.user?.id || existingAi.userTurnId,
                  // Merge responses: preserve existing data while accepting backend updates
                  // This is important for recompute scenarios where only some responses change
                  batchResponses: (() => {
                    const incoming = (turn.ai as any)?.batchResponses || {};
                    const normalizedIncoming = Object.fromEntries(
                      Object.entries(incoming).map(([pid, val]: [string, any]) => [
                        pid,
                        Array.isArray(val) ? (val as any[]) : [val],
                      ]),
                    );
                    return {
                      ...(existingAi.batchResponses || {}),
                      ...normalizedIncoming,
                    } as any;
                  })(),
                  synthesisResponses: {
                    ...(existingAi.synthesisResponses || {}),
                    ...((turn.ai as AiTurn)?.synthesisResponses || {}),
                  },
                  mappingResponses: {
                    ...(existingAi.mappingResponses || {}),
                    ...((turn.ai as AiTurn)?.mappingResponses || {}),
                  },
                  meta: {
                    ...(existingAi.meta || {}),
                    ...((turn.ai as AiTurn)?.meta || {}),
                    isOptimistic: false,
                  },
                };
                draft.set(aiTurnId, mergedAi);
              }
            }
          });

          // Ensure canonical IDs exist in turnIds (no remapping)
          setTurnIds((idsDraft: string[]) => {
            const ensureId = (id: string | undefined) => {
              if (!id) return;
              if (!idsDraft.includes(id)) idsDraft.push(id);
            };
            ensureId(turn?.user?.id);
            ensureId(aiTurnId);
            // Deduplicate while preserving the first occurrence
            const seen = new Set<string>();
            for (let i = idsDraft.length - 1; i >= 0; i--) {
              const id = idsDraft[i];
              if (seen.has(id)) {
                idsDraft.splice(i, 1);
              } else {
                seen.add(id);
              }
            }
          });

          // Finalization UI state updates
          setIsLoading(false);
          setUiPhase("awaiting_action");
          // Clear active AI turn only after finalization (not in WORKFLOW_COMPLETE)
          setActiveAiTurnId(null);
          setLastActivityAt(Date.now());

          // Reset streaming UX state flags on finalization
          setHasAutoOpenedPane(null);
          setHasAutoWidened(null);

          break;
        }

        case "PARTIAL_RESULT": {
          const {
            stepId,
            providerId,
            chunk,
          } = message;
          if (!chunk?.text) return;

          const stepType = getStepType(stepId);
          if (!stepType) {
            console.warn(`[Port] Cannot determine step type for: ${stepId}`);
            return;
          }

          // Some backends omit providerId for synthesis/mapping partials; derive from stepId if needed
          let pid: string | null | undefined = providerId;
          if (
            (!pid || typeof pid !== "string") &&
            (stepType === "synthesis" || stepType === "mapping")
          ) {
            pid = extractProviderFromStepId(stepId, stepType);
          }
          // âœ… Normalize provider ID to canonical form
          if (pid) {
            pid = normalizeProviderId(pid);
          }
          if (!pid) {
            if (STREAMING_DEBUG_UI) {
              console.warn(
                `[Port] PARTIAL_RESULT missing providerId and could not be derived for step ${stepId}`,
              );
            }
            return;
          }

          // Track which provider is actively streaming (for granular UI indicators)
          setLastStreamingProvider(pid);

          // Log the first partial per provider per step only
          try {
            let perStep = partialLoggedRef.current.get(stepId);
            if (!perStep) {
              perStep = new Set<string>();
              partialLoggedRef.current.set(stepId, perStep);
            }
            if (!perStep.has(pid as string)) {
              const preview =
                typeof chunk?.text === "string" ? chunk.text.slice(0, 200) : "";
              console.log("[Port Handler] PARTIAL_RESULT (first)", {
                stepId,
                providerId: pid,
                preview,
              });
              perStep.add(pid as string);
            }
          } catch (e) {
            // non-fatal
          }

          // Initialize buffer if needed
          if (!streamingBufferRef.current) {
            streamingBufferRef.current = new StreamingBuffer((updates) => {
              const activeId =
                activeRecomputeRef.current?.aiTurnId ||
                activeAiTurnIdRef.current;
              if (!activeId || !updates || updates.length === 0) return;

              setTurnsMap((draft: Map<string, TurnMessage>) => {
                const existing = draft.get(activeId);
                if (!existing || existing.type !== "ai") return;
                const aiTurn = existing as AiTurn;

                // Apply batched updates
                applyStreamingUpdates(aiTurn, updates);

                // CRITICAL: ensure the Map entry is observed as changed
                draft.set(activeId, { ...aiTurn });
              });
            });
          }

          streamingBufferRef.current.addDelta(
            pid,
            chunk.text,
            "streaming",
            stepType,
          );
          setLastActivityAt(Date.now());

          // Store provider context in separate atom
          if (chunk.meta) {
            setProviderContexts((draft: Record<string, any>) => {
              draft[pid as string] = {
                ...(draft[pid as string] || {}),
                ...chunk.meta,
              };
            });
          }
          break;
        }

        case "WORKFLOW_STEP_UPDATE": {
          const {
            stepId,
            status,
            result,
            error,
          } = message;

          // Clean up once a step completes/fails to avoid memory growth
          if (status === "completed" || status === "failed") {
            try {
              partialLoggedRef.current.delete(stepId);
            } catch { }
          }

          // Do not gate by session; process updates irrespective of UI session state

          if (status === "completed" && result) {
            streamingBufferRef.current?.flushImmediate();
            setLastActivityAt(Date.now());

            // âœ… CRITICAL FIX: Properly detect step type and route completions
            const stepType = getStepType(stepId);

            if (!stepType) {
              console.error(
                `[Port] Cannot route completion - unknown stepId: ${stepId}`,
              );
              break;
            }

            // Backend sends either:
            // 1. { results: { claude: {...}, gemini: {...} } } for batch steps
            // 2. { providerId: 'gemini', text: '...', status: '...' } for single-provider steps
            const resultsMap =
              result.results ||
              (result.providerId ? { [result.providerId]: result } : {});

            const _completedProviders: string[] = [];
            Object.entries(resultsMap).forEach(
              ([providerId, data]: [string, any]) => {
                // âœ… Normalize provider ID to canonical form
                const normalizedId = normalizeProviderId(providerId);
                const targetId =
                  (message as any).isRecompute && (message as any).sourceTurnId
                    ? (message as any).sourceTurnId
                    : activeAiTurnIdRef.current;
                if (!targetId) return;
                _completedProviders.push(normalizedId);

                setTurnsMap((draft: Map<string, TurnMessage>) => {
                  const existing = draft.get(targetId);
                  if (!existing || existing.type !== "ai") return;
                  const aiTurn = existing as AiTurn;

                  // Helper to safely update/append response
                  const updateResponseList = (
                    list: any[] | undefined,
                    entry: any,
                  ) => {
                    const arr = Array.isArray(list) ? [...list] : [];
                    const last = arr.length > 0 ? arr[arr.length - 1] : null;
                    // If last item is completed/error, we append a new version (history).
                    // If last item is streaming/pending, we update it (in-place).
                    const isFinal =
                      last?.status === "completed" || last?.status === "error";

                    if (!last || isFinal) {
                      arr.push(entry);
                    } else {
                      // Preserve creation time when updating
                      arr[arr.length - 1] = {
                        ...last,
                        ...entry,
                        createdAt: last.createdAt,
                      };
                    }
                    return arr;
                  };

                  const baseEntry = {
                    providerId: normalizedId,
                    text: data?.text || "",
                    status: "completed" as const,
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    meta: {
                      ...(data?.meta || {}),
                      isPrimary: normalizedId === synthesisProvider
                    },
                    artifacts: data?.artifacts || [], // âœ… Preserve artifacts
                  };

                  if (stepType === "synthesis") {
                    aiTurn.synthesisResponses = {
                      ...(aiTurn.synthesisResponses || {}),
                      [normalizedId]: updateResponseList(
                        aiTurn.synthesisResponses?.[normalizedId],
                        baseEntry,
                      ),
                    };
                    aiTurn.synthesisVersion =
                      (aiTurn.synthesisVersion ?? 0) + 1;
                  } else if (stepType === "mapping") {
                    aiTurn.mappingResponses = {
                      ...(aiTurn.mappingResponses || {}),
                      [normalizedId]: updateResponseList(
                        aiTurn.mappingResponses?.[normalizedId],
                        baseEntry,
                      ),
                    };
                    aiTurn.mappingVersion = (aiTurn.mappingVersion ?? 0) + 1;
                  } else if (stepType === "batch") {
                    aiTurn.batchResponses = {
                      ...(aiTurn.batchResponses || {}),
                      [normalizedId]: updateResponseList(
                        aiTurn.batchResponses?.[normalizedId],
                        baseEntry,
                      ),
                    };
                  } else if (stepType === "refiner") {
                    aiTurn.refinerResponses = {
                      ...(aiTurn.refinerResponses || {}),
                      [normalizedId]: updateResponseList(
                        aiTurn.refinerResponses?.[normalizedId],
                        baseEntry,
                      ),
                    };
                    aiTurn.refinerVersion = (aiTurn.refinerVersion ?? 0) + 1;
                  } else if (stepType === "antagonist") {
                    aiTurn.antagonistResponses = {
                      ...(aiTurn.antagonistResponses || {}),
                      [normalizedId]: updateResponseList(
                        aiTurn.antagonistResponses?.[normalizedId],
                        baseEntry,
                      ),
                    };
                    aiTurn.antagonistVersion = (aiTurn.antagonistVersion ?? 0) + 1;
                  }

                  // CRITICAL: ensure the Map entry is observed as changed
                  draft.set(targetId, { ...aiTurn });
                });

                if (data?.meta) {
                  setProviderContexts((draft: Record<string, any>) => {
                    draft[normalizedId] = {
                      ...(draft[normalizedId] || {}),
                      ...data.meta,
                    };
                  });
                }
              },
            );

            // Emit a single aggregated completion log for batch steps to reduce verbosity
            try {
              if (stepType === "batch") {
                const targetId = activeAiTurnIdRef.current;
                if (targetId && _completedProviders.length > 0) {
                  console.log(
                    `[Port] Batch step completed on turn ${targetId} with results from ${_completedProviders.length} providers: ${_completedProviders.join(", ")}`,
                  );
                }
              }
            } catch (_) { }

            if (message.isRecompute) {
              setActiveRecomputeState(null);
            }
          } else if (status === "failed") {
            console.error(`[Port] Step failed: ${stepId}`, error);
            // Update the corresponding response entry to reflect the error
            try {
              const stepType = getStepType(stepId);
              if (stepType) {
                let providerId: string | null | undefined = result?.providerId;
                if (
                  (!providerId || typeof providerId !== "string") &&
                  (!providerId || typeof providerId !== "string") &&
                  (stepType === "synthesis" || stepType === "mapping" || stepType === "refiner" || stepType === "antagonist")
                ) {
                  providerId = extractProviderFromStepId(stepId, stepType);
                }
                // âœ… Normalize provider ID to canonical form
                if (providerId) {
                  providerId = normalizeProviderId(providerId);
                }
                const targetId = (message as any).isRecompute && (message as any).sourceTurnId
                  ? (message as any).sourceTurnId
                  : activeRecomputeRef.current?.aiTurnId ||
                  activeAiTurnIdRef.current;
                if (targetId && providerId) {
                  setTurnsMap((draft: Map<string, TurnMessage>) => {
                    const existing = draft.get(targetId);
                    if (!existing || existing.type !== "ai") return;
                    const aiTurn = existing as AiTurn;
                    const errText =
                      typeof error === "string" ? error : result?.text || "";
                    const now = Date.now();

                    if (stepType === "synthesis") {
                      const arr = Array.isArray(
                        aiTurn.synthesisResponses?.[providerId!],
                      )
                        ? [
                          ...(aiTurn.synthesisResponses![
                            providerId!
                          ] as any[]),
                        ]
                        : [];
                      if (arr.length > 0) {
                        const latest = arr[arr.length - 1] as any;
                        arr[arr.length - 1] = {
                          ...latest,
                          status: "error",
                          text: errText || (latest?.text ?? ""),
                          updatedAt: now,
                        };
                      } else {
                        arr.push({
                          providerId: providerId!,
                          text: errText || "",
                          status: "error",
                          createdAt: now,
                          updatedAt: now,
                        } as any);
                      }
                      aiTurn.synthesisResponses = {
                        ...(aiTurn.synthesisResponses || {}),
                        [providerId!]: arr as any,
                      };
                      aiTurn.synthesisVersion = (aiTurn.synthesisVersion ?? 0) + 1;
                    } else if (stepType === "mapping") {
                      const arr = Array.isArray(
                        aiTurn.mappingResponses?.[providerId!],
                      )
                        ? [...(aiTurn.mappingResponses![providerId!] as any[])]
                        : [];
                      if (arr.length > 0) {
                        const latest = arr[arr.length - 1] as any;
                        arr[arr.length - 1] = {
                          ...latest,
                          status: "error",
                          text: errText || (latest?.text ?? ""),
                          updatedAt: now,
                        };
                      } else {
                        arr.push({
                          providerId: providerId!,
                          text: errText || "",
                          status: "error",
                          createdAt: now,
                          updatedAt: now,
                        } as any);
                      }
                      aiTurn.mappingResponses = {
                        ...(aiTurn.mappingResponses || {}),
                        [providerId!]: arr as any,
                      };
                      aiTurn.mappingVersion = (aiTurn.mappingVersion ?? 0) + 1;
                    } else if (stepType === "batch") {
                      const arr = Array.isArray(aiTurn.batchResponses?.[providerId!])
                        ? [...(aiTurn.batchResponses![providerId!] as any[])]
                        : [];
                      if (arr.length > 0) {
                        const latest = arr[arr.length - 1] as any;
                        arr[arr.length - 1] = {
                          ...latest,
                          status: "error",
                          text: errText || (latest?.text ?? ""),
                          updatedAt: now,
                        } as any;
                      } else {
                        arr.push({
                          providerId: providerId!,
                          text: errText || "",
                          status: "error",
                          createdAt: now,
                          updatedAt: now,
                        } as any);
                      }
                      aiTurn.batchResponses = {
                        ...(aiTurn.batchResponses || {}),
                        [providerId!]: arr as any,
                      } as any;
                    } else if (stepType === "refiner") {
                      const arr = Array.isArray(aiTurn.refinerResponses?.[providerId!])
                        ? [...(aiTurn.refinerResponses![providerId!] as any[])]
                        : [];
                      if (arr.length > 0) {
                        const latest = arr[arr.length - 1] as any;
                        arr[arr.length - 1] = {
                          ...latest,
                          status: "error",
                          text: errText || (latest?.text ?? ""),
                          updatedAt: now,
                        } as any;
                      } else {
                        arr.push({
                          providerId: providerId!,
                          text: errText || "",
                          status: "error",
                          createdAt: now,
                          updatedAt: now,
                        } as any);
                      }
                      aiTurn.refinerResponses = {
                        ...(aiTurn.refinerResponses || {}),
                        [providerId!]: arr as any,
                      } as any;
                      aiTurn.refinerVersion = (aiTurn.refinerVersion ?? 0) + 1;
                    } else if (stepType === "antagonist") {
                      const arr = Array.isArray(aiTurn.antagonistResponses?.[providerId!])
                        ? [...(aiTurn.antagonistResponses![providerId!] as any[])]
                        : [];
                      if (arr.length > 0) {
                        const latest = arr[arr.length - 1] as any;
                        arr[arr.length - 1] = {
                          ...latest,
                          status: "error",
                          text: errText || (latest?.text ?? ""),
                          updatedAt: now,
                        } as any;
                      } else {
                        arr.push({
                          providerId: providerId!,
                          text: errText || "",
                          status: "error",
                          createdAt: now,
                          updatedAt: now,
                        } as any);
                      }
                      aiTurn.antagonistResponses = {
                        ...(aiTurn.antagonistResponses || {}),
                        [providerId!]: arr as any,
                      } as any;
                      aiTurn.antagonistVersion = (aiTurn.antagonistVersion ?? 0) + 1;
                    }
                  });
                }
              }
            } catch (e) {
              console.warn(
                "[Port] Failed to tag error state on turn response",
                e,
              );
            }

            setIsLoading(false);
            setUiPhase("awaiting_action");
            setLastActivityAt(Date.now());
            // On failure, clear recompute target so UI stops indicating loading
            if (message.isRecompute) {
              setActiveRecomputeState(null);
            }
          }
          break;
        }

        case "WORKFLOW_PROGRESS": {
          try {
            const { providerStatuses, phase } = message as any;
            const mapStatusToStage = (
              status: 'queued' | 'active' | 'streaming' | 'completed' | 'failed',
              phase: 'batch' | 'synthesis' | 'mapping'
            ) => {
              if (status === 'queued') return 'idle';
              if (status === 'active') return phase === 'synthesis' ? 'synthesizing' : 'thinking';
              if (status === 'streaming') return 'streaming';
              if (status === 'completed') return 'complete';
              if (status === 'failed') return 'error';
              return 'idle';
            };
            if (Array.isArray(providerStatuses)) {
              const progressMap: Record<string, { stage: string; progress?: number; error?: string }> = {};
              for (const ps of providerStatuses) {
                const pid = String(ps.providerId);
                progressMap[pid] = {
                  stage: mapStatusToStage(ps.status, phase),
                  progress: typeof ps.progress === 'number' ? ps.progress : undefined,
                  error: ps.error,
                };
              }
              setWorkflowProgress(progressMap as any);

              // NEW: Extract and store errors for retry controls
              try {
                const errors: Record<string, any> = {};
                for (const status of providerStatuses) {
                  if (status?.error) {
                    errors[String(status.providerId)] = status.error;
                  }
                }
                setProviderErrors(errors);
              } catch (_) { }

              // AUTO-OPEN SPLIT PANE: On first streaming provider (do not override if already open or user-selected)
              const activeId = activeAiTurnIdRef.current;
              if (activeId && hasAutoOpenedPane !== activeId && phase === 'batch') {
                const firstStreaming = providerStatuses.find(
                  (ps: any) => ps.status === 'streaming' || ps.status === 'active'
                );

                if (firstStreaming && !isSplitOpenRef.current && !activeSplitPanelRef.current) {
                  setActiveSplitPanel({
                    turnId: activeId,
                    providerId: String(firstStreaming.providerId)
                  });
                  setSplitPaneRatio(70); // Left pane 70%, right pane 30%
                  setHasAutoOpenedPane(activeId);
                }
              }

              // AUTO-WIDEN FOR SYNTHESIS: When synthesis phase starts
              if (
                activeId &&
                phase === 'synthesis' &&
                hasAutoWidened !== activeId
              ) {
                setSplitPaneRatio(75); // Widen left pane to 75%
                setHasAutoWidened(activeId);
              }
            }
          } catch (e) {
            console.warn('[Port] Failed to process WORKFLOW_PROGRESS', e);
          }
          break;
        }

        case "WORKFLOW_PARTIAL_COMPLETE": {
          try {
            const partialMsg = message as any;
            setWorkflowDegraded({
              isDegraded: Array.isArray(partialMsg.failedProviders) && partialMsg.failedProviders.length > 0,
              successCount: Array.isArray(partialMsg.successfulProviders) ? partialMsg.successfulProviders.length : 0,
              totalCount: ((partialMsg.successfulProviders || []).length) + ((partialMsg.failedProviders || []).length),
              failedProviders: (partialMsg.failedProviders || []).map((f: any) => f.providerId),
            });
            const errors: Record<string, any> = {};
            for (const failed of partialMsg.failedProviders || []) {
              errors[failed.providerId] = failed.error;
            }
            setProviderErrors(errors);
          } catch (e) {
            console.warn('[Port] Failed to process WORKFLOW_PARTIAL_COMPLETE', e);
          }
          break;
        }

        case "WORKFLOW_COMPLETE": {
          const { } = message;

          streamingBufferRef.current?.flushImmediate();
          // Fallback finalization is no longer needed.
          // The robust TURN_FINALIZED handler will manage this state change.
          setIsLoading(false);
          setUiPhase("awaiting_action");
          setLastActivityAt(Date.now());

          // Reset streaming UX state for next round
          setHasAutoOpenedPane(null);
          setHasAutoWidened(null);
          // Do NOT clear activeAiTurnId here; wait for TURN_FINALIZED
          break;
        }
      }
    },
    [
      setTurnsMap,
      setTurnIds,
      setCurrentSessionId,
      currentSessionId,
      setIsLoading,
      setUiPhase,
      setActiveAiTurnId,
      setProviderContexts,
      selectedModels,
      mappingEnabled,
      mappingProvider,
      synthesisProvider,
      refinerProvider,
      // Auto-open split pane dependencies
      isSplitOpen,
      setActiveSplitPanel,
      hasAutoOpenedPane,
      setHasAutoOpenedPane,
      hasAutoWidened,
      setHasAutoWidened,
      setSplitPaneRatio,
    ],
  );

  // Register handler with API
  useEffect(() => {
    api.setPortMessageHandler(handler);
    return () => {
      api.setPortMessageHandler(null);
      streamingBufferRef.current?.clear();
    };
  }, [handler]);

  return { streamingBufferRef };
}
// Minimize streaming log noise in UI; toggle for deep debugging only
const STREAMING_DEBUG_UI = false;



================================================
FILE: ui/hooks/chat/useRoundActions.ts
================================================
// ui/hooks/useRoundActions.ts - PRIMITIVES-ALIGNED VERSION
import { useCallback, useRef } from "react";
import { useAtom, useAtomValue, useSetAtom } from "jotai";

import {
  turnsMapAtom,
  synthRecomputeSelectionsByRoundAtom,
  mappingRecomputeSelectionByRoundAtom,
  currentSessionIdAtom,
  isLoadingAtom,
  uiPhaseAtom,
  currentAppStepAtom,
  activeAiTurnIdAtom,
  thinkSynthByRoundAtom,
  thinkMappingByRoundAtom,
  activeRecomputeStateAtom,
  alertTextAtom,
} from "../../state/atoms";
import api from "../../services/extension-api";
import { PRIMARY_STREAMING_PROVIDER_IDS } from "../../constants";
import type {
  ProviderKey,
  PrimitiveWorkflowRequest,
} from "../../../shared/contract";
import type { TurnMessage, AiTurn, ProviderResponse } from "../../types";

export function useRoundActions() {
  const turnsMap = useAtomValue(turnsMapAtom);
  const setTurnsMap = useSetAtom(turnsMapAtom);

  const [synthSelectionsByRound, setSynthSelectionsByRound] = useAtom(
    synthRecomputeSelectionsByRoundAtom,
  );
  const [mappingSelectionByRound, setMappingSelectionByRound] = useAtom(
    mappingRecomputeSelectionByRoundAtom,
  );
  const [currentSessionId] = useAtom(currentSessionIdAtom);
  const setIsLoading = useSetAtom(isLoadingAtom);
  const setUiPhase = useSetAtom(uiPhaseAtom);
  const setCurrentAppStep = useSetAtom(currentAppStepAtom);
  const setActiveAiTurnId = useSetAtom(activeAiTurnIdAtom);
  const [thinkSynthByRound] = useAtom(thinkSynthByRoundAtom);
  const [thinkMappingByRound] = useAtom(thinkMappingByRoundAtom);
  const setActiveRecomputeState = useSetAtom(activeRecomputeStateAtom);
  const setAlertText = useSetAtom(alertTextAtom);

  const isSynthRunningRef = useRef(false);

  // ============================================================================
  // SYNTHESIS RECOMPUTE (Direct AI Turn Operation)
  // ============================================================================

  /**
   * Recompute synthesis for a specific AI turn.
   * Uses the 'recompute' primitive which fetches frozen outputs from the backend.
   *
   * @param aiTurnId - The AI turn to recompute synthesis for
   * @param providerIdOverride - Optional: Force synthesis for a specific provider
   */
  const runSynthesisForAiTurn = useCallback(
    async (aiTurnId: string, providerIdOverride?: string) => {
      if (!currentSessionId || isSynthRunningRef.current) return;

      const ai = turnsMap.get(aiTurnId) as AiTurn | undefined;
      if (!ai || ai.type !== "ai") {
        console.warn(`[RoundActions] AI turn ${aiTurnId} not found`);
        return;
      }

      // âœ… Validate we have enough source data for synthesis
      const outputsFromBatch = Object.values(ai.batchResponses || {})
        .map((v: any) => (Array.isArray(v) ? v : [v]))
        .map((arr: any[]) => arr[arr.length - 1])
        .filter((r: any) => r && r.status === "completed" && r.text?.trim());

      const hasCompletedSynthesis = ai?.synthesisResponses
        ? Object.values(ai.synthesisResponses).some((resp) => {
          const responses = Array.isArray(resp) ? resp : [resp];
          return responses.some(
            (r) => r.status === "completed" && r.text?.trim(),
          );
        })
        : false;

      const hasCompletedMapping = ai?.mappingResponses
        ? Object.values(ai.mappingResponses).some((resp) => {
          const responses = Array.isArray(resp) ? resp : [resp];
          return responses.some(
            (r) => r.status === "completed" && r.text?.trim(),
          );
        })
        : false;

      const enoughOutputs =
        outputsFromBatch.length >= 2 ||
        hasCompletedSynthesis ||
        hasCompletedMapping;
      if (!enoughOutputs) {
        console.warn(
          `[RoundActions] Not enough outputs for synthesis in turn ${aiTurnId}`,
        );
        setAlertText("Not enough source data to run synthesis. Please wait for more providers to finish.");
        return;
      }

      // âœ… Determine which providers to synthesize
      // NOTE: UI state keys still use userTurnId for backward compatibility
      const userTurnId = ai.userTurnId;
      const selected = providerIdOverride
        ? [providerIdOverride]
        : Object.entries(synthSelectionsByRound[userTurnId] || {})
          .filter(([_, on]) => on)
          .map(([pid]) => pid);

      if (selected.length === 0) {
        console.warn(
          `[RoundActions] No synthesis providers selected for turn ${aiTurnId}`,
        );
        return;
      }

      // âœ… Initialize optimistic synthesis responses in UI state
      setTurnsMap((draft: Map<string, TurnMessage>) => {
        const existing = draft.get(ai.id);
        if (!existing || existing.type !== "ai") return;
        const aiTurn = existing as AiTurn;
        if (!aiTurn.synthesisResponses) aiTurn.synthesisResponses = {};
        const next: Record<string, ProviderResponse[]> = {
          ...aiTurn.synthesisResponses,
        };

        selected.forEach((pid) => {
          const arr = Array.isArray(next[pid]) ? [...next[pid]] : [];
          const initialStatus: "streaming" | "pending" =
            PRIMARY_STREAMING_PROVIDER_IDS.includes(pid)
              ? "streaming"
              : "pending";

          arr.push({
            providerId: pid as ProviderKey,
            text: "",
            status: initialStatus,
            createdAt: Date.now(),
          });
          next[pid] = arr;
        });
        aiTurn.synthesisResponses = next;
        aiTurn.synthesisVersion = (aiTurn.synthesisVersion ?? 0) + 1;
      });

      // âœ… Set loading state
      setActiveAiTurnId(ai.id);
      isSynthRunningRef.current = true;
      setIsLoading(true);
      setUiPhase("streaming");
      setCurrentAppStep("synthesis");

      try {
        // âœ… Execute recompute primitive for each selected provider
        for (const pid of selected) {
          // Aim recompute state precisely at the current provider/turn
          setActiveRecomputeState({
            aiTurnId: ai.id,
            stepType: "synthesis",
            providerId: pid,
          });

          // âœ… Send recompute primitive - backend will fetch frozen outputs
          const primitive: PrimitiveWorkflowRequest = {
            type: "recompute",
            sessionId: currentSessionId as string,
            sourceTurnId: ai.id, // âœ… Direct AI turn reference - no user turn lookup needed
            stepType: "synthesis",
            targetProvider: pid as ProviderKey,
            useThinking: !!thinkSynthByRound[userTurnId],
          };

          await api.executeWorkflow(primitive);
        }

        // âœ… Persist last synthesis model preference
        if (selected.length === 1) {
          try {
            localStorage.setItem("htos_last_synthesis_model", selected[0]);
          } catch { }
        }
      } catch (err) {
        console.error("[RoundActions] Synthesis run failed:", err);
        setAlertText("Synthesis request failed. Please try again.");

        // Revert optimistic state to error
        setTurnsMap((draft) => {
          const turn = draft.get(ai.id) as AiTurn | undefined;
          if (!turn || turn.type !== "ai" || !turn.synthesisResponses) return;
          selected.forEach((pid) => {
            const arr = turn.synthesisResponses?.[pid];
            if (Array.isArray(arr) && arr.length > 0) {
              const last = arr[arr.length - 1];
              if (last.status === "streaming" || last.status === "pending") {
                last.status = "error";
                last.text = "Request failed";
              }
            }
          });
        });

        setIsLoading(false);
        setUiPhase("awaiting_action");
        setActiveAiTurnId(null);
        setActiveRecomputeState(null);
      } finally {
        isSynthRunningRef.current = false;
      }
    },
    [
      currentSessionId,
      turnsMap,
      synthSelectionsByRound,
      thinkSynthByRound,
      setTurnsMap,
      setActiveAiTurnId,
      setIsLoading,
      setUiPhase,
      setCurrentAppStep,
      setActiveRecomputeState,
      setAlertText,
    ],
  );

  // ============================================================================
  // MAPPING RECOMPUTE (Direct AI Turn Operation)
  // ============================================================================

  /**
   * Recompute mapping for a specific AI turn.
   * Uses the 'recompute' primitive which fetches frozen outputs from the backend.
   *
   * @param aiTurnId - The AI turn to recompute mapping for
   * @param providerIdOverride - Optional: Force mapping for a specific provider
   */
  const runMappingForAiTurn = useCallback(
    async (aiTurnId: string, providerIdOverride?: string) => {
      if (!currentSessionId) return;

      const ai = turnsMap.get(aiTurnId) as AiTurn | undefined;
      if (!ai || ai.type !== "ai") {
        console.warn(`[RoundActions] AI turn ${aiTurnId} not found`);
        return;
      }

      // âœ… Validate we have enough source data for mapping
      const outputsFromBatch = Object.values(ai.batchResponses || {}).filter(
        (r: any) => r.status === "completed" && r.text?.trim(),
      );

      const hasCompletedSynthesis = ai?.synthesisResponses
        ? Object.values(ai.synthesisResponses).some((resp) => {
          const responses = Array.isArray(resp) ? resp : [resp];
          return responses.some(
            (r) => r.status === "completed" && r.text?.trim(),
          );
        })
        : false;

      const hasCompletedMapping = ai?.mappingResponses
        ? Object.values(ai.mappingResponses).some((resp) => {
          const responses = Array.isArray(resp) ? resp : [resp];
          return responses.some(
            (r) => r.status === "completed" && r.text?.trim(),
          );
        })
        : false;

      const enoughOutputs =
        outputsFromBatch.length >= 2 ||
        hasCompletedSynthesis ||
        hasCompletedMapping;
      if (!enoughOutputs) {
        console.warn(
          `[RoundActions] Not enough outputs for mapping in turn ${aiTurnId}`,
        );
        setAlertText("Not enough source data to run mapping. Please wait for more providers to finish.");
        return;
      }

      // âœ… Determine which provider to use for mapping
      // NOTE: UI state keys still use userTurnId for backward compatibility
      const userTurnId = ai.userTurnId;
      const effectiveMappingProvider =
        providerIdOverride || mappingSelectionByRound[userTurnId];

      if (!effectiveMappingProvider) {
        console.warn(
          `[RoundActions] No mapping provider selected for turn ${aiTurnId}`,
        );
        return;
      }

      // âœ… Update UI state to track mapping selection
      setMappingSelectionByRound((draft: Record<string, string | null>) => {
        if (draft[userTurnId] === effectiveMappingProvider) return;
        draft[userTurnId] = effectiveMappingProvider;
      });

      // âœ… Initialize optimistic mapping response in UI state
      setTurnsMap((draft: Map<string, TurnMessage>) => {
        const existing = draft.get(ai.id);
        if (!existing || existing.type !== "ai") return;
        const aiTurn = existing as AiTurn;
        const prev = aiTurn.mappingResponses || {};
        const next: Record<string, ProviderResponse[]> = { ...prev };

        const arr = Array.isArray(next[effectiveMappingProvider])
          ? [...next[effectiveMappingProvider]]
          : [];

        const initialStatus: "streaming" | "pending" =
          PRIMARY_STREAMING_PROVIDER_IDS.includes(effectiveMappingProvider)
            ? "streaming"
            : "pending";

        arr.push({
          providerId: effectiveMappingProvider as ProviderKey,
          text: "",
          status: initialStatus,
          createdAt: Date.now(),
        });
        next[effectiveMappingProvider] = arr;
        aiTurn.mappingResponses = next;
        aiTurn.mappingVersion = (aiTurn.mappingVersion ?? 0) + 1;
        draft.set(ai.id, { ...aiTurn });
      });

      // âœ… Set loading state
      setActiveAiTurnId(ai.id);
      setIsLoading(true);
      setUiPhase("streaming");
      setCurrentAppStep("synthesis");

      try {
        // Aim recompute state precisely at the mapping provider
        setActiveRecomputeState({
          aiTurnId: ai.id,
          stepType: "mapping",
          providerId: effectiveMappingProvider,
        });

        // âœ… Send recompute primitive - backend will fetch frozen outputs
        const primitive: PrimitiveWorkflowRequest = {
          type: "recompute",
          sessionId: currentSessionId as string,
          sourceTurnId: ai.id, // âœ… Direct AI turn reference - no user turn lookup needed
          stepType: "mapping",
          targetProvider: effectiveMappingProvider as ProviderKey,
          useThinking:
            effectiveMappingProvider === "chatgpt"
              ? !!thinkMappingByRound[userTurnId]
              : false,
        };

        await api.executeWorkflow(primitive);
      } catch (err) {
        console.error("[RoundActions] Mapping run failed:", err);
        setAlertText("Mapping request failed. Please try again.");

        // Revert optimistic state to error
        setTurnsMap((draft) => {
          const turn = draft.get(ai.id) as AiTurn | undefined;
          if (!turn || turn.type !== "ai" || !turn.mappingResponses) return;
          const arr = turn.mappingResponses[effectiveMappingProvider];
          if (Array.isArray(arr) && arr.length > 0) {
            const last = arr[arr.length - 1];
            if (last.status === "streaming" || last.status === "pending") {
              last.status = "error";
              last.text = "Request failed";
            }
          }
        });

        setIsLoading(false);
        setUiPhase("awaiting_action");
        setActiveAiTurnId(null);
        setActiveRecomputeState(null);
      }
    },
    [
      currentSessionId,
      turnsMap,
      mappingSelectionByRound,
      setMappingSelectionByRound,
      thinkMappingByRound,
      setTurnsMap,
      setActiveAiTurnId,
      setIsLoading,
      setUiPhase,
      setCurrentAppStep,
      setActiveRecomputeState,
      setAlertText,
    ],
  );


  const runRefinerForAiTurn = useCallback(
    async (aiTurnId: string, providerIdOverride?: string) => {
      if (!currentSessionId) return;

      const ai = turnsMap.get(aiTurnId) as AiTurn | undefined;
      if (!ai || ai.type !== "ai") {
        console.warn(`[RoundActions] AI turn ${aiTurnId} not found`);
        return;
      }

      // Check for sufficient inputs (at least synthesis or mapping or batch)
      const outputsFromBatch = Object.values(ai.batchResponses || {}).filter(
        (r: any) => r.status === "completed" && r.text?.trim(),
      );
      const hasSynthesis = ai.synthesisResponses && Object.keys(ai.synthesisResponses).length > 0;

      const enoughOutputs = outputsFromBatch.length >= 1 || hasSynthesis;
      if (!enoughOutputs) {
        setAlertText("Refiner requires at least one completed batch or synthesis response.");
        return;
      }

      // Determine provider
      let effectiveProviderId = providerIdOverride;
      if (!effectiveProviderId) {
        try {
          const stored = localStorage.getItem("htos_last_refiner_model");
          if (stored) effectiveProviderId = stored;
        } catch { }
      }
      if (!effectiveProviderId) effectiveProviderId = "gemini"; // Default

      // Initialize optimistic state
      setTurnsMap((draft: Map<string, TurnMessage>) => {
        const existing = draft.get(ai.id);
        if (!existing || existing.type !== "ai") return;
        const aiTurn = existing as AiTurn;

        const prev = aiTurn.refinerResponses || {};
        const next: Record<string, ProviderResponse[]> = { ...prev };

        const arr = Array.isArray(next[effectiveProviderId]) ? [...next[effectiveProviderId]] : [];
        const initialStatus = PRIMARY_STREAMING_PROVIDER_IDS.includes(effectiveProviderId)
          ? "streaming"
          : "pending";

        arr.push({
          providerId: effectiveProviderId as ProviderKey,
          text: "",
          status: initialStatus,
          createdAt: Date.now(),
        });
        next[effectiveProviderId] = arr;
        aiTurn.refinerResponses = next;
      });

      // Set Loading
      setActiveAiTurnId(ai.id);
      setIsLoading(true);
      setUiPhase("streaming");

      try {
        setActiveRecomputeState({
          aiTurnId: ai.id,
          stepType: "refiner" as any, // Cast to 'any' if types aren't updated yet
          providerId: effectiveProviderId,
        });

        // Send Primitive
        const primitive: PrimitiveWorkflowRequest = {
          type: "recompute",
          sessionId: currentSessionId as string,
          sourceTurnId: ai.id,
          stepType: "refiner" as any, // Cast if needed
          targetProvider: effectiveProviderId as ProviderKey,
        } as any; // Cast entire object if PrimitiveWorkflowRequest is strict

        await api.executeWorkflow(primitive);

        // Persist last refiner used
        try {
          localStorage.setItem("htos_last_refiner_model", effectiveProviderId);
        } catch { }

      } catch (err) {
        console.error("[RoundActions] Refiner run failed:", err);
        setAlertText("Refiner request failed. Please try again.");


        // Revert optimistic
        setTurnsMap((draft) => {
          const turn = draft.get(ai.id) as AiTurn | undefined;
          if (!turn || turn.type !== "ai" || !turn.refinerResponses) return;
          const arr = turn.refinerResponses[effectiveProviderId];
          if (Array.isArray(arr) && arr.length > 0) {
            const last = arr[arr.length - 1];
            if (last.status === "streaming" || last.status === "pending") {
              last.status = "error";
              last.text = "Request failed";
            }
          }
        });
        setIsLoading(false);
        setUiPhase("awaiting_action");
        setActiveAiTurnId(null);
        setActiveRecomputeState(null);
      }
    },
    [currentSessionId, turnsMap, setTurnsMap, setActiveAiTurnId, setIsLoading, setUiPhase, setActiveRecomputeState, setAlertText]
  );

  const runAntagonistForAiTurn = useCallback(
    async (aiTurnId: string, providerIdOverride?: string) => {
      if (!currentSessionId) return;

      const ai = turnsMap.get(aiTurnId) as AiTurn | undefined;
      if (!ai || ai.type !== "ai") {
        console.warn(`[RoundActions] AI turn ${aiTurnId} not found`);
        return;
      }

      // Check inputs (Antagonist needs full context, similar to Refiner)
      const outputsFromBatch = Object.values(ai.batchResponses || {}).filter(
        (r: any) => r.status === "completed" && r.text?.trim(),
      );
      const hasSynthesis = ai.synthesisResponses && Object.keys(ai.synthesisResponses).length > 0;

      const enoughOutputs = outputsFromBatch.length >= 1 || hasSynthesis;
      if (!enoughOutputs) {
        setAlertText("Antagonist requires completed responses to analyze context.");
        return;
      }

      // Determine provider
      let effectiveProviderId = providerIdOverride;
      if (!effectiveProviderId) {
        try {
          const stored = localStorage.getItem("htos_last_antagonist_model");
          if (stored) effectiveProviderId = stored;
        } catch { }
      }
      if (!effectiveProviderId) effectiveProviderId = "gemini"; // Default

      // Initialize optimistic state
      setTurnsMap((draft: Map<string, TurnMessage>) => {
        const existing = draft.get(ai.id);
        if (!existing || existing.type !== "ai") return;
        const aiTurn = existing as AiTurn;

        const prev = aiTurn.antagonistResponses || {};
        const next: Record<string, ProviderResponse[]> = { ...prev };

        const arr = Array.isArray(next[effectiveProviderId]) ? [...next[effectiveProviderId]] : [];
        const initialStatus = PRIMARY_STREAMING_PROVIDER_IDS.includes(effectiveProviderId)
          ? "streaming"
          : "pending";

        arr.push({
          providerId: effectiveProviderId as ProviderKey,
          text: "",
          status: initialStatus,
          createdAt: Date.now(),
        });
        next[effectiveProviderId] = arr;
        aiTurn.antagonistResponses = next;
      });

      // Set Loading
      setActiveAiTurnId(ai.id);
      setIsLoading(true);
      setUiPhase("streaming");

      try {
        setActiveRecomputeState({
          aiTurnId: ai.id,
          stepType: "antagonist" as any,
          providerId: effectiveProviderId,
        });

        const primitive: PrimitiveWorkflowRequest = {
          type: "recompute",
          sessionId: currentSessionId as string,
          sourceTurnId: ai.id,
          stepType: "antagonist" as any,
          targetProvider: effectiveProviderId as ProviderKey,
        } as any;

        await api.executeWorkflow(primitive);

        try {
          localStorage.setItem("htos_last_antagonist_model", effectiveProviderId);
        } catch { }

      } catch (err) {
        console.error("[RoundActions] Antagonist run failed:", err);
        setAlertText("Antagonist request failed. Please try again.");

        setTurnsMap((draft) => {
          const turn = draft.get(ai.id) as AiTurn | undefined;
          if (!turn || turn.type !== "ai" || !turn.antagonistResponses) return;
          const arr = turn.antagonistResponses[effectiveProviderId];
          if (Array.isArray(arr) && arr.length > 0) {
            const last = arr[arr.length - 1];
            if (last.status === "streaming" || last.status === "pending") {
              last.status = "error";
              last.text = "Request failed";
            }
          }
        });
        setIsLoading(false);
        setUiPhase("awaiting_action");
        setActiveAiTurnId(null);
        setActiveRecomputeState(null);
      }
    },
    [currentSessionId, turnsMap, setTurnsMap, setActiveAiTurnId, setIsLoading, setUiPhase, setActiveRecomputeState, setAlertText]
  );

  // ============================================================================
  // UI STATE HELPERS (For controlling per-turn settings)
  // ============================================================================

  /**
   * Toggle synthesis provider selection for a specific user turn.
   * NOTE: This uses userTurnId as the key for backward compatibility with existing UI state.
   */
  const toggleSynthForRound = useCallback(
    (userTurnId: string, providerId: string) => {
      setSynthSelectionsByRound(
        (draft: Record<string, Record<string, boolean>>) => {
          const current = draft[userTurnId] || {};
          draft[userTurnId] = {
            ...current,
            [providerId]: !current[providerId],
          };
        },
      );
    },
    [setSynthSelectionsByRound]
  );

  /**
   * Select mapping provider for a specific user turn.
   * NOTE: This uses userTurnId as the key for backward compatibility with existing UI state.
   */
  const selectMappingForRound = useCallback(
    (userTurnId: string, providerId: string) => {
      setMappingSelectionByRound((draft: Record<string, string | null>) => {
        draft[userTurnId] =
          draft[userTurnId] === providerId ? null : providerId;
      });
    },
    [setMappingSelectionByRound],
  );

  return {
    runSynthesisForAiTurn,
    runMappingForAiTurn,
    runRefinerForAiTurn,
    runAntagonistForAiTurn,
    toggleSynthForRound,
    selectMappingForRound,
  };

}



================================================
FILE: ui/hooks/providers/useProviderActions.ts
================================================
// ui/hooks/useProviderActions.ts
// Extracted from ProviderResponseBlockConnected.tsx for use in ModelResponsePanel

import { useCallback } from 'react';
import { useAtom, useSetAtom, useAtomValue } from 'jotai';
import {
    activeRecomputeStateAtom,
    activeProviderTargetAtom,
    turnsMapAtom,
} from '../../state/atoms';
import api from '../../services/extension-api';
import type { AiTurn, ProviderKey } from '../../types';
import type { PrimitiveWorkflowRequest } from '../../../shared/contract';

/**
 * Hook providing provider-level actions: retry, branch continuation, and targeting.
 * Extracted from the deprecated ProviderResponseBlockConnected.tsx.
 */
export function useProviderActions(
    sessionId: string | undefined,
    aiTurnId: string
) {
    const turnsMap = useAtomValue(turnsMapAtom);
    const aiTurn = turnsMap.get(aiTurnId) as AiTurn | undefined;
    const setActiveRecomputeState = useSetAtom(activeRecomputeStateAtom);
    const [activeTarget, setActiveTarget] = useAtom(activeProviderTargetAtom);

    // Retry: same prompt, same provider (recompute-batch)
    const handleRetryProvider = useCallback(async (providerId: string) => {
        if (!sessionId || !aiTurn) {
            console.warn("[useProviderActions] Cannot retry: missing session or turn");
            return;
        }

        console.log(`[useProviderActions] Retrying provider: ${providerId}`, { aiTurnId, sessionId });

        // Set recompute state to show branching indicator
        try {
            setActiveRecomputeState({ aiTurnId, stepType: "batch" as any, providerId });
        } catch (_) { /* non-fatal */ }

        // Get original user message for retry
        const userMessage = (() => {
            try {
                const u = turnsMap.get(aiTurn.userTurnId) as any;
                return u && u.type === "user" && typeof u.text === "string" ? u.text : undefined;
            } catch {
                return undefined;
            }
        })();

        const primitive: PrimitiveWorkflowRequest = {
            type: "recompute",
            sessionId,
            sourceTurnId: aiTurnId,
            stepType: "batch" as any,
            targetProvider: providerId as ProviderKey,
            userMessage,
            useThinking: false,
        } as any;

        try {
            await api.executeWorkflow(primitive);
        } catch (error) {
            console.error("[useProviderActions] Retry failed:", error);
            try { setActiveRecomputeState(null); } catch { }
        }
    }, [sessionId, aiTurn, aiTurnId, setActiveRecomputeState, turnsMap]);

    // Branch: custom prompt, same provider (recompute-batch with different message)
    const handleBranchContinue = useCallback(async (providerId: string, prompt: string) => {
        if (!sessionId || !aiTurn) {
            console.warn("[useProviderActions] Cannot branch: missing session or turn");
            return;
        }

        console.log(`[useProviderActions] Branching with provider: ${providerId}`, { prompt });

        try {
            setActiveRecomputeState({ aiTurnId, stepType: "batch" as any, providerId });
        } catch (_) { /* non-fatal */ }

        const primitive: PrimitiveWorkflowRequest = {
            type: "recompute",
            sessionId,
            sourceTurnId: aiTurnId,
            stepType: "batch" as any,
            targetProvider: providerId as ProviderKey,
            userMessage: prompt, // Custom prompt = branch
            useThinking: false,
        } as any;

        try {
            await api.executeWorkflow(primitive);
        } catch (error) {
            console.error("[useProviderActions] Branch failed:", error);
            try { setActiveRecomputeState(null); } catch { }
        }
    }, [sessionId, aiTurn, aiTurnId, setActiveRecomputeState]);

    // Toggle targeting for inline branch input
    const handleToggleTarget = useCallback((providerId: string) => {
        if (activeTarget?.aiTurnId === aiTurnId && activeTarget?.providerId === providerId) {
            setActiveTarget(null);
        } else {
            setActiveTarget({ aiTurnId, providerId });
        }
    }, [activeTarget, aiTurnId, setActiveTarget]);

    return {
        handleRetryProvider,
        handleBranchContinue,
        handleToggleTarget,
        activeTarget: activeTarget?.aiTurnId === aiTurnId ? activeTarget : null,
    };
}



================================================
FILE: ui/hooks/providers/useProviderStatus.ts
================================================
import { useEffect, useCallback, useState } from 'react';
import { useAtom } from 'jotai';
import { providerAuthStatusAtom } from '../../state/atoms';
import api from '../../services/extension-api';

export interface UseProviderStatusOptions {
  /**
   * If true, performs API verification on mount (slower but authoritative)
   * If false, only does cookie-based refresh (fast but less reliable)
   */
  verifyOnMount?: boolean;
}

export interface UseProviderStatusReturn {
  /**
   * Current auth status for all providers
   * Format: { chatgpt: true, claude: false, ... }
   */
  status: Record<string, boolean>;

  /**
   * Manually refresh auth status (cookie-based, fast)
   */
  manualRefresh: () => Promise<Record<string, boolean>>;

  /**
   * Verify auth via API (slower but authoritative)
   * @param providerId - Optional specific provider to verify, or all if omitted
   */
  verifyAuth: (providerId?: string) => Promise<Record<string, boolean>>;

  /**
   * True while API verification is in progress
   */
  isVerifying: boolean;
}

export function useProviderStatus(
  options: UseProviderStatusOptions = {}
): UseProviderStatusReturn {
  const [status, setStatus] = useAtom(providerAuthStatusAtom);
  const [isVerifying, setIsVerifying] = useState(false);

  useEffect(() => {
    // 1. Instant load from storage (cached, no network)
    chrome.storage.local.get(['provider_auth_status'], (result) => {
      if (result.provider_auth_status) {
        setStatus(result.provider_auth_status as Record<string, boolean>);
      }
    });

    // 2. Optional: verify via API on mount
    if (options.verifyOnMount) {
      setIsVerifying(true);
      chrome.runtime
        .sendMessage({ type: 'VERIFY_AUTH_TOKEN' })
        .then((response) => {
          if (response?.success) {
            setStatus(response.data);
          }
        })
        .catch((err) => {
          console.warn('[useProviderStatus] API verification failed:', err);
        })
        .finally(() => {
          setIsVerifying(false);
        });
    } else {
      // Fast cookie-based refresh (background, non-blocking)
      api.refreshAuthStatus().catch((err) => {
        console.warn('[useProviderStatus] Cookie refresh failed:', err);
      });
    }

    // 3. Listen for live updates from AuthManager
    const listener = (changes: { [key: string]: chrome.storage.StorageChange }, area: string) => {
      if (area === 'local' && changes.provider_auth_status) {
        setStatus((changes.provider_auth_status.newValue as Record<string, boolean>) || ({} as Record<string, boolean>));
      }
    };

    chrome.storage.onChanged.addListener(listener);
    return () => chrome.storage.onChanged.removeListener(listener);
  }, [setStatus, options.verifyOnMount]);

  /**
   * Manually refresh auth status (cookie-based, fast)
   */
  const manualRefresh = useCallback(async () => {
    const fresh = await api.refreshAuthStatus();
    setStatus(fresh);
    return fresh;
  }, [setStatus]);

  /**
   * Verify auth via API (slower but authoritative)
   */
  const verifyAuth = useCallback(async (providerId?: string) => {
    setIsVerifying(true);

    try {
      const response = await chrome.runtime.sendMessage({
        type: 'VERIFY_AUTH_TOKEN',
        payload: providerId ? { providerId } : undefined
      });

      if (response?.success) {
        setStatus((prev: Record<string, boolean>) => ({ ...prev, ...response.data }));
        return response.data;
      }

      throw new Error(response?.error || 'Verification failed');
    } finally {
      setIsVerifying(false);
    }
  }, [setStatus]);

  return {
    status,
    manualRefresh,
    verifyAuth,
    isVerifying
  };
}



================================================
FILE: ui/hooks/providers/useRetryProvider.ts
================================================
// ui/hooks/useRetryProvider.ts
import { useCallback } from 'react';
import api from '../../services/extension-api';

export function useRetryProvider() {
  const retryProviders = useCallback(
    async (
      sessionId: string,
      aiTurnId: string,
      providerIds: string[],
      retryScope: 'batch' | 'synthesis' | 'mapping' = 'batch'
    ) => {
      try {
        const port = await api.ensurePort();
        port.postMessage({
          type: 'RETRY_PROVIDERS',
          sessionId,
          aiTurnId,
          providerIds,
          retryScope,
        });
      } catch (e) {
        console.error('[useRetryProvider] Failed to send retry request', e);
      }
    },
    []
  );

  return { retryProviders };
}



================================================
FILE: ui/hooks/providers/useSmartProviderDefaults.ts
================================================
import { useEffect, useRef } from 'react';
import { useAtom, useAtomValue, useSetAtom } from 'jotai';
import {
    providerAuthStatusAtom,
    synthesisProviderAtom,
    mappingProviderAtom,
    antagonistProviderAtom,
    refinerProviderAtom,
    providerLocksAtom,
} from '../../state/atoms';
import {
    selectBestProvider,
    isProviderAuthorized,
} from '@shared/provider-config';
import {
    getProviderLocks,
    subscribeToLockChanges,
} from '@shared/provider-locks';

/**
 * Automatically selects best available providers when:
 * 1. Auth status changes (provider logged in/out)
 * 2. Current selection becomes unauthorized
 * 3. No selection exists yet
 * 
 * Respects user locks - won't auto-change locked providers.
 */
export function useSmartProviderDefaults() {
    const authStatus = useAtomValue(providerAuthStatusAtom);
    const [synthesisProvider, setSynthesisProvider] = useAtom(synthesisProviderAtom);
    const [mappingProvider, setMappingProvider] = useAtom(mappingProviderAtom);
    const [antagonistProvider, setAntagonistProvider] = useAtom(antagonistProviderAtom);
    const [refinerProvider, setRefinerProvider] = useAtom(refinerProviderAtom);
    const setLocks = useSetAtom(providerLocksAtom);

    // Track if we've done initial selection to avoid flash
    const initializedRef = useRef(false);

    // Load locks from chrome.storage on mount + subscribe to changes
    useEffect(() => {
        getProviderLocks().then(setLocks);
        return subscribeToLockChanges(setLocks);
    }, [setLocks]);

    const locks = useAtomValue(providerLocksAtom);

    // React to auth changes
    useEffect(() => {
        // Skip if no auth data yet
        if (Object.keys(authStatus).length === 0) return;

        // === Synthesis Provider ===
        if (!locks.synthesis) {
            const currentValid = synthesisProvider && isProviderAuthorized(synthesisProvider, authStatus);

            if (!currentValid) {
                const best = selectBestProvider('synthesis', authStatus);
                if (best && best !== synthesisProvider) {
                    console.log(`[SmartDefaults] Synthesis: ${synthesisProvider} â†’ ${best}`);
                    setSynthesisProvider(best);
                }
            }
        }

        // === Mapping Provider ===
        if (!locks.mapping) {
            const currentValid = mappingProvider && isProviderAuthorized(mappingProvider, authStatus);

            if (!currentValid) {
                const best = selectBestProvider('mapping', authStatus);
                if (best && best !== mappingProvider) {
                    console.log(`[SmartDefaults] Mapping: ${mappingProvider} â†’ ${best}`);
                    setMappingProvider(best);
                }
            }
        }

        // === Antagonist Provider ===
        if (!locks.antagonist) {
            const currentValid = antagonistProvider && isProviderAuthorized(antagonistProvider, authStatus);

            if (!currentValid) {
                const best = selectBestProvider('antagonist', authStatus);
                if (best && best !== antagonistProvider) {
                    console.log(`[SmartDefaults] Antagonist: ${antagonistProvider} â†’ ${best}`);
                    setAntagonistProvider(best);
                }
            }
        }

        // === Refiner Provider ===
        if (!locks.refiner) {
            const currentValid = refinerProvider && isProviderAuthorized(refinerProvider, authStatus);

            if (!currentValid) {
                const best = selectBestProvider('refiner', authStatus);
                if (best && best !== refinerProvider) {
                    console.log(`[SmartDefaults] Refiner: ${refinerProvider} â†’ ${best}`);
                    setRefinerProvider(best);
                }
            }
        }

        initializedRef.current = true;
    }, [authStatus, locks, synthesisProvider, mappingProvider, antagonistProvider, refinerProvider, setSynthesisProvider, setMappingProvider, setAntagonistProvider, setRefinerProvider]);

    return { isInitialized: initializedRef.current };
}



================================================
FILE: ui/hooks/ui/useKey.ts
================================================
import { useEventListener } from "usehooks-ts";

type KeyCallback = (event: KeyboardEvent) => void;

export function useKey(key: string, callback: KeyCallback) {
  const handleKeyDown = (event: KeyboardEvent) => {
    if (event.key === key) {
      callback(event);
    }
  };

  useEventListener("keydown", handleKeyDown);
}



================================================
FILE: ui/hooks/ui/useLoadingWatchdog.ts
================================================
import { useEffect } from "react";
import { useAtomValue, useSetAtom } from "jotai";
import {
  isLoadingAtom,
  uiPhaseAtom,
  activeAiTurnIdAtom,
  alertTextAtom,
  lastActivityAtAtom,
  connectionStatusAtom,
} from "../../state/atoms";

const LOADING_TIMEOUT_MS = 45000; // 45 seconds

export function useLoadingWatchdog() {
  const isLoading = useAtomValue(isLoadingAtom);
  const lastActivityAt = useAtomValue(lastActivityAtAtom);
  const setIsLoading = useSetAtom(isLoadingAtom);
  const setUiPhase = useSetAtom(uiPhaseAtom);
  const setActiveAiTurnId = useSetAtom(activeAiTurnIdAtom);
  const setAlertText = useSetAtom(alertTextAtom);

  useEffect(() => {
    let timeout: any;
    if (isLoading) {
      const now = Date.now();
      const baseline =
        lastActivityAt && lastActivityAt > 0 ? lastActivityAt : now;
      const remaining = Math.max(LOADING_TIMEOUT_MS - (now - baseline), 1000);
      timeout = setTimeout(() => {
        const elapsed = Date.now() - (lastActivityAt || baseline);
        if (isLoading && elapsed >= LOADING_TIMEOUT_MS) {
          setIsLoading(false);
          setUiPhase("awaiting_action");
          setActiveAiTurnId(null);
          setAlertText("Processing stalled or timed out. Please try again.");
        }
      }, remaining);
    }
    return () => {
      if (timeout) clearTimeout(timeout);
    };
  }, [
    isLoading,
    lastActivityAt,
    setIsLoading,
    setUiPhase,
    setActiveAiTurnId,
    setAlertText,
  ]);
}

/**
 * useResponsiveLoadingGuard
 * Non-destructive guard that observes loading and activity and surfaces alerts
 * rather than resetting state. Intended to replace useLoadingWatchdog.
 */
export function useResponsiveLoadingGuard(options?: {
  idleWarnMs?: number;
  idleCriticalMs?: number;
}) {
  const idleWarnMs = options?.idleWarnMs ?? 15_000;
  const idleCriticalMs = options?.idleCriticalMs ?? 45_000;

  const isLoading = useAtomValue(isLoadingAtom);
  const lastActivityAt = useAtomValue(lastActivityAtAtom);
  const connection = useAtomValue(connectionStatusAtom);
  const setAlertText = useSetAtom(alertTextAtom);
  const alertText = useAtomValue(alertTextAtom);

  useEffect(() => {
    // Guard only when connected and currently loading
    if (!isLoading || !connection?.isConnected) {
      if (alertText) setAlertText(null);
      return;
    }

    let warned = false;
    let escalated = false;
    const baseline =
      lastActivityAt && lastActivityAt > 0 ? lastActivityAt : Date.now();

    const interval = setInterval(() => {
      const now = Date.now();
      const idleFor = now - baseline;

      // Clear on fresh activity or when loading finishes
      if (!isLoading || (lastActivityAt && lastActivityAt > baseline)) {
        if (alertText) setAlertText(null);
        return;
      }

      if (!warned && idleFor >= idleWarnMs) {
        setAlertText(
          "Still processingâ€¦ you can press Stop to abort and retry if needed.",
        );
        warned = true;
      }

      if (!escalated && idleFor >= idleCriticalMs) {
        setAlertText(
          "Processing is taking longer than expected. Consider pressing Stop, checking provider status, or switching model.",
        );
        escalated = true;
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [
    isLoading,
    lastActivityAt,
    connection?.isConnected,
    setAlertText,
    alertText,
    idleWarnMs,
    idleCriticalMs,
  ]);
}



================================================
FILE: ui/providers/providerIcons.tsx
================================================
import React from "react";
import { tokens } from "../styles/tokens";

const baseIcon =
  (fill: string) =>
    ({ size = 16, style = {} as React.CSSProperties } = {}) => (
      <div
        aria-hidden="true"
        style={{
          width: size,
          height: size,
          borderRadius: 4,
          background: fill,
          ...style,
        }}
      />
    );

// Icons pull from tokens to keep Rail free of hard-coded color values
export const ChatGPTIcon = baseIcon(tokens.accents.chatgpt);
export const ClaudeIcon = baseIcon(tokens.accents.claude);
export const GeminiIcon = baseIcon(tokens.accents.gemini);
export const QwenIcon = baseIcon(tokens.accents.qwen);



================================================
FILE: ui/providers/providerRegistry.ts
================================================
import type { LLMProvider } from "../types";

// Provider icons are light-weight and color-driven via tokens to remain dark-mode safe
import { ChatGPTIcon, ClaudeIcon, GeminiIcon, QwenIcon } from "./providerIcons";

// Import SVG Logos
import ChatGPTLogo from "../assets/chatgpt.svg";
import ClaudeLogo from "../assets/claude.svg";
import GeminiLogo from "../assets/gemini.svg";
import QwenLogo from "../assets/qwen.svg";

// Central registry for provider metadata used by the UI (lanes/rail)
// - Do NOT hard-code hex colors inside Rail; colors live here (or in tokens)
// - This module exposes addProvider for future dynamic extension

export interface ProviderConfig extends LLMProvider {
  // Icon component for micro-cards and badges
  icon?: (props: { size?: number; style?: React.CSSProperties }) => JSX.Element;
  logoSrc?: string;
}

// Initial providers (seeded). This is the only place you should edit to add a new provider by config-only.
export const INITIAL_PROVIDERS: ProviderConfig[] = [
  {
    id: "chatgpt",
    name: "ChatGPT",
    color: "#10A37F",
    logoBgClass: "bg-green-500",
    hostnames: ["chat.openai.com", "chatgpt.com"],
    icon: ChatGPTIcon,
    logoSrc: ChatGPTLogo,
  },
  {
    id: "claude",
    name: "Claude",
    color: "#FF7F00",
    logoBgClass: "bg-orange-500",
    hostnames: ["claude.ai"],
    icon: ClaudeIcon,
    logoSrc: ClaudeLogo,
  },
  {
    id: "gemini",
    name: "Gemini",
    color: "#4285F4",
    logoBgClass: "bg-blue-500",
    hostnames: ["gemini.google.com"],
    icon: GeminiIcon,
    logoSrc: GeminiLogo,
  },
  {
    id: "gemini-pro",
    name: "Gemini 2.5 Pro",
    color: "#3B82F6",
    logoBgClass: "bg-blue-600",
    hostnames: ["gemini.google.com"],
    icon: GeminiIcon,
    logoSrc: GeminiLogo,
  },
  {
    id: "gemini-exp", // Must match the key in GeminiModels
    name: "Gemini 3.0",
    color: "#8B5CF6", // Purple to distinguish from others
    logoBgClass: "bg-purple-600",
    hostnames: ["gemini.google.com"],
    icon: GeminiIcon,
    logoSrc: GeminiLogo,
  },
  {
    id: "qwen",
    name: "Qwen",
    color: "#00A9E0",
    logoBgClass: "bg-cyan-500",
    hostnames: ["qianwen.com", "qianwen.aliyun.com"],
    icon: QwenIcon,
    emoji: "ðŸ¤–",
    logoSrc: QwenLogo,
  },
];

// Mutable list used by the LaneFactory/Rail
let providers: ProviderConfig[] = [...INITIAL_PROVIDERS];

export function getProviders(): ProviderConfig[] {
  return providers;
}

export function getProviderById(id: string): ProviderConfig | undefined {
  return providers.find((p) => p.id === id);
}

// Add a provider at runtime. Higher layers can call this once adapter is available.
export function addProvider(p: ProviderConfig): void {
  if (!p || !p.id) return;
  // De-duplicate by id
  providers = [...providers.filter((x) => x.id !== p.id), p];
}



================================================
FILE: ui/services/extension-api.ts
================================================
// src/ui/services/extension-api.ts

import {
  EXECUTE_WORKFLOW,
  GET_FULL_HISTORY,
  GET_HISTORY_SESSION,
  DELETE_SESSION,
  DELETE_SESSIONS,
  RENAME_SESSION,

  REFRESH_AUTH_STATUS,
} from "../../shared/messaging";

import type { HistorySessionSummary, HistoryApiResponse } from "../types";
import type { PrimitiveWorkflowRequest } from "../../shared/contract";
import { PortHealthManager } from "./port-health-manager";

interface BackendApiResponse<T = any> {
  success: boolean;
  data?: T;
  [key: string]: any;
}

let EXTENSION_ID: string | null = null;

class ExtensionAPI {
  private portHealthManager: PortHealthManager | null = null;
  private connectionStateCallbacks: Set<(connected: boolean) => void> =
    new Set();
  private port: chrome.runtime.Port | null = null;
  private portMessageHandler: ((message: any) => void) | null = null;

  constructor() {
    this.portHealthManager = new PortHealthManager("htos-popup", {
      onHealthy: () => this.notifyConnectionState(true),
      onUnhealthy: () => this.notifyConnectionState(false),
      onReconnect: () => this.notifyConnectionState(true),
    });

    try {
      window.addEventListener("beforeunload", () => this.disconnectAll());
      window.addEventListener("pagehide", () => this.disconnectAll());
    } catch (e) {
      console.warn("[ExtensionAPI] Failed to attach unload handlers", e);
    }
  }

  private disconnectAll() {
    try {
      this.portHealthManager?.disconnect();
    } catch { }
    try {
      this.port?.disconnect();
    } catch { }
    this.port = null;
  }

  onConnectionStateChange(callback: (connected: boolean) => void): () => void {
    this.connectionStateCallbacks.add(callback);
    return () => this.connectionStateCallbacks.delete(callback);
  }

  private notifyConnectionState(connected: boolean) {
    this.connectionStateCallbacks.forEach((cb) => {
      try {
        cb(connected);
      } catch (e) {
        console.error("[ExtensionAPI] Connection state callback error:", e);
      }
    });
  }

  getConnectionStatus() {
    return (
      this.portHealthManager?.getStatus() || {
        isConnected: !!this.port,
        reconnectAttempts: 0,
        lastPongTimestamp: 0,
        timeSinceLastPong: Infinity,
      }
    );
  }

  checkHealth() {
    this.portHealthManager?.checkHealth();
  }

  setExtensionId(id: string): void {
    if (!EXTENSION_ID) {
      EXTENSION_ID = id;
    }
  }

  async ensurePort(
    options: { sessionId?: string; force?: boolean } = {},
  ): Promise<chrome.runtime.Port> {
    const { force = false } = options;
    if (
      this.port &&
      !force &&
      this.portHealthManager?.getStatus().isConnected
    ) {
      return this.port;
    }

    if (this.portHealthManager && this.portMessageHandler) {
      this.port = this.portHealthManager.connect(
        this.portMessageHandler,
        () => {
          console.warn("[ExtensionAPI] Port disconnected via callback");
          this.port = null;
        },
      );
      return this.port;
    }

    // Fallback if manager isn't ready
    if (!EXTENSION_ID)
      throw new Error(
        "Extension ID not set. Call setExtensionId() on startup.",
      );
    this.port = chrome.runtime.connect(EXTENSION_ID, { name: "htos-popup" });
    this.port.onMessage.addListener((msg) => this.portMessageHandler?.(msg));
    this.port.onDisconnect.addListener(() => {
      console.warn("[ExtensionAPI] Port disconnected (fallback)");
      this.port = null;
    });
    return this.port;
  }

  setPortMessageHandler(handler: ((message: any) => void) | null): void {
    this.portMessageHandler = handler;
  }

  async executeWorkflow(request: PrimitiveWorkflowRequest): Promise<void> {
    try {
      const port = await this.ensurePort();
      this.portHealthManager?.checkHealth();
      port.postMessage({
        type: EXECUTE_WORKFLOW,
        payload: request,
      });
    } catch (error) {
      console.error(
        "[ExtensionAPI] Failed to post executeWorkflow message, attempting reconnect:",
        error,
      );
      // Attempt a single reconnect and retry
      const newPort = await this.ensurePort({ force: true });
      newPort.postMessage({ type: EXECUTE_WORKFLOW, payload: request });
    }
  }

  async abortWorkflow(sessionId: string): Promise<void> {
    try {
      const port = await this.ensurePort();
      port.postMessage({ type: "abort", sessionId });
      console.log(`[ExtensionAPI] Sent abort signal for session ${sessionId}`);
    } catch (error) {
      console.error("[ExtensionAPI] Failed to send abort signal:", error);
    }
  }

  async queryBackend<T = any>(message: {
    type: string;
    [key: string]: any;
  }): Promise<T> {
    if (!EXTENSION_ID)
      throw new Error(
        "Extension not connected. Please call setExtensionId on startup or reload the extension.",
      );

    return new Promise<T>((resolve, reject) => {
      try {
        chrome.runtime.sendMessage(
          EXTENSION_ID as string,
          message,
          (response: BackendApiResponse<T> | null) => {
            if (chrome.runtime.lastError) {
              console.error(
                "[API] Connection error:",
                chrome.runtime.lastError,
              );
              return reject(
                new Error(
                  `Extension connection failed: ${chrome.runtime.lastError.message}. Try reloading the extension.`,
                ),
              );
            }

            if (!response) {
              console.error("[API] Empty response received for", message.type);
              return reject(
                new Error(
                  "No response from extension. The service worker may be inactive.",
                ),
              );
            }

            if (response?.success) {
              if (response.data !== undefined) {
                return resolve(response.data as T);
              }
              const copy: any = { ...response };
              delete copy.success;
              delete copy.error;
              const keys = Object.keys(copy);
              if (keys.length === 1) {
                return resolve(copy[keys[0]] as T);
              }
              return resolve(copy as T);
            }

            console.error(
              "[API] Backend error for",
              message.type,
              ":",
              response?.error,
            );
            const errMsg =
              (response?.error as any)?.message ||
              response?.error ||
              "Unknown backend error. See extension logs.";
            return reject(new Error(errMsg as string));
          },
        );
      } catch (err) {
        console.error("[API] Fatal extension error:", err);
        reject(
          new Error(
            `Extension communication error: ${err instanceof Error ? err.message : String(err)}`,
          ),
        );
      }
    });
  }

  // === DATA & SESSION METHODS ===
  getHistoryList(): Promise<HistoryApiResponse> {
    return this.queryBackend<HistoryApiResponse>({ type: GET_FULL_HISTORY });
  }

  getHistorySession(sessionId: string): Promise<HistorySessionSummary> {
    return this.queryBackend<HistorySessionSummary>({
      type: GET_HISTORY_SESSION,
      payload: { sessionId },
    });
  }

  getSession(sessionId: string): Promise<any> {
    return this.queryBackend<any>({
      type: GET_HISTORY_SESSION,
      payload: { sessionId }
    });
  }

  deleteBackgroundSession(sessionId: string): Promise<{ removed: boolean }> {
    return this.queryBackend<{ removed: boolean }>({
      type: DELETE_SESSION,
      payload: { sessionId },
    });
  }

  deleteBackgroundSessions(
    sessionIds: string[],
  ): Promise<{ removed: number; ids: string[] }> {
    return this.queryBackend<{ removed: number; ids: string[] }>({
      type: DELETE_SESSIONS,
      payload: { sessionIds },
    });
  }

  renameSession(
    sessionId: string,
    title: string,
  ): Promise<{ updated: boolean; sessionId: string; title: string }> {
    return this.queryBackend<{
      updated: boolean;
      sessionId: string;
      title: string;
    }>({
      type: RENAME_SESSION,
      payload: { sessionId, title },
    });
  }



  runAnalyst(
    fragment: string,
    context: any,
    authoredPrompt: string,
    analystModel?: string,
    originalPrompt?: string
  ): Promise<{ audit: string; variants: string[] } | null> {
    return this.queryBackend<{ audit: string; variants: string[] } | null>({
      type: "RUN_ANALYST",
      payload: { fragment, context, authoredPrompt, analystModel, originalPrompt },
    });
  }

  runComposer(
    draftPrompt: string,
    context: any,
    composerModel?: string,
    analystCritique?: string
  ): Promise<{ refinedPrompt: string; explanation: string } | null> {
    return this.queryBackend<{ refinedPrompt: string; explanation: string } | null>({
      type: "RUN_COMPOSER",
      payload: { draftPrompt, context, composerModel, analystCritique },
    });
  }

  async refreshAuthStatus(): Promise<Record<string, boolean>> {
    return this.queryBackend<Record<string, boolean>>({ type: REFRESH_AUTH_STATUS });
  }
}

const api = new ExtensionAPI();
export default api;



================================================
FILE: ui/services/port-health-manager.ts
================================================
export class PortHealthManager {
  private port: chrome.runtime.Port | null = null;
  private healthCheckInterval: number | null = null;
  private reconnectTimeout: number | null = null;
  private messageHandler: ((msg: any) => void) | null = null;
  private onDisconnectCallback: (() => void) | undefined = undefined;

  // Relaxed health check and reconnect strategy to reduce churn
  private readonly HEALTH_CHECK_INTERVAL = 30000; // 30s
  private readonly RECONNECT_DELAY = 2000; // base delay
  private readonly RECONNECT_JITTER_MS = 500; // random jitter

  // Throttle constants
  private readonly ACTIVITY_THROTTLE_MS = 5000; // Only send activity ping every 5s max
  private lastActivitySent = 0;

  private reconnectAttempts = 0;
  private isConnected = false;
  private lastPongTimestamp = 0;

  constructor(
    private portName: string = "htos-popup",
    private options: {
      onHealthy?: () => void;
      onUnhealthy?: () => void;
      onReconnect?: () => void;
    } = {},
  ) {}

  connect(
    messageHandler: (msg: any) => void,
    onDisconnect?: () => void,
  ): chrome.runtime.Port {
    this.messageHandler = messageHandler;
    this.onDisconnectCallback = onDisconnect;

    this.port = chrome.runtime.connect({ name: this.portName });
    this.isConnected = true;
    this.reconnectAttempts = 0;

    this.port.onMessage.addListener(this.handleMessage.bind(this));
    this.port.onDisconnect.addListener(this.handleDisconnect.bind(this));

    this.startHealthCheck();

    console.log("[PortHealthManager] Connected to service worker");
    return this.port;
  }

  private sendKeepalivePing() {
    if (!this.port || !this.isConnected) return;

    try {
      this.port.postMessage({ type: "KEEPALIVE_PING", timestamp: Date.now() });
    } catch (error) {
      console.warn("[PortHealthManager] Failed to send keepalive ping:", error);
      this.handleUnhealthyPort();
    }
  }

  private startHealthCheck() {
    if (this.healthCheckInterval) clearInterval(this.healthCheckInterval);

    this.healthCheckInterval = window.setInterval(() => {
      this.sendKeepalivePing();

      const timeSinceLastPong = Date.now() - this.lastPongTimestamp;
      // Be more tolerant before declaring unhealthy
      if (timeSinceLastPong > this.HEALTH_CHECK_INTERVAL * 3) {
        console.warn(
          "[PortHealthManager] No pong received, port may be unhealthy",
        );
        this.handleUnhealthyPort();
      }
    }, this.HEALTH_CHECK_INTERVAL);
  }

  private stopHealthCheck() {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }
  }

  private handleMessage(message: any) {
    // Any inbound traffic indicates the port is alive; update timestamp first
    this.lastPongTimestamp = Date.now();

    // Notify SW of activity so lifecycle manager can record activity (best-effort)
    // FIX: THROTLED to prevent flooding SW with thousands of messages during streaming
    const now = Date.now();
    if (now - this.lastActivitySent > this.ACTIVITY_THROTTLE_MS) {
      this.lastActivitySent = now;
      try {
        if (
          chrome &&
          chrome.runtime &&
          typeof chrome.runtime.sendMessage === "function"
        ) {
          chrome.runtime.sendMessage(
            { type: "htos.activity", timestamp: now },
            () => {
              try {
                if (chrome.runtime && chrome.runtime.lastError) {
                  /* ignore transient delivery errors */
                }
              } catch (_) {}
            },
          );
        }
      } catch (e) {}
    }

    if (message.type === "KEEPALIVE_PONG") {
      if (!this.isConnected) {
        this.isConnected = true;
        console.log("[PortHealthManager] Port healthy again");
        this.options.onHealthy?.();
      }
      return;
    }

    if (message.type === "HANDLER_READY") {
      console.log("[PortHealthManager] Service worker handler ready");
      this.isConnected = true;
      return;
    }

    if (this.messageHandler) {
      this.messageHandler(message);
    }
  }

  private handleDisconnect() {
    console.warn("[PortHealthManager] Port disconnected");
    this.isConnected = false;
    this.stopHealthCheck();

    this.options.onUnhealthy?.();
    this.onDisconnectCallback?.();

    this.attemptReconnect();
  }

  private handleUnhealthyPort() {
    if (!this.isConnected) return;

    console.warn("[PortHealthManager] Port unhealthy, attempting reconnect");
    this.isConnected = false;
    this.options.onUnhealthy?.();

    this.disconnect();
    this.attemptReconnect();
  }

  private attemptReconnect() {
    this.reconnectAttempts++;
    const jitter = Math.floor(Math.random() * this.RECONNECT_JITTER_MS);
    const base = this.RECONNECT_DELAY + jitter;
    const delay = base * Math.pow(2, this.reconnectAttempts - 1);

    console.log(
      `[PortHealthManager] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`,
    );

    this.reconnectTimeout = window.setTimeout(() => {
      if (this.messageHandler) {
        this.connect(this.messageHandler, this.onDisconnectCallback);
        this.options.onReconnect?.();
      }
    }, delay);
  }

  disconnect() {
    this.isConnected = false;
    this.stopHealthCheck();

    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }

    if (this.port) {
      try {
        this.port.disconnect();
      } catch (e) {}
      this.port = null;
    }
  }

  getStatus() {
    return {
      isConnected: this.isConnected,
      reconnectAttempts: this.reconnectAttempts,
      lastPongTimestamp: this.lastPongTimestamp,
      timeSinceLastPong: Date.now() - this.lastPongTimestamp,
    };
  }

  checkHealth() {
    this.sendKeepalivePing();
  }
}



================================================
FILE: ui/state/atoms.ts
================================================
import { atom } from "jotai";
import { atomWithImmer } from "jotai-immer";
import { atomWithStorage, atomFamily } from "jotai/utils";

// Import UI types and constants
import type {
  TurnMessage,
  AiTurn,
  ProviderResponse,
  UiPhase,
  AppStep,
  HistorySessionSummary,
} from "../types";

// =============================================================================
// ATOMIC STATE PRIMITIVES (Map + ID index)
// =============================================================================
/**
 * Map-based turn storage for O(1) lookups and surgical updates.
 * This is the single source of truth for all turn data.
 */
export const turnsMapAtom = atomWithImmer<Map<string, TurnMessage>>(new Map());

/**
 * Ordered list of turn IDs. Changes only when turns are added/removed.
 */
export const turnIdsAtom = atomWithImmer<string[]>([]);

/**
 * Backward-compat: derived messages view from Map + IDs. Read-only.
 */
export const messagesAtom = atom<TurnMessage[]>((get) => {
  const ids = get(turnIdsAtom);
  const map = get(turnsMapAtom);
  return ids.map((id) => map.get(id)).filter((t): t is TurnMessage => !!t);
});

/**
 * Selector: provider responses for a specific AI turn (isolated subscription).
 * DEPRECATED: Use providerEffectiveStateFamily for component isolation.
 */
export const providerResponsesForTurnAtom = atom(
  (get) =>
    (turnId: string): Record<string, ProviderResponse> => {
      const turn = get(turnsMapAtom).get(turnId);
      if (!turn || turn.type !== "ai") return {};
      const aiTurn = turn as AiTurn;
      const out: Record<string, ProviderResponse> = {};
      // Flatten arrays for batch responses: take latest per provider
      Object.entries(aiTurn.batchResponses || {}).forEach(([pid, val]: [string, any]) => {
        const arr = Array.isArray(val) ? val : [val];
        if (arr.length > 0) out[pid] = arr[arr.length - 1] as ProviderResponse;
      });
      return out;
    },
);

// -----------------------------
// Provider Island Isolation Atoms
// -----------------------------
/**
 * Atom family: Get the full response array for a specific provider in a turn.
 * Returns the complete history as an array (never flattened).
 * If the provider has no responses, returns an empty array.
 */
export const providerResponseArrayFamily = atomFamily(
  ({ turnId, providerId }: { turnId: string; providerId: string }) =>
    atom((get) => {
      const turn = get(turnsMapAtom).get(turnId);
      if (!turn || turn.type !== "ai") return [];

      const aiTurn = turn as AiTurn;
      const responses = aiTurn.batchResponses?.[providerId];

      // Always return array, normalize if needed
      if (!responses) return [];
      return Array.isArray(responses) ? responses : [responses];
    }),
  (a, b) => a.turnId === b.turnId && a.providerId === b.providerId
);

/**
 * Derived atom family: Stable, UI-optimized state for a provider.
 * Prevents expensive recalculations during render.
 */
export const providerEffectiveStateFamily = atomFamily(
  ({ turnId, providerId }: { turnId: string; providerId: string }) =>
    atom((get) => {
      const responses = get(providerResponseArrayFamily({ turnId, providerId }));

      return {
        latestResponse: responses.length > 0 ? responses[responses.length - 1] : null,
        historyCount: responses.length,
        isEmpty: responses.length === 0,
        allResponses: responses, // Include full array for history expansion
      };
    }),
  (a, b) => a.turnId === b.turnId && a.providerId === b.providerId
);

/**
 * Atom family: Get only the list of provider IDs for a turn.
 * Parent layout subscribes to this to avoid re-rendering on provider data changes.
 */
export const providerIdsForTurnFamily = atomFamily(
  (turnId: string) =>
    atom((get) => {
      const turn = get(turnsMapAtom).get(turnId);
      if (!turn || turn.type !== "ai") return [];

      const aiTurn = turn as AiTurn;
      return Object.keys(aiTurn.batchResponses || {});
    }),
  (a, b) => a === b
);

/**
 * Selector: get a single turn by ID (entity accessor).
 */
export const turnByIdAtom = atom(
  (get) =>
    (turnId: string): TurnMessage | undefined =>
      get(turnsMapAtom).get(turnId),
);

// -----------------------------
// Core chat state
// -----------------------------
export const currentSessionIdAtom = atomWithStorage<string | null>(
  "htos_last_session_id",
  null,
);
// Deprecated legacy pending user turns removed; TURN_CREATED event handles optimistic UI

// -----------------------------
// UI phase & loading
// -----------------------------
export const isLoadingAtom = atom<boolean>(false);
export const uiPhaseAtom = atom<UiPhase>("idle");
export const activeAiTurnIdAtom = atom<string | null>(null);
export const currentAppStepAtom = atom<AppStep>("initial");
// Derived: continuation mode is true whenever there is an active session and at least one turn
export const isContinuationModeAtom = atom((get) => {
  const sessionId = get(currentSessionIdAtom);
  const turnIds = get(turnIdsAtom);
  return sessionId !== null && turnIds.length > 0;
});

// -----------------------------
// Streaming performance optimization
// -----------------------------
/**
 * Tracks which provider is currently streaming (for granular streaming indicators).
 * Updated by usePortMessageHandler when processing PARTIAL_RESULT messages.
 */
export const lastStreamingProviderAtom = atom<string | null>(null);

/**
 * Derived atom: represents the turn that should be "live" in the UI.
 * Merges recompute targeting and normal streaming into a single source of truth.
 */
export const activeStreamingTurnIdAtom = atom<string | null>((get) => {
  const recompute = get(activeRecomputeStateAtom);
  if (recompute) return recompute.aiTurnId;
  return get(activeAiTurnIdAtom);
});

/**
 * Bundle all global streaming state for efficient subscription.
 */
const globalStreamingStateAtom = atom((get) => ({
  activeId: get(activeStreamingTurnIdAtom),
  isLoading: get(isLoadingAtom),
  appStep: get(currentAppStepAtom),
}));

/**
 * Shared idle state object: ensures reference equality for non-active turns.
 * Critical: without this, every turn re-renders on every streaming tick.
 */
const idleStreamingState: { isLoading: boolean; appStep: AppStep; activeProviderId: string | null } = {
  isLoading: false,
  appStep: "initial",
  activeProviderId: null,
};

/**
 * Per-turn derived streaming state with active provider tracking.
 * Only the active turn sees changing values. All other turns share idleStreamingState.
 * Extended to track which specific provider is streaming for granular UI indicators.
 */
export const turnStreamingStateFamily = atomFamily(
  (turnId: string) =>
    atom((get) => {
      const { activeId, isLoading, appStep } = get(globalStreamingStateAtom);
      const recompute = get(activeRecomputeStateAtom);
      const lastStreamingProvider = get(lastStreamingProviderAtom);

      if (activeId === turnId) {
        // Priority: recompute provider > last streaming provider > null
        const activeProviderId = recompute?.aiTurnId === turnId
          ? recompute.providerId
          : (isLoading ? lastStreamingProvider : null);

        // New object only for active turn â€“ triggers re-render
        return { isLoading, appStep, activeProviderId };
      }
      // All non-active turns share this single, stable reference
      return idleStreamingState;
    }),
  (a, b) => a === b,
);

// -----------------------------
// UI visibility
// -----------------------------
export const isHistoryPanelOpenAtom = atom<boolean>(false);
export const isSettingsOpenAtom = atom<boolean>(false);
export const showWelcomeAtom = atom((get) => get(turnIdsAtom).length === 0);
export const turnExpandedStateFamily = atomFamily(
  (_turnId: string) => atom(false),
  (a, b) => a === b,
);



export const showScrollToBottomAtom = atom<boolean>(false);

// -----------------------------
// Model & feature configuration (persisted)
// -----------------------------
export const selectedModelsAtom = atomWithStorage<Record<string, boolean>>(
  "htos_selected_models",
  {},
);
export const mappingEnabledAtom = atomWithStorage<boolean>(
  "htos_mapping_enabled",
  true,
);
export const mappingProviderAtom = atomWithStorage<string | null>(
  "htos_mapping_provider",
  null,
);
export const synthesisProviderAtom = atomWithStorage<string | null>(
  "htos_synthesis_provider",
  null,
);
export const refinerProviderAtom = atomWithStorage<string | null>(
  "htos_refiner_provider",
  null,
);
export const antagonistProviderAtom = atomWithStorage<string | null>(
  "htos_antagonist_provider",
  null,
);

/**
 * Provider locks - stored in chrome.storage.local for backend access
 * UI writes, backend reads. Not atomWithStorage because we need chrome.storage.local
 */
export const providerLocksAtom = atom<{ synthesis: boolean; mapping: boolean; refiner: boolean; antagonist: boolean }>({
  synthesis: false,
  mapping: false,
  refiner: false,
  antagonist: false,
});





export const powerUserModeAtom = atomWithStorage<boolean>(
  "htos_power_user_mode",
  false,
);
export const thinkOnChatGPTAtom = atomWithStorage<boolean>(
  "htos_think_chatgpt",
  false,
);
export const isVisibleModeAtom = atomWithStorage<boolean>(
  "htos_visible_mode",
  true,
);
export const isReducedMotionAtom = atomWithStorage<boolean>(
  "htos_reduced_motion",
  false,
);
export const includePromptInCopyAtom = atomWithStorage<boolean>(
  "htos_include_prompt_in_copy",
  true,
);

// Provider Contexts
export const providerContextsAtom = atomWithImmer<Record<string, any>>({});

// -----------------------------
// Precise recompute targeting
// -----------------------------
export const activeRecomputeStateAtom = atom<{
  aiTurnId: string;
  stepType: "synthesis" | "mapping" | "batch" | "refiner" | "antagonist";
  providerId: string;
} | null>(null);

export const activeProviderTargetAtom = atom<{
  aiTurnId: string;
  providerId: string;
} | null>(null);

// -----------------------------
// Pill-menu provider swap state
// -----------------------------
/**
 * Tracks which 3 providers are currently visible in the response block.
 * Users can swap providers in/out via the pill menu UI.
 */
export const visibleProvidersAtom = atomWithStorage<string[]>(
  "htos_visible_providers",
  ["claude", "gemini", "chatgpt"], // Default visible trio
);

/**
 * Tracks which provider is currently selected for swapping.
 * Can be a visible provider (click-to-swap) or a hidden provider (swap source).
 * Null = no selection active.
 */
export const swapSourceProviderAtom = atom<string | null>(null);

// -----------------------------
// Round-level selections
// -----------------------------
export const synthRecomputeSelectionsByRoundAtom = atomWithImmer<
  Record<string, Record<string, boolean>>
>({});
export const mappingRecomputeSelectionByRoundAtom = atomWithImmer<
  Record<string, string | null>
>({});
export const refinerRecomputeSelectionByRoundAtom = atomWithImmer<
  Record<string, string | null>
>({});
export const antagonistRecomputeSelectionByRoundAtom = atomWithImmer<
  Record<string, string | null>
>({});
// Persist "show history" state per provider (aiTurnId-providerId)
export const providerHistoryExpandedFamily = atomFamily(
  (_key: string) => atom(false),
  (a, b) => a === b,
);

export const thinkSynthByRoundAtom = atomWithImmer<Record<string, boolean>>({});
export const thinkMappingByRoundAtom = atomWithImmer<Record<string, boolean>>(
  {},
);


// -----------------------------
// History & sessions
// -----------------------------
export const historySessionsAtom = atomWithImmer<HistorySessionSummary[]>([]);
export const isHistoryLoadingAtom = atom<boolean>(false);
// -----------------------------
// Connection & system state
// -----------------------------
export const connectionStatusAtom = atom<{
  isConnected: boolean;
  isReconnecting: boolean;
}>({ isConnected: false, isReconnecting: true });
export const providerAuthStatusAtom = atom<Record<string, boolean>>({});
export const alertTextAtom = atom<string | null>(null);
export const chatInputHeightAtom = atom<number>(80);
// Track last meaningful workflow activity to allow UI watchdogs
export const lastActivityAtAtom = atom<number>(0);

// -----------------------------
// Derived atoms (examples)
// -----------------------------
export const activeProviderCountAtom = atom((get) => {
  const selected = get(selectedModelsAtom) || {};
  return Object.values(selected).filter(Boolean).length;
});

export const isFirstTurnAtom = atom((get) => {
  const ids = get(turnIdsAtom);
  const map = get(turnsMapAtom);
  return !ids.some((id) => map.get(id)?.type === "user");
});

// -----------------------------
// Prompt Refiner State
// -----------------------------
export const iscomposingAtom = atom<boolean>(false);
export const composerModelAtom = atomWithStorage<string | null>(
  "htos_composer_model",
  "gemini",
  undefined,
  { getOnInit: true }
);
export const analystModelAtom = atomWithStorage<string | null>(
  "htos_analyst_model",
  "gemini",
  undefined,
  { getOnInit: true }
);
export const chatInputValueAtom = atomWithStorage<string>(
  "htos_chat_input_value",
  "",
  undefined,
  { getOnInit: true }
);
export const hasRejectedRefinementAtom = atom<boolean>(false);

// -----------------------------
// Composer/Analyst Refinement State
// -----------------------------
// Original prompt saved when Composer replaces input (for Revert)
export const originalPromptAtom = atom<string | null>(null);
// Composer draft saved when user reverts (can be re-applied)
export const composerDraftAtom = atom<string | null>(null);
// Analyst drawer visibility
export const analystDrawerOpenAtom = atom<boolean>(false);
// Track refinement state for current draft: "composer" | "analyst" | "both" | null
export const currentRefinementStateAtom = atom<"composer" | "analyst" | "both" | null>(null);
// Message refinement metadata (keyed by message ID)
export const messageRefinementMetaAtom = atomWithImmer<Record<string, { composed?: boolean; audited?: boolean }>>({});

// -----------------------------
// Global Toast Notification
// -----------------------------
export type Toast = {
  id: number;
  message: string;
  type?: 'info' | 'success' | 'error';
} | null;

export const toastAtom = atom<Toast>(null);

// -----------------------------
// Split Pane & Decision Map State
// -----------------------------

export const activeSplitPanelAtom = atom<{ turnId: string; providerId: string } | null>(null);

// Derived atom for performance: ChatView subscribes to this boolean, not the full object
export const isSplitOpenAtom = atom((get) => get(activeSplitPanelAtom) !== null);

export type TrustPanelSection = 'blockers' | 'risks' | 'context' | null;

export const trustPanelFocusAtom = atom<{
  turnId: string;
  section: TrustPanelSection;
} | null>(null);

export const isDecisionMapOpenAtom = atom<{ turnId: string } | null>(null);
export const isDecisionMapVisibleAtom = atom((get) => get(isDecisionMapOpenAtom) !== null);

// -----------------------------
// Launchpad State
// -----------------------------
import type { LaunchpadDraft } from "../types";

export const launchpadDraftsAtom = atomWithStorage<LaunchpadDraft[]>(
  "htos_launchpad_drafts",
  [],
);

export const launchpadOpenAtom = atom<boolean>(false);

export const showLaunchpadTabAtom = atom((get) => get(launchpadDraftsAtom).length > 0);

// =============================================================================
// Workflow Progress (for Council Orbs UI)
// =============================================================================

export type WorkflowStage =
  | 'idle'
  | 'thinking'
  | 'streaming'
  | 'complete'
  | 'error'
  | 'synthesizing';

export interface ProviderWorkflowState {
  stage: WorkflowStage;
  progress?: number; // 0-100
  error?: string;
}

// ProviderId -> { stage, progress }
export const workflowProgressAtom = atom<Record<string, ProviderWorkflowState>>({});

// =============================================================================
// Error resilience state (per-current turn)
// =============================================================================
import type { ProviderError } from "@shared/contract";

/**
 * Track errors per provider for the current turn
 */
export const providerErrorsAtom = atom<Record<string, ProviderError>>({});

/**
 * Track which providers can be retried based on error classification
 */
export const retryableProvidersAtom = atom<string[]>((get) => {
  const errors = get(providerErrorsAtom);
  return Object.entries(errors)
    .filter(([, err]) => !!err && !!err.retryable)
    .map(([pid]) => pid);
});

/**
 * Current workflow degradation status
 */
export const workflowDegradedAtom = atom<{
  isDegraded: boolean;
  successCount: number;
  totalCount: number;
  failedProviders: string[];
}>({
  isDegraded: false,
  successCount: 0,
  totalCount: 0,
  failedProviders: []
});

// =============================================================================
// Streaming UX State (for Council Orbs visibility control)
// =============================================================================

/**
 * Derived atom: true when a round is actively running
 * Used to hide config orbs and show active turn orbs
 */
export const isRoundActiveAtom = atom((get) => {
  const activeId = get(activeAiTurnIdAtom);
  const isLoading = get(isLoadingAtom);
  return activeId !== null && isLoading;
});

/**
 * Track if we've auto-opened the split pane for the current turn
 * Value is the turnId or null
 */
export const hasAutoOpenedPaneAtom = atom<string | null>(null);

/**
 * Track if we've auto-widened the left pane for synthesis this turn
 * Value is the turnId or null
 */
export const hasAutoWidenedForSynthesisAtom = atom<string | null>(null);

/**
 * Split pane ratio (left pane percentage) for programmatic control
 * Used by ChatView to sync with react-resizable-panels
 */
export const splitPaneRatioAtom = atom<number>(60);




================================================
FILE: ui/styles/input.css
================================================
@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

/* Import Math Styles (Lazy-loaded logic handled by component, but styles here for now) */
@import './math-styles.css';

/* CSS Custom Properties */
:root {
    --font-dm-mono: 'DM Mono';
}

/* ============================================================================
   Council Orbs Enhanced Styles (GPU-accelerated)
   ============================================================================ */

/* Variables */
:root {
    --council-orb-size: 24px;
    --council-orb-size-voice: 32px;
    --council-orb-gap: 24px;
    --council-transition-smooth: cubic-bezier(0.4, 0, 0.2, 1);
    --council-transition-bounce: cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* Containers */
.council-container {
    position: relative;
    width: 100%;
}

.council-orb-bar {
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    padding: 16px 0;
    background: transparent;
}

.council-orb-bar::before {
    content: '';
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 300px;
    height: 100px;
    background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.03) 0%, transparent 70%);
    pointer-events: none;
}

.council-orb-bar--active {
    /* No backdrop - orbs are now inside the chat input container */
    background: transparent;
    backdrop-filter: none;
    border: none;
    border-radius: 0;
    padding: 0;
    box-shadow: none;
}

.council-orb-bar--active::before {
    display: none;
}

/* Groups */
.council-orb-group {
    display: flex;
    align-items: center;
    gap: var(--council-orb-gap);
    flex: 1;
}

.council-orb-group--left {
    justify-content: flex-end;
    padding-right: 16px;
}

.council-orb-group--right {
    justify-content: flex-start;
    padding-left: 16px;
}

/* Voice Zone */
.council-voice-zone {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 56px;
    height: 56px;
    flex-shrink: 0;
}

.council-glass-ring {
    position: absolute;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    border: 1px solid rgba(255, 255, 255, 0.06);
    background: radial-gradient(circle at center, rgba(255, 255, 255, 0.02) 0%, transparent 70%);
}

/* Orb Wrapper */
.council-orb-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s var(--council-transition-smooth);
}

.council-orb-wrapper--voice {
    z-index: 5;
}

.council-orb-wrapper--inactive {
    opacity: 0.5;
    filter: saturate(0.3);
}

.council-orb-wrapper:hover {
    transform: scale(1.1) translateY(-2px);
    z-index: 10;
}

/* Crown */
.council-crown {
    position: absolute;
    top: -16px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 14px;
    z-index: 20;
    background: none;
    border: none;
    cursor: pointer;
    transition: all 0.3s var(--council-transition-bounce);
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
}

.council-crown--active {
    animation: crown-float 2s ease-in-out infinite;
    filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.6)) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
}

.council-crown--historical {
    opacity: 0.4;
    filter: grayscale(1);
    cursor: default;
}

.council-crown--selecting {
    animation: crown-pulse 0.5s ease-in-out infinite;
    filter: drop-shadow(0 0 12px rgba(139, 92, 246, 0.8)) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
}

@keyframes crown-float {

    0%,
    100% {
        transform: translateX(-50%) translateY(0);
    }

    50% {
        transform: translateX(-50%) translateY(-3px);
    }
}

@keyframes crown-pulse {

    0%,
    100% {
        transform: translateX(-50%) scale(1);
    }

    50% {
        transform: translateX(-50%) scale(1.2);
    }
}

/* Progress Ring */
.council-progress-ring {
    position: absolute;
    width: calc(var(--council-orb-size) + 12px);
    height: calc(var(--council-orb-size) + 12px);
    pointer-events: none;
    z-index: 1;
}

.council-orb-wrapper--voice .council-progress-ring {
    width: calc(var(--council-orb-size-voice) + 14px);
    height: calc(var(--council-orb-size-voice) + 14px);
}

.council-progress-ring__progress {
    transition: stroke-dashoffset 0.3s var(--council-transition-smooth);
    will-change: stroke-dashoffset;
}

/* Orb Button */
.council-orb {
    position: relative;
    width: var(--council-orb-size);
    height: var(--council-orb-size);
    border-radius: 50%;
    border: none;
    cursor: pointer;
    overflow: hidden;
    will-change: transform, box-shadow;
    transform: translateZ(0);
    backface-visibility: hidden;
    transition: transform 0.3s var(--council-transition-bounce), box-shadow 0.3s var(--council-transition-smooth), filter 0.3s var(--council-transition-smooth);
    box-shadow: 0 0 20px -4px var(--orb-color), 0 4px 12px rgba(0, 0, 0, 0.3), inset 0 1px 2px rgba(255, 255, 255, 0.1);
}

.council-orb--voice {
    width: var(--council-orb-size-voice);
    height: var(--council-orb-size-voice);
    box-shadow: 0 0 30px -4px var(--orb-color), 0 0 60px -8px var(--orb-color), 0 6px 16px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.15);
}

.council-orb--regular:hover {
    transform: scale(1.25) translateY(-4px);
    box-shadow: 0 0 30px -2px var(--orb-color), 0 0 50px -8px var(--orb-color), 0 8px 24px rgba(0, 0, 0, 0.4);
}

/* Orb Internals */
.council-orb__core {
    position: absolute;
    inset: 0;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.25) 0%, transparent 50%), radial-gradient(circle at 70% 70%, rgba(0, 0, 0, 0.3) 0%, transparent 50%), linear-gradient(135deg, var(--orb-color) 0%, var(--orb-accent) 100%);
    z-index: 1;
}

.council-orb__glow {
    position: absolute;
    inset: -4px;
    border-radius: 50%;
    background: radial-gradient(circle at center, var(--orb-color) 0%, transparent 70%);
    opacity: 0.3;
    z-index: 0;
    animation: glow-breathe 3s ease-in-out infinite;
}

@keyframes glow-breathe {

    0%,
    100% {
        opacity: 0.2;
        transform: scale(1);
    }

    50% {
        opacity: 0.4;
        transform: scale(1.1);
    }
}

.council-orb__spinner {
    position: absolute;
    inset: 2px;
    border-radius: 50%;
    background: conic-gradient(from 0deg, transparent 0deg, var(--orb-color) 30deg, transparent 60deg);
    opacity: 0.6;
    z-index: 2;
    animation: spin-smooth 6s linear infinite;
    will-change: transform;
    transform: translateZ(0);
}

@keyframes spin-smooth {
    from {
        transform: rotate(0deg);
    }

    to {
        transform: rotate(360deg);
    }
}

.council-orb__logo {
    position: absolute;
    inset: 15%;
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    opacity: 0.5;
    z-index: 3;
    transition: opacity 0.3s ease;
    filter: brightness(1.2);
}

.council-orb:hover .council-orb__logo {
    opacity: 1;
}

.council-orb__pulse {
    position: absolute;
    inset: 0;
    border-radius: 50%;
    background: radial-gradient(circle at center, var(--orb-color) 0%, transparent 70%);
    z-index: 4;
    animation: pulse-stream 1s ease-out infinite;
}

@keyframes pulse-stream {
    0% {
        opacity: 0.5;
        transform: scale(0.8);
    }

    100% {
        opacity: 0;
        transform: scale(1.5);
    }
}

/* Orb State Mods */
.council-orb--historical {
    filter: grayscale(0.8) brightness(0.7);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.council-orb--historical .council-orb__spinner {
    animation-duration: 20s;
    opacity: 0.2;
}

.council-orb--historical .council-orb__glow {
    animation: none;
    opacity: 0.1;
}

.council-orb--historical:hover {
    filter: none;
    box-shadow: 0 0 25px -4px var(--orb-color), 0 6px 16px rgba(0, 0, 0, 0.3);
}

.council-orb--historical:hover .council-orb__spinner {
    animation-duration: 4s;
    opacity: 0.6;
}

.council-orb--error {
    --orb-color: #EF4444;
    --orb-accent: #B91C1C;
    animation: error-shake 0.5s ease-in-out;
}

@keyframes error-shake {

    0%,
    100% {
        transform: translateX(0);
    }

    20%,
    60% {
        transform: translateX(-3px);
    }

    40%,
    80% {
        transform: translateX(3px);
    }
}

.council-orb--streaming .council-orb__spinner {
    animation-duration: 2s;
}

.council-orb--crown-target {
    animation: target-pulse 1s ease-in-out infinite;
    box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5), 0 0 20px -4px var(--orb-color);
}

@keyframes target-pulse {

    0%,
    100% {
        box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.3), 0 0 20px -4px var(--orb-color);
    }

    50% {
        box-shadow: 0 0 0 6px rgba(139, 92, 246, 0.5), 0 0 30px -4px var(--orb-color);
    }
}

.council-orb--disabled {
    opacity: 0.4;
    cursor: not-allowed;
    filter: grayscale(1);
}

.council-orb--selected {
    box-shadow: 0 0 25px -2px var(--orb-color), 0 0 50px -8px var(--orb-color), 0 0 0 2px rgba(255, 255, 255, 0.2);
}

.council-orb--unselected {
    filter: grayscale(0.6) brightness(0.6);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.council-orb--unselected:hover {
    filter: none;
}

/* Stage Badge */
.council-stage-badge {
    position: absolute;
    bottom: -8px;
    right: -8px;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    z-index: 15;
    border: 2px solid rgba(0, 0, 0, 0.8);
    animation: badge-pop 0.3s var(--council-transition-bounce);
}

@keyframes badge-pop {
    from {
        transform: scale(0);
    }

    to {
        transform: scale(1);
    }
}

/* Tooltip */
.council-tooltip {
    position: absolute;
    bottom: calc(100% + 12px);
    left: 50%;
    transform: translateX(-50%);
    background: rgba(20, 20, 30, 0.95);
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 8px 12px;
    white-space: nowrap;
    z-index: 100;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    animation: tooltip-fade-in 0.2s ease-out;
    display: flex;
    flex-direction: column;
    gap: 2px;
}

@keyframes tooltip-fade-in {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(4px);
    }

    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

.council-tooltip__name {
    font-size: 13px;
    font-weight: 500;
    color: #fff;
}

.council-tooltip__stage {
    font-size: 11px;
    color: rgba(255, 255, 255, 0.6);
}

.council-tooltip__action {
    font-size: 11px;
    color: #A78BFA;
}

/* Crown Mode Indicator */
.council-crown-indicator {
    position: absolute;
    top: -40px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #8B5CF6 0%, #6366F1 100%);
    color: white;
    font-size: 12px;
    font-weight: 500;
    padding: 6px 12px;
    border-radius: 20px;
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
    animation: indicator-bounce 1s ease-in-out infinite;
    z-index: 50;
}

@keyframes indicator-bounce {

    0%,
    100% {
        transform: translateX(-50%) translateY(0);
    }

    50% {
        transform: translateX(-50%) translateY(-4px);
    }
}

/* Settings Button */
.council-settings-btn {
    position: absolute;
    right: -48px;
    top: 50%;
    transform: translateY(-50%);
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: rgba(40, 40, 50, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.6);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.council-settings-btn:hover {
    background: rgba(60, 60, 70, 0.9);
    color: white;
    border-color: rgba(255, 255, 255, 0.2);
    transform: translateY(-50%) scale(1.05);
}

/* Menu Panel */
.council-menu {
    position: absolute;
    left: 50%;
    bottom: calc(100% + 16px);
    transform: translateX(-50%);
    background: rgba(25, 25, 35, 0.98);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 20px;
    min-width: 560px;
    max-width: 640px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
    z-index: 100;
    animation: menu-slide-up 0.3s var(--council-transition-bounce);
}

@keyframes menu-slide-up {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(10px);
    }

    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

.council-menu__header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

.council-menu__header h3 {
    font-size: 14px;
    font-weight: 600;
    color: white;
    margin: 0;
}

.council-menu__close {
    width: 24px;
    height: 24px;
    border-radius: 6px;
    border: none;
    background: rgba(255, 255, 255, 0.05);
    color: rgba(255, 255, 255, 0.5);
    cursor: pointer;
    font-size: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.council-menu__close:hover {
    background: rgba(255, 255, 255, 0.1);
    color: white;
}

.council-menu__grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
}

.council-menu__section {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.council-menu__section--full {
    grid-column: span 2;
}

.council-menu__label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    font-weight: 500;
    color: rgba(255, 255, 255, 0.7);
}

.council-menu__options {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.council-menu__options--wrap {
    flex-direction: row;
    flex-wrap: wrap;
}

.council-menu__chip {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(255, 255, 255, 0.03);
    color: rgba(255, 255, 255, 0.7);
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.council-menu__chip:hover:not(:disabled) {
    background: rgba(255, 255, 255, 0.08);
    border-color: var(--chip-color);
}

.council-menu__chip--selected {
    background: rgba(139, 92, 246, 0.15);
    border-color: rgba(139, 92, 246, 0.5);
    color: white;
}

.council-menu__chip--small {
    padding: 6px 10px;
}

.council-menu__chip:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.council-menu__chip-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
}

.council-menu__chip-check {
    margin-left: auto;
    color: #A78BFA;
}

.council-menu__chip-lock {
    margin-left: auto;
    font-size: 10px;
}

@layer base {

    /* Font Face Declarations */
    @font-face {
        font-family: 'Inter';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url('../fonts/Inter-Regular.woff2') format('woff2');
    }

    @font-face {
        font-family: 'Inter';
        font-style: normal;
        font-weight: 600;
        font-display: swap;
        src: url('../fonts/Inter-SemiBold.woff2') format('woff2');
    }

    @font-face {
        font-family: 'DM Mono';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url('../fonts/DMMono-Regular.ttf') format('truetype');
    }

    /* CSS Custom Properties */
    :root {
        --font-dm-mono: 'DM Mono';
    }

    /* Base Styles */
    body {
        @apply font-sans text-text-primary bg-surface text-base leading-relaxed;
    }

    #root {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
    }

    header {
        background-color: #2c3e50;
        color: #ecf0f1;
        padding: 15px 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    header h1 {
        margin: 0;
        font-size: 24px;
    }

    nav ul {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
    }

    nav li {
        margin-left: 20px;
    }

    nav a {
        color: #ecf0f1;
        text-decoration: none;
        font-weight: bold;
        transition: color 0.3s ease;
    }

    nav a:hover {
        color: #3498db;
    }

    main {
        flex-grow: 1;
        padding: 20px;
    }

    footer {
        background-color: #2c3e50;
        color: #ecf0f1;
        text-align: center;
        padding: 10px 20px;
        box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
        font-size: 14px;
    }

    /* Layout clamps */
    html,
    body,
    #root {
        max-width: 100%;
        overflow-x: hidden;
    }

    .singularity-app-container,
    .main-content-wrapper,
    .chat-area {
        width: 100%;
        max-width: 100%;
        min-width: 0;
        overflow-x: hidden;
    }

    /* Ensure long words/content wrap within the editor */
    .ProseMirror {
        overflow-wrap: anywhere;
        word-break: break-word;
    }
}

@layer components {
    .batch-filler {
        overflow: hidden;
    }

    .primaries {
        overflow: visible;
    }

    .user-turn-block pre,
    .ai-turn-block pre {
        max-width: 100%;
        overflow-x: auto;
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 15px;
    }

    .card {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        padding: 20px;
        margin-bottom: 20px;
    }

    .button {
        display: inline-block;
        background-color: #3498db;
        color: #fff;
        padding: 10px 15px;
        border-radius: 5px;
        text-decoration: none;
        transition: background-color 0.3s ease;
    }

    .button:hover {
        background-color: #2980b9;
    }

    .streaming-dots::after {
        content: "● ● ●";
        font-size: 12px;
        letter-spacing: 0.1em;
        color: #c084fc;
        animation: pulse 1.2s infinite;
    }

    .copy-button-wrapper {
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
    }

    .provider-block:hover .copy-button-wrapper {
        opacity: 1;
    }

    .truncated-content {
        display: -webkit-box;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
        line-clamp: 3;
    }

    .composer-toolbar {
        width: 100%;
    }

    .chat-view,
    .chat-input-wrapper,
    .chat-main,
    main {
        min-height: 0 !important;
    }

    .chat-input-wrapper {
        flex: 0 0 auto !important;
        z-index: 10;
    }

    .htos-citation-pill {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 0 6px;
        margin-left: 4px;
        margin-right: 4px;
        background-color: #2563eb;
        border: 1px solid #1d4ed8;
        border-radius: 9999px;
        color: #ffffff;
        font-size: 12px;
        font-weight: 700;
        line-height: 1.4;
        cursor: pointer;
        user-select: none;
        box-shadow: 0 0 0 1px rgba(29, 78, 216, 0.6);
        transition: transform 0.1s ease, background-color 0.1s ease;
    }

    .htos-citation-pill:hover {
        background-color: #1d4ed8;
        transform: translateY(-1px);
    }

    .htos-citation-pill:active {
        transform: translateY(0);
    }

    /* Reset block code inside pre to prevent bubble styling */
    .markdown-body pre code {
        background: transparent;
        border: none;
        padding: 0;
        display: inline;
        white-space: pre;
    }

    /* Council Orbs Styles (Migrated from module) */

    /* Orb Bar Container */
    .council-orb-bar {
        /* Fully transparent with subtle borders */
        background: transparent;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        position: relative;
        padding: 12px 0;
    }

    .council-orb-bar::before {
        content: '';
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.08) 0%, transparent 70%);
        pointer-events: none;
        z-index: 0;
    }

    /* Override: Active variant should have no borders */
    .council-orb-bar--active {
        border-top: none !important;
        border-bottom: none !important;
        padding: 0 !important;
        background: transparent !important;
    }

    .council-orb-bar--active::before {
        display: none !important;
    }

    /* Glass ring around voice orb */
    .council-glass-ring {
        position: absolute;
        width: 80px;
        height: 80px;
        border-radius: 50%;
        border: 1px solid rgba(255, 255, 255, 0.08);
        pointer-events: none;
        z-index: 0;
    }

    /* Base Orb Styles */
    .council-orb {
        border-radius: 50%;
        background: #475569;
        background: radial-gradient(circle at 30% 30%, #ffffff44, #00000066);
        box-shadow: 0 0 12px rgba(255, 255, 255, 0.4);
        transition: all 0.3s cubic-bezier(0.17, 0.67, 0.12, 1.34);
        position: relative;
        overflow: hidden;
        z-index: 1;
    }

    /* Size variants */
    .council-orb-regular {
        width: 28px;
        height: 28px;
    }

    .council-orb-voice {
        width: 32px;
        height: 32px;
    }

    .council-orb::before {
        content: '';
        position: absolute;
        inset: 0;
        background: conic-gradient(from var(--rotation, 0deg),
                var(--model-color),
                transparent 80%);
        opacity: 0.8;
        animation: spin 8s linear infinite, breathe 4s infinite alternate;
        z-index: 0;
    }

    /* Logo backdrop - ALWAYS visible at 35%, scales to 100% on hover */
    .council-orb::after {
        content: '';
        position: absolute;
        inset: 0;
        background-image: var(--logo-src);
        background-size: 60%;
        background-position: center;
        background-repeat: no-repeat;
        opacity: 0.35;
        transition: opacity 0.4s ease-in-out;
        z-index: 2;
    }

    .council-orb:hover::after {
        opacity: 1;
    }

    .council-orb:hover {
        transform: scale(1.4) translateY(-4px);
        box-shadow: 0 0 24px var(--model-color);
        z-index: 10;
    }

    .council-orb-voice {
        box-shadow: 0 0 20px var(--model-color), 0 0 0 3px #ffffff44;
        animation: goldenPulse 2s infinite;
    }

    .council-orb-streaming::after {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(circle, var(--model-color) 0%, transparent 70%);
        opacity: 0.3;
        animation: fillPulse 1.5s infinite;
        z-index: 2;
    }

    .council-orb-error {
        background: radial-gradient(circle at 30% 30%, #ff000022, #00000044);
        box-shadow: 0 0 12px rgba(255, 0, 0, 0.5);
    }

    .council-orb-error::before {
        background: conic-gradient(from var(--rotation, 0deg),
                #ef4444,
                transparent 80%);
    }

    /* Variant-specific styles */
    .council-tray {
        width: auto;
    }

    .council-divider {
        max-width: 80%;
    }

    .council-historical {
        max-width: 80%;
    }

    .council-historical-dimmed {
        opacity: 0.5;
    }

    .council-tray-dimmed-split {
        opacity: 0.4;
        filter: grayscale(50%);
    }

    /* Historical orbs: Slightly muted but still colored (75% saturation) */
    .council-orb-historical {
        animation: none !important;
        filter: saturate(0.75) brightness(0.85);
        /* Slightly muted, not grayscale */
        transform: scale(0.85);
        /* Physically recede */
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.3) !important;
        /* Subtle shadow */
    }

    /* Remove internal animations for dormant state */
    .council-orb-historical::before {
        animation: none !important;
        opacity: 0.3;
    }

    /* Reset separate voice styling for historical to match unison "dormant" look */
    .council-orb-historical.council-orb-voice {
        animation: none !important;
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.3) !important;
        width: 28px;
        /* Normalize size to match others until hover */
        height: 28px;
    }

    /* WAKE UP on hover: Restore full saturation, scale, and glow */
    .council-orb-historical:hover {
        filter: saturate(1) brightness(1);
        transform: scale(1.15) translateY(-2px);
        box-shadow: 0 0 20px var(--model-color) !important;
        z-index: 50;
        cursor: pointer;
    }

    /* Restore internal vitality on hover */
    .council-orb-historical:hover::before {
        opacity: 0.8;
        animation: spin 4s linear infinite !important;
    }

    .council-orb-historical:hover::after {
        opacity: 1;
    }

    /* Ensure smooth transition for dimming */
    .council-tray-container {
        transition: opacity 0.5s ease-in-out;
    }

    /* Override historical muting for orbs that are STREAMING or ACTIVE */
    /* These orbs should look bright to draw attention */
    .council-orb-historical.council-orb-streaming,
    .council-orb-historical.council-orb--start-pulse,
    .council-orb-historical.council-orb--complete-flash {
        filter: saturate(1) brightness(1);
        transform: scale(1);
        box-shadow: 0 0 20px var(--model-color) !important;
    }

    .council-orb-historical.council-orb-streaming::before {
        opacity: 0.8;
        animation: spin 3s linear infinite !important;
    }

    /* Per-orb animations for streaming start/finish */
    @keyframes orb-start-pulse {
        0% {
            transform: scale(1);
            box-shadow: 0 0 0 0 var(--model-color);
        }

        50% {
            transform: scale(1.2);
            box-shadow: 0 0 25px 6px var(--model-color);
        }

        100% {
            transform: scale(1);
            box-shadow: 0 0 0 0 transparent;
        }
    }

    @keyframes orb-complete-flash {
        0% {
            filter: brightness(1);
        }

        50% {
            filter: brightness(1.4);
        }

        100% {
            filter: brightness(1);
        }
    }

    .council-orb--start-pulse {
        animation: orb-start-pulse 0.6s ease-out !important;
    }

    .council-orb--complete-flash {
        animation: orb-complete-flash 0.5s ease-out !important;
    }

    /* Decision Map Sheet Premium Styling */
    .decision-sheet-bg {
        background: #000000;
        position: relative;
    }

    /* Noise texture overlay */
    .decision-sheet-bg::before {
        content: '';
        position: absolute;
        inset: 0;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        opacity: 0.03;
        pointer-events: none;
        z-index: 0;
    }

    /* Pill-shaped tabs */
    .decision-tab-pill {
        padding: 0.5rem 1.25rem;
        border-radius: 9999px;
        font-size: 0.8125rem;
        font-weight: 600;
        letter-spacing: 0.025em;
        transition: all 0.3s ease;
        border: 1px solid transparent;
        background: rgba(255, 255, 255, 0.05);
        color: rgba(255, 255, 255, 0.6);
    }

    .decision-tab-pill:hover {
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.85);
    }

    /* Graph tab active - violet */
    .decision-tab-active-graph {
        background: rgba(139, 92, 246, 0.2);
        border-color: rgba(139, 92, 246, 0.5);
        color: #a78bfa;
        box-shadow: 0 0 20px rgba(139, 92, 246, 0.25), inset 0 0 12px rgba(139, 92, 246, 0.1);
    }

    /* Narrative tab active - amber */
    .decision-tab-active-narrative {
        background: rgba(245, 158, 11, 0.2);
        border-color: rgba(245, 158, 11, 0.5);
        color: #fbbf24;
        box-shadow: 0 0 20px rgba(245, 158, 11, 0.25), inset 0 0 12px rgba(245, 158, 11, 0.1);
    }

    /* Options tab active - emerald */
    .decision-tab-active-options {
        background: rgba(16, 185, 129, 0.2);
        border-color: rgba(16, 185, 129, 0.5);
        color: #34d399;
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.25), inset 0 0 12px rgba(16, 185, 129, 0.1);
    }

    /* Model orb badges (40px) for supporters */
    .decision-orb-badge {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.3), rgba(0, 0, 0, 0.4));
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: 700;
        color: white;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
        overflow: hidden;
    }

    .decision-orb-badge::before {
        content: '';
        position: absolute;
        inset: 0;
        background: conic-gradient(from 0deg, var(--orb-color), transparent 80%);
        opacity: 0.7;
        animation: spin 6s linear infinite;
    }

    .decision-orb-badge:hover {
        transform: scale(1.15);
        box-shadow: 0 0 16px var(--orb-color);
    }

    .decision-orb-badge span {
        position: relative;
        z-index: 1;
    }

    /* Detail view header */
    .decision-detail-header {
        font-size: 1.5rem;
        font-weight: 700;
        line-height: 1.3;
        max-width: 80%;
        text-align: center;
    }

    /* Narrative manuscript prose styling */
    .narrative-prose {
        max-width: 48rem;
        margin: 0 auto;
        line-height: 1.75;
        font-size: 1rem;
        color: rgba(255, 255, 255, 0.9);
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
    }

    .narrative-prose p {
        margin-bottom: 1.25rem;
    }

    /* Superscript citations in narrative */
    .narrative-prose .citation-link {
        font-size: 0.7em;
        vertical-align: super;
        color: #8b5cf6;
        cursor: pointer;
        padding: 0 2px;
        transition: color 0.2s ease;
    }

    .narrative-prose .citation-link:hover {
        color: #a78bfa;
        text-decoration: underline;
    }

    /* Highlighted sentence in detail view */
    .narrative-highlight {
        background: rgba(139, 92, 246, 0.2);
        border-left: 3px solid #8b5cf6;
        padding: 0.5rem 1rem;
        margin: 0.5rem 0;
        border-radius: 0 8px 8px 0;
    }

    /* Theme section in Options tab */
    .options-theme-section {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        margin-bottom: 1rem;
        overflow: hidden;
    }

    .options-theme-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem 1.25rem;
        cursor: pointer;
        transition: background 0.2s ease;
    }

    .options-theme-header:hover {
        background: rgba(255, 255, 255, 0.05);
    }

    .options-theme-title {
        font-weight: 600;
        font-size: 1rem;
        color: rgba(255, 255, 255, 0.9);
    }

    .options-theme-chevron {
        transition: transform 0.2s ease;
        color: rgba(255, 255, 255, 0.5);
    }

    .options-theme-chevron.expanded {
        transform: rotate(180deg);
    }

    .options-theme-content {
        padding: 0 1.25rem 1rem;
    }

    /* Option card */
    .option-card {
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 1rem;
        margin-bottom: 0.75rem;
        transition: all 0.2s ease;
    }

    .option-card:hover {
        background: rgba(255, 255, 255, 0.06);
        border-color: rgba(255, 255, 255, 0.15);
    }

    .option-card-title {
        font-weight: 600;
        font-size: 0.9375rem;
        color: rgba(255, 255, 255, 0.95);
        margin-bottom: 0.5rem;
    }

    .option-card-description {
        font-size: 0.875rem;
        color: rgba(255, 255, 255, 0.7);
        line-height: 1.5;
        margin-bottom: 0.75rem;
    }

    .option-card-supporters {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
    }

    /* Back button in detail view */
    .decision-back-btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background: rgba(139, 92, 246, 0.15);
        border: 1px solid rgba(139, 92, 246, 0.4);
        border-radius: 8px;
        color: #a78bfa;
        font-size: 0.8125rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .decision-back-btn:hover {
        background: rgba(139, 92, 246, 0.25);
        box-shadow: 0 0 12px rgba(139, 92, 246, 0.3);
    }
}

@layer utilities {
    @keyframes breathe {
        from {
            opacity: 0.4;
        }

        to {
            opacity: 0.8;
        }
    }

    @keyframes fillPulse {

        0%,
        100% {
            opacity: 0.2;
        }

        50% {
            opacity: 0.5;
        }
    }

    @keyframes pulse {

        0%,
        100% {
            opacity: 1;
        }

        50% {
            opacity: 0.5;
        }
    }

    @keyframes goldenPulse {

        0%,
        100% {
            box-shadow: 0 0 20px var(--model-color), 0 0 0 3px #ffffff44;
        }

        50% {
            box-shadow: 0 0 32px var(--model-color), 0 0 0 3px #ffffff66;
        }
    }

    @keyframes synthesisGlow {
        0% {
            opacity: 0.5;
        }

        100% {
            opacity: 1;
        }
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    /* Conflict edge slow pulse for red dashed lines */
    @keyframes conflictPulse {

        0%,
        100% {
            stroke-opacity: 0.4;
        }

        50% {
            stroke-opacity: 0.8;
        }
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(10px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
        }

        to {
            opacity: 1;
        }
    }

    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* Lightweight Math Styling */
    .math-inline {
        font-style: italic;
        font-family: 'Times New Roman', 'Georgia', serif;
        white-space: nowrap;
    }

    .math-text {
        font-style: normal;
        font-family: inherit;
    }

    .math-sup {
        font-size: 0.75em;
        vertical-align: super;
        line-height: 0;
    }

    .math-sub {
        font-size: 0.75em;
        vertical-align: sub;
        line-height: 0;
    }

    /* 
     FIX: Global Safety Net for Math Scrollbars
     Ensure the parent chat bubble allows the child to handle scrolling.
     We target the markdown body and the turn block to ensure no overflow: hidden clips the scrollbar.
  */
    .markdown-body,
    .ai-turn-block,
    .user-turn-block {
        overflow-wrap: break-word;
        /* overflow: hidden;  <-- DO NOT USE THIS, it clips the scrollbar */
    }
}


================================================
FILE: ui/styles/math-styles.css
================================================
/* 
 * Minimal KaTeX Styles
 * Only includes structural styles. Fonts are excluded to prevent bundling.
 * We use system fonts for performance and bundle size optimization.
 */

/* Import KaTeX structure (this path depends on how rehype-katex/katex are resolved, 
   but since we want to avoid bundling fonts, we'll define critical styles manually 
   or assume a very minimal set. 
   
   Actually, for strict isolation, we should NOT import the full katex.css 
   because it includes @font-face rules.
   
   Instead, we define the minimal necessary styles for layout.
*/

.katex {
    font-family: 'system-ui', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif !important;
    font-size: 1.1em;
    line-height: 1.2;
    text-rendering: optimizeLegibility;
}

/* 
   FIX: Math Overflow & Scrollbar Layout 
   - max-width: 100% prevents overflow
   - overflow-x: auto enables scrolling
   - padding-bottom: 6px reserves space for the scrollbar so it doesn't clip descenders
*/
.katex-display {
    display: block;
    margin: 1em 0;
    text-align: center;
    max-width: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    padding-bottom: 6px;
}

/* Custom Slim Scrollbar for Chrome Extension */
.katex-display::-webkit-scrollbar {
    height: 6px;
}

.katex-display::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
}

.katex-display::-webkit-scrollbar-track {
    background-color: transparent;
}

.katex-html {
    display: inline-block;
}

/* Ensure fractions and other elements align correctly */
.katex .base {
    position: relative;
    white-space: nowrap;
    width: min-content;
}

/* 
   FIX: Force horizontal growth for the inner container 
   This ensures that if the math is wide, it forces the scrollbar on the parent (.katex-display)
*/
.katex-display>.katex {
    white-space: nowrap;
}

.katex .strut {
    display: inline-block;
}

/* Dark mode adjustments if needed */
@media (prefers-color-scheme: dark) {
    .katex {
        color: inherit;
        /* Inherit text color from parent */
    }

    .katex-display::-webkit-scrollbar-thumb {
        background-color: rgba(255, 255, 255, 0.2);
    }
}

/* Fix for some common KaTeX layout issues without fonts */
.katex .mord.mathnormal {
    font-style: italic;
}

.katex .msupsub {
    text-align: left;
}


================================================
FILE: ui/styles/tokens.ts
================================================
// Centralized theme tokens for UI chrome elements used by the Rail to avoid hard-coded hex values
// Keep values aligned with existing UI styling

export const tokens = {
  rail: {
    bg: "rgba(255, 255, 255, 0.04)",
    bgHover: "rgba(255, 255, 255, 0.06)",
    border: "rgba(255, 255, 255, 0.1)",
    cardBg: "rgba(255, 255, 255, 0.08)",
    cardBgHover: "rgba(255, 255, 255, 0.12)",
    cardShadow: "0 1px 2px rgba(0,0,0,0.25)",
  },
  status: {
    streaming: "#10b981",
    unread: "#f59e0b",
    error: "#ef4444",
  },
  text: {
    muted: "#94a3b8",
  },
  accents: {
    chatgpt: "#10A37F",
    claude: "#FF7F00",
    gemini: "#4285F4",
    qwen: "#00A9E0", // A distinct teal color for Qwen
  },
} as const;



================================================
FILE: ui/types/env.d.ts
================================================
// ui/types/env.d.ts

// Asset declarations
declare module "*.svg" {
    const content: string;
    export default content;
}

declare module "*.png" {
    const content: string;
    export default content;
}

declare module "*.jpg" {
    const content: string;
    export default content;
}

declare module "*.webp" {
    const content: string;
    export default content;
}

// CSS Modules
declare module '*.module.css' {
    const classes: { [key: string]: string };
    export default classes;
}

// Chrome extension API type definitions
declare namespace chrome {
    namespace runtime {
        const id: string;
        const lastError: { message: string } | undefined;

        // Overloads for sendMessage
        function sendMessage(
            message: any,
            callback?: (response: any) => void,
        ): void;
        function sendMessage(
            extensionId: string,
            message: any,
            callback?: (response: any) => void,
        ): void;

        // onMessage event with add/remove listener methods
        const onMessage: {
            addListener(
                callback: (
                    message: any,
                    sender: any,
                    sendResponse: (response?: any) => void,
                ) => void,
            ): void;
            removeListener(
                callback: (
                    message: any,
                    sender: any,
                    sendResponse: (response?: any) => void,
                ) => void,
            ): void;
        };
    }

    namespace tabs {
        interface Tab {
            id?: number;
            url?: string;
            title?: string;
            windowId?: number;
        }

        // getCurrent
        function getCurrent(): Promise<Tab>;
        function getCurrent(callback: (tab: Tab) => void): void;

        // get
        function get(tabId: number): Promise<Tab>;
        function get(tabId: number, callback: (tab: Tab) => void): void;

        // query
        function query(queryInfo: any): Promise<Tab[]>;
        function query(queryInfo: any, callback: (tabs: Tab[]) => void): void;

        // update
        function update(tabId: number, updateProperties: any): Promise<Tab>;
        function update(
            tabId: number,
            updateProperties: any,
            callback: (tab: Tab) => void,
        ): void;

        // create
        function create(createProperties: any): Promise<Tab>;
        function create(createProperties: any, callback: (tab: Tab) => void): void;

        // remove
        function remove(tabIds: number | number[]): Promise<void>;
        function remove(tabIds: number | number[], callback: () => void): void;

        // reload
        function reload(tabId?: number, reloadProperties?: any): Promise<void>;
        function reload(
            tabId: number,
            reloadProperties: any,
            callback: () => void,
        ): void;

        // sendMessage
        function sendMessage(
            tabId: number,
            message: any,
            options?: any,
        ): Promise<any>;
        function sendMessage(
            tabId: number,
            message: any,
            responseCallback: (response: any) => void,
        ): void;
        function sendMessage(
            tabId: number,
            message: any,
            options: any,
            responseCallback: (response: any) => void,
        ): void;

        // events (minimal)
        const onUpdated: {
            addListener(
                callback: (tabId: number, changeInfo: any, tab: Tab) => void,
            ): void;
            removeListener(
                callback: (tabId: number, changeInfo: any, tab: Tab) => void,
            ): void;
        };
        const onRemoved: {
            addListener(callback: (tabId: number, removeInfo?: any) => void): void;
            removeListener(callback: (tabId: number, removeInfo?: any) => void): void;
        };
        const onCreated: {
            addListener(callback: (tab: Tab) => void): void;
            removeListener(callback: (tab: Tab) => void): void;
        };
        const onActivated: {
            addListener(callback: (activeInfo: any) => void): void;
            removeListener(callback: (activeInfo: any) => void): void;
        };
    }
}



================================================
FILE: ui/types/index.ts
================================================
// src/ui/types.ts

/**
 * UI-LAYER TYPES
 *
 * This file serves as the single source of truth for all UI type definitions.
 * It imports types from the shared contract and persistence layers, then re-exports
 * them along with UI-specific types to create a unified type system.
 */

// Import types from shared contract (runtime types)
import type {
  ProviderKey,
  ProviderResponse as ContractProviderResponse,
  AiTurn as ContractAiTurn,
} from "../../shared/contract";
import {
  isUserTurn as isUserTurnContract,
  isAiTurn as isAiTurnContract,
} from "../../shared/contract";



// =============================================================================
// RE-EXPORTED TYPES FROM SHARED CONTRACT
// =============================================================================

export type { ProviderKey, PortMessage } from "../../shared/contract";

// Provider response type (unified from contract)
export type ProviderResponse = ContractProviderResponse;
export type ProviderResponseStatus = ProviderResponse["status"];

// =============================================================================
// RE-EXPORTED TYPES FROM PERSISTENCE LAYER
// =============================================================================

export type {
  SessionRecord,
  ThreadRecord,
  TurnRecord,
  UserTurnRecord,
  AiTurnRecord,
  ProviderResponseRecord,
} from "../../src/persistence/types";

// =============================================================================
// UI-SPECIFIC TYPES
// =============================================================================

/** The current high-level step of the UI, controlling what major controls are shown. */
export type AppStep =
  | "initial"
  | "awaitingSynthesis"
  | "synthesis"
  | "synthesisDone";

/** The UI's finite state for core user interactions. */
export type UiPhase = "idle" | "streaming" | "awaiting_action";

/** Defines the primary view mode of the application. */

/** Defines the properties for rendering a supported LLM provider in the UI. */
export interface LLMProvider {
  id: ProviderKey | string;
  name: string;
  hostnames: string[];
  color: string;
  logoBgClass: string;
  icon?: any;
  logoSrc?: string;
  emoji?: string;
}

// =============================================================================
// UNIFIED TURN TYPES (UI-ADAPTED FROM CONTRACT)
// =============================================================================

/** Represents a turn initiated by the user. */
export interface UserTurn {
  type: "user";
  id: string;
  text: string;
  createdAt: number;
  sessionId: string | null;
}

/**
 * Represents a turn from the AI, containing all provider responses.
 * This extends the contract AiTurn with UI-specific properties.
 */
export interface AiTurn extends Omit<ContractAiTurn, "type"> {
  type: "ai";
  // UI-only fields for efficient dependency tracking in React hooks
  synthesisVersion?: number;
  mappingVersion?: number;
  refinerVersion?: number;
  antagonistVersion?: number;
}

/** The union type for any message in the chat timeline. This is the main type for the `messages` state array. */
export type TurnMessage = UserTurn | AiTurn;

/** Type guard to check if a turn is a UserTurn. */
export const isUserTurn = (turn: TurnMessage): turn is UserTurn =>
  isUserTurnContract(turn as any);

/** Type guard to check if a turn is an AiTurn. */
export const isAiTurn = (turn: TurnMessage): turn is AiTurn =>
  isAiTurnContract(turn as any);

// =============================================================================
// HISTORY & SESSION LOADING
// =============================================================================

/** Represents a session summary object used for display in the history panel. */
export interface HistorySessionSummary {
  id: string;
  sessionId: string;
  startTime: number;
  lastActivity: number;
  title: string;
  firstMessage?: string;
  messageCount: number;
  messages?: TurnMessage[];
}

/** The shape of the API response when fetching the list of chat sessions. */
export interface HistoryApiResponse {
  sessions: HistorySessionSummary[];
}

/** The shape of the API response when fetching a full session to load into the UI. */
export interface FullSessionPayload {
  id: string;
  sessionId: string;
  title: string;
  createdAt: number;
  lastActivity: number;
  turns: TurnMessage[];
  providerContexts: Record<string, any>;
}

export type { GraphNode, GraphEdge, GraphTopology } from "../../shared/contract";

// =============================================================================
// LAUNCHPAD TYPES
// =============================================================================

/** Represents a saved draft in the Launchpad drawer. */
export interface LaunchpadDraftSection {
  id: string;
  title: string;
  text: string;
}

export interface LaunchpadDraft {
  id: string;
  title: string;
  text: string;
  source: "composer" | "analyst-audit" | "analyst-variant";
  createdAt: number;
  originalPrompt?: string;
  primarySectionId?: string;
  sections?: LaunchpadDraftSection[];
}




================================================
FILE: ui/types/jotai-immer.d.ts
================================================
declare module "jotai/immer" {
  import type { WritableAtom } from "jotai";
  /**
   * Minimal type declaration for atomWithImmer used in this project.
   * This returns an Atom whose value is of the provided type and which
   * supports Immer-style setters when used with Jotai.
   */
  export function atomWithImmer<Value = unknown>(
    initialValue: Value,
  ): WritableAtom<Value, any, any>;
  export function atomWithImmer<Value = unknown>(
    getter: () => Value,
  ): WritableAtom<Value, any, any>;
}



================================================
FILE: ui/types/think-shims.d.ts
================================================
// ui/types/think-shims.d.ts
declare module "../src/think/lib/think/computeThinkFlag.js" {
  export interface ComputeThinkFlagArgs {
    modeThinkButtonOn: boolean;
    input: string;
    inputFlags?: string[] | string | null;
  }
  export function computeThinkFlag(args: ComputeThinkFlagArgs): boolean;
}

declare module "../src/think/lib/think/constants.js" {
  export const AI_THINK_FLAG: string;
  export const O1_TOOL_NAME: string;
}



================================================
FILE: ui/utils/cn.ts
================================================
/**
 * A simple utility to merge class names.
 * This is a lightweight replacement for clsx + tailwind-merge since those dependencies are not installed.
 */
export function cn(...classes: (string | undefined | null | false | 0)[]) {
    return classes.filter(Boolean).join(" ");
}



================================================
FILE: ui/utils/copy-format-utils.ts
================================================
import { AiTurn, GraphTopology, ProviderResponse, UserTurn, TurnMessage, isUserTurn, isAiTurn } from "../types";
import { LLM_PROVIDERS_CONFIG } from "../constants";
import { getProviderName } from "./provider-helpers";

// ============================================================================
// MARKDOWN FORMATTING UTILITIES
// ============================================================================

export function formatSynthesisForMd(text: string, providerName: string): string {
    return `## Singularity Synthesis (via ${providerName})\n\n${text}\n\n`;
}

export function formatDecisionMapForMd(
    narrative: string,
    options: string | null,
    graphTopology: GraphTopology | null
): string {
    let md = "### The Decision Landscape\n\n";

    if (narrative) {
        // Convert narrative blockquotes or ensure they stand out
        // If narrative already uses blockquotes, keep them. If not, maybe quote the whole thing?
        // For now, raw narrative is usually fine if it's structured.
        md += `${narrative}\n\n`;
    }

    if (options) {
        md += `#### Options\n\n${options}\n\n`;
    }

    if (graphTopology) {
        md += `#### Graph Topology\n\n${formatGraphForMd(graphTopology)}\n\n`;
    }

    return md;
}

export function formatGraphForMd(topology: GraphTopology): string {
    if (!topology.edges || topology.edges.length === 0) return "*No graph relationships defined.*";

    const lines = topology.edges.map(edge => {
        const source = topology.nodes.find(n => n.id === edge.source)?.label || edge.source;
        const target = topology.nodes.find(n => n.id === edge.target)?.label || edge.target;
        return `- **${source}** --[${edge.type}]--> **${target}**`;
    });

    return lines.join('\n');
}

export function formatProviderResponseForMd(response: ProviderResponse, providerName: string): string {
    const text = response.text || "*Empty response*";
    return `**${providerName}**:\n\n${text}\n\n`;
}

export function formatTurnForMd(
    _turnid: string,
    userPrompt: string | null,
    synthesisText: string | null,
    synthesisProviderId: string | undefined,
    decisionMap: { narrative?: string; options?: string | null; topology?: GraphTopology | null } | null,
    batchResponses: Record<string, ProviderResponse>,
    includePrompt: boolean = true
): string {
    let md = "";

    // 1. User Prompt
    if (includePrompt && userPrompt) {
        md += `## User\n\n${userPrompt}\n\n`;
    }

    // 2. Synthesis
    if (synthesisText) {
        const providerName = synthesisProviderId
            ? getProviderName(synthesisProviderId)
            : "Unknown";
        md += formatSynthesisForMd(synthesisText, providerName);
    }

    // 3. Decision Map
    if (decisionMap) {
        md += formatDecisionMapForMd(
            decisionMap.narrative || "",
            decisionMap.options || null,
            decisionMap.topology || null
        );
    }

    // 4. Raw Responses (Collapsible)
    const providers = LLM_PROVIDERS_CONFIG;
    const responsesWithContent = providers
        .map(p => ({
            name: p.name,
            id: String(p.id),
            response: (batchResponses[String(p.id)] as any)?.isArray ? (batchResponses[String(p.id)] as any)[0] : batchResponses[String(p.id)] // Handle simple vs array if needed, but usually we just grab latest logic before calling this
        }))
        .filter(item => {
            // We expect the caller to pass fully resolved/latest responses, but let's be safe
            // If batchResponses is directly from AiTurn, it might be an array.
            // We'll rely on the caller to normalize `batchResponses` to { [pid]: ProviderResponse } (single latest)
            // OR we handle it here. Let's assume input is Record<string, ProviderResponse>.
            return !!item.response;
        });

    // Actually, let's make the input signature strictly Record<string, ProviderResponse>
    // where ProviderResponse is the *latest* one.

    if (responsesWithContent.length > 0) {
        md += `<details>\n<summary>Raw Council Outputs (${responsesWithContent.length} Models)</summary>\n\n`;

        responsesWithContent.forEach(({ name, response }) => {
            // Check if it's the actual response object
            if (response && typeof response === 'object' && 'text' in response) {
                md += formatProviderResponseForMd(response as ProviderResponse, name);
            }
        });

        md += `</details>\n\n`;
    }

    return md;
}

export function formatSessionForMarkdown(fullSession: { title: string, turns: TurnMessage[] }): string {
    let md = `# Session Title: ${fullSession.title}\n\n`;

    // We iterate through turns. We need to pair User + AI turn if possible, or just dump them.
    // The turn structure is linear: User -> AI -> User -> AI.
    // Sometimes User -> User (if error/retry) or AI -> AI (unlikely).

    // A simple robust way is just to iterate.
    // However, AiTurn contains batch/synth/map which are reactions to the *preceding* user turn.
    // formatTurnForMd is designed to take pieces.

    // Let's iterate and process each AiTurn, looking back for its UserTurn if needed, OR just render sequentially.
    // Actually formatTurnForMd seems to be designed to render a "Round".

    let lastUserTurn: UserTurn | null = null;

    fullSession.turns.forEach(turn => {
        if (isUserTurn(turn)) {
            lastUserTurn = turn;
            // We don't render immediately? Or do we?
            // If we render immediately, we might duplicate if AiTurn also renders it.
            // But formatTurnForMd takes `userPrompt`.
            // Let's assume we render "Rounds" keyed by AiTurn.
            // But what if there is no AiTurn (last turn is user)?
            // We should render it.
        } else if (isAiTurn(turn)) {
            // Found AI turn. Render the pair.
            const aiTurn = turn as AiTurn;

            // Resolve effective user prompt
            // If aiTurn.userTurnId matches lastUserTurn.id, use that.
            // Else find it? (But we just have the array here).
            let userPrompt = null;
            if (lastUserTurn && lastUserTurn.id === aiTurn.userTurnId) {
                userPrompt = lastUserTurn.text;
                lastUserTurn = null; // Mark as consumed
            } else {
                // Fallback: try to find in array? Or just ignore?
                // If we missed the user turn (e.g. it was consumed by previous AI turn?? No, 1:1 usually)
                // If the array is ordered, we likely saw it.
            }

            // Extract Synthesis
            let synthesisText = null;
            let synthesisProviderId = undefined;
            let decisionMap = null;

            // Synthesis
            const synthPid = (aiTurn.meta as any)?.synthesizer;
            const synthResponses = aiTurn.synthesisResponses || {};
            let targetSynthPid = synthPid;
            if (!targetSynthPid) {
                targetSynthPid = Object.keys(synthResponses).find(pid => {
                    const arr = synthResponses[pid];
                    return Array.isArray(arr) && arr.some(r => r.text);
                });
            }
            if (targetSynthPid && synthResponses[targetSynthPid]) {
                const resps = synthResponses[targetSynthPid];
                const latest = Array.isArray(resps) ? resps[resps.length - 1] : resps;
                if (latest && latest.text) {
                    synthesisText = latest.text;
                    synthesisProviderId = targetSynthPid;
                }
            }

            // Decision Map
            const mapPid = (aiTurn.meta as any)?.mapper;
            const mapResponses = aiTurn.mappingResponses || {};
            let targetMapPid = mapPid;
            if (!targetMapPid) {
                targetMapPid = Object.keys(mapResponses).find(pid => {
                    const arr = mapResponses[pid];
                    return Array.isArray(arr) && arr.some(r => r.text);
                });
            }
            if (targetMapPid && mapResponses[targetMapPid]) {
                const resps = mapResponses[targetMapPid];
                const latest = Array.isArray(resps) ? resps[resps.length - 1] : resps;
                if (latest && latest.text) {
                    const meta = (latest as any).meta || {};
                    decisionMap = {
                        narrative: latest.text,
                        options: meta.allAvailableOptions || null,
                        topology: meta.graphTopology || null
                    };
                }
            }

            // Batch Responses (flatten to single latest)
            const batchResponses: Record<string, ProviderResponse> = {};
            Object.entries(aiTurn.batchResponses || {}).forEach(([pid, val]) => {
                const arr = Array.isArray(val) ? val : [val];
                const latest = arr[arr.length - 1]; // ProviderResponse
                if (latest) {
                    batchResponses[pid] = latest;
                }
            });


            md += formatTurnForMd(
                aiTurn.id,
                userPrompt,
                synthesisText,
                synthesisProviderId,
                decisionMap,
                batchResponses,
                !!userPrompt // include prompt if we found it
            );
            md += "\n---\n\n";
        }
    });

    // If there's a dangling user turn at the end (no AI response yet)
    if (lastUserTurn) {
        md += `## User\n\n${(lastUserTurn as UserTurn).text}\n\n`;
    }

    return md;
}

// ============================================================================
// JSON EXPORT UTILITIES (SAF - Singularity Archive Format)
// ============================================================================

export interface SingularityExport {
    version: "1.0";
    exportedAt: number;
    session: {
        id: string;
        title: string;
        sessionId: string;
        turns: SanitizedTurn[];
    };
}

type SanitizedTurn = SanitizedUserTurn | SanitizedAiTurn;

interface SanitizedUserTurn {
    role: "user";
    timestamp: number;
    content: string;
}

interface SanitizedAiTurn {
    role: "council";
    timestamp: number;
    synthesis?: {
        providerId: string;
        text: string;
        modelName?: string;
    };
    decisionMap?: {
        providerId: string;
        narrative: string;
        options: string | null;
        graphTopology: GraphTopology | null;
    };
    councilMemberOutputs: {
        providerId: string;
        text: string;
        modelName?: string;
    }[];
    // Internal/Sensitive data (Only included in 'full' mode)
    providerContexts?: Record<string, any>;
    batchResponses?: Record<string, ProviderResponse[]>; // Full history if needed? The spec says "councilMemberOutputs" which is flat.
    // Actually, for "Full Backup", we should probably include the RAW turn object or a richer structure?
    // But the user asked for "providerContexts" specifically to be resumable.
    // And "isOptimistic", etc.
    meta?: any;
}

/**
 * Sanitizes a full session payload for export.
 * STRICTLY WHITELISTS fields to prevent leaking of providerContexts, cursors, or tokens.
 * 
 * @param fullSession The session data with normalized turns
 * @param mode 'safe' (default) removes sensitive data; 'full' preserves it for backup.
 */
export function sanitizeSessionForExport(
    fullSession: { id: string, title: string, sessionId: string, turns: TurnMessage[] },
    mode: 'safe' | 'full' = 'safe'
): SingularityExport {
    const sanitizedTurns: SanitizedTurn[] = fullSession.turns.map(turn => {
        if (isUserTurn(turn)) {
            return {
                role: "user",
                timestamp: turn.createdAt,
                content: turn.text
            } as SanitizedUserTurn;
        }

        if (isAiTurn(turn)) {
            // 1. Extract Synthesis
            let synthesis: SanitizedAiTurn['synthesis'] | undefined;
            const synthPid = (turn.meta as any)?.synthesizer;
            const synthResponses = turn.synthesisResponses || {};

            let targetSynthPid = synthPid;
            if (!targetSynthPid) {
                targetSynthPid = Object.keys(synthResponses).find(pid => {
                    const arr = synthResponses[pid];
                    return Array.isArray(arr) && arr.some(r => r.text);
                });
            }

            if (targetSynthPid && synthResponses[targetSynthPid]) {
                const resps = synthResponses[targetSynthPid];
                const latest = Array.isArray(resps) ? resps[resps.length - 1] : resps;
                if (latest && latest.text) {
                    synthesis = {
                        providerId: targetSynthPid,
                        text: latest.text,
                    };
                }
            }

            // 2. Extract Decision Map (Mapping)
            let decisionMap: SanitizedAiTurn['decisionMap'] | undefined;
            const mapPid = (turn.meta as any)?.mapper;
            const mapResponses = turn.mappingResponses || {};

            let targetMapPid = mapPid;
            if (!targetMapPid) {
                targetMapPid = Object.keys(mapResponses).find(pid => {
                    const arr = mapResponses[pid];
                    return Array.isArray(arr) && arr.some(r => r.text);
                });
            }

            if (targetMapPid && mapResponses[targetMapPid]) {
                const resps = mapResponses[targetMapPid];
                const latest = Array.isArray(resps) ? resps[resps.length - 1] : resps;
                if (latest && latest.text) {
                    const meta = (latest as any).meta || {};
                    decisionMap = {
                        providerId: targetMapPid,
                        narrative: latest.text,
                        options: meta.allAvailableOptions || null,
                        graphTopology: meta.graphTopology || null
                    };
                }
            }

            // 3. Batch Outputs
            const councilMemberOutputs: SanitizedAiTurn['councilMemberOutputs'] = [];
            const batchResponses = turn.batchResponses || {};
            Object.entries(batchResponses).forEach(([pid, val]) => {
                const arr = Array.isArray(val) ? val : [val];
                const latest = arr[arr.length - 1]; // ProviderResponse
                if (latest && latest.text) {
                    councilMemberOutputs.push({
                        providerId: pid,
                        text: latest.text
                    });
                }
            });

            const base: SanitizedAiTurn = {
                role: "council",
                timestamp: (turn as any).createdAt || Date.now(),
                synthesis,
                decisionMap,
                councilMemberOutputs
            };

            if (mode === 'full') {
                // In full mode, we attach extra metadata for valid resumption
                // We might want to pass through the original 'turn' mostly intact, 
                // but let's stick to the schema and add fields.
                base.meta = turn.meta;
                // Provider contexts are usually stored at the session level, not turn level?
                // Wait, `FullSessionPayload` has `providerContexts`.
                // The `AiTurn` has `providerContexts` in persistence but maybe not in UI type?
                // Contract AiTurn doesn't have it.
                // Persistence AiTurnRecord HAS it.

                // If the UI turn object has it (it might satisfy the index signature or be missing types), we include it.
                if ((turn as any).providerContexts) {
                    base.providerContexts = (turn as any).providerContexts;
                }
            }

            return base;
        }

        // Fallback for unknown turn types
        return {
            role: "user",
            timestamp: Date.now(),
            content: "Unknown turn type"
        } as SanitizedUserTurn;
    });

    const exportObj: SingularityExport = {
        version: "1.0",
        exportedAt: Date.now(),
        session: {
            id: fullSession.id,
            title: fullSession.title,
            sessionId: fullSession.sessionId,
            turns: sanitizedTurns
        }
    };

    // If Full Backup, include top-level provider contexts
    if (mode === 'full' && (fullSession as any).providerContexts) {
        // Clone and strip 'text' from contexts to avoid duplication with turn data
        // We only need the metadata (cursors, tokens, ids) for continuation.
        // The actual text content is already preserved in the turns.
        const contexts = (fullSession as any).providerContexts;
        const strippedContexts: Record<string, any> = {};

        Object.entries(contexts).forEach(([pid, ctx]: [string, any]) => {
            // Keep everything EXCEPT 'text'
            const { text, ...rest } = ctx;

            // Deep clone meta to allow deletion
            let meta = rest.meta ? { ...rest.meta } : {};

            // Strip redundant extracted data
            if (meta.allAvailableOptions) delete meta.allAvailableOptions;
            if (meta.graphTopology) delete meta.graphTopology;

            strippedContexts[pid] = {
                ...rest,
                meta
            };
        });

        (exportObj.session as any).providerContexts = strippedContexts;
    }

    return exportObj;
}



================================================
FILE: ui/utils/graphAdapter.ts
================================================
import { GraphTopology, GraphNode, GraphEdge } from '../../shared/parsing-utils';
import { ClaimNode, ClaimEdge } from '../components/DecisionMapGraph';

/**
 * Converts mapper GraphTopology output to DecisionMapGraph format
 */
export function adaptGraphTopology(topology: GraphTopology | null): {
    nodes: ClaimNode[];
    edges: ClaimEdge[];
} {
    if (!topology || !topology.nodes.length) {
        return { nodes: [], edges: [] };
    }

    // Convert nodes
    const nodes: ClaimNode[] = topology.nodes.map((node: GraphNode) => ({
        id: node.id,
        label: node.label,
        theme: node.theme,
        supporters: node.supporters.map(s => String(s)),
        support_count: node.support_count,
        // Preserve consensus strength for visual sizing
        consensusStrength: node.support_count / Math.max(...topology.nodes.map((n: GraphNode) => n.support_count), 1),
    }));

    // Convert edges - preserve all 3 semantic types
    const edges: ClaimEdge[] = topology.edges.map((edge: GraphEdge) => ({
        source: edge.source,
        target: edge.target,
        reason: edge.reason,
        // Preserve semantic edge types for force-directed layout
        type: (['conflicts', 'complements', 'prerequisite'].includes(edge.type) ? edge.type : 'complements') as ClaimEdge['type'],
    }));

    return { nodes, edges };
}



================================================
FILE: ui/utils/math-renderer.ts
================================================
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import rehypeStringify from 'rehype-stringify';

// Cache the processor to avoid recreating it
let processor: any = null;

/**
 * Lazy-loads KaTeX and related plugins.
 * This function is only called when math is detected in the content.
 */
export async function loadMathPlugins() {
    // Parallel load all necessary modules
    const [
        { default: remarkMath },
        { default: rehypeKatex },
         // Ensure katex is loaded for side effects if needed, though rehype-katex usually handles it
    ] = await Promise.all([
        import('remark-math'),
        import('rehype-katex'),
        import('katex')
    ]);

    return {
        remarkMath,
        rehypeKatex
    };
}

/**
 * Lazy-loads KaTeX and renders math in markdown content.
 * This function is only called when math is detected in the content.
 */
export async function renderMathInMarkdown(content: string): Promise<string> {
    // 1. Initialize processor if needed
    if (!processor) {
        const { remarkMath, rehypeKatex } = await loadMathPlugins();

        processor = unified()
            .use(remarkParse)
            .use(remarkMath)
            .use(remarkRehype)
            .use(rehypeKatex)
            .use(rehypeStringify);
    }

    // 2. Process the content
    try {
        const result = await processor.process(content);
        return String(result);
    } catch (error) {
        console.error('Failed to render math:', error);
        return content; // Fallback to original content
    }
}

/**
 * Checks if the content contains math syntax ($...$ or $$...$$)
 */
export function containsMath(content: string): boolean {
    // Simple heuristic: check for $ delimiters
    // This is a fast check to decide if we should load the heavy math machinery
    return /\$[^$]+\$/.test(content) || /\$\$[^$]+\$\$/.test(content);
}



================================================
FILE: ui/utils/provider-helpers.ts
================================================
import {
  INITIAL_PROVIDERS,
  getProviderById as registryGetById,
} from "../providers/providerRegistry";
import { PROVIDER_COLORS } from "../constants";
import type { ProviderConfig } from "../providers/providerRegistry";

/**
 * Get the full configuration object for a provider.
 */
export function getProviderConfig(
  providerId: string,
): ProviderConfig | undefined {
  return (
    registryGetById(providerId) ||
    INITIAL_PROVIDERS.find((p) => p.id === providerId)
  );
}

/**
 * Get the display name for a provider, with a fallback to the ID.
 */
export function getProviderName(providerId: string): string {
  const config = getProviderConfig(providerId);
  return config?.name || providerId || "Unknown Model";
}

/**
 * Get the color for a provider, with a safe fallback to default/violet.
 */
export function getProviderColor(providerId: string): string {
  // Check specific color map first
  if (PROVIDER_COLORS[providerId]) {
    return PROVIDER_COLORS[providerId];
  }
  
  // Check config object
  const config = getProviderConfig(providerId);
  if (config?.color) {
    return config.color;
  }

  // Fallback
  return PROVIDER_COLORS['default'] || '#8b5cf6';
}

/**
 * Get the logo source for a provider, if available.
 */
export function getProviderLogo(providerId: string): string | undefined {
  return getProviderConfig(providerId)?.logoSrc;
}

/**
 * Helper to check if a provider requires auth/login
 * (Wraps your auth logic if you have a centralized status map, 
 * otherwise just checks if the provider exists in the config)
 */
export function isProviderValid(providerId: string): boolean {
  return !!getProviderConfig(providerId);
}



================================================
FILE: ui/utils/provider-id-mapper.ts
================================================
/**
 * Normalize backend provider IDs to canonical frontend IDs
 * E.g., "gemini-exp-1206" -> "gemini-exp"
 * 
 * This handles cases where the backend sends model-specific variant IDs
 * but the frontend only recognizes canonical provider IDs.
 */
export function normalizeProviderId(backendId: string): string {
    if (!backendId || typeof backendId !== 'string') return backendId;

    // Gemini variants - check exact matches first
    if (backendId === 'gemini-exp' || backendId.startsWith('gemini-exp-')) {
        return 'gemini-exp';
    }
    if (backendId === 'gemini-pro' || backendId.startsWith('gemini-pro-')) {
        return 'gemini-pro';
    }
    if (backendId === 'gemini' || backendId.startsWith('gemini-flash')) {
        return 'gemini';
    }

    // ChatGPT variants
    if (backendId.startsWith('chatgpt-')) return 'chatgpt';

    // Claude variants
    if (backendId.startsWith('claude-')) return 'claude';

    // Qwen variants
    if (backendId.startsWith('qwen-')) return 'qwen';

    // Default: return as-is
    return backendId;
}



================================================
FILE: ui/utils/refiner-helpers.ts
================================================
/**
 * Refiner Helper Utilities - Updated for signal-based RefinerOutput
 */

import type { RefinerOutput, Signal, SignalPriority, NextStepAction } from "../../shared/parsing-utils";
import { getSignalCounts, hasCriticalSignals } from "./signalUtils";

// =============================================================================
// TYPE GUARDS & ACCESSORS
// =============================================================================

/**
 * Check if refiner has any signals requiring attention
 */
export function hasVerificationNeeded(refiner: RefinerOutput | null): boolean {
    if (!refiner?.signals) return false;
    return refiner.signals.some(s => s.priority === 'blocker' || s.type === 'divergence');
}

/**
 * Get signals that need verification (blockers and risks)
 */
export function getVerificationItems(refiner: RefinerOutput | null): Signal[] {
    if (!refiner?.signals) return [];
    return refiner.signals.filter(s => s.priority === 'blocker' || s.priority === 'risk');
}

/**
 * Check if any signal is a blocker
 */
export function hasBlockerSignal(refiner: RefinerOutput | null): boolean {
    return refiner?.signals?.some(s => s.priority === 'blocker') ?? false;
}

/**
 * Get signals by type
 */
export function getSignalsByType(refiner: RefinerOutput | null, type: Signal['type']): Signal[] {
    if (!refiner?.signals) return [];
    return refiner.signals.filter(s => s.type === type);
}

/**
 * Get gap-type signals (including blindspots)
 */
export function getGapSignals(refiner: RefinerOutput | null): Signal[] {
    if (!refiner?.signals) return [];
    return refiner.signals.filter(s => s.type === 'gap' || s.type === 'blindspot');
}

/**
 * Get overclaim signals
 */
export function getOverclaimSignals(refiner: RefinerOutput | null): Signal[] {
    if (!refiner?.signals) return [];
    return refiner.signals.filter(s => s.type === 'overclaim');
}

/**
 * Get divergence signals (model disagreements)
 */
export function getDivergenceSignals(refiner: RefinerOutput | null): Signal[] {
    if (!refiner?.signals) return [];
    return refiner.signals.filter(s => s.type === 'divergence');
}

// =============================================================================
// UI STATE DETERMINATION
// =============================================================================

export type UIState = 'simple' | 'intermediate' | 'workbench';

/**
 * Determine UI state based on refiner output
 */
export function determineUIState(refiner: RefinerOutput | null): UIState {
    if (!refiner) return 'intermediate';

    const counts = getSignalCounts(refiner.signals);

    // Workbench: blockers or multiple risks
    if (counts.blockers > 0) return 'workbench';
    if (counts.risks > 2) return 'workbench';
    if (refiner.reframe) return 'workbench';

    if (counts.risks === 0 && counts.enhancements <= 1 &&
        refiner.leap?.action === 'proceed') {
        return 'simple';
    }

    return 'intermediate';
}

/**
 * Determine if trust icon should pulse
 */
export function shouldPulseTrustIcon(refiner: RefinerOutput | null): boolean {
    return hasCriticalSignals(refiner?.signals);
}

/**
 * Determine if side panel should auto-open
 */
export function shouldAutoOpenSidePanel(refiner: RefinerOutput | null): boolean {
    if (!refiner) return false;
    return hasBlockerSignal(refiner);
}

// =============================================================================
// DISPLAY FORMATTERS - Updated for new structure
// =============================================================================

/**
 * Format signal count summary
 */
export function formatSignalSummary(refiner: RefinerOutput | null): string {
    if (!refiner?.signals?.length) return 'No signals';

    const counts = getSignalCounts(refiner.signals);
    const parts: string[] = [];

    if (counts.blockers > 0) parts.push(`${counts.blockers} blocker${counts.blockers > 1 ? 's' : ''}`);
    if (counts.risks > 0) parts.push(`${counts.risks} risk${counts.risks > 1 ? 's' : ''}`);
    if (counts.enhancements > 0) parts.push(`${counts.enhancements} enhancement${counts.enhancements > 1 ? 's' : ''}`);

    return parts.join(', ') || 'No signals';
}

/**
 * Get priority-based color class
 */
export function getPriorityColor(priority: SignalPriority | undefined): string {
    switch (priority) {
        case 'blocker': return 'text-intent-danger';
        case 'risk': return 'text-intent-warning';
        case 'enhancement': return 'text-brand-400';
        default: return 'text-text-muted';
    }
}

// =============================================================================
// NEXT STEP VISUAL STYLES
// =============================================================================

interface NextStepStyles {
    container: string;
    icon: string;
    label: string;
}

export function getNextStepStyles(action: NextStepAction | null | undefined): NextStepStyles {
    switch (action) {
        case 'proceed':
            return {
                container: 'bg-emerald-500/10 border-emerald-500/60',
                icon: 'text-emerald-400',
                label: 'text-emerald-300',
            };
        case 'verify':
            return {
                container: 'bg-intent-warning/15 border-intent-warning/40',
                icon: 'text-intent-warning',
                label: 'text-intent-warning',
            };
        case 'reframe':
            return {
                container: 'bg-sky-500/10 border-sky-500/50',
                icon: 'text-sky-400',
                label: 'text-sky-300',
            };
        case 'research':
            return {
                container: 'bg-violet-500/15 border-violet-500/40',
                icon: 'text-violet-400',
                label: 'text-violet-300',
            };
        default:
            return {
                container: 'bg-surface-highlight/40 border-border-subtle',
                icon: 'text-brand-400',
                label: 'text-text-primary',
            };
    }
}


/**
 * Shorten insight text for tooltips: first line, first sentence, max 8 words.
 */
export function shortenInsight(text: string | null | undefined): string {
    if (!text) return '';

    // 1. Get first line
    const firstLine = text.split('\n')[0].trim();

    // 2. Get first sentence (naive split on . followed by space or end)
    const firstSentence = firstLine.split(/\.\s/)[0].trim();

    // 3. Limit to 8 words
    const words = firstSentence.split(/\s+/);
    if (words.length <= 8) {
        // If we didn't truncate words but the original was longer, add ellipsis
        const result = firstSentence.replace(/\.$/, ''); // Remove trailing dot if it will be added back later or if it's the end
        return result === firstLine ? result : result + '...';
    }

    return words.slice(0, 8).join(' ') + '...';
}



================================================
FILE: ui/utils/safeLazy.ts
================================================
import React from 'react';

/**
 * A wrapper around React.lazy that detects if a chunk fails to load
 * (usually due to a new deployment/build) and reloads the page automatically.
 */
export function safeLazy<T extends React.ComponentType<any>>(
    importFn: () => Promise<{ default: T }>
) {
    return React.lazy(async () => {
        try {
            return await importFn();
        } catch (error) {
            console.warn("[safeLazy] Lazy load failed, reloading to get new version...", error);
            // Force a reload of the extension frame to fetch the new index.html and chunks
            window.location.reload();
            // Return a dummy component to satisfy Typescript while the page reloads
            return { default: (() => null) as unknown as T };
        }
    });
}



================================================
FILE: ui/utils/signalUtils.ts
================================================
/**
 * Signal utilities for categorizing and working with Refiner signals.
 */

import { Signal, SignalPriority } from '../../shared/parsing-utils';

export interface CategorizedSignals {
    blockerSignals: Signal[];
    riskSignals: Signal[];
    enhancementSignals: Signal[];
}

/**
 * Categorize signals by priority level.
 */
export function categorizeSignals(signals: Signal[] | undefined): CategorizedSignals {
    if (!signals || !Array.isArray(signals)) {
        return {
            blockerSignals: [],
            riskSignals: [],
            enhancementSignals: []
        };
    }

    return {
        blockerSignals: signals.filter(s => s.priority === 'blocker'),
        riskSignals: signals.filter(s => s.priority === 'risk'),
        enhancementSignals: signals.filter(s => s.priority === 'enhancement')
    };
}

/**
 * Get the icon for a signal type.
 */
export function getSignalIcon(type: Signal['type']): string {
    switch (type) {
        case 'divergence': return '⚠️';
        case 'overclaim': return '⚠️';
        case 'gap': return '💡';
        case 'blindspot': return '🕳️';
        default: return '📌';
    }
}

/**
 * Get the label for a signal type.
 */
export function getSignalLabel(type: Signal['type']): string {
    switch (type) {
        case 'divergence': return 'AI models disagreed';
        case 'overclaim': return 'May be overstated';
        case 'gap': return 'Context dropped';
        case 'blindspot': return 'Not addressed';
        default: return 'Signal';
    }
}

/**
 * Get CSS classes for signal priority styling.
 */
export function getSignalPriorityClasses(priority: SignalPriority): {
    background: string;
    border: string;
    text: string;
} {
    switch (priority) {
        case 'blocker':
            return {
                background: 'bg-intent-danger/10',
                border: 'border-intent-danger/40',
                text: 'text-intent-danger'
            };
        case 'risk':
            return {
                background: 'bg-intent-warning/10',
                border: 'border-intent-warning/40',
                text: 'text-intent-warning'
            };
        case 'enhancement':
        default:
            return {
                background: 'bg-brand-500/10',
                border: 'border-brand-500/30',
                text: 'text-brand-400'
            };
    }
}

/**
 * Check if there are any critical signals (blockers or risks).
 */
export function hasCriticalSignals(signals: Signal[] | undefined): boolean {
    if (!signals) return false;
    return signals.some(s => s.priority === 'blocker' || s.priority === 'risk');
}

/**
 * Get a summary count of signals by priority.
 */
export function getSignalCounts(signals: Signal[] | undefined): { blockers: number; risks: number; enhancements: number } {
    const { blockerSignals, riskSignals, enhancementSignals } = categorizeSignals(signals);
    return {
        blockers: blockerSignals.length,
        risks: riskSignals.length,
        enhancements: enhancementSignals.length
    };
}

export function getTrustBadge(signals: Signal[] | undefined): { count: number; type: 'blocker' | 'risk' } | null {
	if (!signals || !Array.isArray(signals) || signals.length === 0) {
		return null;
	}

	const { blockerSignals, riskSignals } = categorizeSignals(signals);

	if (blockerSignals.length > 0) {
		return { count: blockerSignals.length, type: 'blocker' };
	}

	if (riskSignals.length > 0) {
		return { count: riskSignals.length, type: 'risk' };
	}

	return null;
}



================================================
FILE: ui/utils/smart-defaults.ts
================================================

// Priority list for Synthesis (Single Speaker)
// Claude as strongest, gemini 3.0 exp next in line, then Qwen, Then gemini 2.5 pro, then chatgpt, then gemini default
export const SYNTHESIS_PRIORITY = [
    'qwen',
    'gemini',
    'claude',
    'gemini-pro',
    'chatgpt',
    'gemini-exp'
];

// Priority list for Mapping (Decision Map)
// Best for decision maps: gemini default, qwen, chatgpt, gemini 3.0, claude, gemini 2.5 pro
export const MAPPING_PRIORITY = [
    'gemini',
    'qwen',
    'gemini-pro',
    'gemini-exp',
    'claude',
    'chatgpt'
];

// Priority list for Antagonist
// Claude as strongest, gemini 3.0 exp next in line, then Qwen, Then gemini 2.5 pro, then chatgpt, then gemini default
export const ANTAGONIST_PRIORITY = [
    'gemini',
    'qwen',
    'claude',
    'gemini-pro',
    'gemini-exp',
    'chatgpt'
];

// Priority list for Refiner
// Best for refiner: gemini default, qwen, chatgpt, gemini 3.0, claude, gemini 2.5 pro
export const REFINDER_PRIORITY = [
    'claude',
    'qwen',
    'gemini',
    'gemini-pro',
    'gemini-exp',
    'chatgpt'
];

/**
 * Selects the best available provider from a priority list based on authentication status.
 * @param priorityList Array of provider IDs in descending order of preference.
 * @param authStatus Record of provider IDs to boolean auth status.
 * @returns The ID of the best available provider, or null if none are available.
 */
export function selectSmartDefault(
    priorityList: string[],
    authStatus: Record<string, boolean>
): string | null {
    for (const providerId of priorityList) {
        if (authStatus[providerId] === true) {
            return providerId;
        }
    }
    return null; // No providers available
}



================================================
FILE: ui/utils/streamingBuffer.ts
================================================
// src/ui/utils/streamingBuffer.ts
type ResponseType = "batch" | "synthesis" | "mapping" | "refiner" | "antagonist";

interface BatchUpdate {
  providerId: string;
  text: string;
  status: string;
  responseType: ResponseType;
  createdAt: number;
}

export class StreamingBuffer {
  // Keyed by `${responseType}:${providerId}` to avoid collisions across types
  private pendingDeltas: Map<
    string,
    {
      deltas: { text: string; ts: number }[];
      status: string;
      responseType: ResponseType;
    }
  > = new Map();

  private onFlushCallback: (updates: BatchUpdate[]) => void;

  constructor(onFlush: (updates: BatchUpdate[]) => void) {
    this.onFlushCallback = onFlush;
  }

  addDelta(
    providerId: string,
    delta: string,
    status: string,
    responseType: ResponseType,
  ) {
    const key = `${responseType}:${providerId}`;
    if (!this.pendingDeltas.has(key)) {
      this.pendingDeltas.set(key, {
        deltas: [],
        status,
        responseType,
      });
    }

    const entry = this.pendingDeltas.get(key)!;
    entry.deltas.push({ text: delta, ts: Date.now() });
    entry.status = status;
    entry.responseType = responseType;

    // âœ… IMMEDIATE FLUSH: Zero throttling.
    // Rely on React 18 automatic batching and tab-based isolation for performance.
    this.flushAll();
  }

  private flushAll() {
    const updates: BatchUpdate[] = [];

    this.pendingDeltas.forEach((entry, compositeKey) => {
      const idx = compositeKey.indexOf(":");
      const providerId = idx >= 0 ? compositeKey.slice(idx + 1) : compositeKey;
      const concatenatedText = entry.deltas.map((d) => d.text).join("");
      const lastTs = entry.deltas.length
        ? entry.deltas[entry.deltas.length - 1].ts
        : Date.now();
      updates.push({
        providerId,
        text: concatenatedText,
        status: entry.status,
        responseType: entry.responseType,
        createdAt: lastTs,
      });
    });

    this.pendingDeltas.clear();

    if (updates.length > 0) {
      updates.sort((a, b) => a.createdAt - b.createdAt);
      this.onFlushCallback(updates);
    }
  }

  flushImmediate() {
    this.flushAll();
  }

  clear() {
    this.pendingDeltas.clear();
  }
}



================================================
FILE: ui/utils/turn-helpers.ts
================================================
// ui/utils/turn-helpers.ts - ALIGNED VERSION
import type { AiTurn, ProviderResponse, UserTurn, ProviderKey } from "../types";
import { PRIMARY_STREAMING_PROVIDER_IDS } from "../constants";

/**
 * Normalize a response value to ProviderResponse[]
 * Backend can send either single object or array
 */
export function normalizeResponseArray(value: any): ProviderResponse[] {
  if (!value) return [];
  if (Array.isArray(value)) return value as ProviderResponse[];
  return [value as ProviderResponse];
}

/**
 * Safely get the latest response from a provider's response array
 */
export function getLatestResponse(
  responses: ProviderResponse[] | ProviderResponse | undefined,
): ProviderResponse | undefined {
  if (!responses) return undefined;
  if (Array.isArray(responses)) return responses[responses.length - 1];
  return responses as ProviderResponse;
}

export function createOptimisticAiTurn(
  aiTurnId: string,
  userTurn: UserTurn,
  activeProviders: ProviderKey[],
  shouldUseMapping: boolean,
  shouldUseSynthesis: boolean,
  shouldUseRefiner: boolean,
  mappingProvider?: string,
  synthesisProvider?: string,
  refinerProvider?: string,
  antagonistProvider?: string,
  timestamp?: number,
  explicitUserTurnId?: string,
  requestedFeatures?: { synthesis: boolean; mapping: boolean; refiner: boolean; antagonist: boolean },
): AiTurn {
  const now = timestamp || Date.now();

  // Initialize batch responses for all active providers as arrays
  const pendingBatch: Record<string, ProviderResponse[]> = {};
  activeProviders.forEach((pid) => {
    pendingBatch[pid] = [
      {
        providerId: pid,
        text: "",
        status: PRIMARY_STREAMING_PROVIDER_IDS.includes(String(pid))
          ? "streaming"
          : "pending",
        createdAt: now,
        updatedAt: now,
      },
    ];
  });

  // Initialize synthesis responses if enabled
  const synthesisResponses: Record<string, ProviderResponse[]> = {};
  if (shouldUseSynthesis && synthesisProvider) {
    synthesisResponses[synthesisProvider] = [
      {
        providerId: synthesisProvider as ProviderKey,
        text: "",
        status: PRIMARY_STREAMING_PROVIDER_IDS.includes(
          String(synthesisProvider),
        )
          ? "streaming"
          : "pending",
        createdAt: now,
        updatedAt: now,
      },
    ];
  }

  // Initialize mapping responses if enabled
  const mappingResponses: Record<string, ProviderResponse[]> = {};
  if (shouldUseMapping && mappingProvider) {
    mappingResponses[mappingProvider] = [
      {
        providerId: mappingProvider as ProviderKey,
        text: "",
        status: PRIMARY_STREAMING_PROVIDER_IDS.includes(String(mappingProvider))
          ? "streaming"
          : "pending",
        createdAt: now,
        updatedAt: now,
      },
    ];
  }
  // --- NEW: Refiner setup ---
  const refinerResponses: Record<string, ProviderResponse[]> = {};
  if (shouldUseRefiner && refinerProvider) {
    refinerResponses[refinerProvider] = [{
      providerId: refinerProvider as ProviderKey,
      text: "",
      status: PRIMARY_STREAMING_PROVIDER_IDS.includes(String(refinerProvider)) ? "streaming" : "pending",
      createdAt: now,
      updatedAt: now,
    }];
  }

  // --- NEW: Antagonist setup ---
  const antagonistResponses: Record<string, ProviderResponse[]> = {};
  if (requestedFeatures?.antagonist && antagonistProvider) {
    antagonistResponses[antagonistProvider] = [{
      providerId: antagonistProvider as ProviderKey,
      text: "",
      status: PRIMARY_STREAMING_PROVIDER_IDS.includes(String(antagonistProvider)) ? "streaming" : "pending",
      createdAt: now,
      updatedAt: now,
    }];
  }

  const effectiveUserTurnId = explicitUserTurnId || userTurn.id;

  return {
    type: "ai",
    id: aiTurnId,
    createdAt: now,
    sessionId: userTurn.sessionId,
    threadId: "default-thread",
    userTurnId: effectiveUserTurnId,
    batchResponses: pendingBatch,
    synthesisResponses,
    mappingResponses,
    refinerResponses,
    antagonistResponses,
    meta: {
      isOptimistic: true,
      expectedProviders: activeProviders, // âœ… STORE expected providers
      synthesizer: synthesisProvider,
      mapper: mappingProvider,
      refiner: refinerProvider,
      antagonist: antagonistProvider,
      ...(requestedFeatures ? { requestedFeatures } : {}),
      ...(synthesisProvider ? { synthesizer: synthesisProvider } : {}),
      ...(mappingProvider ? { mapper: mappingProvider } : {}),
      ...(refinerProvider ? { refiner: refinerProvider } : {}),
      ...(antagonistProvider ? { antagonist: antagonistProvider } : {}),
    },
  };
}


export function applyStreamingUpdates(
  aiTurn: AiTurn,
  updates: Array<{
    providerId: string;
    text: string;
    status: string;
    responseType: "batch" | "synthesis" | "mapping" | "refiner" | "antagonist";
  }>,
) {
  updates.forEach(({ providerId, text: delta, status, responseType }) => {
    if (responseType === "batch") {
      // Update batch responses (array per provider)
      if (!aiTurn.batchResponses) aiTurn.batchResponses = {};
      const arr = normalizeResponseArray(
        aiTurn.batchResponses[providerId],
      );

      // Check if we should start a new response (branching/retry)
      // If the latest response is terminal (completed/error) and the new update is active (streaming/pending),
      // we must preserve the history and start a new entry.
      const latest = arr.length > 0 ? arr[arr.length - 1] : undefined;
      const isLatestTerminal = latest && (latest.status === "completed" || latest.status === "error");
      const isNewStream = status === "streaming" || status === "pending";

      if (latest && !isLatestTerminal) {
        // Update existing active response
        arr[arr.length - 1] = {
          ...latest,
          text: (latest.text || "") + delta,
          status: status as any,
          updatedAt: Date.now(),
        };
      } else if (isLatestTerminal && !isNewStream) {
        // Edge case: late arrival of terminal update for already terminal response?
        // Or maybe just updating metadata. For safety, we update the latest.
        arr[arr.length - 1] = {
          ...latest,
          text: (latest.text || "") + delta,
          status: status as any,
          updatedAt: Date.now(),
        };
      } else {
        // Create new response (either first one, or branching from terminal)
        arr.push({
          providerId: providerId as ProviderKey,
          text: delta,
          status: status as any,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        });
      }

      aiTurn.batchResponses[providerId] = arr;
    } else if (responseType === "synthesis") {
      // Update synthesis responses (array per provider)
      if (!aiTurn.synthesisResponses) aiTurn.synthesisResponses = {};
      const arr = normalizeResponseArray(aiTurn.synthesisResponses[providerId]);

      const latest = arr.length > 0 ? arr[arr.length - 1] : undefined;
      const isLatestTerminal = latest && (latest.status === "completed" || latest.status === "error");


      if (latest && !isLatestTerminal) {
        arr[arr.length - 1] = {
          ...latest,
          text: (latest.text || "") + delta,
          status: status as any,
          updatedAt: Date.now(),
        };
      } else {
        arr.push({
          providerId: providerId as ProviderKey,
          text: delta,
          status: status as any,
          createdAt: Date.now(),
        });
      }

      aiTurn.synthesisResponses[providerId] = arr;
      aiTurn.synthesisVersion = (aiTurn.synthesisVersion ?? 0) + 1;
    } else if (responseType === "mapping") {
      // Update mapping responses (array per provider)
      if (!aiTurn.mappingResponses) aiTurn.mappingResponses = {};
      const arr = normalizeResponseArray(aiTurn.mappingResponses[providerId]);

      const latest = arr.length > 0 ? arr[arr.length - 1] : undefined;
      const isLatestTerminal = latest && (latest.status === "completed" || latest.status === "error");


      if (latest && !isLatestTerminal) {
        arr[arr.length - 1] = {
          ...latest,
          text: (latest.text || "") + delta,
          status: status as any,
          updatedAt: Date.now(),
        };
      } else {
        arr.push({
          providerId: providerId as ProviderKey,
          text: delta,
          status: status as any,
          createdAt: Date.now(),
        });
      }

      aiTurn.mappingResponses[providerId] = arr;
      aiTurn.mappingVersion = (aiTurn.mappingVersion ?? 0) + 1;
    }
    else if (responseType === "refiner") {
      // Update refiner responses (array per provider)
      if (!aiTurn.refinerResponses) aiTurn.refinerResponses = {};
      const arr = normalizeResponseArray(aiTurn.refinerResponses[providerId]);

      const latest = arr.length > 0 ? arr[arr.length - 1] : undefined;
      const isLatestTerminal = latest && (latest.status === "completed" || latest.status === "error");

      if (latest && !isLatestTerminal) {
        arr[arr.length - 1] = {
          ...latest,
          text: (latest.text || "") + delta,
          status: status as any,
          updatedAt: Date.now(),
        };
      } else {
        arr.push({
          providerId: providerId as ProviderKey,
          text: delta,
          status: status as any,
          createdAt: Date.now(),
        });
      }

      aiTurn.refinerResponses[providerId] = arr;
      aiTurn.refinerVersion = (aiTurn.refinerVersion ?? 0) + 1;
    } else if (responseType === "antagonist") {
      // Update antagonist responses (array per provider)
      if (!aiTurn.antagonistResponses) aiTurn.antagonistResponses = {};
      const arr = normalizeResponseArray(aiTurn.antagonistResponses[providerId]);

      const latest = arr.length > 0 ? arr[arr.length - 1] : undefined;
      const isLatestTerminal = latest && (latest.status === "completed" || latest.status === "error");

      if (latest && !isLatestTerminal) {
        arr[arr.length - 1] = {
          ...latest,
          text: (latest.text || "") + delta,
          status: status as any,
          updatedAt: Date.now(),
        };
      } else {
        arr.push({
          providerId: providerId as ProviderKey,
          text: delta,
          status: status as any,
          createdAt: Date.now(),
        });
      }

      aiTurn.antagonistResponses[providerId] = arr;
      aiTurn.antagonistVersion = (aiTurn.antagonistVersion ?? 0) + 1;
    }
  });
}

/**
 * Transforms raw backend "rounds" (from fullSession.turns) into normalized UserTurn/AiTurn objects
 * mirroring the logic in useChat.ts selectChat
 */
export function normalizeBackendRoundsToTurns(
  rawTurns: any[],
  sessionId: string
): Array<UserTurn | AiTurn> {
  if (!rawTurns) return [];
  const normalized: Array<UserTurn | AiTurn> = [];

  rawTurns.forEach((round: any) => {
    if (!round) return;

    // 1. Extract UserTurn
    if (round.user && round.user.text) {
      const userTurn: UserTurn = {
        type: "user",
        id: round.userTurnId || round.user.id || `user-${round.createdAt}`,
        text: round.user.text,
        createdAt: round.user.createdAt || round.createdAt || Date.now(),
        sessionId: sessionId,
      };
      normalized.push(userTurn);
    }

    // 2. Extract AiTurn
    const providers = round.providers || {};
    const hasProviderData = Object.keys(providers).length > 0;

    if (hasProviderData) {
      // Transform providers object to batchResponses (arrays per provider)
      const batchResponses: Record<string, ProviderResponse[]> = {};
      Object.entries(providers).forEach(([providerId, data]: [string, any]) => {
        const arr: ProviderResponse[] = Array.isArray(data)
          ? (data as ProviderResponse[])
          : [
            {
              providerId: providerId as ProviderKey,
              text: (data?.text as string) || "",
              status: "completed",
              createdAt: round.completedAt || round.createdAt || Date.now(),
              updatedAt: round.completedAt || round.createdAt || Date.now(),
              meta: data?.meta || {},
            },
          ];
        batchResponses[providerId] = arr;
      });

      // Normalize synthesis/mapping responses to arrays
      const normalizeSynthMap = (
        raw: any
      ): Record<string, ProviderResponse[]> => {
        if (!raw) return {};
        const result: Record<string, ProviderResponse[]> = {};
        Object.entries(raw).forEach(([pid, val]: [string, any]) => {
          if (Array.isArray(val)) {
            result[pid] = val;
          } else {
            result[pid] = [val];
          }
        });
        return result;
      };

      const aiTurn: AiTurn = {
        type: "ai",
        id: round.aiTurnId || `ai-${round.completedAt || Date.now()}`,
        userTurnId: round.userTurnId,
        sessionId: sessionId,
        threadId: "default-thread",
        createdAt: round.completedAt || round.createdAt || Date.now(),
        batchResponses,
        synthesisResponses: normalizeSynthMap(round.synthesisResponses),
        mappingResponses: normalizeSynthMap(round.mappingResponses),
        refinerResponses: normalizeSynthMap(round.refinerResponses),
        antagonistResponses: normalizeSynthMap(round.antagonistResponses),
        meta: round.meta || {},
      };
      normalized.push(aiTurn);
    }
  });

  return normalized;
}



================================================
FILE: ui/views/ChatView.tsx
================================================
import React, { useMemo, useEffect, useRef, Suspense } from "react";
import { Virtuoso, VirtuosoHandle } from "react-virtuoso";
import { useAtom, useAtomValue, useSetAtom } from "jotai";
import {
  turnIdsAtom,
  showWelcomeAtom,
  currentSessionIdAtom,
  isSplitOpenAtom,
  activeSplitPanelAtom,
  isDecisionMapOpenAtom,
  splitPaneRatioAtom,
  chatInputHeightAtom
} from "../state/atoms";
import { Panel, PanelGroup, PanelResizeHandle, ImperativePanelGroupHandle } from "react-resizable-panels";
import clsx from "clsx";

import MessageRow from "../components/MessageRow";
import ChatInput from "../components/ChatInput";
import WelcomeScreen from "../components/WelcomeScreen";
import { useChat } from "../hooks/chat/useChat";
import { SplitPaneRightPanel } from "../components/SplitPaneRightPanel";
import { CouncilOrbsVertical } from "../components/CouncilOrbsVertical";
import { useSmartProviderDefaults } from "../hooks/providers/useSmartProviderDefaults";

import { safeLazy } from "../utils/safeLazy";
// Lazy load DecisionMapSheet (named export adapter)
const DecisionMapSheet = safeLazy(() =>
  import("../components/DecisionMapSheet").then(module => ({ default: module.DecisionMapSheet }))
);

export default function ChatView() {
  const [turnIds] = useAtom(turnIdsAtom as any) as [string[], any];
  const [showWelcome] = useAtom(showWelcomeAtom as any) as [boolean, any];
  const [currentSessionId] = useAtom(currentSessionIdAtom as any) as [
    string | null,
    any,
  ];

  // Split Pane State
  const isSplitOpen = useAtomValue(isSplitOpenAtom);
  const setActiveSplitPanel = useSetAtom(activeSplitPanelAtom);
  const isDecisionMapOpen = useAtomValue(isDecisionMapOpenAtom);
  const setDecisionMapOpen = useSetAtom(isDecisionMapOpenAtom);
  const splitPaneRatio = useAtomValue(splitPaneRatioAtom);
  const chatInputHeight = useAtomValue(chatInputHeightAtom);
  const panelGroupRef = useRef<ImperativePanelGroupHandle>(null);

  // Sync split pane ratio to panel layout (for auto-open/widen)
  useEffect(() => {
    if (panelGroupRef.current && isSplitOpen) {
      panelGroupRef.current.setLayout([splitPaneRatio, 100 - splitPaneRatio]);
    }
  }, [splitPaneRatio, isSplitOpen]);

  // Smart Defaults
  useSmartProviderDefaults();

  const virtuosoRef = useRef<VirtuosoHandle | null>(null);
  const { selectChat } = useChat();

  // ESC Key Handler
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        if (isDecisionMapOpen) {
          setDecisionMapOpen(null);
        } else if (isSplitOpen) {
          setActiveSplitPanel(null);
        }
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, [isDecisionMapOpen, isSplitOpen, setDecisionMapOpen, setActiveSplitPanel]);

  const itemContent = useMemo(
    () => (_index: number, turnId: string) => {
      if (!turnId) {
        return (
          <div className="p-2 text-intent-danger">
            Error: Invalid turn ID
          </div>
        );
      }
      return <MessageRow turnId={turnId} />;
    },
    [],
  );

  // Memoize Virtuoso Scroller to avoid remounts that can reset scroll position
  type ScrollerProps = Pick<
    React.DetailedHTMLProps<
      React.HTMLAttributes<HTMLDivElement>,
      HTMLDivElement
    >,
    "children" | "style" | "tabIndex"
  >;
  const ScrollerComponent = useMemo(
    () =>
      React.forwardRef<HTMLDivElement, ScrollerProps>((props, ref) => (
        <div
          {...props}
          ref={(node) => {
            if (typeof ref === "function") ref(node as HTMLDivElement | null);
            else if (ref && "current" in (ref as any))
              (ref as React.MutableRefObject<HTMLDivElement | null>).current =
                node as HTMLDivElement | null;
          }}
          style={{
            ...(props.style || {}),
            WebkitOverflowScrolling: "touch",
          }}
          className="h-full min-h-0 overflow-y-auto"
        />
      )),
    [],
  );

  // Jump-to-turn event listener with optional cross-session loading
  useEffect(() => {
    const handler = async (evt: Event) => {
      try {
        const detail = (evt as CustomEvent<any>).detail || {};
        const targetTurnId: string | undefined =
          detail.turnId || detail.aiTurnId || detail.userTurnId;
        const targetProviderId: string | undefined = detail.providerId;
        const targetSessionId: string | undefined = detail.sessionId;
        if (!targetTurnId) return;

        const doScroll = () => {
          try {
            const index = turnIds.findIndex((id) => id === targetTurnId);
            if (index !== -1) {
              virtuosoRef.current?.scrollToIndex({
                index,
                behavior: "smooth",
                align: "center",
              });
            } else {
              // Fallback to DOM query when item is rendered
              const el = document.querySelector(
                `[data-turn-id="${CSS.escape(targetTurnId)}"]`,
              ) as HTMLElement | null;
              if (el && typeof el.scrollIntoView === "function") {
                el.scrollIntoView({ behavior: "smooth", block: "center" });
              }
            }
            // Brief highlight pulse
            const row =
              document.getElementById(`turn-${targetTurnId}`) ||
              document.querySelector(
                `[data-turn-id="${CSS.escape(targetTurnId)}"]`,
              );
            if (row && row instanceof HTMLElement) {
              row.classList.add('shadow-glow-brand-soft');
              setTimeout(() => {
                row.classList.remove('shadow-glow-brand-soft');
              }, 1200);
            }
            // Focus provider card if requested - open split pane directly
            if (targetProviderId) {
              setTimeout(() => {
                setActiveSplitPanel({
                  turnId: targetTurnId,
                  providerId: targetProviderId
                });
              }, 120);
            }
          } catch (e) {
            console.warn("[ChatView] doScroll failed", e);
          }
        };

        // Cross-session navigation support
        if (
          targetSessionId &&
          currentSessionId &&
          targetSessionId !== currentSessionId
        ) {
          const summary = {
            id: targetSessionId,
            sessionId: targetSessionId,
            startTime: Date.now(),
            lastActivity: Date.now(),
            title: "",
            firstMessage: "",
            messageCount: 0,
            messages: [],
          };
          await selectChat(summary as any);
          // Wait a tick for state to settle then scroll
          requestAnimationFrame(() => doScroll());
        } else {
          doScroll();
        }
      } catch (e) {
        console.warn("[ChatView] jump-to-turn handler failed", e);
      }
    };
    document.addEventListener("jump-to-turn", handler as EventListener);
    return () =>
      document.removeEventListener("jump-to-turn", handler as EventListener);
  }, [turnIds, currentSessionId, selectChat]);

  return (
    <div className="chat-view flex flex-col h-full w-full flex-1 min-h-0 relative">
      {showWelcome ? (
        <WelcomeScreen />
      ) : (
        <PanelGroup
          ref={panelGroupRef}
          direction="horizontal"
          className="flex-1 h-full"
          style={{ paddingBottom: (chatInputHeight || 80) + 12 }}
        >
          {/* LEFT: Main Thread */}
          <Panel defaultSize={60} minSize={35}>
            <Virtuoso
              className="h-full"
              data={turnIds}
              followOutput={(isAtBottom: boolean) =>
                isAtBottom ? "smooth" : false
              }
              increaseViewportBy={{ top: 300, bottom: 200 }}
              components={{
                Scroller: ScrollerComponent as unknown as React.ComponentType<any>,
                Footer: () => <div style={{ height: 24 }} />
              }}
              itemContent={itemContent}
              computeItemKey={(index, turnId) => turnId || `fallback-${index}`}
              ref={virtuosoRef as any}
            />
          </Panel>

          {/* RIGHT: Model Response Panel (only when open) */}
          {isSplitOpen && (
            <>
              {/* Divider with Orbs */}
              <PanelResizeHandle className="w-1.5 bg-border-subtle hover:bg-brand-500/50 transition-colors cursor-col-resize relative z-10">
                {/* Adjacent Orb Column - uses fixed Y centering to prevent shift when ChatInput changes */}
                <div
                  className="divider-handle absolute left-0 -translate-x-full w-10 h-full flex flex-col items-center justify-center z-20"
                  style={{
                    pointerEvents: 'none',
                    transform: 'translateX(-100%)'
                  }}
                >
                  <div className="orb-bar pointer-events-auto cursor-default bg-surface-raised border-y border-l border-border-subtle rounded-l-xl shadow-sm p-1 flex flex-col items-center justify-center gap-2" style={{ cursor: 'default' }}>
                    <CouncilOrbsVertical />
                  </div>
                </div>
              </PanelResizeHandle>

              <Panel defaultSize={40} minSize={0} className="min-w-0 overflow-hidden">
                <SplitPaneRightPanel />
              </Panel>
            </>
          )}
        </PanelGroup>
      )}

      {/* Decision Map - Fixed Overlay */}
      <Suspense fallback={null}>
        <DecisionMapSheet />
      </Suspense>

      <div
        className={clsx(
          "absolute left-1/2 -translate-x-1/2 max-w-[min(900px,calc(100%-24px))] z-[50] flex flex-col items-center pointer-events-none transition-opacity duration-300",
          showWelcome ? "bottom-[16px]" : "bottom-0",
        )}
      >
        <ChatInput />
      </div>
    </div>
  );
}

