```markdown
# System Integrity Audit: Singularity Cognitive Pipeline

## Context

You are auditing a Chrome extension that implements a multi-model cognitive pipeline. The system has been incrementally built and has accumulated disconnects between layers. Your task is to trace all data flows from end to end and identify every mismatch, dead path, missing handler, type inconsistency, and serialization failure.

---

## Architecture Overview

```
User Input
    ↓
[Batch Fan-out] → N model responses (parallel)
    ↓
[Shadow Mapper] → ShadowStatement[] (mechanical extraction)
    ↓
[Semantic Mapper] → Claims + Edges (LLM clustering)
    ↓
[Claim Assembly] → AssembledClaim[] (attach provenance)
    ↓
[Traversal Graph] → TraversalGraph (tiers, gates, tensions)
    ↓
[Forcing Points] → ForcingPoint[] (user decision points)
    ↓
[PIPELINE PAUSE] → awaiting_traversal (if forcing points exist)
    ↓
[User Traversal] → User resolves gates/conflicts via UI
    ↓
[Synthesis] → Concierge receives context + collected evidence
    ↓
[Response] → Final output to user
```

---

## Files to Audit (by layer)

### Type Contracts
- `shared/contract.ts` — All shared types including:
  - `MapperArtifact`
  - `AiTurn`
  - `TraversalTier`, `TraversalGate`, `SerializedTraversalGraph`
  - `ForcingPoint`, `SerializedForcingPoint`, `ForcingPointType`
  - `PipelineStatus`
  - `Claim`, `Edge`

### Shadow Mapper
- `src/core/ConciergeService/shadow/StatementTypes.ts`
- `src/core/ConciergeService/shadow/ShadowExtractor.ts`
- `src/core/ConciergeService/shadow/ShadowDelta.ts`
- `src/core/ConciergeService/shadow/ExclusionRules.ts`
- `src/core/ConciergeService/shadow/index.ts`

### Semantic Mapper / Claim Assembly
- `src/core/ConciergeService/claimAssembly.ts`
- `src/core/ConciergeService/v2-to-v1-adapter.ts`

### Traversal Layer
- `src/core/ConciergeService/traversal.ts`
- `src/core/ConciergeService/forcingPoints.ts`
- `src/core/ConciergeService/traversalState.ts`

### Pipeline Execution
- `src/core/execution/CognitivePipelineHandler.js`
- `src/core/execution/StepExecutor.js`

### UI Components
- `src/ui/components/TraversalGraphView.tsx`
- `src/ui/components/TraversalGateCard.tsx`
- `src/ui/components/TraversalForcingPointCard.tsx`
- `src/ui/components/cognitive/CognitiveOutputRenderer.tsx`
- `src/ui/components/cognitive/SingularityOutputView.tsx`

### UI Hooks
- `src/ui/hooks/useTraversalState.ts`
- `src/ui/hooks/useSingularityOutput.ts`

### Utilities
- `src/ui/utils/traversal-prompt-builder.ts`
- `shared/parsing-utils.ts`

---

## Audit Checklist

### 1. Type Consistency Across Boundaries

For each type in `shared/contract.ts`, verify:

- [ ] Every producer (function that creates this type) outputs the exact shape
- [ ] Every consumer (function/component that uses this type) expects the exact shape
- [ ] No `any` casts that hide mismatches
- [ ] Optional fields (`?`) are handled with guards at consumption sites

**Specific checks:**

| Type | Producers | Consumers | Check |
|------|-----------|-----------|-------|
| `TraversalTier` | `traversal.ts:computeTiers` | `TraversalGraphView.tsx`, `useTraversalState.ts` | `gates` field exists and is array |
| `SerializedTraversalGraph` | `traversal.ts:buildTraversalGraph` | `CognitiveOutputRenderer.tsx`, UI components | `tiers` is array not Map |
| `ForcingPoint` | `forcingPoints.ts:extractForcingPoints` | `TraversalForcingPointCard.tsx` | All fields present |
| `MapperArtifact` | `StepExecutor.js` | `CognitiveOutputRenderer.tsx` | `traversalGraph`, `forcingPoints` fields |
| `AiTurn` | `CognitivePipelineHandler.js` | All UI components | `pipelineStatus` field |

### 2. Serialization Safety

**Map objects cannot be serialized to JSON.** Find all uses of `Map` and verify they are converted to arrays/objects before:

- Storing in IndexedDB/storage
- Sending via `postMessage`
- Including in any object that gets `JSON.stringify`

**Check these specific locations:**

- [ ] `traversal.ts` — `tiers` must be `TraversalTier[]` not `Map<number, string[]>`
- [ ] `traversalState.ts` — any Maps in state must be serializable
- [ ] `useTraversalState.ts` — same check

### 3. Message Flow Integrity

Trace each message type from sender to handler:

| Message Type | Sender | Handler | Check |
|--------------|--------|---------|-------|
| `COGNITIVE_REQUEST` | UI | `CognitivePipelineHandler.js` | Handler exists and processes correctly |
| `CONTINUE_COGNITIVE_REQUEST` | `TraversalGraphView.tsx` | `CognitivePipelineHandler.js` | Handler exists, `isTraversalContinuation` flag handled |
| `MAPPER_ARTIFACT_READY` | Pipeline | UI atoms/hooks | Listener exists, updates state |
| `TURN_FINALIZED` | Pipeline | UI | `pipelineStatus` included in payload |
| `WORKFLOW_STEP_UPDATE` | Pipeline | UI | All fields present |

### 4. Pipeline Pause/Resume Logic

Verify the pause mechanism:

- [ ] In `CognitivePipelineHandler.js`:
  - Check for `traversalGraph` AND `forcingPoints.length > 0`
  - If true AND NOT `isTraversalContinuation`, set `pipelineStatus = 'awaiting_traversal'`
  - Send notification to UI
  - Return early (do not proceed to Singularity)
  
- [ ] In `CognitivePipelineHandler.js` (resume path):
  - Handle `CONTINUE_COGNITIVE_REQUEST`
  - Set `isTraversalContinuation = true`
  - Pass user's continuation prompt to Singularity
  - Update `pipelineStatus = 'complete'`

- [ ] In `CognitiveOutputRenderer.tsx`:
  - Watch `aiTurn.pipelineStatus`
  - If `'awaiting_traversal'`, show `TraversalGraphView`
  - If `'complete'`, show `SingularityOutputView`

### 5. UI Component Props vs. Data Shape

For each UI component, verify props match actual data:

**TraversalGraphView.tsx:**
```typescript
// Expected props:
traversalGraph: SerializedTraversalGraph
forcingPoints: ForcingPoint[]
claims: Claim[]
originalQuery: string
sessionId: string
aiTurnId: string
```

- [ ] `traversalGraph.tiers` accessed as array (`.map()`, `.forEach()`, not `.entries()`)
- [ ] `tier.claimIds` not `tier.claims`
- [ ] `tier.gates` exists and is array

**TraversalForcingPointCard.tsx:**
- [ ] `forcingPoint.type` is `'conditional' | 'prerequisite' | 'conflict'` (not `'binary_choice'` etc.)
- [ ] All fields from `ForcingPoint` interface are handled
- [ ] `useEffect` syncs local state with `resolution` prop changes

**TraversalGateCard.tsx:**
- [ ] `gate` prop matches `TraversalGate` shape
- [ ] `useEffect` syncs `userInput` state with `resolution?.userInput`

### 6. Hook State Management

**useTraversalState.ts:**
- [ ] Iterates `tiers` as array, not Map
- [ ] Returns serializable state (no Maps)
- [ ] Handles missing/undefined `traversalGraph` gracefully

### 7. Dead Code / Orphaned Imports

Find and flag:
- [ ] Imports that reference deleted/renamed files
- [ ] Functions defined but never called
- [ ] Types defined but never used
- [ ] Duplicate implementations of same logic

### 8. Error Boundaries and Guards

Verify defensive coding at layer boundaries:

- [ ] `TraversalGraphView.tsx` — returns `null` if `traversalGraph.tiers` is not a valid array
- [ ] `CognitiveOutputRenderer.tsx` — guards before rendering `TraversalGraphView`
- [ ] All `.map()` calls on potentially undefined arrays have guards

### 9. Duplicate Code Blocks

Search for and consolidate:
- [ ] Duplicate processing blocks in `StepExecutor.js` (assembly, traversal, shadow delta)
- [ ] Duplicate type definitions across files
- [ ] Repeated logic that should be a shared utility

---

## Known Issues to Verify Fixed

1. **`traversalGraph.tiers.forEach is not a function`**
   - Cause: `tiers` was `Map`, serialized to `{}`
   - Fix: `tiers` should be `TraversalTier[]` everywhere

2. **`traversalGraph.tiers is not iterable`**
   - Cause: Legacy data has `tiers: {}`
   - Fix: Guard in UI + migration for old data

3. **ForcingPoint type mismatch**
   - UI expected: `'binary_choice' | 'multi_option' | 'gate_resolution'`
   - Contract defines: `'conditional' | 'prerequisite' | 'conflict'`
   - Fix: Align UI to contract types

4. **Pipeline doesn't pause for traversal**
   - Cause: No check for `forcingPoints` before Singularity execution
   - Fix: Add gating logic in `CognitivePipelineHandler.js`

5. **State not syncing with props**
   - `TraversalForcingPointCard`: `selectedOption` doesn't update when `resolution` prop changes
   - `TraversalGateCard`: `userInput` doesn't update when `resolution` prop changes
   - Fix: Add `useEffect` to sync

6. **Port listener memory leak**
   - `TraversalGraphView.tsx`: `port.onMessage.addListener` never removed
   - Fix: Capture listener, add cleanup in finally/unmount

---

## Output Format

Produce a report with:

1. **Critical Issues** (will crash or break functionality)
   - File, line number, issue, fix

2. **Type Mismatches** (will cause runtime errors)
   - Source type, consumer expectation, locations

3. **Missing Handlers** (dead paths)
   - Message type or function call with no handler

4. **Serialization Risks** (Maps, Sets, circular refs)
   - Location, type, fix

5. **Suggested Fixes** (code snippets for each issue)

---

## Execution

1. Start with `shared/contract.ts` — this is the source of truth
2. Trace each type to its producers and consumers
3. Follow message flows from UI → service worker → back
4. Check every conditional render has matching data shape
5. Verify every `useEffect` dependency array is complete
6. Flag any `any` type that hides a mismatch

Do not stop at the first error. Complete the full audit before reporting.
```