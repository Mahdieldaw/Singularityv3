# End-to-End System Flow: The Authoritative Architecture

You're right to notice the confusion. Let me clarify exactly what happens and what goes where.

---

## The Clean Pipeline

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 1: COLLECTION                                                         │
│                                                                              │
│   User Query                                                                 │
│       ↓                                                                      │
│   Batch Execution (6 models in parallel)                                     │
│       ↓                                                                      │
│   6 Raw Model Responses                                                      │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 2: MECHANICAL EXTRACTION (No LLM, Deterministic)                       │
│                                                                              │
│   Shadow Extractor                                                           │
│       → ShadowStatement[] (s_0, s_1, s_2, ...)                              │
│       → Each has: text, stance, signals, modelIndex, location               │
│                                                                              │
│   Paragraph Projector                                                        │
│       → ShadowParagraph[] (p_0, p_1, p_2, ...)                              │
│       → Groups statements by (modelIndex, paragraphIndex)                    │
│       → Each has: statementIds[], dominantStance, contested, signals        │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 3: GEOMETRIC SUBSTRATE (No LLM, Deterministic)                         │
│                                                                              │
│   Embedding Generation (offscreen worker)                                    │
│       → Map<paragraphId, Float32Array>                                       │
│                                                                              │
│   Substrate Builder                                                          │
│       → GeometricSubstrate {                                                 │
│           nodes: NodeLocalStats[]                                            │
│           graphs: { knn, mutual, strong }                                    │
│           topology: { components, isolationRatio, density }                  │
│         }                                                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 4: INTERPRETATION (No LLM, Deterministic)                              │
│                                                                              │
│   Adaptive Lens                                                              │
│       → regime, shouldRunClustering, hardMergeThreshold                      │
│                                                                              │
│   Optional HAC Clustering (only if lens.shouldRunClustering)                 │
│       → ParagraphCluster[] (pc_0, pc_1, ...)                                │
│                                                                              │
│   Regionization                                                              │
│       → Region[] (r_0, r_1, ...) ← THIS IS THE KEY ABSTRACTION              │
│       → Each region is ONE OF: cluster | component | patch                   │
│       → Fallback hierarchy ensures regions ALWAYS exist                      │
│                                                                              │
│   Region Profiling                                                           │
│       → RegionProfile[] (tier, purity, geometry, predictions)                │
│                                                                              │
│   Opposition Detection                                                       │
│       → OppositionPair[] (semantic conflicts between regions)                │
│                                                                              │
│   Mapper Guidance                                                            │
│       → MapperGeometricHints (shape prediction, attention, expected claims) │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 5: SEMANTIC MAPPING (LLM)                                              │
│                                                                              │
│   INPUT (what the mapper receives):                                          │
│     1. Shadow Statements (for citation - the ground truth)                   │
│     2. Regions (the groupings - NOT raw paragraphs separately)               │
│     3. Geometric Hints (predictions and attention signals)                   │
│     4. User Query                                                            │
│                                                                              │
│   OUTPUT:                                                                    │
│     → SemanticClaim[] with gates (conditionals, prerequisites)               │
│     → Conflict/support relationships                                         │
│     → All claims cite statement IDs (provenance enforced)                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 6: POST-SEMANTIC ANALYSIS (Computation, No LLM)                        │
│                                                                              │
│   Claim Enrichment                                                           │
│       → supportRatio, leverage, isKeystone, isHighSupport                    │
│                                                                              │
│   Shape Detection (from claims, not geometry)                                │
│       → actual primary shape + patterns                                      │
│                                                                              │
│   Pattern Detection                                                          │
│       → dissent, keystone, chain, fragile, etc.                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 7: VALIDATION (Computation, No LLM)                                    │
│                                                                              │
│   Compare pre-semantic predictions vs post-semantic reality                  │
│       → shapeMatch?                                                          │
│       → tierAlignment?                                                       │
│       → conflictPrecision/Recall?                                           │
│       → violations[]                                                         │
│       → overallFidelity score                                               │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 8: TRAVERSAL (User Interaction)                                        │
│                                                                              │
│   Forcing Points surfaced in order:                                          │
│       1. Conditionals (broadest impact)                                      │
│       2. Prerequisites (dependency chains)                                   │
│       3. Conflicts (final disambiguation)                                    │
│                                                                              │
│   User answers → claims pruned → active claim set shrinks                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 9: CONCIERGE SYNTHESIS (LLM)                                           │
│                                                                              │
│   INPUT:                                                                     │
│     1. User path (traversal decisions)                                       │
│     2. Active claims (post-pruning)                                          │
│     3. Claim evidence (shadow statement passages)                            │
│     4. Structural notes (validation insights)                                │
│                                                                              │
│   OUTPUT:                                                                    │
│     → Decisive, conditional recommendation                                   │
│     → Permission to transcend (can go beyond suggestions)                    │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## The Confusion: Paragraphs vs Clusters vs Regions

Here's the source of confusion and the resolution:

### The Old Mental Model (Confusing)

```
Mapper receives:
  - Shadow Statements ✓
  - Shadow Paragraphs ← REDUNDANT?
  - Clusters (when available) ← DOUBLE INPUT?
```

### The Correct Mental Model

```
Mapper receives:
  - Shadow Statements (for citation)
  - Regions (the ONLY grouping structure)
  
Where each Region contains:
  - nodeIds (which paragraph IDs are in this region)
  - statementIds (which statement IDs to cite)
  - sourceId (was it a cluster? component? patch?)
```

**The key insight: REGIONS replace both "paragraphs as groups" and "clusters as groups".**

---

## What Gets Sent to the Semantic Mapper

### Correct Mapper Input Structure

```typescript
interface SemanticMapperInput {
  // The query
  userQuery: string;
  
  // Ground truth for citation (what to cite)
  statements: Array<{
    id: string;           // s_0, s_1, ...
    text: string;         // The actual sentence
    stance: Stance;
    modelIndex: number;
  }>;
  
  // Grouping structure (how things cluster semantically)
  regions: Array<{
    id: string;           // r_0, r_1, ...
    kind: 'cluster' | 'component' | 'patch';
    statementIds: string[];   // Which statements are in this region
    tier: 'peak' | 'hill' | 'floor';
    dominantStance: Stance;
    modelIndices: number[];   // Which models contributed
  }>;
  
  // Geometric guidance (what structure to expect)
  hints: {
    predictedShape: PrimaryShape;
    expectedClaimCount: [number, number];
    expectedConflicts: number;
    attentionRegions: AttentionRegion[];
    oppositionPairs: OppositionPair[];
  };
}
```

### What You Do NOT Send

```typescript
// ❌ WRONG - Double input
{
  paragraphs: ShadowParagraph[],  // NO - these are subsumed by regions
  clusters: ParagraphCluster[],   // NO - these are subsumed by regions
  regions: Region[],              // YES - this is the only grouping
}

// ✓ CORRECT - Single grouping structure
{
  statements: ShadowStatement[],  // Ground truth for citation
  regions: Region[],              // Unified grouping (cluster|component|patch)
  hints: MapperGeometricHints,    // Structural guidance
}
```

---

## The Data Flow Diagram

```
ShadowStatements (s_*)
        │
        │ ← Ground truth, never changes
        │
        ▼
ShadowParagraphs (p_*)
        │
        │ ← Grouped by model+position
        │
        ▼
   [Embeddings]
        │
        ▼
GeometricSubstrate
        │
        ├──→ kNN Graph
        ├──→ Mutual Graph  
        ├──→ Strong Graph
        └──→ Topology (components)
                │
                ▼
         AdaptiveLens
                │
                ├──→ shouldRunClustering? ──→ [Optional HAC] ──→ Clusters (pc_*)
                │                                                      │
                ▼                                                      │
        ┌───────────────────────────────────────────────────────────────┘
        │
        ▼
   Regionization
        │
        │ Priority: clusters > components > patches
        │
        ▼
   Regions (r_*)  ← THE UNIFIED ABSTRACTION
        │
        ├──→ Profiling (peak/hill/floor)
        ├──→ Opposition Detection
        └──→ Mapper Hints
                │
                ▼
┌───────────────────────────────────────┐
│ SEMANTIC MAPPER INPUT                 │
│                                       │
│   statements: s_* (for citation)      │
│   regions: r_* (grouping structure)   │
│   hints: (shape, attention, etc.)     │
└───────────────────────────────────────┘
                │
                ▼
        Claims + Edges
```

---

## The Provenance Chain

Everything traces back to shadow statements:

```
Claim c_3
    ↓ cites
Statement s_12, s_18, s_24
    ↓ belong to
Paragraph p_4, p_7, p_11
    ↓ grouped into
Region r_2 (kind: cluster)
    ↓ came from
Models 2, 4, 5
    ↓ visible in
Council Orbs (click to see raw response)
```

---

## What Each Phase Produces

| Phase | Input | Output | LLM? |
|-------|-------|--------|------|
| Batch | Query | 6 raw responses | ✓ (6 calls) |
| Shadow | Responses | Statements (s_*) | ✗ |
| Projection | Statements | Paragraphs (p_*) | ✗ |
| Embedding | Paragraphs | Float32Array per p_* | ✗ (local model) |
| Substrate | Embeddings | kNN/mutual/strong graphs | ✗ |
| Lens | Substrate | Regime + thresholds | ✗ |
| Clustering | Paragraphs + embeddings | Clusters (pc_*) | ✗ |
| Regionization | Substrate + clusters | Regions (r_*) | ✗ |
| Profiling | Regions | Peak/Hill/Floor | ✗ |
| Opposition | Regions + profiles | Pairs | ✗ |
| Guidance | All above | Mapper hints | ✗ |
| **Mapping** | **Statements + Regions + Hints** | **Claims + Edges** | **✓** |
| Analysis | Claims + Edges | Enriched claims + patterns | ✗ |
| Validation | Pre + Post | Fidelity score | ✗ |
| Traversal | Claims + Gates | User decisions | ✗ (user) |
| **Concierge** | **Active claims + path** | **Recommendation** | **✓** |

**Total LLM calls per query: 6 (batch) + 1 (mapper) + 1 (concierge) = 8**

---

## The Mapper Prompt Structure

```xml
<system>
You are a Semantic Cartographer. Your task is to extract claims 
from the provided statements, grouped by semantic regions.
</system>

<geometric_guidance>
Predicted Shape: FORKED (confidence: 0.82)
Evidence:
- 2 peak regions detected
- Semantic opposition between peaks
- Clusters discuss same topic but reach opposite conclusions

Expected Claims: 3-6
Expected Conflicts: 2
Expected Dissent: YES

Attention Regions:
- r_0 [semantic_opposition]: Opposes r_1. Expect conflict edge.
- r_2 [stance_inversion]: Hill challenging peak consensus.
</geometric_guidance>

<regions>
Region r_0 (cluster, PEAK):
  Statements: s_0, s_3, s_7, s_12
  Models: 1, 2, 4
  Dominant stance: prescriptive
  
Region r_1 (cluster, PEAK):
  Statements: s_1, s_5, s_9
  Models: 3, 5, 6
  Dominant stance: cautionary
  
Region r_2 (component, HILL):
  Statements: s_2, s_8
  Models: 2
  Dominant stance: uncertain
</regions>

<statements>
s_0: "You should use React for this project" [prescriptive, model 1]
s_1: "Avoid React due to bundle size concerns" [cautionary, model 3]
s_2: "It depends on your team's experience" [uncertain, model 2]
...
</statements>

<query>
Should I use React or Vue for my startup's frontend?
</query>

<instructions>
1. Create claims by grouping related statements
2. Each claim must cite statement IDs (s_*)
3. Create conflict edges where geometric hints indicate opposition
4. Pay special attention to marked attention regions
5. Output JSON only, no prose
</instructions>
```

---

## Summary: The Resolution

| Confusion | Resolution |
|-----------|------------|
| "Do we send paragraphs AND clusters?" | No. We send **Regions**, which abstract over both. |
| "What if clustering fails?" | Regions fall back to components, then to patches. Always exist. |
| "What does the mapper cite?" | Statement IDs (s_*) only. Never paragraph or cluster IDs. |
| "What's the grouping structure?" | Regions (r_*) with tier, stance, model info. |
| "Is geometric guidance mandatory?" | No, but it helps. System works without it (just less accurate). |

**The key architectural invariant:**

> Paragraphs are intermediate computation.
> Clusters are optional optimization.
> **Regions are the semantic interface.**