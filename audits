## Agent Prompt: Audit Session Lifecycle, Port Management, and State Synchronization

### Context
You are auditing a Chrome MV3 extension with a complex workflow system. Recent fixes addressed immediate UI rendering bugs (traversal not showing due to stale `currentSessionId`), but deeper architectural issues remain around session lifecycle, port connection management, and state synchronization across conversation switches.

### Primary Objectives

**1. SESSION STATE LIFECYCLE AUDIT**
- Trace all code paths that **set** `currentSessionIdAtom` and `activeAiTurnIdAtom`
- Identify all user actions that **should** reset these atoms but currently don't:
  - Starting new conversation
  - Switching to different chat history
  - Extension close/reopen
  - Manual "clear chat" actions
- Map the lifecycle of `currentSessionId` from:
  - Initial null state → first adoption → conversation switch → reset (or lack thereof)
- **Verify:** Does stale `currentSessionId` ever cause:
  - Wrong conversation's messages to render?
  - Port messages routed to wrong UI state?
  - Context resolution pulling from wrong session?

**Files to investigate:**
- `ui/state/atoms.ts` — atom definitions and initial values
- `ui/hooks/chat/usePortMessageHandler.ts` — where atoms get set from messages
- `ui/views/ChatView.tsx` — top-level conversation UI and navigation handlers
- `ui/hooks/chat/useChat.ts` — conversation switching logic
- `ui/hooks/useHistoryLoader.ts` — history loading and session restoration
- Search codebase for: `setCurrentSessionId`, `currentSessionIdAtom`, `activeAiTurnIdAtom`, pattern: `atom.*reset|clear`

**Deliverable:**
- List every scenario where session state should reset but doesn't
- Identify race conditions where `currentSessionId` could point to wrong conversation
- Document expected vs actual behavior for "New Chat" button, history navigation, extension reopen

---

**2. PORT CONNECTION SCOPING AND LIFECYCLE**
- Audit `extension-api.ts` `ensurePort()` implementation:
  - Is port truly global (one port for all sessions)?
  - What happens when multiple workflows execute concurrently?
  - Can messages from session A arrive while UI is displaying session B?
- Trace port creation, disconnection, and reconnection logic:
  - When does `ensurePort()` create a new port vs reuse existing?
  - What triggers port disconnect? (SW suspension, user navigation, manual close)
  - Is there retry/reconnect logic when port dies mid-workflow?
- Map all places that create ports **outside** `ensurePort()`:
  - `TraversalGraphView.tsx` creates its own port via `chrome.runtime.connect({ name: 'htos-traversal' })`
  - Are there other direct port creations bypassing the API layer?
- **Verify:** Backend `ConnectionHandler` behavior:
  - Does `chrome.runtime.onConnect` create one handler per port?
  - Can one handler receive messages from multiple sessions if port is reused?
  - What happens to in-flight messages if port disconnects during workflow execution?

**Files to investigate:**
- `ui/services/extension-api.ts` — `ensurePort()` implementation
- `ui/hooks/useConnectionMonitoring.ts` — port health checks and disconnect handling
- `ui/services/port-health-manager.ts` — keepalive ping logic
- `ui/components/traversal/TraversalGraphView.tsx` — direct port creation
- `src/core/connection-handler.js` — backend port message routing
- Search codebase for: `chrome.runtime.connect`, `ensurePort`, `port.disconnect`, `onDisconnect`

**Deliverable:**
- Document port lifecycle: creation → usage → disconnection → reconnection
- Identify scenarios where port messages could route to wrong session
- List all direct `chrome.runtime.connect()` calls and their scope/purpose
- Assess whether port should be session-scoped vs global

---

**3. MESSAGE ORDERING AND RACE CONDITIONS**
- Analyze message flow assumptions in `usePortMessageHandler.ts`:
  - Does code assume strict ordering: `TURN_CREATED` → `MAPPER_ARTIFACT_READY` → `TURN_FINALIZED`?
  - What happens if messages arrive out of order? (network delays, concurrent workflows)
  - Are there guards against processing messages for inactive/wrong turns?
- Trace `activeAiTurnId` state transitions:
  - When is it set? (on `TURN_CREATED`)
  - When is it cleared? (on `TURN_FINALIZED`)
  - Can it be set to turn A while messages for turn B are still arriving?
- **Verify:** State merge behavior in port message handler:
  - How does `const mergedAi = { ...existingAi, ...incoming }` handle missing fields?
  - Can `pipelineStatus` be accidentally overwritten to `undefined`?
  - Are there explicit null checks for critical fields like `sessionId`, `pipelineStatus`, `mapperArtifact`?
- Check for idempotency and deduplication:
  - Can duplicate `TURN_CREATED` events create multiple turns?
  - Are there client-side message IDs or sequence numbers?

**Files to investigate:**
- `ui/hooks/chat/usePortMessageHandler.ts` — all message type handlers
- `src/core/connection-handler.js` — backend message emission and idempotency guards
- `src/core/execution/TurnEmitter.js` — event emission logic
- Search codebase for: `case "TURN_CREATED"`, `case "MAPPER_ARTIFACT_READY"`, `case "TURN_FINALIZED"`, `mergedAi`, `activeAiTurnId`

**Deliverable:**
- Document assumed vs guaranteed message ordering
- Identify race conditions when switching conversations rapidly
- List fields that could be lost during state merges
- Assess whether message deduplication/idempotency exists

---

**4. TRAVERSAL RESUME RELIABILITY**
- Trace the complete traversal pause → resume flow:
  - Backend pauses, sends `MAPPER_ARTIFACT_READY` + `pipelineStatus: 'awaiting_traversal'`
  - UI renders `TraversalGraphView`, user selects gates/forcing points
  - `TraversalGraphView` sends `CONTINUE_COGNITIVE_WORKFLOW` via **new port** (not reusing `ensurePort()`)
  - Backend receives continuation, resumes workflow
- **Verify:** What happens if service worker suspends during traversal pause?
  - User leaves extension open at traversal UI for 30+ seconds
  - MV3 suspends service worker
  - Port disconnects
  - User returns, clicks "Continue" in traversal UI
  - Does the continuation message reach the backend? Or fail silently?
- Check `TraversalGraphView` error handling:
  - Does it detect port disconnect before sending continuation?
  - Is there retry logic if `postMessage` fails?
  - Are there user-facing error messages if continuation doesn't respond?
- **Verify:** Backend continuation handler robustness:
  - Does `CognitivePipelineHandler.handleContinueRequest` validate turn state before resuming?
  - What if continuation arrives for a turn that's already completed/abandoned?

**Files to investigate:**
- `ui/components/traversal/TraversalGraphView.tsx` — continuation message sending
- `src/core/execution/CognitivePipelineHandler.js` — `handleContinueRequest` implementation
- `ui/hooks/useConnectionMonitoring.ts` — port disconnect detection
- `src/core/connection-handler.js` — continuation message routing
- Search codebase for: `CONTINUE_COGNITIVE_WORKFLOW`, `isTraversalContinuation`, `handleContinueRequest`

**Deliverable:**
- Document traversal resume flow end-to-end
- Identify failure modes if SW suspends during pause
- Assess whether continuation has retry/reconnect logic
- List error scenarios with no user-facing feedback

---

**5. TURN_FINALIZED SEMANTIC OVERLOAD**
- Analyze all uses of `TURN_FINALIZED` event:
  - When does backend emit it? (search `TurnEmitter`, `CognitivePipelineHandler`)
  - What does UI assume it means? (search `case "TURN_FINALIZED"`)
- **Verify:** Does `TURN_FINALIZED` mean:
  - "Turn data is canonical and persisted" (always)?
  - "Workflow is complete and no more processing will occur" (sometimes)?
  - "UI should stop loading spinner" (always)?
- Document the **dual semantics** problem:
  - In normal flow: `TURN_FINALIZED` = workflow complete, turn done
  - In traversal pause: `TURN_FINALIZED` = artifact ready, **but workflow paused**
- Check UI loading/completion state handling:
  - Does `setActiveAiTurnId(null)` always happen on `TURN_FINALIZED`?
  - Does `setIsLoading(false)` always happen?
  - Could this cause UI to show "completed" state when workflow is actually paused?
- **Assess:** Should a new event type exist?
  - `TURN_UPDATED` — partial state change (artifact ready, but not done)
  - `WORKFLOW_PAUSED` — explicit pause signal
  - `TURN_FINALIZED` — reserved for truly complete turns only

**Files to investigate:**
- `src/core/execution/TurnEmitter.js` — event emission sites
- `src/core/execution/CognitivePipelineHandler.js` — when `TURN_FINALIZED` is emitted
- `ui/hooks/chat/usePortMessageHandler.ts` — `TURN_FINALIZED` handler
- Search codebase for: `emit.*TURN_FINALIZED`, `case "TURN_FINALIZED"`, `pipelineStatus`, `activeAiTurnId.*null`

**Deliverable:**
- List all scenarios where `TURN_FINALIZED` is emitted
- Document what each scenario expects UI to do
- Identify cases where event semantics conflict
- Propose cleaner event taxonomy (if needed)

---

**6. PERSISTENCE AND STATE MERGE FRAGILITY**
- Audit state merge logic in `usePortMessageHandler.ts`:
  - How does `{ ...existingAi, ...incoming }` behave when `incoming` has `undefined` fields?
  - Are there explicit checks to prevent overwriting valid state with `undefined`?
- Trace `pipelineStatus` persistence:
  - When is it written to IndexedDB? (search `SessionManager.persist`)
  - When is it read from IndexedDB? (search history loading)
  - Could it be lost between pause → resume → reconnect?
- **Verify:** History loading behavior:
  - When user reloads extension mid-workflow, does turn restore correctly?
  - Does `aiTurn.pipelineStatus` get restored from IndexedDB?
  - Does `currentSessionId` get adopted from restored turn?
- Check for schema validation:
  - Are there TypeScript types enforcing required fields in `TURN_FINALIZED` messages?
  - Does backend guarantee `pipelineStatus` is always included?
  - Could schema drift (backend changes) break UI assumptions?

**Files to investigate:**
- `ui/hooks/chat/usePortMessageHandler.ts` — state merge logic
- `src/persistence/SessionManager.js` — turn persistence and retrieval
- `ui/hooks/useHistoryLoader.ts` — history loading from IndexedDB
- `ui/types/index.ts` — `AiTurn` interface definition
- Search codebase for: `pipelineStatus`, `mergedAi`, `SessionManager.persist`, `getAiTurnById`

**Deliverable:**
- Document state merge behavior for all message types
- Identify fields that could be accidentally nullified
- Verify persistence guarantees for `pipelineStatus` across reloads
- Assess whether schema validation exists

---

Recommendation for Next Audit Phase
Add to audit prompt:
10. BACKEND-UI SCHEMA SYNCHRONIZATION

Map all fields in AiTurn TypeScript interface
For each field, verify it appears in:

SessionManager.persist() (write to IndexedDB)
GET_HISTORY_SESSION response (read from IndexedDB)
useChat.selectChat() hydration (map to UI state)
normalizeBackendRoundsToTurns() export (save to file)


Identify fields present in some but not all paths
Assess whether missing fields are bugs or intentional

Files to investigate:

src/persistence/SessionManager.js — what gets persisted
src/sw-entry.js — GET_HISTORY_SESSION handler
ui/hooks/chat/useChat.ts — history chat hydration
ui/utils/turn-helpers.ts — export normalization
ui/types/index.ts — canonical AiTurn interface
Search codebase for: rounds.push, const aiTurn:, SessionManager.persist

This would catch not just pipelineStatus, but any other fields suffering from the same hydration gap.

--

### Methodology Requirements

**For each objective:**
1. **Search first** — Use `SearchCodebase` or grep patterns to find all relevant code locations before reading files
2. **Read selectively** — Only read file sections containing the patterns you found (use offset/length parameters)
3. **Trace execution paths** — Map the flow from trigger → state change → persistence → UI update
4. **Document gaps** — Note where error handling is missing, where race conditions could occur, where assumptions aren't validated
5. **No fixes yet** — Only document issues and assess severity. Do NOT write patches or propose specific code changes.

**Evidence standards:**
- For each issue, cite specific file:line references
- For race conditions, provide concrete scenario that triggers the bug
- For missing features, show code path where the feature should exist but doesn't
- For semantic issues, quote conflicting comments or variable names

**Output format:**
- **Issue title** (one-line summary)
- **Severity:** Critical / High / Medium / Low
- **Files affected:** (list with line numbers if possible)
- **Current behavior:** (what happens now)
- **Expected behavior:** (what should happen)
- **Reproduction scenario:** (step-by-step user actions that trigger the issue)
- **Root cause:** (architectural problem, missing validation, incorrect assumption, etc.)
- **Notes:** (related issues, dependencies, unknowns)

---

### Constraints

- **Do NOT modify any code** — This is audit-only
- **Do NOT propose specific fixes** — Document problems, not solutions
- **Run tests/typecheck ONLY to verify current state** — Not to validate hypothetical changes
- **Prioritize session lifecycle and port management** — These affect core reliability
- **Assess optimization opportunities separately** — Mark them as "optimization" vs "bug"
- **If file is too large to read fully** — Use grep to find relevant sections first, then read those offsets
- **If you're uncertain about behavior** — Document it as "unknown/requires runtime testing" rather than speculating

---

### Success Criteria

You will have succeeded when you can answer:
1. **When and why does `currentSessionId` become stale?** (all scenarios documented)
2. **Can port messages route to wrong conversation?** (yes/no + proof)
3. **What happens if SW suspends during traversal pause?** (specific failure modes)
4. **Does message ordering matter, and is it guaranteed?** (documented assumptions vs reality)
5. **What does `TURN_FINALIZED` actually mean?** (semantic overload confirmed/denied)
6. **Are there redundant keepalive mechanisms?** (activity tracking overlap documented)
7. **Can state merges lose critical fields?** (`pipelineStatus` fragility confirmed/denied)

If you cannot answer any of these definitively, document **what additional information is needed** (runtime logging, user testing, architectural decision records, etc.).


**7. KEEPALIVE AND ACTIVITY TRACKING COHERENCE**
- Review the recent keepalive fixes:
  - `sw-entry.js` now ACKs `htos.keepalive` and `htos.activity`
  - `ConnectionHandler` calls `recordActivity()` on every port message
- **Verify:** Is activity tracking now redundant?
  - If every port message records activity, why send separate `htos.activity` messages?
  - Does `PortHealthManager` still send both `KEEPALIVE_PING` (port) and `htos.activity` (runtime message)?
- Trace `LifecycleManager` self-ping behavior:
  - Does it still send `htos.keepalive` to itself?
  - Given that port messages already update `lastActivity`, is self-ping still needed?
  - What scenarios require SW to stay alive when UI is disconnected?
- **Assess:** Activity signal consolidation:
  - Can `htos.activity` runtime messages be removed entirely?
  - Should `KEEPALIVE_PING` stop recording activity (just health check)?
  - Or should self-ping be removed if port traffic keeps SW alive?

**Files to investigate:**
- `ui/services/port-health-manager.ts` — ping and activity message sending
- `src/core/lifecycle-manager.js` — self-ping and `recordActivity` implementation
- `src/core/connection-handler.js` — where `recordActivity` is called
- `src/sw-entry.js` — message handlers for keepalive/activity
- Search codebase for: `recordActivity`, `htos.keepalive`, `htos.activity`, `KEEPALIVE_PING`, `lastActivity`

**Deliverable:**
- Map all activity recording call sites
- Identify redundant activity signals (multiple mechanisms doing same thing)
- Document when SW *should* stay alive vs when it can suspend
- Propose simplified keepalive strategy (if applicable)

---

### Secondary Objectives

**8. PRE-INITIALIZATION RACE CONDITIONS**
- Audit hooks that run before `isInitialized` barrier:
  - `useSmartProviderDefaults` accesses `chrome.storage` before `EXTENSION_ID` is set
  - `usePortMessageHandler` registers handler before initialization completes
- **Verify:** Can these cause errors or undefined behavior?
  - What if `chrome.runtime.id` is unavailable when `useSmartProviderDefaults` runs?
  - What if port messages arrive before `currentSessionId` is initialized?
- Check initialization order in `App.tsx`:
  - Which hooks run unconditionally vs after `isInitialized` check?
  - Are there dependencies between hooks that could race?

**Files to investigate:**
- `ui/App.tsx` — hook call order and initialization barrier
- `ui/hooks/providers/useSmartProviderDefaults.ts` — Chrome storage access timing
- `ui/hooks/chat/usePortMessageHandler.ts` — handler registration timing
- `ui/hooks/useInitialization.ts` — what sets `isInitialized` and when

**Deliverable:**
- List hooks that run before initialization barrier
- Identify Chrome API calls that could fail if extension ID unavailable
- Document expected vs actual initialization order
- Assess whether race conditions exist

---

**9. BROADCAST CHANNEL MISMATCH (MINOR)**
- Earlier investigation found:
  - `BusController` uses channel `"htos-bus-channel"`
  - `oi.js` (offscreen) may use different identifier
- **Verify:** Do these channels actually mismatch?
  - Read `src/oi.js` and check `BroadcastChannel` instantiation
  - Read `src/HTOS/BusController.js` (or wherever it's defined)
  - Are they using the same channel name?
- **Assess:** If mismatch exists, does it break functionality?
  - What messages are sent over this channel?
  - Does anything fail if offscreen can't receive bus messages?

**Files to investigate:**
- `src/oi.js` — offscreen script BroadcastChannel usage
- `src/HTOS/BusController.js` (or search for BusController definition)
- Search codebase for: `BroadcastChannel`, `htos-bus-channel`

**Deliverable:**
- Confirm whether channel name mismatch exists
- Document what breaks (if anything) when channels don't align
- Assess severity (critical vs cosmetic)

---

### Methodology Requirements

**For each objective:**
1. **Search first** — Use `SearchCodebase` or grep patterns to find all relevant code locations before reading files
2. **Read selectively** — Only read file sections containing the patterns you found (use offset/length parameters)
3. **Trace execution paths** — Map the flow from trigger → state change → persistence → UI update
4. **Document gaps** — Note where error handling is missing, where race conditions could occur, where assumptions aren't validated
5. **No fixes yet** — Only document issues and assess severity. Do NOT write patches or propose specific code changes.

**Evidence standards:**
- For each issue, cite specific file:line references
- For race conditions, provide concrete scenario that triggers the bug
- For missing features, show code path where the feature should exist but doesn't
- For semantic issues, quote conflicting comments or variable names

**Output format:**
- **Issue title** (one-line summary)
- **Severity:** Critical / High / Medium / Low
- **Files affected:** (list with line numbers if possible)
- **Current behavior:** (what happens now)
- **Expected behavior:** (what should happen)
- **Reproduction scenario:** (step-by-step user actions that trigger the issue)
- **Root cause:** (architectural problem, missing validation, incorrect assumption, etc.)
- **Notes:** (related issues, dependencies, unknowns)

---

### Constraints

- **Do NOT modify any code** — This is audit-only
- **Do NOT propose specific fixes** — Document problems, not solutions
- **Run tests/typecheck ONLY to verify current state** — Not to validate hypothetical changes
- **Prioritize session lifecycle and port management** — These affect core reliability
- **Assess optimization opportunities separately** — Mark them as "optimization" vs "bug"
- **If file is too large to read fully** — Use grep to find relevant sections first, then read those offsets
- **If you're uncertain about behavior** — Document it as "unknown/requires runtime testing" rather than speculating

---

### Success Criteria

You will have succeeded when you can answer:
1. **When and why does `currentSessionId` become stale?** (all scenarios documented)
2. **Can port messages route to wrong conversation?** (yes/no + proof)
3. **What happens if SW suspends during traversal pause?** (specific failure modes)
4. **Does message ordering matter, and is it guaranteed?** (documented assumptions vs reality)
5. **What does `TURN_FINALIZED` actually mean?** (semantic overload confirmed/denied)
6. **Are there redundant keepalive mechanisms?** (activity tracking overlap documented)
7. **Can state merges lose critical fields?** (`pipelineStatus` fragility confirmed/denied)

If you cannot answer any of these definitively, document **what additional information is needed** (runtime logging, user testing, architectural decision records, etc.).