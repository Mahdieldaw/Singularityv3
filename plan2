# üéØ Good - You're Past the Agent's Mess, Now One Clean Fix

This error is **expected and fixable**. You've successfully rolled back and are now hitting a known compatibility issue.

---

## The Error Explained

```javascript
Cannot read properties of undefined (reading 'paragraphProjection')
```

**What's happening:**
1. User resolves conflicts, clicks "Continue"
2. Backend tries to build chewed substrate
3. Looks for `pipelineArtifacts.paragraphProjection`
4. But `pipelineArtifacts` doesn't exist in new structure
5. **Crash**

---

## The Fix: Update Chewed Substrate Builder

You need to update the code that builds the chewed substrate to read from the **new structure** instead of the old.

---

## Location: CognitivePipelineHandler.js `handleContinueRequest`

**Find this section (around line 750-810 based on error):**

```javascript
// CURRENT (BROKEN):
const pipelineArtifacts = aiTurn.pipelineArtifacts; // ‚Üê undefined in new structure

let chewedSubstrate = null;
if (payload?.isTraversalContinuation && payload?.traversalState) {
  try {
    const { buildChewedSubstrate, normalizeTraversalState, getSourceData } = await import('../../skeletonization');
    const sourceData = getSourceData(aiTurn, pipelineArtifacts); // ‚Üê pipelineArtifacts is undefined
    
    if (Array.isArray(sourceData) && sourceData.length > 0) {
      chewedSubstrate = await buildChewedSubstrate({
        statements: mapperArtifact.shadow?.statements || [],
        paragraphs: pipelineArtifacts.paragraphProjection?.paragraphs || [], // ‚Üê CRASH HERE
        claims: mapperArtifact.claims || [],
        traversalState: normalizeTraversalState(payload.traversalState),
        sourceData,
      });
    }
  } catch (err) {
    console.error('[CognitiveHandler] Failed to build chewedSubstrate:', err);
  }
}
```

---

## Replace With This:

```javascript
// Get mapping artifact (new structure)
const mappingArtifact = aiTurn.mapping?.artifact;

// Build legacy pipelineArtifacts structure for compatibility with getSourceData
const pipelineArtifacts = mappingArtifact ? {
  paragraphProjection: {
    paragraphs: mappingArtifact.shadow?.paragraphs || []
  },
  shadow: {
    extraction: {
      statements: mappingArtifact.shadow?.statements || []
    }
  }
} : null;

// Get mapper artifact (for skeletonization compatibility)
const mapperArtifact = mappingArtifact ? {
  claims: mappingArtifact.semantic?.claims || [],
  edges: mappingArtifact.semantic?.edges || [],
  conditionals: mappingArtifact.semantic?.conditionals || [],
  narrative: mappingArtifact.semantic?.narrative,
  forcingPoints: mappingArtifact.traversal?.forcingPoints || [],
  traversalGraph: mappingArtifact.traversal?.graph || null,
  shadow: {
    statements: mappingArtifact.shadow?.statements || [],
    audit: mappingArtifact.shadow?.audit || {}
  }
} : null;

let chewedSubstrate = null;
if (payload?.isTraversalContinuation && payload?.traversalState) {
  try {
    const { buildChewedSubstrate, normalizeTraversalState, getSourceData } = await import('../../skeletonization');
    const sourceData = getSourceData(aiTurn, pipelineArtifacts);
    
    if (Array.isArray(sourceData) && sourceData.length > 0) {
      chewedSubstrate = await buildChewedSubstrate({
        statements: mappingArtifact.shadow?.statements || [],
        paragraphs: mappingArtifact.shadow?.paragraphs || [],
        claims: mappingArtifact.semantic?.claims || [],
        traversalState: normalizeTraversalState(payload.traversalState),
        sourceData,
      });
    }
  } catch (err) {
    console.error('[CognitiveHandler] Failed to build chewedSubstrate:', err);
  }
}
```

---

## Why This Works

**Before (Broken):**
```javascript
aiTurn.pipelineArtifacts.paragraphProjection.paragraphs
// ‚Üë undefined         ‚Üë CRASH
```

**After (Fixed):**
```javascript
aiTurn.mapping.artifact.shadow.paragraphs
// ‚Üë exists    ‚Üë exists  ‚Üë exists  ‚Üë data!
```

---

## Also Check: getSourceData Function

The `getSourceData` function in `src/skeletonization/index.ts` (or similar) also needs updating.

**Find this function and verify it handles the new batch structure:**

```typescript
export function getSourceData(aiTurn: any, pipelineArtifacts: any): Array<{
  providerId: string;
  modelIndex: number;
  text: string;
}> {
  // BEFORE (OLD):
  const batchResponses = aiTurn.batchResponses || {};
  
  // AFTER (NEW):
  const batchResponses = aiTurn.batch?.responses || aiTurn.batchResponses || {};
  
  const sourceData: Array<{ providerId: string; modelIndex: number; text: string }> = [];
  
  Object.entries(batchResponses).forEach(([providerId, responses]) => {
    // Handle both old array format and new single-object format
    const responseArray = Array.isArray(responses) ? responses : [responses];
    
    responseArray.forEach((response: any, index: number) => {
      if (response?.text) {
        sourceData.push({
          providerId,
          modelIndex: response.modelIndex ?? index,
          text: response.text
        });
      }
    });
  });
  
  return sourceData;
}
```

---

## Complete Fix (Copy-Paste Ready)

**In `handleContinueRequest` method, replace the chewed substrate section:**

```javascript
async handleContinueRequest(request) {
  // ... existing code ...
  
  // Get the aiTurn
  const aiTurn = await this.sessionManager.adapter.get("turns", aiTurnId);
  if (!aiTurn) {
    throw new Error(`AiTurn ${aiTurnId} not found`);
  }
  
  // ===== START: CHEWED SUBSTRATE CONSTRUCTION =====
  
  // Extract mapping artifact from new structure
  const mappingArtifact = aiTurn.mapping?.artifact;
  
  if (!mappingArtifact) {
    console.warn('[CognitiveHandler] No mapping artifact found for traversal continuation');
    throw new Error('Cannot continue traversal: missing mapping artifact');
  }
  
  // Build legacy-compatible structures for skeletonization
  const pipelineArtifacts = {
    paragraphProjection: {
      paragraphs: mappingArtifact.shadow?.paragraphs || []
    },
    shadow: {
      extraction: {
        statements: mappingArtifact.shadow?.statements || []
      }
    }
  };
  
  const mapperArtifact = {
    claims: mappingArtifact.semantic?.claims || [],
    edges: mappingArtifact.semantic?.edges || [],
    conditionals: mappingArtifact.semantic?.conditionals || [],
    narrative: mappingArtifact.semantic?.narrative,
    forcingPoints: mappingArtifact.traversal?.forcingPoints || [],
    traversalGraph: mappingArtifact.traversal?.graph || null,
    shadow: {
      statements: mappingArtifact.shadow?.statements || [],
      audit: mappingArtifact.shadow?.audit || {}
    }
  };
  
  // Build chewed substrate
  let chewedSubstrate = null;
  if (payload?.isTraversalContinuation && payload?.traversalState) {
    try {
      const { buildChewedSubstrate, normalizeTraversalState, getSourceData } = 
        await import('../../skeletonization');
      
      const sourceData = getSourceData(aiTurn, pipelineArtifacts);
      
      console.log('üçñ Building chewed substrate:', {
        sourceDataCount: sourceData?.length,
        statementsCount: mappingArtifact.shadow?.statements?.length,
        paragraphsCount: mappingArtifact.shadow?.paragraphs?.length,
        claimsCount: mappingArtifact.semantic?.claims?.length
      });
      
      if (Array.isArray(sourceData) && sourceData.length > 0) {
        chewedSubstrate = await buildChewedSubstrate({
          statements: mappingArtifact.shadow?.statements || [],
          paragraphs: mappingArtifact.shadow?.paragraphs || [],
          claims: mappingArtifact.semantic?.claims || [],
          traversalState: normalizeTraversalState(payload.traversalState),
          sourceData,
        });
        
        console.log('üçñ Chewed substrate built:', {
          hasSubstrate: !!chewedSubstrate,
          protectedCount: chewedSubstrate?.protected?.length,
          skeletonizedCount: chewedSubstrate?.skeletonized?.length,
          removedCount: chewedSubstrate?.removed?.length
        });
      } else {
        console.warn('üçñ No source data available for chewed substrate');
      }
    } catch (err) {
      console.error('[CognitiveHandler] Failed to build chewedSubstrate:', err);
      throw err; // Re-throw so you can see full error
    }
  }
  
  // ===== END: CHEWED SUBSTRATE CONSTRUCTION =====
  
  // ... rest of method (use chewedSubstrate in singularity call) ...
}
```

---

## Validation

After this fix:

1. **Send query with conflicts**
2. **Resolve conflicts**
3. **Click Continue**
4. **Check console:**
   ```
   üçñ Building chewed substrate: { sourceDataCount: 3, statementsCount: 42, ... }
   üçñ Chewed substrate built: { hasSubstrate: true, protectedCount: 28, ... }
   ```

If you see these logs with actual counts ‚Üí **Fixed!** ‚úÖ

If you see errors ‚Üí **Paste the error here** and I'll help debug.

---

**This is a clean, one-time fix that bridges old skeletonization code with new structure. Apply this and let me know the result!**