# Analysis: Agent's Investigation Findings

## What the Agent Found

### The Root Cause
```typescript
// CognitiveOutputRenderer.tsx - THREE conditions must ALL be true
const isAwaitingTraversal = aiTurn.pipelineStatus === 'awaiting_traversal';
const hasTraversalGraph = !!aiTurn.mapperArtifact?.traversalGraph && !!currentSessionId;
                                                                     ^^^^^^^^^^^^^^
                                                                     THIS WAS NULL!

if (isAwaitingTraversal && hasTraversalGraph) {
  return <TraversalGraphView ... />;
}
```

**The Bug:** `currentSessionId` was null because `MAPPER_ARTIFACT_READY` handler wasn't setting it. The SW correctly paused the pipeline, but the UI gate failed silently.

### What Was Fixed

| File | Change |
|------|--------|
| `usePortMessageHandler.ts` | Added sessionId adoption from `MAPPER_ARTIFACT_READY` |
| `connection-handler.js` | Added `pipelineStatus` to reconnection TURN_FINALIZED emission |

---

## Abnormalities/Code Smells Found (Not Fixed)

### 1. Fragile Turn State Merging

The agent noted multiple handlers updating the same turn with different merge strategies:

```typescript
// TURN_CREATED - creates optimistic turn
const newAiTurn = { id: aiTurnId, type: 'ai', ... };

// TURN_FINALIZED - merges into existing
const mergedAiTurn = { ...existingAi, ...turn.ai, pipelineStatus: turn.ai.pipelineStatus };

// MAPPER_ARTIFACT_READY - patches specific field
prev.set(existingId, { ...existing, mapperArtifact: msg.artifact });
```

**Risk:** If any handler runs out of order or misses, state becomes inconsistent.

---

### 2. History Load Missing pipelineStatus

The agent noted:
> "if they refresh, they might lose functionality in the traversal UI"

When loading history from persistence, `pipelineStatus` may not be preserved:

```typescript
// GET_HISTORY_SESSION response doesn't include pipelineStatus
rounds.push({
  userTurnId, aiTurnId, user, providers, mappingResponses,
  mapperArtifact: hydratedMapperArtifact,
  // pipelineStatus: ???  â† Not included
});
```

**Impact:** After page refresh, an `awaiting_traversal` turn would appear as complete.

---

### 3. Session ID Race Condition

Original code had problematic check:

```typescript
// Could prevent valid updates
if (!currentSessionId || currentSessionId === msgSessionId) {
  setCurrentSessionId(msgSessionId);
}
```

**Issue:** If `currentSessionId` was set to a different value before the artifact arrived, it wouldn't update.

---

### 4. Large Artifact Cloning Risk

The agent suspected:
> "The artifact might be too large, leading to structured cloning failures"

```typescript
// postMessage uses structured clone, which can fail on:
// - Functions
// - Circular references
// - Very large objects (memory limits)
port.postMessage({ mapperArtifact: hugeObject });
```

**Risk:** Silent failure if artifact contains non-cloneable data.

---

### 5. Dual Artifact Construction

There are two paths creating artifacts:

```javascript
// Path 1: Parse from raw text
parseMapperArtifact(rawMappingText)

// Path 2: Build traversal graph
buildTraversalGraph(assemblyResult)
```

**Unclear:** How these are merged, whether all fields from both sources end up in the final artifact.

---

### 6. Complex Memoization in CognitiveOutputRenderer

```typescript
// Multiple useMemo with similar dependencies
const visibleProviderIds = useMemo(() => { ... }, [aiTurn, selectedModels]);
const orbProviderIds = useMemo(() => { ... }, [mapperProviderId, visibleProviderIds]);
const orbVoiceProviderId = useMemo(() => { ... }, [mapperProviderId, aiTurn.mappingResponses, orbProviderIds]);
const isWorkflowSettled = useMemo(() => { ... }, [workflowProgress]);
const structuralAnalysis = useMemo(() => { ... }, [aiTurn.mapperArtifact]);
const problemStructure = useMemo(() => { ... }, [aiTurn.mapperArtifact]);
```

**Risk:** Cascade of recomputes, potential stale closures, hard to debug.

---

### 7. Inconsistent Pipeline Status Values

The agent searched for all `pipelineStatus` usages but didn't find a central enum:

```typescript
// Various places use string literals
'awaiting_traversal'
'complete'
'streaming'
undefined  // treated as complete
```

**Risk:** Typo in any location silently breaks gating.

---

### 8. Missing Error Boundaries in Traversal Flow

The agent noted the port communication has try/catch but errors may be swallowed:

```typescript
// TraversalGraphView.tsx
try {
  port.postMessage({ type: CONTINUE_COGNITIVE_WORKFLOW, ... });
} catch (error) {
  setSubmissionError('Failed to submit: ' + String(error));
}
```

**Issue:** If port is disconnected before catch, user sees generic error.

---

## Recommended Follow-Up Tasks

| Priority | Issue | Action |
|----------|-------|--------|
| **High** | History load missing pipelineStatus | Add to persistence and GET_HISTORY_SESSION |
| **High** | No pipelineStatus enum | Create shared enum, use everywhere |
| **Medium** | Fragile turn merging | Consolidate into single update handler |
| **Medium** | Large artifact cloning | Add serialization/size guards |
| **Low** | Complex memoization | Consider zustand or simpler state |
| **Low** | Missing error boundaries | Add React error boundary around TraversalGraphView |

---

## Summary

The agent correctly identified that `currentSessionId` not being set was the immediate cause. The fix is surgical and correct. However, the investigation revealed deeper architectural fragility in how turn state is managed across multiple asynchronous message handlers. The history persistence gap is the most likely source of future bugs.