## Comprehensive Refactor Plan: Implementing Real Fixes for Tasks 1-6, 10, and Remaining 11 Issues

---

## **Agent Prompt: Architectural Refactoring for State Synchronization, Schema Validation, and Data Integrity**

### **Context**
You are implementing **structural fixes** (not band-aids) to address recurring patterns of data loss, state desynchronization, and missing validation across a Chrome MV3 extension. Previous fixes addressed symptoms; this prompt targets root causes.

**Completed symptomatic fixes:**
- Task 7-9: Keepalive/activity tracking (resolved)
- Task 11 (partial): Depth truncation, port serialization, `pipelineStatus` merge (patched)

**Remaining structural work:**
- Tasks 1-6: Session lifecycle, port scoping, message ordering, traversal resume, event semantics, persistence fragility
- Task 10: Schema synchronization (backend ↔ UI)
- Task 11 (remaining): Centralized hydration, schema validation, serialization boundaries

---

## **TASK 1: SESSION STATE LIFECYCLE - Implement Explicit Reset and Validation**

### **Objective**
Prevent `currentSessionId` and `activeAiTurnId` from becoming stale across conversation switches, causing wrong-session routing and UI state corruption.

### **Root Cause Analysis**
**Current behavior:**
- Atoms are **set** on port messages but **never reset** on navigation
- No validation that message belongs to active session
- Stale atoms cause traversal gate failures, wrong context resolution

### **Required Implementation**

#### **1.1: Add Session Reset Hook**
```typescript
// NEW FILE: ui/hooks/useSessionLifecycle.ts

import { useEffect } from 'react';
import { useSetAtom } from 'jotai';
import { currentSessionIdAtom, activeAiTurnIdAtom } from '@/state/atoms';

/**
 * Resets session state when conversation changes.
 * Call this in ChatView, history navigation, "New Chat" handlers.
 */
export function useSessionReset() {
  const setCurrentSessionId = useSetAtom(currentSessionIdAtom);
  const setActiveAiTurnId = useSetAtom(activeAiTurnIdAtom);

  return () => {
    setCurrentSessionId(null);
    setActiveAiTurnId(null);
  };
}
```

**Where to integrate:**
- `ui/views/ChatView.tsx` — on mount, on conversation switch
- `ui/hooks/chat/useChat.ts` — in `selectChat()` before loading new session
- Any "New Chat" button handler

**Validation rule:**
```typescript
// In usePortMessageHandler.ts - BEFORE adopting session:
if (msgSessionId && currentSessionId && msgSessionId !== currentSessionId) {
  console.warn('[Session] Message for different session, resetting state');
  resetSession(); // Call new hook
}
```

#### **1.2: Add Session Validation Guard**
```typescript
// ui/hooks/chat/usePortMessageHandler.ts - MODIFY

// At top of message handler:
const validateMessage = (msg: PortMessage) => {
  const { sessionId: msgSessionId, aiTurnId: msgAiTurnId } = msg;
  
  // If we have an active session, message MUST match or be new turn
  if (currentSessionId && msgSessionId && msgSessionId !== currentSessionId) {
    // Exception: Allow if this is TURN_CREATED for new conversation
    if (msg.type !== 'TURN_CREATED') {
      console.warn('[Session] Ignoring message for inactive session', {
        current: currentSessionId,
        message: msgSessionId
      });
      return false;
    }
  }
  
  return true;
};

// In port message handler:
if (!validateMessage(message)) return;
```

#### **1.3: Test Coverage**
```typescript
// NEW FILE: ui/hooks/chat/__tests__/useSessionLifecycle.test.ts

describe('Session lifecycle', () => {
  test('resets state on conversation switch', () => {
    // Setup: active session A
    // Action: call resetSession()
    // Assert: atoms are null
  });
  
  test('rejects messages from wrong session', () => {
    // Setup: active session A
    // Action: receive message for session B
    // Assert: message ignored, warning logged
  });
  
  test('allows TURN_CREATED for new session', () => {
    // Setup: active session A
    // Action: receive TURN_CREATED for session B
    // Assert: session switches to B
  });
});
```

**Success Criteria:**
- [ ] Session resets on: New Chat click, history navigation, extension reopen
- [ ] Wrong-session messages rejected (except `TURN_CREATED`)
- [ ] No stale `currentSessionId` causing traversal gate failures
- [ ] Tests validate all reset triggers

**Files to modify:**
- `ui/hooks/useSessionLifecycle.ts` (new)
- `ui/hooks/chat/usePortMessageHandler.ts` (add validation)
- `ui/views/ChatView.tsx` (integrate reset hook)
- `ui/hooks/chat/useChat.ts` (call reset in `selectChat`)

---

## **TASK 2: PORT CONNECTION SCOPING - Session-Aware Port Management**

### **Objective**
Prevent message routing confusion when multiple workflows execute concurrently, and ensure port reconnect on SW suspension.

### **Root Cause Analysis**
**Current behavior:**
- `ensurePort()` creates **one global port** for all sessions
- No distinction between port health check vs. user activity
- `TraversalGraphView` creates **separate port** bypassing API

### **Required Implementation**

#### **2.1: Session-Scoped Port Registry**
```typescript
// ui/services/extension-api.ts - REFACTOR

class ExtensionAPI {
  private ports: Map<string, chrome.runtime.Port> = new Map();
  private reconnectAttempts: Map<string, number> = new Map();
  
  /**
   * Get or create port for specific session.
   * @param sessionId - Session identifier (use 'global' for system messages)
   */
  ensurePort(sessionId: string = 'global'): chrome.runtime.Port {
    const existing = this.ports.get(sessionId);
    if (existing && this.isPortAlive(existing)) {
      return existing;
    }
    
    // Create new port with session identifier
    const port = chrome.runtime.connect({ 
      name: `htos-${sessionId}` 
    });
    
    // Reconnect logic on disconnect
    port.onDisconnect.addListener(() => {
      this.ports.delete(sessionId);
      this.handleReconnect(sessionId);
    });
    
    this.ports.set(sessionId, port);
    return port;
  }
  
  private isPortAlive(port: chrome.runtime.Port): boolean {
    try {
      // Ports have no direct "is alive" check, use heuristic
      return port.name !== undefined && !chrome.runtime.lastError;
    } catch {
      return false;
    }
  }
  
  private handleReconnect(sessionId: string) {
    const attempts = this.reconnectAttempts.get(sessionId) || 0;
    if (attempts >= 3) {
      console.error('[Port] Max reconnect attempts reached', sessionId);
      return;
    }
    
    setTimeout(() => {
      console.log('[Port] Reconnecting...', sessionId);
      this.reconnectAttempts.set(sessionId, attempts + 1);
      this.ensurePort(sessionId); // Recursive reconnect
    }, Math.pow(2, attempts) * 1000); // Exponential backoff
  }
  
  /**
   * Close port when session ends (cleanup).
   */
  closePort(sessionId: string) {
    const port = this.ports.get(sessionId);
    if (port) {
      port.disconnect();
      this.ports.delete(sessionId);
      this.reconnectAttempts.delete(sessionId);
    }
  }
}
```

#### **2.2: Backend Port Handler Updates**
```javascript
// src/core/connection-handler.js - MODIFY

// Parse session ID from port name:
constructor(port) {
  this.port = port;
  this.sessionId = this.parseSessionId(port.name); // NEW
  // ... rest
}

parseSessionId(portName) {
  // portName format: 'htos-{sessionId}' or 'htos-global'
  const match = portName.match(/^htos-(.+)$/);
  return match ? match[1] : 'unknown';
}

// Validate messages match port's session:
handleUnifiedMessage(msg) {
  if (msg.sessionId && msg.sessionId !== this.sessionId) {
    console.warn('[ConnectionHandler] Message session mismatch', {
      port: this.sessionId,
      message: msg.sessionId
    });
    // Still process if sessionId is 'global' (system messages)
    if (this.sessionId !== 'global') return;
  }
  // ... rest of handler
}
```

#### **2.3: Fix TraversalGraphView Direct Port Creation**
```typescript
// ui/components/traversal/TraversalGraphView.tsx - REFACTOR

import { api } from '@/services/extension-api';

// BEFORE:
// const port = chrome.runtime.connect({ name: 'htos-traversal' });

// AFTER:
const sessionId = aiTurn.sessionId || 'unknown';
const port = api.ensurePort(sessionId); // Use centralized port management

// When sending continuation:
port.postMessage({
  type: 'CONTINUE_COGNITIVE_WORKFLOW',
  sessionId, // Include for backend validation
  // ... rest of payload
});
```

#### **2.4: Add Port Health Monitoring**
```typescript
// ui/hooks/usePortHealth.ts (new)

export function usePortHealth(sessionId: string) {
  useEffect(() => {
    const port = api.ensurePort(sessionId);
    
    const healthCheck = setInterval(() => {
      if (!api.isPortAlive(sessionId)) {
        console.warn('[Port] Dead port detected, reconnecting');
        api.ensurePort(sessionId); // Trigger reconnect
      }
    }, 15000);
    
    return () => clearInterval(healthCheck);
  }, [sessionId]);
}
```

#### **2.5: Test Coverage**
```typescript
// ui/services/__tests__/extension-api.test.ts

describe('Session-scoped ports', () => {
  test('creates separate ports for different sessions', () => {
    const portA = api.ensurePort('session-a');
    const portB = api.ensurePort('session-b');
    expect(portA.name).toBe('htos-session-a');
    expect(portB.name).toBe('htos-session-b');
  });
  
  test('reconnects on disconnect', async () => {
    const port = api.ensurePort('session-x');
    port.disconnect();
    await wait(1000); // Exponential backoff
    expect(api.ensurePort('session-x')).toBeDefined();
  });
  
  test('cleans up on session close', () => {
    api.ensurePort('session-y');
    api.closePort('session-y');
    expect(ports.get('session-y')).toBeUndefined();
  });
});
```

**Success Criteria:**
- [ ] Each session has isolated port (no cross-session message leaks)
- [ ] Automatic reconnect on SW suspension (3 retries, exponential backoff)
- [ ] TraversalGraphView uses centralized API (no direct `connect()`)
- [ ] Backend validates message session matches port session
- [ ] Tests cover: multi-session, reconnect, cleanup

**Files to modify:**
- `ui/services/extension-api.ts` (session-scoped registry)
- `ui/components/traversal/TraversalGraphView.tsx` (use centralized API)
- `ui/hooks/usePortHealth.ts` (new, health monitoring)
- `src/core/connection-handler.js` (session validation)

---

## **TASK 3: MESSAGE ORDERING AND IDEMPOTENCY**

### **Objective**
Handle out-of-order messages gracefully, prevent duplicate turn creation, validate message sequence assumptions.

### **Root Cause Analysis**
**Current behavior:**
- Code assumes strict order: `TURN_CREATED` → `MAPPER_ARTIFACT_READY` → `TURN_FINALIZED`
- No sequence numbers or timestamps
- Spread merge can overwrite valid state with stale data

### **Required Implementation**

#### **3.1: Add Message Sequencing**
```typescript
// shared/contract.ts - EXTEND

interface PortMessage {
  type: string;
  sequence?: number;        // Monotonic counter per session
  timestamp?: number;       // Sent time (ms since epoch)
  sessionId?: string;
  aiTurnId?: string;
  // ... rest
}
```

```javascript
// src/core/connection-handler.js - ADD

class ConnectionHandler {
  constructor(port) {
    this.port = port;
    this.messageSequence = 0;
    this.lastProcessedSequence = -1;
  }
  
  emit(type, payload) {
    const message = {
      ...payload,
      type,
      sequence: this.messageSequence++,
      timestamp: Date.now()
    };
    
    this.port.postMessage(message);
  }
  
  handleUnifiedMessage(msg) {
    // Detect out-of-order delivery
    if (msg.sequence !== undefined && msg.sequence <= this.lastProcessedSequence) {
      console.warn('[Message] Out-of-order or duplicate, ignoring', {
        received: msg.sequence,
        expected: this.lastProcessedSequence + 1
      });
      return;
    }
    
    this.lastProcessedSequence = msg.sequence || this.lastProcessedSequence;
    // ... rest of handler
  }
}
```

#### **3.2: State Merge with Defined-Only Fields**
```typescript
// ui/hooks/chat/usePortMessageHandler.ts - REFACTOR

// BEFORE:
const mergedAi = { ...existingAi, ...incoming };

// AFTER:
const mergedAi = {
  ...existingAi,
  ...Object.fromEntries(
    Object.entries(incoming).filter(([_, v]) => v !== undefined)
  )
};
```

**Or use explicit merge rules:**
```typescript
function mergeAiTurn(existing: AiTurn, incoming: Partial<AiTurn>): AiTurn {
  return {
    ...existing,
    ...(incoming.id !== undefined && { id: incoming.id }),
    ...(incoming.pipelineStatus !== undefined && { pipelineStatus: incoming.pipelineStatus }),
    ...(incoming.mapperArtifact !== undefined && { mapperArtifact: incoming.mapperArtifact }),
    // ... explicit for each field
  };
}
```

#### **3.3: Idempotent Turn Creation**
```javascript
// src/core/connection-handler.js - MODIFY

handleExecuteWorkflow(msg) {
  const { clientUserTurnId, clientAiTurnId } = msg;
  
  // Check if turn already exists (idempotency)
  const existing = await this.sessionManager.getAiTurnById(clientAiTurnId);
  if (existing) {
    console.log('[Workflow] Turn already exists, skipping creation');
    this.port.postMessage({
      type: 'TURN_ALREADY_EXISTS',
      aiTurnId: clientAiTurnId,
      turn: existing
    });
    return;
  }
  
  // ... proceed with creation
}
```

#### **3.4: Test Coverage**
```typescript
describe('Message ordering', () => {
  test('ignores out-of-order messages', () => {
    // Send: seq 1, 2, 3
    // Receive: seq 1, 3, 2 (out of order)
    // Assert: seq 2 ignored, warning logged
  });
  
  test('prevents duplicate turn creation', async () => {
    // Send: EXECUTE_WORKFLOW (clientAiTurnId: 'abc')
    // Send: EXECUTE_WORKFLOW again (same ID)
    // Assert: second request returns TURN_ALREADY_EXISTS
  });
  
  test('merge preserves existing fields when incoming undefined', () => {
    const existing = { id: '1', pipelineStatus: 'awaiting_traversal' };
    const incoming = { id: '1', mapperArtifact: {...} }; // No pipelineStatus
    const merged = mergeAiTurn(existing, incoming);
    expect(merged.pipelineStatus).toBe('awaiting_traversal'); // Preserved
  });
});
```

**Success Criteria:**
- [ ] All port messages include `sequence` and `timestamp`
- [ ] Out-of-order messages logged and ignored
- [ ] State merge never overwrites defined fields with `undefined`
- [ ] Duplicate turn creation returns existing turn (idempotent)
- [ ] Tests validate ordering, merge, idempotency

**Files to modify:**
- `shared/contract.ts` (add sequence/timestamp to PortMessage)
- `src/core/connection-handler.js` (sequencing, idempotency)
- `ui/hooks/chat/usePortMessageHandler.ts` (safe merge)

---

## **TASK 4: TRAVERSAL RESUME RELIABILITY**

### **Objective**
Ensure traversal continuation works after SW suspension, with proper error handling and user feedback.

### **Root Cause Analysis**
**Current behavior:**
- `TraversalGraphView` sends continuation via port (may be dead after 30s)
- No retry logic if message fails
- No user-facing error if backend doesn't respond

### **Required Implementation**

#### **4.1: Continuation with Retry Logic**
```typescript
// ui/components/traversal/TraversalGraphView.tsx - REFACTOR

const sendContinuation = async (resolutions: GateResolution[]) => {
  const sessionId = aiTurn.sessionId || 'unknown';
  const maxRetries = 3;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const port = api.ensurePort(sessionId); // Reconnects if needed
      
      const responsePromise = new Promise((resolve, reject) => {
        const timeout = setTimeout(() => reject(new Error('Timeout')), 10000);
        
        const handler = (msg: any) => {
          if (msg.type === 'CONTINUATION_ACK' && msg.aiTurnId === aiTurn.id) {
            clearTimeout(timeout);
            port.onMessage.removeListener(handler);
            resolve(msg);
          }
        };
        
        port.onMessage.addListener(handler);
      });
      
      port.postMessage({
        type: 'CONTINUE_COGNITIVE_WORKFLOW',
        sessionId,
        aiTurnId: aiTurn.id,
        resolutions,
        isTraversalContinuation: true
      });
      
      await responsePromise;
      console.log('[Traversal] Continuation sent successfully');
      return; // Success
      
    } catch (error) {
      console.warn(`[Traversal] Attempt ${attempt} failed:`, error);
      if (attempt === maxRetries) {
        throw new Error('Failed to send continuation after 3 attempts');
      }
      await new Promise(r => setTimeout(r, 1000 * attempt)); // Backoff
    }
  }
};
```

#### **4.2: Backend Continuation ACK**
```javascript
// src/core/execution/CognitivePipelineHandler.js - ADD

async handleContinueRequest(msg) {
  const { aiTurnId, resolutions } = msg;
  
  // Validate turn state
  const turn = await this.sessionManager.getAiTurnById(aiTurnId);
  if (!turn) {
    this.port.postMessage({
      type: 'CONTINUATION_ERROR',
      aiTurnId,
      error: 'Turn not found'
    });
    return;
  }
  
  if (turn.pipelineStatus !== 'awaiting_traversal') {
    this.port.postMessage({
      type: 'CONTINUATION_ERROR',
      aiTurnId,
      error: `Invalid state: ${turn.pipelineStatus}`
    });
    return;
  }
  
  // Send ACK immediately
  this.port.postMessage({
    type: 'CONTINUATION_ACK',
    aiTurnId
  });
  
  // Process continuation async
  await this.resumePipeline(turn, resolutions);
}
```

#### **4.3: UI Error Handling**
```typescript
// ui/components/traversal/TraversalGraphView.tsx - ADD

const [error, setError] = useState<string | null>(null);

// In render:
{error && (
  <Alert variant="destructive">
    <AlertTitle>Continuation Failed</AlertTitle>
    <AlertDescription>
      {error}
      <Button onClick={() => sendContinuation(resolutions)}>
        Retry
      </Button>
    </AlertDescription>
  </Alert>
)}
```

#### **4.4: Test Coverage**
```typescript
describe('Traversal resume', () => {
  test('retries on port disconnect', async () => {
    // Setup: port dies after first attempt
    // Action: sendContinuation()
    // Assert: 3 attempts made, succeeds on retry
  });
  
  test('shows error after max retries', async () => {
    // Setup: all attempts fail
    // Action: sendContinuation()
    // Assert: error message displayed with retry button
  });
  
  test('backend validates turn state before resume', async () => {
    // Setup: turn in 'complete' state (not awaiting_traversal)
    // Action: send CONTINUE_COGNITIVE_WORKFLOW
    // Assert: CONTINUATION_ERROR returned
  });
});
```

**Success Criteria:**
- [ ] Continuation retries 3x with exponential backoff
- [ ] Backend sends ACK before processing (avoid timeout perception)
- [ ] Backend validates turn state before resuming
- [ ] UI shows error with retry button on failure
- [ ] Tests validate retry, timeout, error handling

**Files to modify:**
- `ui/components/traversal/TraversalGraphView.tsx` (retry logic, error UI)
- `src/core/execution/CognitivePipelineHandler.js` (ACK, validation)

---

## **TASK 5: EVENT SEMANTIC CLARITY - Replace Overloaded `TURN_FINALIZED`**

### **Objective**
Eliminate dual semantics of `TURN_FINALIZED` (both "data ready" and "workflow complete"), introduce explicit event types.

### **Root Cause Analysis**
**Current behavior:**
- `TURN_FINALIZED` sent when artifact ready (traversal pause)
- Also sent when workflow complete
- UI can't distinguish states

### **Required Implementation**

#### **5.1: New Event Types**
```typescript
// shared/contract.ts - ADD

type WorkflowEvent = 
  | 'TURN_CREATED'           // Turn initialized, optimistic ID assigned
  | 'TURN_UPDATED'           // Partial state change (artifact ready, not done)
  | 'TURN_FINALIZED'         // Workflow complete, turn is canonical
  | 'WORKFLOW_PAUSED'        // Pipeline paused for user input
  | 'WORKFLOW_RESUMED'       // User provided input, resuming
  | 'WORKFLOW_COMPLETE'      // All processing finished
  | 'WORKFLOW_ERROR';        // Unrecoverable error
```

#### **5.2: Backend Event Emission**
```javascript
// src/core/execution/CognitivePipelineHandler.js - REFACTOR

// When artifact ready (traversal pause):
this.turnEmitter.emit('TURN_UPDATED', {
  aiTurnId,
  turn: {
    ...turn,
    pipelineStatus: 'awaiting_traversal',
    mapperArtifact: artifact
  }
});

this.turnEmitter.emit('WORKFLOW_PAUSED', {
  aiTurnId,
  reason: 'traversal_conflicts',
  data: { traversalGraph, forcingPoints }
});

// When workflow complete:
this.turnEmitter.emit('TURN_FINALIZED', {
  aiTurnId,
  turn: {
    ...turn,
    pipelineStatus: 'complete'
  }
});

this.turnEmitter.emit('WORKFLOW_COMPLETE', {
  aiTurnId
});
```

#### **5.3: UI Event Handlers**
```typescript
// ui/hooks/chat/usePortMessageHandler.ts - REFACTOR

case 'TURN_UPDATED':
  // Partial update, keep loading state
  updateAiTurn(msg.turn);
  break;

case 'WORKFLOW_PAUSED':
  // Show traversal UI, stop loading for now
  setIsLoading(false);
  updateAiTurn({ pipelineStatus: 'awaiting_traversal' });
  break;

case 'TURN_FINALIZED':
  // Workflow complete, final state
  updateAiTurn(msg.turn);
  setIsLoading(false);
  setActiveAiTurnId(null);
  break;

case 'WORKFLOW_COMPLETE':
  // All processing done, safe to cleanup
  setIsLoading(false);
  break;
```

#### **5.4: Backward Compatibility (Transition Period)**
```javascript
// src/core/execution/TurnEmitter.js - TEMPORARY

emit(type, payload) {
  this.bus.emit(type, payload);
  
  // LEGACY: Also emit old event names during transition
  if (type === 'TURN_UPDATED') {
    this.bus.emit('MAPPER_ARTIFACT_READY', payload); // Old name
  }
  if (type === 'WORKFLOW_PAUSED') {
    this.bus.emit('TURN_FINALIZED', { ...payload, legacy: true }); // Old behavior
  }
  
  // TODO: Remove after UI fully migrated
}
```

#### **5.5: Test Coverage**
```typescript
describe('Event semantics', () => {
  test('TURN_UPDATED sent on artifact ready', () => {
    // Action: mapping step completes
    // Assert: TURN_UPDATED emitted, loading continues
  });
  
  test('WORKFLOW_PAUSED sent on traversal conflicts', () => {
    // Action: conflicts detected
    // Assert: WORKFLOW_PAUSED emitted, UI stops loading
  });
  
  test('TURN_FINALIZED only sent on workflow complete', () => {
    // Action: full workflow completes
    // Assert: TURN_FINALIZED + WORKFLOW_COMPLETE emitted
  });
});
```

**Success Criteria:**
- [ ] Distinct events for: data update, pause, completion, error
- [ ] `TURN_FINALIZED` reserved for truly final state
- [ ] UI can distinguish "artifact ready" vs. "workflow done"
- [ ] Backward compatibility during transition
- [ ] Tests validate event emission timing

**Files to modify:**
- `shared/contract.ts` (new event types)
- `src/core/execution/CognitivePipelineHandler.js` (emit new events)
- `src/core/execution/TurnEmitter.js` (legacy compatibility)
- `ui/hooks/chat/usePortMessageHandler.ts` (handle new events)

---

## **TASK 6: PERSISTENCE MERGE FRAGILITY - Schema-Driven Validation**

### **Objective**
Prevent state corruption from unsafe merges, validate data against schema at serialization boundaries.

### **Root Cause Analysis**
**Current behavior:**
- Spread merge can overwrite fields with `undefined`
- No runtime validation that persisted data matches TypeScript types
- Schema drift causes silent failures

### **Required Implementation**

#### **6.1: Schema Validation with Zod**
```typescript
// shared/schemas.ts (NEW)

import { z } from 'zod';

export const MapperArtifactSchema = z.object({
  claims: z.array(ClaimSchema),
  edges: z.array(EdgeSchema),
  traversalGraph: z.object({
    tiers: z.array(TraversalTierSchema)
  }).optional(),
  forcingPoints: z.array(ForcingPointSchema).optional(),
  // ... all fields with validators
});

export const AiTurnSchema = z.object({
  id: z.string(),
  sessionId: z.string().optional(),
  pipelineStatus: z.enum(['running', 'awaiting_traversal', 'complete', 'error']).optional(),
  mapperArtifact: MapperArtifactSchema.optional(),
  // ... all fields
});

// Runtime validator
export function validateAiTurn(data: unknown): AiTurn {
  return AiTurnSchema.parse(data); // Throws on mismatch
}
```

#### **6.2: Validate at Serialization Boundaries**
```javascript
// src/persistence/SessionManager.js - ADD

const { validateAiTurn } = require('../../shared/schemas');

persist(sessionId, threadId, request) {
  // Validate before persisting
  try {
    validateAiTurn(request);
  } catch (error) {
    console.error('[Persistence] Schema validation failed:', error);
    // Either throw or sanitize invalid fields
  }
  
  // ... rest of persist logic
}
```

```typescript
// ui/hooks/chat/usePortMessageHandler.ts - ADD

import { validateAiTurn } from '@/shared/schemas';

case 'TURN_UPDATED':
case 'TURN_FINALIZED':
  try {
    const validated = validateAiTurn(msg.turn);
    updateAiTurn(validated);
  } catch (error) {
    console.error('[UI] Invalid turn data received:', error);
    // Show error to user or request re-fetch
  }
  break;
```

#### **6.3: Safe Merge Utility**
```typescript
// ui/utils/state-merge.ts (NEW)

/**
 * Merges partial updates without overwriting defined fields with undefined.
 * Only applies fields that are explicitly set in incoming data.
 */
export function safeMerge<T extends object>(
  existing: T,
  incoming: Partial<T>
): T {
  const merged = { ...existing };
  
  for (const [key, value] of Object.entries(incoming)) {
    if (value !== undefined) {
      (merged as any)[key] = value;
    }
  }
  
  return merged;
}
```

**Use in port handler:**
```typescript
const mergedAi = safeMerge(existingAi, msg.turn);
```

#### **6.4: Integration Tests**
```typescript
// __tests__/integration/persistence-round-trip.test.ts (NEW)

describe('Persistence round-trip', () => {
  test('turn survives save → reload with all fields', async () => {
    const originalTurn: AiTurn = {
      id: 'test-1',
      sessionId: 'sess-1',
      pipelineStatus: 'awaiting_traversal',
      mapperArtifact: {
        claims: [...],
        edges: [...],
        traversalGraph: { tiers: [...] }
      }
    };
    
    // Persist
    await sessionManager.persist('sess-1', 'thread-1', originalTurn);
    
    // Reload
    const session = await sessionManager.getHistorySession('sess-1');
    const loadedTurn = session.rounds[0].ai;
    
    // Validate
    expect(loadedTurn).toEqual(originalTurn); // Deep equality
    expect(loadedTurn.pipelineStatus).toBe('awaiting_traversal');
    expect(loadedTurn.mapperArtifact.traversalGraph).toBeDefined();
  });
  
  test('schema validation catches missing required fields', () => {
    const invalidTurn = { id: 'test-2' }; // Missing other fields
    
    expect(() => validateAiTurn(invalidTurn)).toThrow();
  });
});
```

**Success Criteria:**
- [ ] Zod schemas for all persisted types
- [ ] Runtime validation at: persistence write, port message receive, history load
- [ ] `safeMerge