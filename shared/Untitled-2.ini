# IDE Agent Prompt: V3 Mapper Refactor

```
## Overview

We are refactoring the Singularity cognitive pipeline from V2 (artifact-first, container-based display) to V3 (narrative-first, unified schema). This is a significant architectural change that simplifies the mapper output, removes container selection logic, and makes the narrative the primary user interface.

## The Core Conceptual Shift

V2 treated the MapperArtifact as the primary output, with structured cards and containers (Direct Answer, Comparison Matrix, Decision Tree, Exploration Space) selected based on query type and topology. The narrative was secondary.

V3 inverts this. The narrative is the primary display. Claims are embedded in the narrative as clickable anchors. The structured data exists for graph rendering and downstream processing, but users read prose, not cards.

## Schema Changes

### Old Schema (Remove)

The current MapperArtifact has:
- consensus.claims with support_count, dimension, applies_when, equifinal_with
- consensus.quality (resolved | conventional | deflected)
- consensus.strength
- outliers array separate from consensus
- tensions array
- dimensions_found
- topology label (high_confidence | dimensional | contested)
- Separate graph_topology with nodes and edges

### New Schema (Implement)

A single map structure with three arrays:

claims: id (claim_1, claim_2...), label (canonical label), text (full claim), supporters (model numbers array), type (factual | prescriptive | conditional | contested | speculative), role (anchor | branch | challenger | supplement), challenges (string or null)

edges: from (claim_id), to (claim_id), type (supports | conflicts | tradeoff | prerequisite)

ghosts: array of strings, or null

There is no separation between consensus and outliers. A claim with one supporter and a claim with five supporters are both just claims with different supporters arrays. The distinction is computed when needed from supporters.length.

There is no separate graph structure. Claims ARE the nodes. Edges ARE the edges. Node size derives from supporters.length. Edge styling derives from edge type.

Remove these fields entirely: dimension, applies_when, equifinal_with, consensus.quality, consensus.strength, dimensions_found, topology label. They are not used in V3.

## Mapper Prompt Changes

Replace the current mapper prompt with a split structure. The prompt is divided into two parts with model outputs in the middle.

The new prompt text is:

BEFORE:
"You are not a summarizer. You are the Epistemic Cartographer, and your mandate is the Incorruptible Distillation of Signal—preserving every Incommensurable insight while discarding only connective tissue that adds nothing to the answer.

Index the Singular Particulars (what only one source saw) and the Consensus Meridians (where paths converged). If a source provides a unique methodology or divergent conclusion, it is indispensable. If two signals reach the same end through different logic, they are distinct topographies—both preserved. If a signal proposes a different end-state entirely, it is a bifurcation of possibility.

Every distinct claim you identify receives a canonical label and sequential ID. That exact pairing—**[Label|claim_N]**—will bind your map to your narrative.

User query: [USER_PROMPT]

<model_outputs>
[MODEL_OUTPUTS_BLOCK]
</model_outputs>"

AFTER:
"Now distill what you found into two outputs: <map> and <narrative>.

THE MAP

<map>
A JSON object with three arrays:

claims: each carrying id, label (two to six words), text (the claim in one sentence), supporters (model numbers), type (factual | prescriptive | conditional | contested | speculative), role (anchor | branch | challenger | supplement), challenges (what premise this questions, or null).

edges: relationships between claims, each with from, to, and type (supports | conflicts | tradeoff | prerequisite).

ghosts: what no source addressed, or null.
</map>

THE NARRATIVE

<narrative>
Weave the claims into an insightful essay revealing the landscape, using **[Label|claim_N]** anchors throughout. Lead with what matters most given the shape of responses—convergence if settled, novel insight if prescriptive, tension if comparative.

Integrate challengers where they conceptually belong. Note agreement and divergence descriptively without endorsing either. Close with what remains uncharted, if anything does.
</narrative>"

## Parsing Changes

The parser for the mapper currently looks for separate sections: narrative_summary or raw_narrative, options_inventory, mapper_artifact, graph_topology.

Change it to parse for these two sections: map and narrative, but keep the robustness and variants and variations logic for different types of the same selectors

The map section contains JSON that should be parsed into the new schema. The narrative section contains prose with embedded anchors in the format **[Label|claim_N]**.

Write an anchor extraction function that finds all instances of **[Label|claim_N]** in the narrative and returns an array of {label, id, position} objects. Position is the character index where the anchor starts. This enables the UI to render anchors as clickable elements. i.e make them clickable

Update the parsing utilities to handle the new format and produce a ParsedMapperOutput type with: claims (array), edges (array), ghosts (array or null), narrative (string), anchors (extracted anchor positions).

## Container Selection Logic (Remove Entirely)

Find and remove all container selection logic. This includes:

The selectContainer function or equivalent that maps query type and topology to container type.

The four container types: Direct Answer, Decision Tree, Comparison Matrix, Exploration Space.

The gate logic that checks escape velocity, topology primacy, intent plus metadata combinations.

Query type classification for the purpose of container selection. If query type classification exists elsewhere for other purposes it can stay, but it should not drive display decisions.

The container-specific content builders that extract different fields for different containers.

Any UI components that render these four container types as distinct views.

## UI Changes

### Primary Display: Narrative

The narrative is now the main content the user sees. Render it as prose with the anchor patterns converted to interactive elements.

Each **[Label|claim_N]** in the narrative becomes a clickable chip or pill showing the label text. Clicking reveals the claim detail panel and enables selection for continuation.

The narrative text between anchors renders as normal prose.

### Metrics Ribbon

Keep the metrics ribbon but compute values from the new schema:

claim_count: claims.length
convergence_ratio: claims where supporters.length >= 2 divided by total claims
conflict_count: edges where type is conflicts
gap_count: ghosts.length or 0 if null

Remove any metrics that referenced the old schema fields like dimensions_found or topology labels.

### Graph Visualization

Update the force directed graph to render directly from claims and edges:

Nodes come from claims. Node id is claim.id, label is claim.label, size derives from claim.supporters.length.

Edges come from edges array directly. Style edges by type (conflicts, supports, tradeoff, prerequisite).

Remove any code that constructed graph data from the old separate graph_topology structure.

### Claim Detail Panel

When a user clicks an anchor or a node in the graph, show the claim detail panel with: label, full text, supporters (which model numbers), type, role, and challenges if present.

Include a selection action: "Select for continuation" that adds this claim to the selected claims array. i think we currently have some editable claims logic, it will intersect with this im not yet sure of the editing and adding comments logic as a whole yet but foor now just make sure user selected claims are passed along so the signal builder can work with them

### Selected Claims

Maintain a selectedClaims array in UI state. When the user chooses a continuation mode (Understand or Decide), pass this array to the continuation context. (same asvice as with the above point integrate into existing selection logic)


### Remove V2 Display Components

Remove all the container-specific code and components, but for now just comment out or put in a seperate file the relationship rivers logic as we may want to resuuse that, thats the logic that grouped the claims and outliers in boxes on the main ui, the bifurations, frame challenges, preserequsites, and complementary and independent anchors, they need not render anything yet. 

Remove container-specific view components.

Remove any display logic that organized claims into these categories for visual hierarchy, and the code that joined and rendered options and claims, for example.

## Type Definitions

Update the TypeScript interfaces:

update the MapperArtifact to be:

interface Claim {
  id: string;
  label: string;
  text: string;
  supporters: number[];
  type: 'factual' | 'prescriptive' | 'conditional' | 'contested' | 'speculative';
  role: 'anchor' | 'branch' | 'challenger' | 'supplement';
  challenges: string | null;
}

interface Edge {
  from: string;
  to: string;
  type: 'supports' | 'conflicts' | 'tradeoff' | 'prerequisite';
}

interface MapperOutput {
  claims: Claim[];
  edges: Edge[];
  ghosts: string[] | null;
}

interface ParsedMapperOutput extends MapperOutput {
  narrative: string;
  anchors: Array<{label: string; id: string; position: number}>;
}

Remove interfaces for: consensus structure, outliers as separate type, tensions, topology labels, graph_topology.

## Continuation Context Changes

When calling continuation modes (Understand or Decide), the context should include:

The full MapperOutput (implicict as i think we pass the mapers artifact but that one may have missed fields, we should update it to be the current structure) (claims, edges, ghosts)
The user's selectedClaims (array of claim ids)
The narrative text
Any user notes

Remove references to: container type, topology label, consensus vs outlier distinction in the context.

The continuation modes should treat all claims equally, weighted by user selection rather than by our categorization.

## Files Likely Affected

Mapper prompt construction: wherever the mapper system prompt is built /promptservic.ts
Parsing utilities: shared/parsing-utils.ts or similar
Type definitions: shared/contract.ts or type definition files
Container selection: src/core/cognitive/explore-computer.ts or similar
Content builders: ui/components/cognitive/content-builders.ts or similar
Artifact display components: ui/components/cognitive/
Graph rendering: wherever force directed graph is rendered
Continuation handlers: src/core/execution/CognitivePipelineHandler.js or similar

## Verification

After refactoring, verify:

The mapper prompt is split with model outputs in the middle.

The parser extracts map and narrative sections correctly.

Anchors are extracted from narrative and rendered as clickable elements.

The graph renders nodes from claims and edges from edges with no separate graph structure.

No container selection logic remains.

The metrics ribbon computes from the new schema.

Selected claims flow correctly to continuation modes.

All old schema fields are removed from type definitions.
```