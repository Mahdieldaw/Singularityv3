# Complete Refactor Specification

## Final Analysis Summary

Based on all files reviewed:

| Layer | Shadow Dependency | Changes Needed |
|-------|-------------------|----------------|
| **Structural Analysis** | Audit types only (`ShadowAudit`, `UnindexedStatement`) | NONE |
| **Traversal** | `ShadowStatement` type for evidence | Type import update |
| **Claim Assembly** | Resolves `sourceStatementIds` to objects | Update lookup logic |
| **Semantic Mapper** | Receives shadow as prompt input | Prompt text update |
| **Parsing Utils** | Format-agnostic ID validation | NONE |
| **V2-V1 Adapter** | Looks up by ID in array | NONE |

---

## Answers to Your Questions

### Q1: Alias vs Clean Break
**Answer: Hybrid** - New primary type + deprecated alias

```typescript
// New primary type
export interface ShadowParagraph { ... }

// Deprecated alias for gradual migration
/** @deprecated Use ShadowParagraph */
export type ShadowStatement = ShadowParagraph;
```

**Rationale:** TraversalState is the only direct type consumer. Clean break there, alias everywhere else for gradual migration.

### Q2: Evidence Collection in TraversalState
**Answer: Hybrid refs** - IDs + excerpt, not full text

```typescript
// Change from:
collectedEvidence: Map<string, ShadowStatement[]>;

// To:
collectedEvidence: Map<string, EvidenceRef[]>;

interface EvidenceRef {
  paragraphId: string;
  modelIndex: number;
  textExcerpt: string;  // First 200 chars
}
```

**Rationale:** Evidence is used as "user confirmed this" marker + display. Full paragraph text stays in shadow artifact.

### Q3: Confidence Field
**Answer: Keep internal-only**

```typescript
// Internal (for delta ranking)
interface InternalParagraph {
  // ... all fields
  _confidence: number;  // Max of sentence confidences
}

// External (to Semantic Mapper) - stripped
interface ShadowParagraphForSemantic {
  id: string;
  modelIndex: number;
  text: string;
  signals: SignalFlags;
  stanceHints: Stance[];
  // NO confidence
}
```

---

## Complete File Changes

### Phase 1: Shadow V3 Core

#### File 1: `src/shadow/ShadowExtractor.ts` (REPLACE)

```typescript
// ═══════════════════════════════════════════════════════════════════════════
// SHADOW EXTRACTOR - SHADOW MAPPER V3 (Paragraph-Level)
// ═══════════════════════════════════════════════════════════════════════════

import {
    Stance,
    SignalFlags,
    classifyStance,
    detectSignals,
    STANCE_PRIORITY,
    getStancePriority,
} from './StatementTypes';
import { isExcluded } from './ExclusionRules';

// ═══════════════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════════════

/**
 * V3 Primary Output: Paragraph-level extraction
 */
export interface ShadowParagraph {
    id: string;                    // "p_0", "p_1", ...
    modelIndex: number;
    text: string;                  // Full paragraph (NOT fragmented)
    
    signals: SignalFlags;          // Aggregated from sentences
    stanceHints: Stance[];         // All unique stances detected (hints, not verdicts)
    
    // For evidence display (not sent to Semantic)
    dominantStance: Stance;        // Highest-priority stance found
    
    excluded: boolean;
    exclusionReason?: string;
}

/**
 * @deprecated Use ShadowParagraph
 */
export type ShadowStatement = ShadowParagraph;

/**
 * Internal representation with debug fields
 */
interface InternalParagraph extends ShadowParagraph {
    _sentenceCount: number;
    _validSentenceCount: number;
    _wordCount: number;
    _confidence: number;           // For delta ranking
}

export interface ShadowExtractionResult {
    paragraphs: ShadowParagraph[];
    
    /** @deprecated Use paragraphs */
    statements: ShadowParagraph[];
    
    meta: {
        totalParagraphs: number;
        includedParagraphs: number;
        excludedParagraphs: number;
        byModel: Record<number, number>;
        signalCounts: {
            sequence: number;
            tension: number;
            conditional: number;
        };
        processingTimeMs: number;
        
        // V2 compat fields
        sentencesProcessed: number;
        candidatesProcessed: number;
        candidatesExcluded: number;
    };
}

// ═══════════════════════════════════════════════════════════════════════════
// TEXT PROCESSING
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Split text into paragraphs - SIMPLE double-newline split
 * Lists and structured content stay bundled with parent paragraph
 */
function splitIntoParagraphs(text: string): string[] {
    return text
        .split(/\n\n+/)
        .map(p => p.trim())
        .filter(p => p.length > 0);
}

/**
 * Split paragraph into sentences for analysis
 */
function splitIntoSentences(paragraph: string): string[] {
    // Protect abbreviations and decimals
    const protectedText = paragraph
        .replace(/\b(Mr|Mrs|Ms|Dr|Prof|Inc|Ltd|vs|etc|e\.g|i\.e)\./gi, '$1|||')
        .replace(/\b(\d+)\./g, '$1|||');

    const sentences = protectedText
        .split(/(?<=[.!?])\s+/)
        .map(s => s.replace(/\|\|\|/g, '.').trim())
        .filter(s => s.length > 0);

    return sentences;
}

/**
 * Check if sentence is substantive
 */
function isSubstantive(sentence: string): boolean {
    const words = sentence.split(/\s+/).filter(w => w.length > 0);
    if (words.length < 5) return false;

    const metaPatterns = [
        /^(sure|okay|yes|no|well|so|now)[,.]?\s/i,
        /^(let me|I'll|I will|I can|I would)\b/i,
        /^(here's|here is|this is|that's|that is)\s+(a|an|the|my)\s+(summary|overview|breakdown|list)/i,
        /\b(as I mentioned|as discussed|as noted)\b/i,
        /^(to summarize|in summary|in conclusion)\b/i,
    ];

    return !metaPatterns.some(p => p.test(sentence));
}

// ═══════════════════════════════════════════════════════════════════════════
// PARAGRAPH-LEVEL EXCLUSION
// ═══════════════════════════════════════════════════════════════════════════

interface ParagraphExclusion {
    excluded: boolean;
    reason?: string;
}

function checkParagraphExclusion(
    text: string, 
    validSentenceCount: number,
    totalSentenceCount: number
): ParagraphExclusion {
    const wordCount = text.split(/\s+/).length;
    
    // Too short overall
    if (wordCount < 10) {
        return { excluded: true, reason: 'too_short' };
    }
    
    // All sentences were excluded by stance rules
    if (validSentenceCount === 0 && totalSentenceCount > 0) {
        return { excluded: true, reason: 'all_sentences_excluded' };
    }
    
    // Pure code block
    if (/^```/.test(text.trim())) {
        return { excluded: true, reason: 'code_block' };
    }
    
    // Short header only
    if (/^#{1,6}\s+.{0,50}$/.test(text.trim()) && wordCount < 10) {
        return { excluded: true, reason: 'header_only' };
    }
    
    return { excluded: false };
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN EXTRACTION
// ═══════════════════════════════════════════════════════════════════════════

export function extractShadowParagraphs(
    responses: Array<{ modelIndex: number; content: string }>
): ShadowExtractionResult {
    const startTime = performance.now();
    
    const internalParagraphs: InternalParagraph[] = [];
    let idCounter = 0;
    let sentencesProcessed = 0;
    let candidatesProcessed = 0;
    let candidatesExcluded = 0;

    for (const response of responses) {
        const paragraphs = splitIntoParagraphs(response.content);

        for (const paragraphText of paragraphs) {
            const sentences = splitIntoSentences(paragraphText);
            
            // Analyze each sentence
            const stanceSet = new Set<Stance>();
            const signalAgg: SignalFlags = { sequence: false, tension: false, conditional: false };
            let validCount = 0;
            let maxConfidence = 0;
            let highestPriorityStance: Stance = 'assertive';
            let highestPriority = 0;

            for (const sentence of sentences) {
                sentencesProcessed++;
                
                if (!isSubstantive(sentence)) continue;
                candidatesProcessed++;

                const { stance, confidence } = classifyStance(sentence);

                // Apply V2 stance-aware exclusion rules
                if (isExcluded(sentence, stance)) {
                    candidatesExcluded++;
                    continue;
                }

                validCount++;
                stanceSet.add(stance);
                
                // Track highest priority stance
                const priority = getStancePriority(stance);
                if (priority > highestPriority) {
                    highestPriority = priority;
                    highestPriorityStance = stance;
                }
                
                // Aggregate signals (OR)
                const sig = detectSignals(sentence);
                if (sig.sequence) signalAgg.sequence = true;
                if (sig.tension) signalAgg.tension = true;
                if (sig.conditional) signalAgg.conditional = true;
                
                maxConfidence = Math.max(maxConfidence, confidence);
            }

            // Check paragraph-level exclusion
            const exclusion = checkParagraphExclusion(
                paragraphText,
                validCount,
                sentences.length
            );

            internalParagraphs.push({
                id: `p_${idCounter++}`,
                modelIndex: response.modelIndex,
                text: paragraphText,
                signals: signalAgg,
                stanceHints: Array.from(stanceSet),
                dominantStance: highestPriorityStance,
                excluded: exclusion.excluded,
                exclusionReason: exclusion.reason,
                
                // Internal fields
                _sentenceCount: sentences.length,
                _validSentenceCount: validCount,
                _wordCount: paragraphText.split(/\s+/).length,
                _confidence: maxConfidence,
            });
        }
    }

    // Build external output (strip internal fields)
    const paragraphs: ShadowParagraph[] = internalParagraphs.map(p => ({
        id: p.id,
        modelIndex: p.modelIndex,
        text: p.text,
        signals: p.signals,
        stanceHints: p.stanceHints,
        dominantStance: p.dominantStance,
        excluded: p.excluded,
        exclusionReason: p.exclusionReason,
    }));

    const meta = buildMeta(
        internalParagraphs,
        performance.now() - startTime,
        sentencesProcessed,
        candidatesProcessed,
        candidatesExcluded
    );

    return {
        paragraphs,
        statements: paragraphs,  // Alias for V2 compat
        meta,
    };
}

/** @deprecated Use extractShadowParagraphs */
export const extractShadowStatements = extractShadowParagraphs;

// ═══════════════════════════════════════════════════════════════════════════
// METADATA
// ═══════════════════════════════════════════════════════════════════════════

function buildMeta(
    paragraphs: InternalParagraph[],
    processingTimeMs: number,
    sentencesProcessed: number,
    candidatesProcessed: number,
    candidatesExcluded: number
): ShadowExtractionResult['meta'] {
    const byModel: Record<number, number> = {};
    const signalCounts = { sequence: 0, tension: 0, conditional: 0 };
    let includedCount = 0;
    let excludedCount = 0;

    for (const p of paragraphs) {
        byModel[p.modelIndex] = (byModel[p.modelIndex] || 0) + 1;
        
        if (p.excluded) {
            excludedCount++;
        } else {
            includedCount++;
            if (p.signals.sequence) signalCounts.sequence++;
            if (p.signals.tension) signalCounts.tension++;
            if (p.signals.conditional) signalCounts.conditional++;
        }
    }

    return {
        totalParagraphs: paragraphs.length,
        includedParagraphs: includedCount,
        excludedParagraphs: excludedCount,
        byModel,
        signalCounts,
        processingTimeMs,
        sentencesProcessed,
        candidatesProcessed,
        candidatesExcluded,
    };
}

// ═══════════════════════════════════════════════════════════════════════════
// UTILITIES
// ═══════════════════════════════════════════════════════════════════════════

export function getIncludedParagraphs(
    paragraphs: ShadowParagraph[]
): ShadowParagraph[] {
    return paragraphs.filter(p => !p.excluded);
}

export function filterBySignals(
    paragraphs: ShadowParagraph[],
    required: Partial<SignalFlags>
): ShadowParagraph[] {
    return paragraphs.filter(p => {
        if (required.sequence && !p.signals.sequence) return false;
        if (required.tension && !p.signals.tension) return false;
        if (required.conditional && !p.signals.conditional) return false;
        return true;
    });
}

export function filterByModel(
    paragraphs: ShadowParagraph[],
    modelIndex: number
): ShadowParagraph[] {
    return paragraphs.filter(p => p.modelIndex === modelIndex);
}

export function filterByStanceHint(
    paragraphs: ShadowParagraph[],
    stance: Stance
): ShadowParagraph[] {
    return paragraphs.filter(p => p.stanceHints.includes(stance));
}

// V2 Compat aliases
export const filterByStance = filterByStanceHint;
export const filterByConfidence = (paragraphs: ShadowParagraph[], _min: number = 0.7) => paragraphs;
```

#### File 2: `src/shadow/ShadowDelta.ts` (UPDATE)

```typescript
// ═══════════════════════════════════════════════════════════════════════════
// SHADOW DELTA - SHADOW MAPPER V3 (Paragraph-Level)
// ═══════════════════════════════════════════════════════════════════════════

import { Stance, computeSignalWeight } from './StatementTypes';
import { ShadowParagraph, ShadowExtractionResult } from './ShadowExtractor';

// ═══════════════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════════════

export interface UnreferencedParagraph {
    paragraph: ShadowParagraph;
    queryRelevance: number;
    signalWeight: number;
    adjustedScore: number;
}

/** @deprecated Use UnreferencedParagraph */
export type UnreferencedStatement = UnreferencedParagraph;
export type UnindexedStatement = UnreferencedParagraph;

export interface ShadowAudit {
    shadowStatementCount: number;  // V2 compat name
    referencedCount: number;
    unreferencedCount: number;
    highSignalUnreferencedCount: number;
    byStance: Record<Stance, { total: number; unreferenced: number }>;
    gaps: {
        conflicts: number;
        prerequisites: number;
        prescriptive: number;
    };
    extraction: {
        survivalRate: number;
        pass1Candidates: number;
    };
    primaryCounts: {
        claims: number;
    };
}

export interface ShadowDeltaResult {
    unreferenced: UnreferencedParagraph[];
    audit: ShadowAudit;
    processingTimeMs: number;
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN DELTA
// ═══════════════════════════════════════════════════════════════════════════

export function computeShadowDelta(
    shadowResult: ShadowExtractionResult,
    referencedIds: Set<string>,
    userQuery: string
): ShadowDeltaResult {
    const startTime = performance.now();

    // Use paragraphs (V3) or statements (V2 compat)
    const allParagraphs = shadowResult.paragraphs ?? shadowResult.statements ?? [];
    const included = allParagraphs.filter(p => !p.excluded);

    const byStance: Record<Stance, { total: number; unreferenced: number }> = {
        prescriptive: { total: 0, unreferenced: 0 },
        cautionary: { total: 0, unreferenced: 0 },
        prerequisite: { total: 0, unreferenced: 0 },
        dependent: { total: 0, unreferenced: 0 },
        assertive: { total: 0, unreferenced: 0 },
        uncertain: { total: 0, unreferenced: 0 },
    };

    const unreferenced: UnreferencedParagraph[] = [];

    for (const paragraph of included) {
        // Count by dominant stance (V3) or single stance (V2 compat)
        const stance = paragraph.dominantStance ?? 
                       (paragraph.stanceHints?.[0]) ?? 
                       (paragraph as any).stance ?? 
                       'assertive';
        
        byStance[stance].total++;

        if (!referencedIds.has(paragraph.id)) {
            byStance[stance].unreferenced++;

            const queryRelevance = computeQueryRelevance(paragraph.text, userQuery);
            const signalWeight = computeSignalWeight(paragraph.signals);
            
            // Adjusted score for ranking
            const adjustedScore = (1 + queryRelevance) * (1 + signalWeight * 0.2);

            unreferenced.push({
                paragraph,
                queryRelevance,
                signalWeight,
                adjustedScore,
            });
        }
    }

    unreferenced.sort((a, b) => b.adjustedScore - a.adjustedScore);

    const highSignalUnreferencedCount = unreferenced.filter(u => u.signalWeight > 0).length;

    const gaps = {
        conflicts: unreferenced.filter(u => u.paragraph.signals.tension).length,
        prerequisites: unreferenced.filter(u => 
            u.paragraph.stanceHints?.includes('prerequisite') ||
            u.paragraph.stanceHints?.includes('dependent') ||
            u.paragraph.signals.sequence
        ).length,
        prescriptive: byStance.prescriptive.unreferenced + byStance.cautionary.unreferenced,
    };

    const totalParagraphs = allParagraphs.length;

    return {
        unreferenced,
        audit: {
            shadowStatementCount: totalParagraphs,
            referencedCount: included.length - unreferenced.length,
            unreferencedCount: unreferenced.length,
            highSignalUnreferencedCount,
            byStance,
            gaps,
            primaryCounts: {
                claims: referencedIds.size,
            },
            extraction: {
                survivalRate: totalParagraphs > 0
                    ? included.length / totalParagraphs
                    : 0,
                pass1Candidates: shadowResult.meta?.candidatesProcessed ?? 0,
            }
        },
        processingTimeMs: performance.now() - startTime,
    };
}

// ═══════════════════════════════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════════════════════════════

const STOP_WORDS = new Set([
    'the', 'and', 'for', 'are', 'but', 'not', 'you', 'with',
    'this', 'that', 'can', 'will', 'what', 'when', 'where',
    'how', 'why', 'who', 'which', 'their', 'there', 'than',
    'then', 'them', 'these', 'those', 'have', 'has', 'had',
    'was', 'were', 'been', 'being', 'from', 'they', 'she',
    'would', 'could', 'should', 'about', 'into', 'through',
    'your', 'just', 'some', 'also', 'very', 'more', 'most',
]);

function extractSignificantWords(text: string): Set<string> {
    const normalized = text
        .toLowerCase()
        .replace(/[^\w\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();

    const words = normalized.split(' ').filter(w =>
        w.length >= 3 && !STOP_WORDS.has(w)
    );

    return new Set(words);
}

function computeQueryRelevance(paragraphText: string, queryText: string): number {
    const paragraphWords = extractSignificantWords(paragraphText);
    const queryWords = extractSignificantWords(queryText);

    if (paragraphWords.size === 0 || queryWords.size === 0) return 0;

    let overlap = 0;
    paragraphWords.forEach(word => {
        if (queryWords.has(word)) overlap++;
    });

    return overlap / queryWords.size;
}

// ═══════════════════════════════════════════════════════════════════════════
// OUTPUT HELPERS
// ═══════════════════════════════════════════════════════════════════════════

export function getTopUnreferenced(
    delta: ShadowDeltaResult,
    limit: number = 10
): UnreferencedParagraph[] {
    return delta.unreferenced.slice(0, limit);
}

export function getHighSignalUnreferenced(
    delta: ShadowDeltaResult,
    minSignalWeight: number = 2
): UnreferencedParagraph[] {
    return delta.unreferenced.filter(u => u.signalWeight >= minSignalWeight);
}

export function getUnreferencedByStance(
    delta: ShadowDeltaResult,
    stance: Stance
): UnreferencedParagraph[] {
    return delta.unreferenced.filter(u => 
        u.paragraph.stanceHints?.includes(stance) ||
        u.paragraph.dominantStance === stance
    );
}

export function formatUnreferencedForPrompt(
    unreferenced: UnreferencedParagraph[],
    limit: number = 5
): string {
    if (unreferenced.length === 0) return '';

    const top = unreferenced.slice(0, limit);

    let output = '## Additional Context (not in main analysis)\n\n';
    output += 'These paragraphs were extracted but not used in claims:\n\n';

    for (const u of top) {
        const signalTags = [];
        if (u.paragraph.signals.sequence) signalTags.push('SEQ');
        if (u.paragraph.signals.tension) signalTags.push('TENS');
        if (u.paragraph.signals.conditional) signalTags.push('COND');

        const tags = signalTags.length > 0 ? ` [${signalTags.join(',')}]` : '';
        const stances = u.paragraph.stanceHints?.join(',') || u.paragraph.dominantStance || '';
        const displayText = u.paragraph.text.length > 200
            ? u.paragraph.text.substring(0, 200) + '...'
            : u.paragraph.text;

        output += `- (${stances}${tags}) Model ${u.paragraph.modelIndex}: "${displayText}"\n`;
    }

    return output;
}

export function formatAuditSummary(delta: ShadowDeltaResult): string {
    const { audit } = delta;

    let summary = `Shadow Delta Audit:\n`;
    summary += `  Total paragraphs: ${audit.shadowStatementCount}\n`;
    summary += `  Referenced in claims: ${audit.referencedCount}\n`;
    summary += `  Unreferenced: ${audit.unreferencedCount}\n`;
    summary += `  High-signal unreferenced: ${audit.highSignalUnreferencedCount}\n`;
    summary += `\n  By stance:\n`;

    for (const [stance, counts] of Object.entries(audit.byStance)) {
        const percent = counts.total > 0
            ? Math.round((counts.unreferenced / counts.total) * 100)
            : 0;
        summary += `    ${stance}: ${counts.unreferenced}/${counts.total} (${percent}% unreferenced)\n`;
    }

    return summary;
}

/**
 * Extract referenced IDs from semantic mapper claims
 * Works with both V2 (sourceStatementIds) and V3 (sourceParagraphIds) fields
 */
export function extractReferencedIds(
    claims: Array<{ sourceStatementIds?: string[]; sourceParagraphIds?: string[] }>
): Set<string> {
    const ids = new Set<string>();

    for (const claim of claims) {
        // V2 field name
        if (claim.sourceStatementIds) {
            for (const id of claim.sourceStatementIds) {
                ids.add(id);
            }
        }
        // V3 field name (future compat)
        if (claim.sourceParagraphIds) {
            for (const id of claim.sourceParagraphIds) {
                ids.add(id);
            }
        }
    }

    return ids;
}
```

#### File 3: `src/shadow/index.ts` (UPDATE)

```typescript
// ═══════════════════════════════════════════════════════════════════════════
// SHADOW MAPPER V3 - MODULE INDEX
// ═══════════════════════════════════════════════════════════════════════════

import { STANCE_PATTERNS, SIGNAL_PATTERNS } from './StatementTypes';
import { EXCLUSION_RULES } from './ExclusionRules';

// ═══════════════════════════════════════════════════════════════════════════
// INITIALIZATION
// ═══════════════════════════════════════════════════════════════════════════

let _initialized = false;

export function initializeShadowMapper(): void {
    if (_initialized) return;

    Object.freeze(STANCE_PATTERNS);
    Object.freeze(SIGNAL_PATTERNS);
    Object.freeze(EXCLUSION_RULES);

    for (const patterns of Object.values(STANCE_PATTERNS)) {
        Object.freeze(patterns);
    }

    for (const patterns of Object.values(SIGNAL_PATTERNS)) {
        Object.freeze(patterns);
    }

    for (const rule of EXCLUSION_RULES) {
        Object.freeze(rule);
        Object.freeze(rule.appliesTo);
    }

    _initialized = true;
    if (process.env.NODE_ENV !== 'production') {
        console.log('[Shadow V3] Pattern definitions locked. Guardrail active.');
    }
}

initializeShadowMapper();

// ═══════════════════════════════════════════════════════════════════════════
// TYPE EXPORTS
// ═══════════════════════════════════════════════════════════════════════════

// V3 Primary Types
export type {
    ShadowParagraph,
    ShadowExtractionResult,
} from './ShadowExtractor';

export type {
    UnreferencedParagraph,
    ShadowAudit,
    ShadowDeltaResult,
} from './ShadowDelta';

// Shared Types
export type {
    Stance,
    SignalPatterns,
} from './StatementTypes';

export type {
    ExclusionRule,
} from './ExclusionRules';

// ═══════════════════════════════════════════════════════════════════════════
// V2 COMPATIBILITY ALIASES (Deprecated)
// ═══════════════════════════════════════════════════════════════════════════

/** @deprecated Use ShadowParagraph */
export type { ShadowStatement } from './ShadowExtractor';

/** @deprecated Use UnreferencedParagraph */
export type { UnreferencedStatement, UnindexedStatement } from './ShadowDelta';

/** @deprecated Use ShadowExtractionResult */
export type TwoPassResult = import('./ShadowExtractor').ShadowExtractionResult;

/** @deprecated Use ShadowDeltaResult */
export type DeltaResult = import('./ShadowDelta').ShadowDeltaResult;

// ═══════════════════════════════════════════════════════════════════════════
// FUNCTION EXPORTS
// ═══════════════════════════════════════════════════════════════════════════

// Constants
export {
    STANCE_PRIORITY,
    STANCE_PATTERNS,
    SIGNAL_PATTERNS,
} from './StatementTypes';

export {
    EXCLUSION_RULES,
} from './ExclusionRules';

// StatementTypes Functions
export {
    getStancePatterns,
    getStancePriority,
    getSignalPatterns,
    classifyStance,
    detectSignals,
    computeSignalWeight,
} from './StatementTypes';

// ExclusionRules Functions
export {
    isExcluded,
    getExclusionViolations,
} from './ExclusionRules';

// V3 Primary Functions
export {
    extractShadowParagraphs,
    getIncludedParagraphs,
    filterBySignals,
    filterByModel,
    filterByStanceHint,
} from './ShadowExtractor';

// Delta Functions
export {
    computeShadowDelta,
    getTopUnreferenced,
    getHighSignalUnreferenced,
    getUnreferencedByStance,
    formatUnreferencedForPrompt,
    formatAuditSummary,
    extractReferencedIds,
} from './ShadowDelta';

// ═══════════════════════════════════════════════════════════════════════════
// V2 COMPATIBILITY FUNCTION ALIASES (Deprecated)
// ═══════════════════════════════════════════════════════════════════════════

/** @deprecated Use extractShadowParagraphs */
export { extractShadowStatements } from './ShadowExtractor';

/** @deprecated Use extractShadowParagraphs */
export { extractShadowParagraphs as executeShadowExtraction } from './ShadowExtractor';

/** @deprecated Use computeShadowDelta */
export { computeShadowDelta as executeShadowDelta } from './ShadowDelta';

/** @deprecated Use filterByStanceHint */
export { filterByStance, filterByConfidence } from './ShadowExtractor';
```

---

### Phase 2: Semantic Mapper Update

#### File 4: `src/ConciergeService/semanticMapper.ts` (UPDATE)

Key changes to the prompt builder:

```typescript
// ═══════════════════════════════════════════════════════════════════════════
// SEMANTIC MAPPER - PROMPT BUILDER (V3 Update)
// ═══════════════════════════════════════════════════════════════════════════

import { ShadowParagraph } from '../shadow';
import { SemanticMapperOutput } from './contract';
import {
  parseSemanticMapperOutput as baseParseOutput
} from '../../shared/parsing-utils';

// ═══════════════════════════════════════════════════════════════════════════
// PROMPT BUILDER
// ═══════════════════════════════════════════════════════════════════════════

export function buildSemanticMapperPrompt(
  userQuery: string,
  shadowParagraphs: ShadowParagraph[]
): string {

  // Filter to included only
  const included = shadowParagraphs.filter(p => !p.excluded);

  // Group by model
  const groupedByModel: Record<string, Array<{
    id: string;
    text: string;
    stances: string[];
    signals: string[];
  }>> = {};

  for (const para of included) {
    const key = `model_${para.modelIndex}`;
    const signals: string[] = [];
    if (para.signals.tension) signals.push('TENS');
    if (para.signals.sequence) signals.push('SEQ');
    if (para.signals.conditional) signals.push('COND');

    if (!groupedByModel[key]) groupedByModel[key] = [];
    groupedByModel[key].push({
      id: para.id,
      text: para.text,
      stances: para.stanceHints || [para.dominantStance],
      signals
    });
  }

  const paragraphBlock = JSON.stringify(groupedByModel, null, 2);

  return `Semantic Cartographer — Descriptive Core Prompt
You find yourself standing in a landscape made entirely of positions.
Each position is an island — an idea that could stand on its own, be rejected, or be held only if certain things are true.

Your task is to reveal this landscape.

You are given a set of **paragraphs** extracted from multiple model responses.
Each paragraph may contain multiple related ideas from a single model's perspective.
Stance hints and signals are provided as context, but YOU determine the true meaning.

Your first job is to discover the islands:
Identify distinct positions within and across paragraphs, grouping them into claims.
Name each claim with a short verb phrase — something that could be accepted, rejected, or conditioned.

Your second job is to trace the threads:
• When a claim only applies if some condition is true, that is a conditional gate.
• When a claim's validity depends on another claim being true, that is a prerequisite gate.
• When the conditions of one claim prevent another from surviving, that is a conflict.

For every gate or conflict you identify, ask the question that would resolve it.
Not abstractly — as a human decision would actually be made.

You do not choose paths.
You do not collapse the landscape.
You make the structure visible, so choice can occur without confusion.

<user_query>
"${userQuery}"
</user_query>

<shadow_paragraphs>
${paragraphBlock}
</shadow_paragraphs>

# Schema Lock (Strict)
- Respond with a single JSON object only (no markdown, no prose).
- Do not output an "edges" field anywhere.
- The only relationship fields are "enables" and "conflicts".
- Every gate and every conflict must include a non-empty "question".

# Output Format (JSON Only)
<output_schema>
{
  "claims": [
    {
      "id": "c_0",
      "label": "validate inputs at API boundary",
      "description": "Input validation should happen where data enters the system",
      "stance": "prescriptive",
      "gates": {
        "conditionals": [
          {
            "id": "cg_0",
            "condition": "using a web API or service endpoint",
            "question": "Does this system expose a web API or service endpoint?",
            "sourceStatementIds": ["p_5", "p_12"]
          }
        ],
        "prerequisites": [
          {
            "id": "pg_0",
            "claimId": "c_1",
            "condition": "requires schema definition in place",
            "question": "Is a schema definition already in place?",
            "sourceStatementIds": ["p_8"]
          }
        ]
      },
      "enables": ["c_2"],
      "conflicts": [
        {
          "claimId": "c_4",
          "question": "Which matters more: strict validation or development speed?",
          "sourceStatementIds": ["p_15"],
          "nature": "optimization"
        }
      ],
      "sourceStatementIds": ["p_0", "p_5", "p_9", "p_12"]
    }
  ]
}
</output_schema>

# ID Conventions
- Paragraph IDs: "p_0", "p_1", ... (from input)
- Claim IDs: "c_0", "c_1", ...
- Conditional gate IDs: "cg_0", "cg_1", ...
- Prerequisite gate IDs: "pg_0", "pg_1", ...

# Provenance Requirements (Non-Negotiable)
- Every claim must include ≥1 sourceStatementId (paragraph ID).
- Every gate must include ≥1 sourceStatementId.
- Every conflict must include ≥1 sourceStatementId.

Generate the map now.
`;
}

// Rest of file unchanged...
```

#### File 5: `src/ConciergeService/traversalState.ts` (UPDATE)

```typescript
// Only change: import type
import { ShadowParagraph } from '../shadow';

// Update the evidence type
export interface EvidenceRef {
    paragraphId: string;
    modelIndex: number;
    textExcerpt: string;
}

export interface TraversalState {
    // ... other fields unchanged ...
    
    // Updated evidence type
    collectedEvidence: Map<string, EvidenceRef[]>;
    
    // ... rest unchanged ...
}

// Update handlers to use new type
function applyGateAnswer(
    state: TraversalState,
    graph: TraversalGraph,
    fp: ForcingPoint,
    answer: GateAnswer
): void {
    // ... 
    
    if (answer === 'yes') {
        state.resolvedGates.set(fp.gateId, true);

        if (claim) {
            // Convert to evidence refs
            const evidenceRefs: EvidenceRef[] = claim.sourceStatements.map(s => ({
                paragraphId: s.id,
                modelIndex: s.modelIndex,
                textExcerpt: s.text.substring(0, 200),
            }));
            state.collectedEvidence.set(claim.id, evidenceRefs);
            state.pathSummary.push(`✓ "${fp.condition}"`);
        }
    }
    // ...
}

// Update query helper
export function getCollectedEvidence(state: TraversalState): EvidenceRef[] {
    return Array.from(state.collectedEvidence.values()).flat();
}
```

---

### Phase 3: No Changes Needed

These files work as-is:

- `src/core/structural-analysis/*` - Operates on V1 artifact
- `shared/parsing-utils.ts` - Format-agnostic ID validation
- `src/ConciergeService/v2-to-v1-adapter.ts` - Looks up by ID in array

---

## Migration Checklist

```markdown
### Phase 1: Shadow V3 Core
- [ ] Replace `src/shadow/ShadowExtractor.ts`
- [ ] Update `src/shadow/ShadowDelta.ts`
- [ ] Update `src/shadow/index.ts`
- [ ] Run shadow tests

### Phase 2: Semantic Layer
- [ ] Update `src/ConciergeService/semanticMapper.ts` prompt
- [ ] Update `src/ConciergeService/traversalState.ts` types
- [ ] Verify `claimAssembly.ts` works (ID lookup unchanged)

### Phase 3: Integration Test
- [ ] Run full pipeline: Batch → Shadow → Semantic → Traversal
- [ ] Verify paragraph count ~40-60 vs old ~150-200 statements
- [ ] Verify delta audit makes sense
- [ ] Check UI renders correctly

### Phase 4: Cleanup (Optional, Later)
- [ ] Remove deprecated aliases after confirming no usage
- [ ] Update remaining `ShadowStatement` imports
- [ ] Clean up legacy compat fields from types
```

---

## Expected Output Comparison

```typescript
// V2 (Sentence-level)
{
  statements: [
    { id: "s_0", text: "You should use React", stance: "prescriptive", ... },
    { id: "s_1", text: "React has a large ecosystem", stance: "assertive", ... },
    { id: "s_2", text: "However, Vue is simpler", stance: "cautionary", ... },
    // ~150-200 total
  ]
}

// V3 (Paragraph-level)  
{
  paragraphs: [
    { 
      id: "p_0", 
      text: "You should use React. React has a large ecosystem. However, Vue is simpler for beginners.",
      stanceHints: ["prescriptive", "assertive", "cautionary"],
      dominantStance: "prescriptive",  // Highest priority
      signals: { sequence: false, tension: true, conditional: false },
      ...
    },
    // ~40-60 total
  ]
}
```

---

Ready to implement? I can provide the exact diffs for any specific file, or we can proceed with the implementation phase.