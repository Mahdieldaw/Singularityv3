# Shadow Mapper V3 - Clean Implementation

## Overview

Refactor from sentence-level classification to paragraph-level bundling. Shadow annotates and bundles, doesn't verdict.

**Key decisions:**
- 3 signals (sequence, tension, conditional)
- Individual regex patterns (auditable, maintainable)
- Structure-aware paragraph splitting
- Short-fragment merging

---

## File 1: StatementTypes.ts

```typescript
// ═══════════════════════════════════════════════════════════════════════════
// STATEMENT TYPES - SHADOW MAPPER V3 (Paragraph-Level)
// ═══════════════════════════════════════════════════════════════════════════
//
// SIGNALS: 3 types detecting relational language
// STANCES: 6 types for hint aggregation (not verdicts)
//
// Shadow detects patterns. Semantic interprets meaning.
// ═══════════════════════════════════════════════════════════════════════════

export type Stance =
  | 'prescriptive'
  | 'cautionary'
  | 'prerequisite'
  | 'dependent'
  | 'assertive'
  | 'uncertain';

export const STANCE_PRIORITY: Stance[] = [
  'prerequisite',
  'dependent',
  'cautionary',
  'prescriptive',
  'uncertain',
  'assertive',
];

export const STANCE_PATTERNS: Record<Stance, RegExp[]> = {
  cautionary: [
    /\bdon'?t\b/i,
    /\bdo\s+not\b/i,
    /\bavoid\b/i,
    /\bnever\b/i,
    /\brisk\b/i,
    /\bcareful\b/i,
    /\bcaution\b/i,
    /\bwarning\b/i,
    /\bdanger\b/i,
    /\bpitfall\b/i,
    /\btrap\b/i,
    /\bmistake\b/i,
    /\berror\b/i,
    /\bproblem\s+with\b/i,
    /\bwatch\s+out\b/i,
    /\bbe\s+aware\b/i,
    /\bbeware\b/i,
    /\bshould\s+not\b/i,
    /\bshouldn'?t\b/i,
  ],

  prerequisite: [
    /\bbefore\b/i,
    /\bfirst\b/i,
    /\bprior\s+to\b/i,
    /\brequires?\b/i,
    /\bneeds?\s+to\s+have\b/i,
    /\bprerequisite\b/i,
    /\bprecondition\b/i,
    /\bfoundation\s+for\b/i,
    /\bgroundwork\b/i,
    /\benables?\b/i,
    /\bunblocks?\b/i,
    /\ballows?\s+you\s+to\b/i,
    /\binitially\b/i,
  ],

  dependent: [
    /\bafter\b/i,
    /\bonce\b/i,
    /\bthen\s+you\s+can\b/i,
    /\bfollowing\s+this\b/i,
    /\bsubsequent\b/i,
    /\bonly\s+after\b/i,
    /\bhaving\s+(done|completed|established)\b/i,
    /\bin\s+the\s+next\s+step\b/i,
    /\bdownstream\b/i,
  ],

  prescriptive: [
    /\bshould\b/i,
    /\bmust\b/i,
    /\bought\s+to\b/i,
    /\bneed\s+to\b/i,
    /\bhave\s+to\b/i,
    /\bensure\b/i,
    /\bmake\s+sure\b/i,
    /\balways\b/i,
    /\brequired\b/i,
    /\bessential\b/i,
    /\bcritical\s+to\b/i,
    /\brecommend\b/i,
    /\bsuggest\b/i,
    /\badvise\b/i,
    /\bconsider\b/i,
    /\buse\b/i,
    /\bimplement\b/i,
  ],

  uncertain: [
    /\bmight\b/i,
    /\bmay\b/i,
    /\bcould\b/i,
    /\bpossibly\b/i,
    /\bperhaps\b/i,
    /\bmaybe\b/i,
    /\bunclear\b/i,
    /\bunknown\b/i,
    /\buncertain\b/i,
    /\bdepends\b/i,
    /\bnot\s+sure\b/i,
    /\btypically\b/i,
    /\busually\b/i,
    /\bin\s+some\s+cases\b/i,
  ],

  assertive: [
    /\bis\b/i,
    /\bare\b/i,
    /\bwas\b/i,
    /\bwere\b/i,
    /\bdoes\b/i,
    /\bhas\b/i,
    /\bhave\b/i,
    /\bworks?\b/i,
    /\bperforms?\b/i,
    /\bprovides?\b/i,
    /\bincludes?\b/i,
    /\bsupports?\b/i,
  ],
};

// ═══════════════════════════════════════════════════════════════════════════
// SIGNAL PATTERNS (3 types, individual patterns for auditability)
// ═══════════════════════════════════════════════════════════════════════════

export const SIGNAL_PATTERNS = {
  sequence: [
    /\bbefore\b/i,
    /\bafter\b/i,
    /\bfirst\b/i,
    /\bthen\b/i,
    /\bnext\b/i,
    /\bfinally\b/i,
    /\bonce\b/i,
    /\brequires?\b/i,
    /\bdepends\s+on\b/i,
    /\bprior\s+to\b/i,
    /\bsubsequently\b/i,
    /\bsubsequent\b/i,
    /\bfollowing\b/i,
    /\bpreceding\b/i,
    /\bstep\s+\d+\b/i,
    /\benables?\b/i,
    /\bunblocks?\b/i,
    /\bupstream\b/i,
    /\bdownstream\b/i,
    /\bprerequisite\b/i,
    /\bmust\s+have\b/i,
    /\bneeds?\s+to\b/i,
  ],

  tension: [
    /\bbut\b/i,
    /\bhowever\b/i,
    /\balthough\b/i,
    /\bthough\b/i,
    /\bdespite\b/i,
    /\bnevertheless\b/i,
    /\byet\b/i,
    /\binstead\b/i,
    /\brather\s+than\b/i,
    /\bon\s+the\s+other\s+hand\b/i,
    /\bin\s+contrast\b/i,
    /\bconversely\b/i,
    /\bversus\b/i,
    /\bvs\.?\b/i,
    /\btrade-?off\b/i,
    /\bdownside\b/i,
    /\bdrawback\b/i,
    /\bcaveat\b/i,
    /\bconflicts?\s+with\b/i,
  ],

  conditional: [
    /\bif\b/i,
    /\bwhen\b/i,
    /\bunless\b/i,
    /\bassuming\b/i,
    /\bprovided\s+that\b/i,
    /\bgiven\s+that\b/i,
    /\bin\s+case\b/i,
    /\bcontingent\s+on\b/i,
    /\bsubject\s+to\b/i,
    /\bdepending\s+on\b/i,
    /\bonly\s+if\b/i,
    /\bonly\s+when\b/i,
    /\bin\s+(some|certain|specific)\s+cases\b/i,
  ],
} as const;

export type SignalType = keyof typeof SIGNAL_PATTERNS;

// ═══════════════════════════════════════════════════════════════════════════
// SIGNAL FLAGS INTERFACE
// ═══════════════════════════════════════════════════════════════════════════

export interface SignalFlags {
  sequence: boolean;
  tension: boolean;
  conditional: boolean;
}

// ═══════════════════════════════════════════════════════════════════════════
// FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

export function getStancePriority(stance: Stance): number {
  const idx = STANCE_PRIORITY.indexOf(stance);
  return idx === -1 ? 0 : STANCE_PRIORITY.length - idx;
}

/**
 * Detect signals in text (returns 3 booleans)
 */
export function detectSignals(text: string): SignalFlags {
  return {
    sequence: SIGNAL_PATTERNS.sequence.some(p => p.test(text)),
    tension: SIGNAL_PATTERNS.tension.some(p => p.test(text)),
    conditional: SIGNAL_PATTERNS.conditional.some(p => p.test(text)),
  };
}

/**
 * Aggregate signals from multiple text chunks
 */
export function aggregateSignals(texts: string[]): SignalFlags {
  const result: SignalFlags = {
    sequence: false,
    tension: false,
    conditional: false,
  };

  for (const text of texts) {
    const signals = detectSignals(text);
    if (signals.sequence) result.sequence = true;
    if (signals.tension) result.tension = true;
    if (signals.conditional) result.conditional = true;
  }

  return result;
}

/**
 * Compute signal weight for prioritization
 */
export function computeSignalWeight(signals: SignalFlags): number {
  let weight = 0;
  if (signals.conditional) weight += 3;
  if (signals.sequence) weight += 2;
  if (signals.tension) weight += 1;
  return weight;
}

/**
 * Classify stance based on pattern matching with priority order
 * Used for hints, not verdicts
 */
export function classifyStance(text: string): { stance: Stance; confidence: number } {
  let bestStance: Stance = 'assertive';
  let maxPriority = 0;
  let matchCount = 0;

  for (const stance of STANCE_PRIORITY) {
    const patterns = STANCE_PATTERNS[stance];
    const matches = patterns.filter(p => p.test(text)).length;

    if (matches > 0) {
      const priority = getStancePriority(stance);
      if (priority > maxPriority) {
        maxPriority = priority;
        bestStance = stance;
        matchCount = matches;
      }
    }
  }

  const confidence = Math.min(1.0, 0.5 + matchCount * 0.15);
  return { stance: bestStance, confidence };
}
```

---

## File 2: ShadowExtractor.ts

```typescript
// ═══════════════════════════════════════════════════════════════════════════
// SHADOW EXTRACTOR - SHADOW MAPPER V3 (Paragraph-Level)
// ═══════════════════════════════════════════════════════════════════════════
//
// PURPOSE: Bundle model responses into annotated paragraphs
// - Structure-aware paragraph splitting
// - Aggregate signals at paragraph level
// - Provide hints, not classifications
// - Preserve full text for Semantic
// ═══════════════════════════════════════════════════════════════════════════

import {
  Stance,
  SignalFlags,
  detectSignals,
  aggregateSignals,
  classifyStance,
  computeSignalWeight,
} from './StatementTypes';

// ═══════════════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════════════

export interface ShadowParagraph {
  id: string;
  modelIndex: number;
  text: string;
  
  signals: SignalFlags;
  stanceHints: Stance[];
  
  sentenceCount: number;
  wordCount: number;
  
  excluded: boolean;
  exclusionReason?: string;
}

export interface ShadowExtractionResult {
  paragraphs: ShadowParagraph[];
  meta: {
    totalParagraphs: number;
    includedParagraphs: number;
    excludedParagraphs: number;
    byModel: Record<number, number>;
    signalCounts: {
      sequence: number;
      tension: number;
      conditional: number;
    };
    processingTimeMs: number;
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// PARAGRAPH SPLITTING (Structure-Aware)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Split text into paragraphs, respecting markdown structure
 */
function splitIntoParagraphs(text: string): string[] {
  // First pass: split on double newlines
  let paragraphs = text.split(/\n\n+/);

  // Second pass: handle list structures
  paragraphs = paragraphs.flatMap(p => {
    const trimmed = p.trim();
    if (!trimmed) return [];
    
    // Numbered lists: split on newline + digit
    if (/^\d+\.\s/.test(trimmed)) {
      return trimmed.split(/\n(?=\d+\.\s)/);
    }
    
    // Bullet lists: split on newline + bullet
    if (/^[-*•]\s/.test(trimmed)) {
      return trimmed.split(/\n(?=[-*•]\s)/);
    }
    
    return [trimmed];
  });

  // Third pass: merge orphan fragments (< 50 chars) with previous
  const merged: string[] = [];
  for (const p of paragraphs) {
    const trimmed = p.trim();
    if (trimmed.length === 0) continue;
    
    if (trimmed.length < 50 && merged.length > 0 && !isStructuralElement(trimmed)) {
      merged[merged.length - 1] += '\n' + trimmed;
    } else {
      merged.push(trimmed);
    }
  }

  return merged;
}

/**
 * Check if text is a structural element that shouldn't be merged
 */
function isStructuralElement(text: string): boolean {
  if (/^#{1,6}\s/.test(text)) return true;
  if (/^[-*_]{3,}$/.test(text)) return true;
  if (/^(Note|Warning|Tip|Example|Summary):?\s*$/i.test(text)) return true;
  return false;
}

/**
 * Split paragraph into sentences for analysis
 */
function splitIntoSentences(paragraph: string): string[] {
  const protectedText = paragraph
    .replace(/\b(Mr|Mrs|Ms|Dr|Prof|Inc|Ltd|vs|etc|e\.g|i\.e)\./gi, '$1|||')
    .replace(/\b(\d+)\./g, '$1|||');

  const sentences = protectedText
    .split(/(?<=[.!?])\s+/)
    .map(s => s.replace(/\|\|\|/g, '.').trim())
    .filter(s => s.length > 0);

  return sentences;
}

// ═══════════════════════════════════════════════════════════════════════════
// EXCLUSION LOGIC
// ═══════════════════════════════════════════════════════════════════════════

interface ExclusionResult {
  excluded: boolean;
  reason?: string;
}

function checkParagraphExclusion(text: string): ExclusionResult {
  const trimmed = text.trim();
  const wordCount = trimmed.split(/\s+/).length;
  
  // Too short
  if (wordCount < 8) {
    return { excluded: true, reason: 'too_short' };
  }

  // Pure meta-framing
  if (/^(let me|i'll|i will|i can|here's a|here is a|this is a)/i.test(trimmed)) {
    return { excluded: true, reason: 'meta_framing' };
  }

  // Summary meta
  if (/^(in summary|to summarize|in conclusion|overall,|to sum up)/i.test(trimmed)) {
    return { excluded: true, reason: 'summary_meta' };
  }

  // Pure question
  if (/^[^.!]*\?$/.test(trimmed) && trimmed.split(/[.!?]/).length <= 2) {
    return { excluded: true, reason: 'question_only' };
  }

  // Code blocks
  if (/^```/.test(trimmed)) {
    return { excluded: true, reason: 'code_block' };
  }

  // Headers only
  if (/^#{1,6}\s+.{0,50}$/.test(trimmed) && wordCount < 10) {
    return { excluded: true, reason: 'header_only' };
  }

  return { excluded: false };
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN EXTRACTION
// ═══════════════════════════════════════════════════════════════════════════

export function extractShadowParagraphs(
  responses: Array<{ modelIndex: number; content: string }>
): ShadowExtractionResult {
  const startTime = performance.now();
  const paragraphs: ShadowParagraph[] = [];
  let idCounter = 0;

  for (const response of responses) {
    const rawParagraphs = splitIntoParagraphs(response.content);

    for (const paragraphText of rawParagraphs) {
      const sentences = splitIntoSentences(paragraphText);
      
      // Aggregate signals across sentences
      const signals = aggregateSignals(sentences);
      
      // Collect stance hints
      const stanceSet = new Set<Stance>();
      for (const sentence of sentences) {
        const { stance } = classifyStance(sentence);
        stanceSet.add(stance);
      }
      
      // Check exclusion
      const exclusion = checkParagraphExclusion(paragraphText);
      
      paragraphs.push({
        id: `p_${idCounter++}`,
        modelIndex: response.modelIndex,
        text: paragraphText,
        signals,
        stanceHints: Array.from(stanceSet),
        sentenceCount: sentences.length,
        wordCount: paragraphText.split(/\s+/).length,
        excluded: exclusion.excluded,
        exclusionReason: exclusion.reason,
      });
    }
  }

  return {
    paragraphs,
    meta: buildMeta(paragraphs, performance.now() - startTime),
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// METADATA
// ═══════════════════════════════════════════════════════════════════════════

function buildMeta(
  paragraphs: ShadowParagraph[],
  processingTimeMs: number
): ShadowExtractionResult['meta'] {
  const byModel: Record<number, number> = {};
  const signalCounts = { sequence: 0, tension: 0, conditional: 0 };
  let includedCount = 0;
  let excludedCount = 0;

  for (const p of paragraphs) {
    byModel[p.modelIndex] = (byModel[p.modelIndex] || 0) + 1;
    
    if (p.excluded) {
      excludedCount++;
    } else {
      includedCount++;
      if (p.signals.sequence) signalCounts.sequence++;
      if (p.signals.tension) signalCounts.tension++;
      if (p.signals.conditional) signalCounts.conditional++;
    }
  }

  return {
    totalParagraphs: paragraphs.length,
    includedParagraphs: includedCount,
    excludedParagraphs: excludedCount,
    byModel,
    signalCounts,
    processingTimeMs,
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// UTILITIES
// ═══════════════════════════════════════════════════════════════════════════

export function filterBySignals(
  paragraphs: ShadowParagraph[],
  required: Partial<SignalFlags>
): ShadowParagraph[] {
  return paragraphs.filter(p => {
    if (required.sequence && !p.signals.sequence) return false;
    if (required.tension && !p.signals.tension) return false;
    if (required.conditional && !p.signals.conditional) return false;
    return true;
  });
}

export function filterByModel(
  paragraphs: ShadowParagraph[],
  modelIndex: number
): ShadowParagraph[] {
  return paragraphs.filter(p => p.modelIndex === modelIndex);
}

export function filterByStanceHint(
  paragraphs: ShadowParagraph[],
  stance: Stance
): ShadowParagraph[] {
  return paragraphs.filter(p => p.stanceHints.includes(stance));
}

export function getIncludedParagraphs(
  paragraphs: ShadowParagraph[]
): ShadowParagraph[] {
  return paragraphs.filter(p => !p.excluded);
}

export function getHighSignalParagraphs(
  paragraphs: ShadowParagraph[],
  minWeight: number = 2
): ShadowParagraph[] {
  return paragraphs.filter(p => computeSignalWeight(p.signals) >= minWeight);
}
```

---

## File 3: ShadowDelta.ts

```typescript
// ═══════════════════════════════════════════════════════════════════════════
// SHADOW DELTA - SHADOW MAPPER V3 (Paragraph-Level)
// ═══════════════════════════════════════════════════════════════════════════
//
// PURPOSE: After Semantic runs, identify unreferenced paragraphs
// ═══════════════════════════════════════════════════════════════════════════

import { computeSignalWeight } from './StatementTypes';
import { ShadowParagraph, ShadowExtractionResult } from './ShadowExtractor';

// ═══════════════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════════════

export interface UnreferencedParagraph {
  paragraph: ShadowParagraph;
  signalWeight: number;
  queryRelevance: number;
  priority: number;
}

export interface ShadowAudit {
  totalParagraphs: number;
  includedParagraphs: number;
  referencedCount: number;
  unreferencedCount: number;
  highSignalUnreferencedCount: number;
  unreferencedSignals: {
    sequence: number;
    tension: number;
    conditional: number;
  };
}

export interface ShadowDeltaResult {
  unreferenced: UnreferencedParagraph[];
  audit: ShadowAudit;
  processingTimeMs: number;
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN DELTA
// ═══════════════════════════════════════════════════════════════════════════

export function computeShadowDelta(
  shadowResult: ShadowExtractionResult,
  referencedIds: Set<string>,
  userQuery: string
): ShadowDeltaResult {
  const startTime = performance.now();
  
  const unreferenced: UnreferencedParagraph[] = [];
  const unreferencedSignals = { sequence: 0, tension: 0, conditional: 0 };
  
  const included = shadowResult.paragraphs.filter(p => !p.excluded);
  
  for (const paragraph of included) {
    if (!referencedIds.has(paragraph.id)) {
      const signalWeight = computeSignalWeight(paragraph.signals);
      const queryRelevance = computeQueryRelevance(paragraph.text, userQuery);
      const priority = signalWeight * 2 + queryRelevance * 3;
      
      unreferenced.push({ paragraph, signalWeight, queryRelevance, priority });
      
      if (paragraph.signals.sequence) unreferencedSignals.sequence++;
      if (paragraph.signals.tension) unreferencedSignals.tension++;
      if (paragraph.signals.conditional) unreferencedSignals.conditional++;
    }
  }
  
  unreferenced.sort((a, b) => b.priority - a.priority);
  
  return {
    unreferenced,
    audit: {
      totalParagraphs: shadowResult.paragraphs.length,
      includedParagraphs: included.length,
      referencedCount: included.length - unreferenced.length,
      unreferencedCount: unreferenced.length,
      highSignalUnreferencedCount: unreferenced.filter(u => u.signalWeight >= 2).length,
      unreferencedSignals,
    },
    processingTimeMs: performance.now() - startTime,
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════════════════════════════

const STOP_WORDS = new Set([
  'the', 'and', 'for', 'are', 'but', 'not', 'you', 'with',
  'this', 'that', 'can', 'will', 'what', 'when', 'where',
  'how', 'why', 'who', 'which', 'their', 'there', 'than',
  'then', 'them', 'these', 'those', 'have', 'has', 'had',
  'was', 'were', 'been', 'being', 'from', 'they', 'she',
  'would', 'could', 'should', 'about', 'into', 'through',
  'your', 'just', 'some', 'also', 'very', 'more', 'most',
]);

function extractSignificantWords(text: string): Set<string> {
  const normalized = text
    .toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  
  const words = normalized.split(' ').filter(w => 
    w.length >= 3 && !STOP_WORDS.has(w)
  );
  
  return new Set(words);
}

function computeQueryRelevance(paragraphText: string, queryText: string): number {
  const paragraphWords = extractSignificantWords(paragraphText);
  const queryWords = extractSignificantWords(queryText);
  
  if (paragraphWords.size === 0 || queryWords.size === 0) return 0;
  
  let overlap = 0;
  paragraphWords.forEach(word => {
    if (queryWords.has(word)) overlap++;
  });
  
  return overlap / queryWords.size;
}

// ═══════════════════════════════════════════════════════════════════════════
// OUTPUT FORMATTERS
// ═══════════════════════════════════════════════════════════════════════════

export function getTopUnreferenced(
  delta: ShadowDeltaResult,
  limit: number = 5
): UnreferencedParagraph[] {
  return delta.unreferenced.slice(0, limit);
}

export function formatUnreferencedForPrompt(
  unreferenced: UnreferencedParagraph[],
  limit: number = 3
): string {
  if (unreferenced.length === 0) return '';
  
  const top = unreferenced.slice(0, limit);
  let output = '## Additional Context (Unused Paragraphs)\n\n';
  
  for (const u of top) {
    const tags: string[] = [];
    if (u.paragraph.signals.conditional) tags.push('COND');
    if (u.paragraph.signals.sequence) tags.push('SEQ');
    if (u.paragraph.signals.tension) tags.push('TENS');
    
    const tagStr = tags.length > 0 ? ` [${tags.join(',')}]` : '';
    const displayText = u.paragraph.text.length > 200
      ? u.paragraph.text.substring(0, 200) + '...'
      : u.paragraph.text;
    
    output += `- Model ${u.paragraph.modelIndex}${tagStr}: "${displayText}"\n\n`;
  }
  
  return output;
}

export function formatAuditSummary(delta: ShadowDeltaResult): string {
  const { audit } = delta;
  
  return `Shadow Delta:
  Total: ${audit.totalParagraphs} | Included: ${audit.includedParagraphs}
  Referenced: ${audit.referencedCount} | Unreferenced: ${audit.unreferencedCount}
  High-signal missed: ${audit.highSignalUnreferencedCount}
  Signals missed: seq=${audit.unreferencedSignals.sequence} tens=${audit.unreferencedSignals.tension} cond=${audit.unreferencedSignals.conditional}`;
}

export function extractReferencedIds(
  claims: Array<{ sourceParagraphIds?: string[] }>
): Set<string> {
  const ids = new Set<string>();
  for (const claim of claims) {
    if (claim.sourceParagraphIds) {
      claim.sourceParagraphIds.forEach(id => ids.add(id));
    }
  }
  return ids;
}
```

---

## File 4: index.ts

```typescript
// ═══════════════════════════════════════════════════════════════════════════
// SHADOW MAPPER V3 - MODULE INDEX
// ═══════════════════════════════════════════════════════════════════════════

import { STANCE_PATTERNS, SIGNAL_PATTERNS } from './StatementTypes';

let _initialized = false;

export function initializeShadowMapper(): void {
  if (_initialized) return;
  Object.freeze(STANCE_PATTERNS);
  Object.freeze(SIGNAL_PATTERNS);
  _initialized = true;
}

initializeShadowMapper();

// Types
export type { Stance, SignalFlags, SignalType } from './StatementTypes';
export type { ShadowParagraph, ShadowExtractionResult } from './ShadowExtractor';
export type { UnreferencedParagraph, ShadowAudit, ShadowDeltaResult } from './ShadowDelta';

// Functions - StatementTypes
export {
  detectSignals,
  aggregateSignals,
  classifyStance,
  computeSignalWeight,
  getStancePriority,
  STANCE_PATTERNS,
  SIGNAL_PATTERNS,
  STANCE_PRIORITY,
} from './StatementTypes';

// Functions - Extractor
export {
  extractShadowParagraphs,
  filterBySignals,
  filterByModel,
  filterByStanceHint,
  getIncludedParagraphs,
  getHighSignalParagraphs,
} from './ShadowExtractor';

// Functions - Delta
export {
  computeShadowDelta,
  getTopUnreferenced,
  formatUnreferencedForPrompt,
  formatAuditSummary,
  extractReferencedIds,
} from './ShadowDelta';

// Legacy alias
export { extractShadowParagraphs as extractShadowStatements } from './ShadowExtractor';
```

---

## File 5: ExclusionRules.ts

```typescript
// ═══════════════════════════════════════════════════════════════════════════
// EXCLUSION RULES - SHADOW MAPPER V3
// ═══════════════════════════════════════════════════════════════════════════
//
// NOTE: Exclusion logic moved to ShadowExtractor.checkParagraphExclusion()
// This file kept for reference and potential future expansion
// ═══════════════════════════════════════════════════════════════════════════

export interface ExclusionPattern {
  id: string;
  pattern: RegExp;
  reason: string;
}

export const PARAGRAPH_EXCLUSIONS: ExclusionPattern[] = [
  { id: 'meta_framing', pattern: /^(let me|i'll|i will|i can|here's a|here is a)/i, reason: 'Meta-framing' },
  { id: 'summary_meta', pattern: /^(in summary|to summarize|in conclusion|overall,)/i, reason: 'Summary meta' },
  { id: 'question_only', pattern: /^[^.!]*\?$/, reason: 'Pure question' },
  { id: 'code_block', pattern: /^```/, reason: 'Code block' },
];

// Legacy export
export const EXCLUSION_RULES = PARAGRAPH_EXCLUSIONS;
```

---

## Implementation Checklist

```markdown
## For IDE Agent

### Phase 1: Replace Files
- [ ] Backup existing shadow/ directory
- [ ] Replace StatementTypes.ts
- [ ] Replace ShadowExtractor.ts  
- [ ] Replace ShadowDelta.ts
- [ ] Replace index.ts
- [ ] Replace ExclusionRules.ts

### Phase 2: Update Imports
- [ ] Search codebase for `ShadowStatement` → may need alias or update
- [ ] Search for `extractShadowStatements` → now alias for `extractShadowParagraphs`
- [ ] Search for `sourceStatementIds` → change to `sourceParagraphIds`

### Phase 3: Update Semantic Mapper
- [ ] Update prompt to expect paragraphs not sentences
- [ ] Update claim output schema: `sourceParagraphIds: string[]`
- [ ] Semantic now reads full paragraphs, uses signals as hints

### Phase 4: Test
- [ ] Run extraction on sample responses
- [ ] Verify ~40-60 paragraphs vs old ~150-200 sentences
- [ ] Verify signal detection working
- [ ] Run full pipeline Shadow → Semantic → Delta
- [ ] Check audit output makes sense
```

---

## Expected Output Shape

```typescript
// Input: 6 model responses, ~500 words each

// Shadow Output:
{
  paragraphs: [
    {
      id: "p_0",
      modelIndex: 0,
      text: "Before deploying to production, you should ensure...",
      signals: { sequence: true, tension: false, conditional: false },
      stanceHints: ["prerequisite", "prescriptive"],
      sentenceCount: 3,
      wordCount: 45,
      excluded: false
    },
    // ... ~40-60 total
  ],
  meta: {
    totalParagraphs: 48,
    includedParagraphs: 42,
    excludedParagraphs: 6,
    byModel: { 0: 8, 1: 7, 2: 9, 3: 8, 4: 8, 5: 8 },
    signalCounts: { sequence: 12, tension: 8, conditional: 15 },
    processingTimeMs: 23
  }
}
```